import Phaser from 'phaser';
import { getShopItems } from '../data/items.js';
import { bankData, generateBankList, getRandomInRange } from '../data/banks.js';
import { WORLD_CONFIG, getWorldByStage, getBossInfoForStage, shouldHaveSaws, shouldHaveGasZone, shouldHaveFog, shouldHaveFloatingMines, shouldHaveLaserTurrets, isMagnetarStage, isNexusStage, isMetaUniverseStage, shouldDisableCombo, isQuantumSplitStage, isMultiverseCollapseStage } from '../data/worlds.js';

export default class SnakeGame extends Phaser.Scene {
  // Ï†ïÏ†Å Î≥ÄÏàò: ÌÅ¨Î†àÎîß ÌõÑ ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ ÌëúÏãú ÌîåÎûòÍ∑∏
  static showTitleOnRestart = false;

  constructor() {
    super({ key: 'SnakeGame' });
  }

  preload() {
    // Î∞∞Í≤ΩÏùåÏïÖ Î°úÎìú
    this.load.audio('bgm', 'assets/bgm/snake_bgm.mp3');
    this.load.audio('boss3_bgm', 'assets/bgm/3_boss.mp3');
    this.load.audio('boss6_bgm', 'assets/bgm/6_boss.mp3');
    this.load.audio('boss9_bgm', 'assets/bgm/9_boss.mp3');
    this.load.audio('boss12_bgm', 'assets/bgm/12_boss.mp3');
    this.load.audio('boss15_bgm', 'assets/bgm/15_boss.mp3');
    this.load.audio('boss18_bgm', 'assets/bgm/18_boss.mp3');
    // Ïù¥Îèô Ìö®Í≥ºÏùå Î°úÎìú
    this.load.audio('moving', 'assets/sfx/moving.mp3');
    // Î®πÏù¥ Î®πÎäî Ìö®Í≥ºÏùå Î°úÎìú
    this.load.audio('eating', 'assets/sfx/eating.mp3');
    // 6ÌÉÑ Î≥¥Ïä§ Ï¥ùÏïå Î∞úÏÇ¨ Ìö®Í≥ºÏùå
    this.load.audio('boss6_effect', 'assets/sfx/6_boss_effect.mp3');
    // 9ÌÉÑ Î≥¥Ïä§ Í≥µÍ≤© Ìö®Í≥ºÏùå
    this.load.audio('boss9_effect', 'assets/sfx/9_boss_effect.mp3');
    // 14ÌÉÑ Î†àÏù¥Ï†Ä Ìö®Í≥ºÏùå
    this.load.audio('laser14_effect', 'assets/sfx/14_razer_effect.mp3');
    // 6ÌÉÑ Î≥¥Ïä§ ÎåÄÏãú Ìö®Í≥ºÏùå
    this.load.audio('dash_effect', 'assets/sfx/spear_3.mp3');
    // 9ÌÉÑ ÎπõÏùòÏ°∞Í∞Å ÏàòÏßë Ìö®Í≥ºÏùå
    this.load.audio('flare_collect', 'assets/sfx/Gacha_impact_2.mp3');

    // Î±Ä Î®∏Î¶¨ Ïä§ÌîÑÎùºÏù¥Ìä∏ Î°úÎìú (2Í∞úÎ°ú 4Î∞©Ìñ• Íµ¨ÌòÑ)
    this.load.image('snake_head_side', 'assets/sprite/snake_head_side.png'); // Ï¢åÏö∞
    this.load.image('snake_head_top', 'assets/sprite/snake_head_top.png');   // ÏúÑÏïÑÎûò

    // ÎßêÌíçÏÑ† Ïù¥ÎØ∏ÏßÄ Î°úÎìú
    this.load.image('bubble', 'assets/sprite/bubble.png');

    // ÏïÑÏù¥ÌÖú Ïù¥ÎØ∏ÏßÄ Î°úÎìú
    this.load.image('combo_shield', 'assets/items/combo_shield.png');

    // ÏóîÎî© ÎπÑÎîîÏò§ Î°úÎìú
    this.load.video('ending_video', 'assets/video/sujeong.mp4');
    this.load.video('final_ending_video', 'assets/video/ending.mp4');

    // ÏóîÎî© BGM Î°úÎìú
    this.load.audio('rain_is_best_bgm', 'assets/bgm/RAIN_IS_BEST.mp3');
    this.load.audio('ÌîΩÏÖÄÏä§ÌÜ∞', 'assets/bgm/pixel_storm.mp3');
  }

  create() {
    // Í∑∏ÎûòÌîΩ Í∞ùÏ≤¥ Ï¥àÍ∏∞Ìôî
    this.graphics = null;
    this.snakeHeadTint = null;
    this.snakeBodyTint = null;
    this.snakeGlow = false;

    // Ïã≠ÏûêÍ∞Ä ÌõÑÎ†àÏâ¨ ÎùºÏù∏ (6~15Î≤àÏß∏ Î®πÏù¥)
    this.crosshairLines = null;

    // Î∞∞Í≤ΩÏùåÏïÖ ÏÑ§Ï†ï (Ï≤´ ÏûÖÎ†• ÌõÑ Ïû¨ÏÉù)
    this.bgMusic = this.sound.add('bgm', {
      loop: true,
      volume: 0.8
    });

    // 3ÌÉÑ Î≥¥Ïä§ Î∞∞Í≤ΩÏùåÏïÖ
    this.boss3Music = this.sound.add('boss3_bgm', {
      loop: true,
      volume: 0.8
    });

    // 6ÌÉÑ Î≥¥Ïä§ Î∞∞Í≤ΩÏùåÏïÖ (Ï¥ùÏû°Ïù¥)
    this.boss6Music = this.sound.add('boss6_bgm', {
      loop: true,
      volume: 0.8
    });

    // 9ÌÉÑ Î≥¥Ïä§ Î∞∞Í≤ΩÏùåÏïÖ (ÎÖπÌÑ¥)
    this.boss9Music = this.sound.add('boss9_bgm', {
      loop: true,
      volume: 0.8
    });

    // 12ÌÉÑ Î≥¥Ïä§ Î∞∞Í≤ΩÏùåÏïÖ (Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ)
    this.boss12Music = this.sound.add('boss12_bgm', {
      loop: true,
      volume: 0.8
    });

    // 15ÌÉÑ Î≥¥Ïä§ Î∞∞Í≤ΩÏùåÏïÖ (NEXUS)
    this.boss15Music = this.sound.add('boss15_bgm', {
      loop: true,
      volume: 0.8
    });

    // 18ÌÉÑ Î≥¥Ïä§ Î∞∞Í≤ΩÏùåÏïÖ (Multiverse Collapse)
    this.boss18Music = this.sound.add('boss18_bgm', {
      loop: true,
      volume: 0.8
    });

    // ÏóîÎî© Î∞∞Í≤ΩÏùåÏïÖ (RAIN_IS_BEST)
    this.rainIsBestMusic = this.sound.add('rain_is_best_bgm', {
      loop: true,
      volume: 0.8
    });

    // ÌÅ¨Î†àÎîß Î∞∞Í≤ΩÏùåÏïÖ (ÌîΩÏÖÄ Ïä§ÌÜ∞)
    this.pixelStormMusic = this.sound.add('ÌîΩÏÖÄÏä§ÌÜ∞', {
      loop: true,
      volume: 0.8
    });

    // Ïù¥Îèô Ìö®Í≥ºÏùå
    this.movingSound = this.sound.add('moving', {
      volume: 0.3
    });

    // Î®πÏù¥ Î®πÎäî Ìö®Í≥ºÏùå
    this.eatingSound = this.sound.add('eating', {
      volume: 0.5
    });

    // Ï≤´ ÏûÖÎ†• Ïãú ÏùåÏïÖ Ïû¨ÏÉù
    this.musicStarted = false;

    // ÌôîÎ©¥ ÌÅ¨Í∏∞
    const { width, height } = this.cameras.main;

    // UI ÏòÅÏó≠ ÎÜíÏù¥
    this.uiHeight = 60;
    this.bottomUIHeight = 60;

    // ÏÉÅÎã® UI Î∞∞Í≤Ω
    const uiBg = this.add.rectangle(0, 0, width, this.uiHeight, 0x1a1a1a, 0.95).setOrigin(0, 0).setDepth(2000);

    // ÏÉÅÎã® Íµ¨Î∂ÑÏÑ†
    this.add.rectangle(0, this.uiHeight, width, 2, 0x00ff00, 0.3).setOrigin(0, 0).setDepth(2000);

    // ÌïòÎã® UI Î∞∞Í≤Ω
    this.add.rectangle(0, height - this.bottomUIHeight, width, this.bottomUIHeight, 0x1a1a1a, 0.95).setOrigin(0, 0).setDepth(2000);

    // ÌïòÎã® Íµ¨Î∂ÑÏÑ†
    this.add.rectangle(0, height - this.bottomUIHeight - 2, width, 2, 0x00ff00, 0.3).setOrigin(0, 0).setDepth(2000);

    // Í∑∏Î¶¨Îìú ÏÑ§Ï†ï (ÏÉÅÎã®/ÌïòÎã® UI ÏòÅÏó≠ Ï†úÏô∏)
    this.gridSize = 20;
    this.gameAreaY = this.uiHeight; // Í≤åÏûÑ ÏòÅÏó≠ ÏãúÏûë Y Ï¢åÌëú
    this.cols = Math.floor(width / this.gridSize);
    this.rows = Math.floor((height - this.uiHeight - this.bottomUIHeight) / this.gridSize);

    // Î±Ä Ï¥àÍ∏∞Ìôî
    this.snake = [
      { x: 10, y: 15 },
      { x: 9, y: 15 },
      { x: 8, y: 15 }
    ];

    // Î∞©Ìñ• (RIGHT)
    this.direction = 'RIGHT';
    this.inputQueue = []; // ÏûÖÎ†• ÌÅê (ÏµúÎåÄ 2Í∞úÍπåÏßÄ Ï†ÄÏû•)

    // Îç∞ÎìúÏ°¥ ÏãúÏä§ÌÖú (stage 3Î∂ÄÌÑ∞) - generateFood()Î≥¥Îã§ Î®ºÏ†Ä Ï¥àÍ∏∞Ìôî!
    this.deadZones = []; // Î∞üÏúºÎ©¥ Ï£ΩÎäî Ïπ∏Îì§ [{x, y, rect}]
    this.deadZoneGraphics = this.add.graphics(); // Îç∞ÎìúÏ°¥ Í∑∏Î¶¨Í∏∞Ïö©
    // Moving dead zone (saws)
    this.saws = []; // [{ x, y, container, blade, warningRing, spinTween, pulseTween, breathTween, moveDelay, canKill, nextPosition, lastDirection, nextStepSize, moveTimer }]
    this.sawTextureKey = 'deadly_saw';
    this.sawBaseDelay = 600;
    this.maxSaws = 5;

    // Enhanced saws (Stage 14 Í∞ïÌôî ÌÜ±Îãà)
    this.enhancedSaws = [];
    this.maxEnhancedSaws = 3;
    this.enhancedSawDelay = 400; // Í∏∞Î≥∏ 600msÎ≥¥Îã§ Îπ†Î¶Ñ
    this.enhancedSawScale = 1.3; // 1.3Î∞∞ Îçî ÌÅº
    this.enhancedSawTextureKey = 'enhanced_saw';
    this.preserveSawsForNextStage = false; // ÌÜ±Îãà Î≥¥Ï°¥ ÌîåÎûòÍ∑∏

    // Gear Titan Boss (disabled)
    this.gearTitanMode = false;
    this.gearTitanPhase = 'none'; // 'none' | 'intro' | 'phase1' | 'phase2' | 'phase3' | 'vulnerable' | 'enrage' | 'victory'
    this.gearTitanPosition = null;
    this.gearTitanElement = null;
    this.gearTitanContainer = null;
    this.gearTitanHitCount = 0;
    this.gearTitanHitsToKill = 6;
    this.gearTitanHP = this.gearTitanHitsToKill;
    this.gearTitanGears = [];
    this.gearTitanCore = null;
    this.gearTitanLasers = [];
    this.gearTitanAttackTimer = null;
    this.gearTitanAnimTimer = null;
    this.gearTitanVulnerable = false;
    this.gearTitanStunEndTime = 0;

    // Steam Overheat System (Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§Ïö©)
    this.isCharging = false;
    this.chargeStartTime = 0;
    this.steamGaugeDuration = 2500; // Í≤åÏù¥ÏßÄÍ∞Ä ÏôÑÏ†ÑÌûà Ï∞®Îäî ÏãúÍ∞Ñ (2.5Ï¥à)
    this.chargeReady = false;
    this.dashCooldown = 2000; // 2Ï¥à Ïø®Îã§Ïö¥
    this.lastDashTime = 0;
    this.isDashing = false;
    this.dashingHideSnake = false; // ÎåÄÏãú Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ë Î±Ä Ïà®Í∏∞Í∏∞
    this.dashDistance = 6; // 6Ïπ∏ ÎèåÏßÑ
    this.chargeUI = null;
    this.chargeGaugeUI = null;
    this.canChargeDash = false; // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ÏóêÏÑúÎßå ÌôúÏÑ±Ìôî
    this.chargeEffectParticles = []; // Ï∞®ÏßÄ ÏóêÎÑàÏßÄ ÌååÌã∞ÌÅ¥Îì§
    this.chargeEffectTimer = null; // Ï∞®ÏßÄ ÏóêÎÑàÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    this.chargeAuraGraphics = null; // Ï∞®ÏßÄ Ïò§Îùº Í∑∏ÎûòÌîΩ
    this.chargeCompressionGraphics = null; // ÏïïÏ∂ï Ìö®Í≥º Í∑∏ÎûòÌîΩ
    this.chargeCompressionFactor = 0; // ÏïïÏ∂ï Ï†ïÎèÑ (0~0.5)

    // Steam Overheat Ï†ÑÏö© Î≥ÄÏàò
    this.steamPerfectZoneStart = 0.35; // ÌçºÌéôÌä∏ Ï°¥ ÏãúÏûë (35%)
    this.steamPerfectZoneEnd = 0.55;   // ÌçºÌéôÌä∏ Ï°¥ ÎÅù (55%)
    this.steamDangerZoneStart = 0.75;  // ÏúÑÌóò Íµ¨Í∞Ñ ÏãúÏûë (75%)
    this.steamOverheatThreshold = 0.95; // Ïò§Î≤ÑÌûàÌä∏ Î∞úÎèô (95%)
    this.isOverheated = false;
    this.overheatStunDuration = 1500; // Ïò§Î≤ÑÌûàÌä∏ Ïãú 1.5Ï¥à Í∏∞Ï†à
    this.overheatEndTime = 0;
    this.steamDashPower = 'weak'; // 'weak' | 'perfect' | 'strong'

    // ÌôïÏÇ∞Ìòï ÎèÖÍ∞ÄÏä§ ÏãúÏä§ÌÖú (Î∞∞ÌãÄÎ°úÏñÑ ÏûêÍ∏∞Ïû•) - ÏõêÌòï
    this.gasZoneEnabled = false;
    this.gasZoneRadius = 0; // ÌòÑÏû¨ ÏïàÏ†Ñ ÏòÅÏó≠ Î∞òÍ≤Ω (ÌÉÄÏùº Îã®ÏúÑ)
    this.gasZoneMinRadius = 4; // ÏµúÏÜå Î∞òÍ≤Ω (Í≤åÏûÑ Í∞ÄÎä• ÏòÅÏó≠)
    this.gasZoneTimer = null; // ÌôïÏû• ÌÉÄÏù¥Î®∏
    this.gasZoneExpandInterval = 10000; // 10Ï¥àÎßàÎã§ ÌôïÏû• (NEXUS v2 - Îçî Ïó¨Ïú†ÏûàÍ≤å)
    this.gasZoneGraphics = this.add.graphics();
    this.gasZoneGraphics.setDepth(50); // Î±ÄÎ≥¥Îã§ ÏïÑÎûò, Í∑∏Î¶¨ÎìúÎ≥¥Îã§ ÏúÑ
    this.gasZoneParticles = []; // EMP ÌååÌã∞ÌÅ¥Îì§
    this.gasZonePulseTime = 0; // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖòÏö©
    this.gasZoneCenterX = 0; // Ïõê Ï§ëÏã¨ X
    this.gasZoneCenterY = 0; // Ïõê Ï§ëÏã¨ Y

    // ===== Polarity System (ÎπÑÌôúÏÑ±Ìôî - Î†àÏù¥Ï†Ä ÌÑ∞Î†õÏúºÎ°ú ÎåÄÏ≤¥) =====
    this.polarityEnabled = false;
    this.currentPolarity = 'N';
    this.polarityChangeInterval = 10000;
    this.polarityTimer = null;
    this.polarityWarningTimer = null;
    this.polarityMarker = null;
    this.polarityUI = null;
    this.polarityUILabel = null;
    this.polarityChangeWarningTime = 2000;
    this.isPolarityWarning = false;

    // ===== Magnetic Turrets (ÎπÑÌôúÏÑ±Ìôî - Î†àÏù¥Ï†Ä ÌÑ∞Î†õÏúºÎ°ú ÎåÄÏ≤¥) =====
    this.magneticTurrets = [];
    this.turretForceRadius = 5;
    this.turretPulseTime = 0;
    this.turretAnimTimer = null;
    this.baseSpeed = 90;
    this.currentSpeedModifier = 1.0;

    // ===== Laser Turrets (Stage 14: Flux Maze) =====
    this.laserTurrets = []; // [{x, y, container, angle, laserGraphics, warningGraphics, isActive}]
    this.laserTurretPositions = [
      { x: 10, y: 8 },   // Ï¢åÏÉÅÎã®
      { x: 29, y: 8 },   // Ïö∞ÏÉÅÎã®
      { x: 10, y: 19 },  // Ï¢åÌïòÎã®
      { x: 29, y: 19 }   // Ïö∞ÌïòÎã®
    ];
    this.laserRotationSpeed = 0.015; // Î†àÏù¥Ï†Ä ÌöåÏ†Ñ ÏÜçÎèÑ ÏôÑÌôî
    this.laserLength = 22; // Î†àÏù¥Ï†Ä Í∏∏Ïù¥ (ÌÉÄÏùº) ÏÜåÌè≠ Í∞êÏÜå
    this.laserFireInterval = 6000; // Î∞úÏÇ¨ Ï£ºÍ∏∞ ÏôÑÌôî
    this.laserWarningDuration = 1500; // Í≤ΩÍ≥† 1.5Ï¥à
    this.laserActiveDuration = 1500; // Î†àÏù¥Ï†Ä ÌôúÏÑ± ÏãúÍ∞Ñ Îã®Ï∂ï
    this.laserAnimTimer = null; // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.laserFireTimer = null; // Î∞úÏÇ¨ ÌÉÄÏù¥Î®∏
    this.laserPhase = 'idle'; // 'idle' | 'warning' | 'firing'

    // ===== Floating Mines (Stage 14: Flux Maze) =====
    this.floatingMines = []; // [{x, y, element, dx, dy, moveTimer}]
    this.maxFloatingMines = 3;
    this.mineSpeed = 2000; // 2Ï¥àÏóê 1Ïπ∏ Ïù¥Îèô (ÏôÑÌôî)
    this.mineSpawnTimer = null; // Í∏∞Î¢∞ ÏÉùÏÑ± ÌÉÄÏù¥Î®∏
    this.mineSpawnInterval = 7500; // ÏÉùÏÑ± Í∞ÑÍ≤© ÏôÑÌôî

    // ===== NEXUS Boss (Stage 15) =====
    this.nexusMode = false;
    this.nexusPhase = 'none'; // 'none' | 'intro' | 'phase1' | 'phase2' | 'phase3' | 'vulnerable' | 'victory'
    this.nexusPosition = null; // Î≥¥Ïä§ ÏúÑÏπò
    this.nexusElement = null; // Î≥¥Ïä§ Í∑∏ÎûòÌîΩ Ïª®ÌÖåÏù¥ÎÑà
    this.nexusHitCount = 0; // Î≥¥Ïä§ HIT ÌöüÏàò (4Ìöå ÌÅ¥Î¶¨Ïñ¥)
    this.nexusVulnerable = false; // ÏΩîÏñ¥ Ïò§Ìîà ÏÉÅÌÉú
    this.nexusHPBar = null; // HP Î∞î UI
    this.nexusPhaseText = null; // Phase ÌëúÏãú UI

    // NEXUS ÎåÄÏãú ÏãúÏä§ÌÖú
    this.nexusDashCharging = false; // Ï∞®ÏßÄ Ï§ë Ïó¨Î∂Ä
    this.nexusDashChargeStart = 0; // Ï∞®ÏßÄ ÏãúÏûë ÏãúÍ∞Ñ
    this.nexusDashCooldown = 2000; // Ïø®Îã§Ïö¥ 2Ï¥à
    this.nexusLastDashTime = 0; // ÎßàÏßÄÎßâ ÎåÄÏãú ÏãúÍ∞Ñ
    this.nexusDashInvincible = false; // ÎåÄÏãú Ï§ë Î¨¥Ï†Å
    this.nexusDashUI = null; // ÎåÄÏãú Ïø®Îã§Ïö¥ UI

    // NEXUS Í≥µÍ≤© Ìå®ÌÑ¥
    this.nexusScanBeams = []; // Ïä§Ï∫î Îπî Î∞∞Ïó¥
    this.nexusDataBlocks = []; // Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù Î∞∞Ïó¥
    this.nexusTrackers = []; // Ï∂îÏ†ÅÌÉÑ Î∞∞Ïó¥
    this.nexusEMPWaves = []; // EMP ÏÑúÏßÄ Î∞∞Ïó¥
    this.nexusMines = []; // ÏßÄÎ¢∞ Î∞∞Ïó¥
    this.nexusAttackTimer = null; // Í≥µÍ≤© Ìå®ÌÑ¥ ÌÉÄÏù¥Î®∏
    this.nexusAnimTimer = null; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏

    // NEXUS v2: Í≥†Ïä§Ìä∏ Î±Ä + ÎùºÏö¥Îìú ÏãúÏä§ÌÖú
    this.nexusGhostSnakes = []; // Ïä§Ï∫îÏóê ÎßûÏïÑ ÏÉùÏÑ±Îêú Îπ®Í∞Ñ Í≥†Ïä§Ìä∏ Î±Ä (Îç∞ÎìúÏ°¥)
    this.nexusRound = 0; // ÌòÑÏû¨ ÎùºÏö¥Îìú (1-4)
    this.nexusBinaryNodes = []; // Î∞îÏù¥ÎÑàÎ¶¨ ÎÖ∏Îìú Î∞∞Ïó¥ [{x, y, value, element}]
    this.nexusBinarySequence = []; // Î™©Ìëú ÏãúÌÄÄÏä§ [0, 1, 1, 0...]
    this.nexusBinaryCollected = []; // ÏàòÏßëÌïú ÏãúÌÄÄÏä§
    this.nexusTotalNodesCollected = 0; // Ï¥ù ÏàòÏßëÌïú ÎÖ∏Îìú Ïàò (10Í∞ú = ÌÅ¥Î¶¨Ïñ¥)
    this.nexusSequenceUI = null; // ÏãúÌÄÄÏä§ UI

    // Î†àÍ±∞Ïãú Ìò∏Ìôò (isMagnetarStage Ï≤¥ÌÅ¨Ïö©)
    this.magnetarMode = false;
    this.magnetarControlsReversed = false;

    // ===== Meta Universe (Stage 16-18) =====
    this.metaUniverseMode = false;
    this.currentUniverse = 1; // ÌòÑÏû¨ ÏúÑÏπò (1-6)
    this.universeColors = [
      0xff3333, // Universe 1: Îπ®Í∞ï
      0x3399ff, // Universe 2: ÌååÎûë
      0x33ff66, // Universe 3: Ï¥àÎ°ù
      0xffff33, // Universe 4: ÎÖ∏Îûë
      0xcc33ff, // Universe 5: Î≥¥Îùº
      0x33ffff  // Universe 6: ÏãúÏïà
    ];
    this.wormholes = []; // ÌôúÏÑ± ÏõúÌôÄÎì§ [{x, y, targetUniverse, color, container, graphics}]
    this.wormholeAnimTimer = null; // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.foodUniverse = 1; // Î®πÏù¥Í∞Ä ÏûàÎäî Universe
    this.wormholePassCount = 0; // ÏõúÌôÄ ÌÜµÍ≥º ÌöüÏàò
    this.metaUniverseFoodCount = 0; // Î®πÏùÄ Î®πÏù¥ Ïàò
    this.metaUniverseTargetFood = 20; // ÌÅ¥Î¶¨Ïñ¥ Ï°∞Í±¥: 20Í∞ú
    this.universeTitle = null; // "Universe X" ÌÉÄÏù¥ÌãÄ ÌÖçÏä§Ìä∏
    this.metaUniverseIntroShown = false; // Ïù∏Ìä∏Î°ú ÌëúÏãú Ïó¨Î∂Ä
    this.comboDisabled = false; // ÏΩ§Î≥¥ ÎπÑÌôúÏÑ±Ìôî Ïó¨Î∂Ä
    this.multiverseElements = []; // Î©ÄÌã∞Î≤ÑÏä§ Î∑∞ ÏöîÏÜåÎì§
    this.isUniverseTransitioning = false; // Ï†ÑÌôò Ï§ë Ïó¨Î∂Ä
    this.transitionSnakeLength = null; // Ï†ÑÌôò Ïãú Î±Ä Í∏∏Ïù¥ Ï†ÄÏû•

    // ===== Quantum Split System (Stage 17) =====
    this.quantumSplitMode = false;           // Î™®Îìú ÌôúÏÑ±Ìôî
    this.quantumViewports = [];              // 6Í∞ú RenderTexture [{rt, graphics, x, y, universeIndex}]
    this.quantumFoods = [];                  // 6Í∞ú Î®πÏù¥ ÏúÑÏπò [{x, y}]
    this.quantumTotalFood = 0;               // Ï¥ù Î®πÏùÄ Î®πÏù¥ Ïàò (6Í∞ú universe Ìï©ÏÇ∞)
    this.quantumTargetFood = 20;             // ÌÅ¥Î¶¨Ïñ¥ Ï°∞Í±¥: 20Í∞ú
    this.quantumViewportSize = {
      width: 266,                            // 800 / 3
      height: 270                            // 540 / 2
    };
    this.quantumVisibleTiles = 5;            // Î±Ä Î®∏Î¶¨ Í∏∞Ï§Ä Í∞Å Î∞©Ìñ• 5Ïπ∏ (11x11)
    this.quantumIntroShown = false;          // Ïù∏Ìä∏Î°ú ÌëúÏãú Ïó¨Î∂Ä
    this.quantumBorderGraphics = null;       // Î∑∞Ìè¨Ìä∏ ÌÖåÎëêÎ¶¨ Í∑∏ÎûòÌîΩ
    this.quantumBorderGlowLayers = [];       // Í∏ÄÎ°úÏö∞ Î†àÏù¥Ïñ¥Îì§
    this.quantumBorderPulseTimer = null;     // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.quantumCornerNodes = [];            // ÏΩîÎÑà ÎπõÎÇòÎäî ÎÖ∏ÎìúÎì§
    this.quantumEnergyParticles = [];        // ÌÖåÎëêÎ¶¨ Îî∞Îùº ÌùêÎ•¥Îäî ÏûÖÏûêÎì§
    this.quantumBorderAnimTimer = null;      // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.quantumFoodIndicators = [];         // Í∞Å universe Î®πÏù¥ ÌëúÏãú UI
    this.quantumTotalFoodText = null;        // Ï¥ù Î®πÏù¥ Ïπ¥Ïö¥ÌÑ∞ ÌÖçÏä§Ìä∏
    this.quantumFirstFoodSpawned = false;    // Ï≤´ Î®πÏù¥ Ïä§Ìè∞ Ïó¨Î∂Ä (1Î≤à/6Î≤à Í≥†Ï†ïÏö©)

    // ===== Multiverse Collapse Boss (Stage 18) =====
    this.multiverseCollapseMode = false;     // Î≥¥Ïä§ Î™®Îìú ÌôúÏÑ±Ìôî
    this.multiverseCollapsePhase = 'none';   // 'none'|'intro'|'fiveselves'|'fourthwall'|'victory'
    this.multiverseIntroShown = false;       // Ïù∏Ìä∏Î°ú ÏµúÏ¥à 1ÌöåÎßå (Î∂ÄÌôú Ïãú Ïä§ÌÇµ)

    // Phase 1: Five Selves (5Í∞úÏùò Í≥ºÍ±∞ ÏûêÏïÑ)
    this.ghostSnakes = [];                   // [{snake, direction, color, behavior, alive, graphics, trailElements, moveTimer}]
    this.ghostSnakesDefeated = 0;            // Ï†úÍ±∞Ìïú Í≥†Ïä§Ìä∏ Ïàò
    this.ghostColors = [
      0xff6b6b,  // Ghost 1: Îπ®Í∞ï (Stage 3 - Frog)
      0xffa500,  // Ghost 2: Ï£ºÌô© (Stage 6 - Bullet)
      0xffff00,  // Ghost 3: ÎÖ∏Îûë (Stage 9 - Fog)
      0x00ffff,  // Ghost 4: ÏãúÏïà (Stage 12 - Gear)
      0xff00ff   // Ghost 5: ÎßàÏ††ÌÉÄ (Stage 15 - NEXUS)
    ];
    this.ghostBehaviors = ['aggressive', 'evasive', 'stalking', 'pattern', 'smart'];
    this.ghostNames = [
      'Frog Slayer',
      'Bullet Dodger',
      'Fog Walker',
      'Gear Breaker',
      'Nexus Cracker'
    ];
    this.ghostDialogues = [
      'Stage 3... The Frog...',
      'Stage 6... Bullets everywhere...',
      'Stage 9... Lost in fog...',
      'Stage 12... Gears grinding...',
      'Stage 15... NEXUS... pain...'
    ];

    // Phase 2: Doppelganger (ÎèÑÌîåÍ∞±Ïñ¥)
    this.doppelganger = null;                // {snake, direction, hp, graphics, glowGraphics}
    this.doppelInputHistory = [];            // [{direction, time}] ÏûÖÎ†• Í∏∞Î°ù
    this.doppelInputDelay = 500;             // 0.5Ï¥à ÎîúÎ†àÏù¥
    this.doppelMaxHP = 5;                    // ÎèÑÌîåÍ∞±Ïñ¥ HP
    this.doppelRecordTimer = null;           // ÏûÖÎ†• Í∏∞Î°ù ÌÉÄÏù¥Î®∏
    this.doppelHPBar = null;                 // HP Î∞î Ïª®ÌÖåÏù¥ÎÑà
    this.doppelHPBarElements = [];           // HP Î∞î ÏöîÏÜåÎì§
    this.doppelColor = 0x9932cc;             // ÎèÑÌîåÍ∞±Ïñ¥ ÏÉâÏÉÅ (Îã§ÌÅ¨ Î∞îÏù¥Ïò¨Î†õ)

    // Phase 3: Become One (ÏúµÌï©)
    this.twoHeadedMode = false;              // ÏñëÎ®∏Î¶¨ Î™®Îìú
    this.fusionSnake = [];                   // [{x, y, headIndex}] headIndex: 0=Ï¥àÎ°ùÎ®∏Î¶¨, 1=Î≥¥ÎùºÎ®∏Î¶¨, -1=Î™∏ÌÜµ
    this.fusionDirection1 = 'RIGHT';         // Ï≤´ Î≤àÏß∏ Î®∏Î¶¨ Î∞©Ìñ• (WASD)
    this.fusionDirection2 = 'LEFT';          // Îëê Î≤àÏß∏ Î®∏Î¶¨ Î∞©Ìñ• (ÌôîÏÇ¥Ìëú)
    this.fusionInputQueue1 = [];             // Ï≤´ Î≤àÏß∏ Î®∏Î¶¨ ÏûÖÎ†• ÌÅê
    this.fusionInputQueue2 = [];             // Îëê Î≤àÏß∏ Î®∏Î¶¨ ÏûÖÎ†• ÌÅê
    this.fusionFoodCount = 0;                // ÏÑ±Í≥µÌïú Î®πÏù¥ Ïàò
    this.fusionTargetFood = 5;               // ÌÅ¥Î¶¨Ïñ¥ Ï°∞Í±¥
    this.fusionFood = null;                  // ÌòÑÏû¨ Î®πÏù¥ ÏúÑÏπò
    this.fusionFoodGraphics = null;          // Î®πÏù¥ Í∑∏ÎûòÌîΩ

    // Phase 2: Fourth Wall (Ï†ú4Ïùò Î≤Ω ÌååÍ¥¥) - ÏÉà Ïª®ÏÖâ
    this.fourthWallPhase = 'none';           // 'none'|'intro'|'score_attack'|'walls_closing'|'ui_chaos'|'game_over_hunt'
    this.fourthWallProjectiles = [];         // ÎÇ†ÏïÑÏò§Îäî Ïà´Ïûê/UI ÌÉÑÎßâ
    this.fourthWallBoundaries = null;        // {left, right, top, bottom} Ï¢ÅÌòÄÏßÄÎäî Î≤Ω
    this.fourthWallOriginalBounds = null;    // ÏõêÎûò Í≤ΩÍ≥Ñ Ï†ÄÏû•
    this.gameOverLetters = [];               // [{char, x, y, eaten, graphics}]
    this.gameOverLettersEaten = 0;           // Î®πÏùÄ Í∏ÄÏûê Ïàò
    this.fourthWallGraphics = null;          // Î©îÏù∏ Í∑∏ÎûòÌîΩ
    this.fourthWallUIElements = [];          // UI ÏöîÏÜåÎì§ (Ï†ïÎ¶¨Ïö©)
    this.fourthWallTimers = [];              // ÌÉÄÏù¥Î®∏Îì§ (Ï†ïÎ¶¨Ïö©)
    this.fakeGameOverCount = 0;              // Í∞ÄÏßú Í≤åÏûÑÏò§Î≤Ñ ÌöüÏàò

    // Multiverse Collapse Visual Effects
    this.multiverseElements = [];            // Ï†ïÎ¶¨Ïö© ÏöîÏÜå Î∞∞Ïó¥ (Ï§ëÎ≥µ ÏÑ†Ïñ∏Ïù¥ÏßÄÎßå Î≥¥Ïä§Ïö©ÏúºÎ°ú Î∂ÑÎ¶¨)
    this.multiverseAnimTimer = null;         // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.multiverseBossElements = [];        // Î≥¥Ïä§ Ï†ÑÏö© ÏöîÏÜåÎì§

    // ===== Runner Mode (ÏóîÎî© Îü¨ÎÑà Í≤åÏûÑ) =====
    this.runnerMode = false;                 // Îü¨ÎÑà Î™®Îìú ÌôúÏÑ±Ìôî
    this.runnerPhase = 'none';               // 'none'|'transition'|'intro'|'playing'
    this.runnerSpeed = 5;                    // Ïù¥Îèô ÏÜçÎèÑ
    this.runnerY = 0;                        // ÌîåÎ†àÏù¥Ïñ¥ Y ÏúÑÏπò
    this.runnerGroundY = 0;                  // Î∞îÎã• Y ÏúÑÏπò
    this.runnerJumping = false;              // Ï†êÌîÑ Ï§ë
    this.runnerJumpVelocity = 0;             // Ï†êÌîÑ ÏÜçÎèÑ
    this.runnerGravity = 0.8;                // Ï§ëÎ†•
    this.runnerJumpPower = -15;              // Ï†êÌîÑÎ†•
    this.runnerObstacles = [];               // Ïû•Ïï†Î¨º Î∞∞Ïó¥ [{x, y, type, graphics}]
    this.runnerDeadSnakes = [];              // Ï£ΩÏùÄ Î±Ä Î∞∞Í≤Ω [{x, y, graphics}]
    this.runnerWhiteSnakes = [];             // ÏúÑÎ°ú Îã¨Î¶¨Îäî Ìù∞ Î±ÄÎì§
    this.runnerDistance = 0;                 // Îã¨Î¶∞ Í±∞Î¶¨
    this.runnerGraphics = null;              // Î©îÏù∏ Í∑∏ÎûòÌîΩ
    this.runnerElements = [];                // Ï†ïÎ¶¨Ïö© ÏöîÏÜå Î∞∞Ïó¥
    this.runnerTimers = [];                  // ÌÉÄÏù¥Î®∏ Î∞∞Ïó¥
    this.runnerPlayerSnake = [];             // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä ÏÑ∏Í∑∏Î®ºÌä∏
    this.runnerIntroComplete = false;        // Ïù∏Ìä∏Î°ú ÏôÑÎ£å Ïó¨Î∂Ä
    this.runnerDistanceText = null;          // Í±∞Î¶¨ ÌÖçÏä§Ìä∏

    // ÏãúÏïº Ï†úÌïú(Fog of War)
    this.fogStageStart = 7;
    this.fogTestForceEnable = false; // stage 7Î∂ÄÌÑ∞ Ï†ÅÏö©
    this.fogVisibleTiles = 4.0;
    this.fogBaseAlpha = 1.0;
    this.fogFlashAlpha = 0.32;
    this.fogFlashDuration = 300;
    this.fogRenderTexture = null;
    this.fogLightSprite = null;
    this.fogLightTextureKey = 'fog_light_mask';
    this.fogFlashEndTime = 0;
    this.fogFlashUpdateTimer = null;
    this.fogLastRenderKey = null;
    this.fogEnabled = false;
    this.fogTorchEnabled = true; // ÌöÉÎ∂à(Îπõ) ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
    this.fogIntroShown = false;
    this.fogIntroPlaying = false;

    // Stage 8: ÌöÉÎ∂à Î∏îÎûôÏïÑÏõÉ (Î®πÏù¥ 10Í∞úÎ∂ÄÌÑ∞)
    this.stage8BlackoutCycleStarted = false;
    this.stage8BlackoutActive = false;
    this.stage8BlackoutTimer = null;
    this.stage8BlackoutEndTimer = null;
    this.stage8BlackoutSnakeGraphics = null;

    // Stage 7-8: Ïñ¥Îë† Ï∞¢Ïñ¥Ïßê Ïó∞Ï∂ú (Î®πÏù¥ 10Í∞úÎ∂ÄÌÑ∞)
    this.darkCreepCycleStarted = false;
    this.darkCreepTimer = null;
    this.darkCreepInterval = 3000;
    this.darkCreepEffects = [];

    // Stage 8: Í∑ÄÏã† Î™π Ïä§Ìè∞
    this.stage8Ghosts = [];
    this.stage8GhostSpawnTimer = null;
    this.stage8GhostSpawnActive = false;
    this.stage8GhostMax = 3;
    this.stage8GhostLifetime = 3000;

    // ESC ÏùºÏãúÏ†ïÏßÄ
    this.isEscPaused = false;
    this.escPauseElements = [];

    // Î®πÏù¥
    this.food = this.generateFood();
    // this.foodBubbleÏùÄ generateFood()ÏóêÏÑú checkAndShowFoodBubble()ÏùÑ ÌÜµÌï¥ ÏûêÎèôÏúºÎ°ú ÏÑ§Ï†ïÎê®

    // Ï†êÏàò
    this.score = 0;
    this.foodCount = 0; // Î®πÏùÄ Î®πÏù¥ Í∞úÏàò

    // Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏä§ÌÖú
    this.currentStage = 1; // ÌòÑÏû¨ Ïä§ÌÖåÏù¥ÏßÄ (1~100)
    this.maxStages = 100; // ÏµúÎåÄ Ïä§ÌÖåÏù¥ÏßÄ

    // Î±Ä Î®∏Î¶¨ Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏÉùÏÑ± (ÌòÑÏû¨ ÎØ∏ÏÇ¨Ïö©)
    this.snakeHeadSprite = this.add.sprite(0, 0, 'snake_head_side');
    this.snakeHeadSprite.setOrigin(0.5, 0.5);
    this.snakeHeadSprite.setScale(0.5); // 40px ‚Üí 20pxÎ°ú Ïä§ÏºÄÏùº Ï°∞Ï†ï (ÏôÑÎ≤ΩÌïú Ï†ïÏàò Î∞∞Ïú®!)
    this.snakeHeadSprite.setVisible(false); // ÏÇ¨Ïö© ÏïàÌï®
    this.snakeHeadSprite.setDepth(100);

    // UI ÌÖçÏä§Ìä∏Îì§ - 4Í∞ú Í∑†Îì± Î∞∞Ïπò
    const sectionWidth = width / 4;

    // SCORE ÏÑπÏÖò
    this.add.text(sectionWidth * 0.5, 10, 'SCORE:', {
      fontSize: '12px',
      fill: '#888',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);
    this.scoreText = this.add.text(sectionWidth * 0.5, 28, '0', {
      fontSize: '24px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);

    // FOOD ÏÑπÏÖò
    this.add.text(sectionWidth * 1.5, 10, 'FOOD:', {
      fontSize: '12px',
      fill: '#888',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);
    this.foodCountText = this.add.text(sectionWidth * 1.5, 28, '0', {
      fontSize: '24px',
      fill: '#ff6600',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);

    // COMBO ÏÑπÏÖò
    this.add.text(sectionWidth * 2.5, 10, 'COMBO:', {
      fontSize: '12px',
      fill: '#888',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);
    this.comboText = this.add.text(sectionWidth * 2.5, 28, '', {
      fontSize: '24px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff0000',
      strokeThickness: 2
    }).setOrigin(0.5, 0).setDepth(2001);

    // SPEED ÏÑπÏÖò
    this.add.text(sectionWidth * 3.5, 10, 'SPEED:', {
      fontSize: '12px',
      fill: '#888',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);
    this.speedText = this.add.text(sectionWidth * 3.5, 28, '90ms', {
      fontSize: '24px',
      fill: '#00aaff',
      fontStyle: 'bold'
    }).setOrigin(0.5, 0).setDepth(2001);

    // ESC ÏùºÏãúÏ†ïÏßÄ ÏïàÎÇ¥ (ÏÉÅÏ†ê Ï†úÏô∏)
    this.pauseHintText = this.add.text(14, height - this.bottomUIHeight + 20, 'ESC: PAUSE', {
      fontSize: '11px',
      fill: '#666666'
    }).setOrigin(0, 0.5).setDepth(2001);

    // Î®πÏù¥ ÌÖîÎ†àÌè¨Ìä∏ ÏãúÏä§ÌÖú (21Î≤àÏß∏Î∂ÄÌÑ∞)
    this.foodTeleportEnabled = false;
    this.currentFoodTeleportCount = 0; // ÌòÑÏû¨ Î®πÏù¥Í∞Ä Î™á Î≤à ÌÖîÎ†àÌè¨Ìä∏ÎêòÏóàÎäîÏßÄ (ÏµúÎåÄ 2Î≤à)
    this.nextTeleportStep = 0; // Îã§Ïùå ÌÖîÎ†àÌè¨Ìä∏ÍπåÏßÄ ÎÇ®ÏùÄ Ïä§ÌÖù

    // ÏΩ§Î≥¥ ÏãúÏä§ÌÖú
    this.combo = 0;
    this.maxCombo = 0; // ÏµúÎåÄ ÏΩ§Î≥¥ Ï∂îÏ†Å
    this.directionChangesCount = 0; // Î®πÏù¥ Î®πÏùÄ ÌõÑ Î∞©Ìñ• Ï†ÑÌôò ÌöüÏàò
    this.hasEatenFirstFood = false; // Ï≤´ Î®πÏù¥Î•º Î®πÏóàÎäîÏßÄ Ïó¨Î∂Ä
    this.comboLost = false; // Ïã§Îìú Î∂ÄÏ°±ÏúºÎ°ú ÏΩ§Î≥¥Í∞Ä ÎÅäÏñ¥Ï°åÎäîÏßÄ
    this.shieldsUsedThisCycle = false; // Ïù¥Î≤à Î®πÏù¥ ÏÇ¨Ïù¥ÌÅ¥ÏóêÏÑú Ïã§ÎìúÍ∞Ä ÏÇ¨Ïö©ÎêòÏóàÎäîÏßÄ

    this.comboFeedback = null; // ÏΩ§Î≥¥ ÌîºÎìúÎ∞± ÌëúÏãúÏö©

    // ÏïÑÏù¥ÌÖú ÏãúÏä§ÌÖú
    this.items = []; // ÌòÑÏû¨ ÌôîÎ©¥Ïóê ÏûàÎäî ÏïÑÏù¥ÌÖú Î∞∞Ïó¥
    this.itemSpawnTimer = null; // ÏïÑÏù¥ÌÖú ÏÉùÏÑ± ÌÉÄÏù¥Î®∏
    this.nextItemDelay = 5000; // Îã§Ïùå ÏïÑÏù¥ÌÖúÍπåÏßÄ ÎåÄÍ∏∞ ÏãúÍ∞Ñ (Î∞ÄÎ¶¨Ï¥à)
    this.itemDelays = [5000, 4000, 3000, 2000]; // ÏïÑÏù¥ÌÖú ÏÉùÏÑ± Í∞ÑÍ≤© (5Ï¥à -> 4Ï¥à -> 3Ï¥à -> 2Ï¥à)
    this.itemDelayIndex = 0; // ÌòÑÏû¨ ÎîúÎ†àÏù¥ Ïù∏Îç±Ïä§

    // ÏÉÅÏ†ê ÏãúÏä§ÌÖú (Stage 2 ÌÅ¥Î¶¨Ïñ¥ ÌõÑ Ïò§Ìîà)
    this.money = 0; // Î≥¥Ïú† Îèà
    this.shopOpen = false; // ÏÉÅÏ†ê Ïó¥Î¶º ÏÉÅÌÉú
    this.hasOpenedShopBefore = false; // Ï≤´ ÏÉÅÏ†ê Ïò§Ìîà Ïó¨Î∂Ä
    this.shopElements = []; // ÏÉÅÏ†ê UI ÏöîÏÜåÎì§
    this.selectedShopIndex = 0; // ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖú Ïù∏Îç±Ïä§
    this.shopItems = getShopItems(); // items.jsÏóêÏÑú ÏïÑÏù¥ÌÖú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    this.shopKeyboardEnabled = false; // ÏÉÅÏ†ê ÌÇ§Î≥¥Îìú ÌôúÏÑ±Ìôî
    this.isPurchaseConfirmOpen = false; // Íµ¨Îß§ ÌôïÏù∏ Ï∞Ω ÏÉÅÌÉú
    this.lastShopFocusKey = null; // Ìè¨Ïª§Ïä§ Î≥ÄÌôîÎ•º Í∞êÏßÄÌï¥ ÎßàÏù¥ÌÅ¨Î°ú Ïù∏ÌÑ∞ÎûôÏÖò Ï†ÅÏö©
    this.purchaseConfirmElements = []; // Íµ¨Îß§ ÌôïÏù∏ ÏïåÎüø Íµ¨ÏÑ± ÏöîÏÜå
    this.purchaseConfirmButtons = null; // Íµ¨Îß§ ÌôïÏù∏ ÏïåÎüø Î≤ÑÌäº Ï∫êÏã±
    this.purchaseConfirmSelection = 'yes'; // Íµ¨Îß§ ÌôïÏù∏ Ìè¨Ïª§Ïä§ (yes/no)
    this.pendingPurchaseIndex = null; // ÌôïÏù∏ ÌõÑ Íµ¨Îß§Ìï† ÏïÑÏù¥ÌÖú Ïù∏Îç±Ïä§
    this.lastPurchaseConfirmKey = null; // Íµ¨Îß§ ÌôïÏù∏Ï∞Ω Ìè¨Ïª§Ïä§ Ìä∏ÎûòÌÇπ

    // ÏïÑÏù¥ÌÖú Ìö®Í≥º ÏÉÅÌÉú
    this.comboShieldCount = 0; // ÏΩ§Î≥¥ Ïã§Îìú Í∞úÏàò (Ïó¨Îü¨ Í∞ú ÏßÄÏõê)
    this.hasHadShield = false; // Ïã§ÎìúÎ•º Í∞ÄÏ°åÎçò Ï†ÅÏù¥ ÏûàÎäîÏßÄ (NO SHIELD ÌëúÏãúÏö©)
    this.hasSpeedBoost = false; // Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ ÏàòÌä∏ ÌôúÏÑ±Ìôî
    this.speedBoostOrbitals = []; // Í∂§ÎèÑ ÌååÌã∞ÌÅ¥Îì§ (Ïù∏Í≤åÏûÑÏö©)
    this.speedBoostAngle = 0; // Í∂§ÎèÑ ÌöåÏ†Ñ Í∞ÅÎèÑ
    this.speedBoostOrbitalTimer = null; // Í∂§ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏

    // Î∂ÄÌôú ÏãúÏä§ÌÖú (500Ïõê Î∂ÄÌôú)
    this.reviveCost = 500; // Î∂ÄÌôú ÎπÑÏö©
    this.isReviving = false; // Î∂ÄÌôú Ï≤òÎ¶¨ Ï§ë ÌîåÎûòÍ∑∏
    this.reviveElements = []; // Î∂ÄÌôú UI ÏöîÏÜåÎì§ (Ï†ïÎ¶¨Ïö©)

    // Ïù∏Í≤åÏûÑ ÏïÑÏù¥ÌÖú ÏÉÅÌÉú UI (Ïö∞Ï∏° ÌïòÎã®)
    this.createItemStatusUI();

    // Î±ÖÌÇπ/ÎåÄÏ∂ú ÏãúÏä§ÌÖú (Ï†ÑÎ©¥ Í∞úÌé∏)
    this.loans = []; // ÏùÄÌñâÎ≥Ñ ÎåÄÏ∂ú Î∞∞Ïó¥ [{bankId, bankName, principal, interestRate, due}]
    this.loanTier = 0; // ÌòÑÏû¨ ÎåÄÏ∂ú Ìã∞Ïñ¥ (0: ÎØ∏ÎåÄÏ∂ú, 1: 1Ï∞®, 2: 2Ï∞®, 3: 3Ï∞®)
    this.totalDebt = 0; // Ï¥ù Î∂ÄÏ±Ñ
    this.loanUIOpen = false; // ÎåÄÏ∂ú UI Ïó¥Î¶º ÏÉÅÌÉú
    this.isLoanProcessing = false; // ÎåÄÏ∂ú Ï≤òÎ¶¨ Ï§ë (ÏóîÌÑ∞ Ïó∞ÌÉÄ Î∞©ÏßÄ)
    this.loanElements = []; // ÎåÄÏ∂ú UI ÏöîÏÜåÎì§
    this.selectedBankIndex = 0; // ÏÑ†ÌÉùÎêú ÏùÄÌñâ Ïù∏Îç±Ïä§
    this.availableBanks = []; // ÌòÑÏû¨ Ïù¥Ïö© Í∞ÄÎä•Ìïú ÏùÄÌñâ Î™©Î°ù
    this.loanMode = 'borrow'; // 'borrow' ÎòêÎäî 'repay'
    this.missedPayments = 0; // Ïó∞ÏÜç ÎØ∏ÎÇ© ÌöüÏàò (2Ìöå = Í≤åÏûÑÏò§Î≤Ñ)
    this.minimumPaymentRate = 0.1; // ÏµúÏÜå ÏÉÅÌôòÏú® (Ï¥ù Î∂ÄÏ±ÑÏùò 10%)

    // Î≥¥Ïä§Ï†Ñ ÏãúÏä§ÌÖú
    this.isBossStage = false; // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ïó¨Î∂Ä
    this.bossMode = false; // Î≥¥Ïä§Ï†Ñ ÏßÑÌñâ Ï§ë
    this.bossPhase = 'none'; // 'intro', 'trap', 'poisoned', 'battle', 'victory'
    this.snakePoisoned = false; // ÎèÖ ÏÉÅÌÉú (Î≥¥ÎùºÏÉâ Î±Ä)
    this.poisonGrowthActive = false; // ÎèÖ ÏÑ±Ïû• ÌôúÏÑ±Ìôî
    this.poisonGrowthData = null; // ÎèÖ ÏÑ±Ïû• Îç∞Ïù¥ÌÑ∞
    this.bossHitCount = 0; // Î≥¥Ïä§ Ï†ÅÏ§ë ÌöüÏàò (4Î≤à ÌÅ¥Î¶¨Ïñ¥)
    this.bossElement = null; // Î≥¥Ïä§ Í∑∏ÎûòÌîΩ ÏöîÏÜå
    this.bossPosition = null; // Î≥¥Ïä§ ÏúÑÏπò
    this.poisonGrowthTarget = 40; // ÎèÖ ÏÉÅÌÉú Î™©Ìëú Í∏∏Ïù¥
    this.bossInputBlocked = false; // Î≥¥Ïä§ Ïù∏Ìä∏Î°ú Ï§ë ÏûÖÎ†• Ï∞®Îã®
    this.poisonSpeedTarget = 40; // ÎèÖ ÏÉÅÌÉú Î™©Ìëú ÏÜçÎèÑ
    this.savedCombo = 0; // Î≥¥Ïä§Ï†Ñ Ï†Ñ ÏΩ§Î≥¥ Ï†ÄÏû•
    this.savedComboShieldCount = 0; // Î≥¥Ïä§Ï†Ñ Ï†Ñ Ïã§Îìú Ï†ÄÏû•
    this.bossCorners = []; // Î≥¥Ïä§Í∞Ä ÎÇòÌÉÄÎÇ† ÏΩîÎÑà ÏúÑÏπòÎì§
    this.originalSnakeColor = 0x00ff00; // ÏõêÎûò Î±Ä ÏÉâÏÉÅ
    this.bossStageInterval = 3; // Î≥¥Ïä§ Îì±Ïû• Ïä§ÌÖåÏù¥ÏßÄ Í∞ÑÍ≤©
    this.testBossStage = 3; // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ

    // ========== ÌÉÑÎßâ ÏäàÌåÖ Î≥¥Ïä§ ÏãúÏä§ÌÖú (Bullet Hell Boss) ==========
    this.bulletBossMode = false; // ÌÉÑÎßâ Î≥¥Ïä§ Î™®Îìú ÌôúÏÑ±Ìôî
    this.bulletBossPhase = 'none'; // 'none' | 'intro' | 'shooting' | 'vulnerable' | 'victory'
    this.bulletBossPosition = null; // Î≥¥Ïä§ ÏúÑÏπò {x, y}
    this.bulletBossElement = null; // Î≥¥Ïä§ Í∑∏ÎûòÌîΩ Ïª®ÌÖåÏù¥ÎÑà
    this.bulletBossHitCount = 0; // Î≥¥Ïä§ HIT ÌöüÏàò (4Î≤à ÌÅ¥Î¶¨Ïñ¥)
    this.testBulletBossStage = 6; // Stage 6ÏóêÏÑú ÌÉÑÎßâ Î≥¥Ïä§
    this.bulletBossWaveCount = 0; // ÌòÑÏû¨ Ïõ®Ïù¥Î∏å
    this.bulletBossVulnerableTimer = null; // vulnerable ÏÉÅÌÉú ÌÉÄÏù¥Î®∏
    this.bulletBossTeleportStrikeTimers = []; // ÌÖîÎ†àÌè¨Ìä∏ ÌõÑ Ï∂îÍ∞Ä Í≥µÍ≤© ÌÉÄÏù¥Î®∏Îì§
    this.bulletBossTeleportStrikeEffects = []; // (Ìò∏Ìôò/Ï†ïÎ¶¨Ïö©) ÌÖîÎ†àÌè¨Ìä∏ Ïó∞Ï∂ú ÏöîÏÜåÎì§

    // Ï¥ùÏïå ÏãúÏä§ÌÖú
    this.bullets = []; // [{x, y, dx, dy, speed, graphics, trail}, ...]
    this.bulletUpdateTimer = null; // 60fps ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    this.bulletSpawnTimer = null; // Ï¥ùÏïå Î∞úÏÇ¨ ÌÉÄÏù¥Î®∏

    // ÌöåÌîº ÏãúÏä§ÌÖú (Dodge Roll)
    this.canDodge = true; // ÌöåÌîº Í∞ÄÎä• Ïó¨Î∂Ä
    this.dodgeCooldown = 0; // Î¨¥Ìïú Îã∑ÏßÄ
    this.lastDodgeTime = 0; // ÎßàÏßÄÎßâ ÌöåÌîº ÏãúÍ∞Ñ
    this.lastDodgeDirection = 'up'; // Î≤àÍ∞àÏïÑÍ∞ÄÎ©∞ up/down ÎòêÎäî left/right
    this.isInvincible = false; // ÌöåÌîº Ï§ë Î¨¥Ï†Å ÏÉÅÌÉú
    this.dodgeCooldownUI = null; // Ïø®Îã§Ïö¥ UI ÏöîÏÜå
    this.dodgeTutorialShown = false; // ÌäúÌÜ†Î¶¨Ïñº ÌëúÏãú Ïó¨Î∂Ä (Îß§ Î≥¥Ïä§Ï†ÑÎßàÎã§ Ï¥àÍ∏∞Ìôî)
    this.tutorialOpen = false; // ÌäúÌÜ†Î¶¨Ïñº Ïó¥Î¶º ÏÉÅÌÉú (Îã∑ÏßÄ ÎπÑÌôúÏÑ±ÌôîÏö©)
    this.postDodgeShieldActive = false; // Îã∑ÏßÄ ÌõÑ Î≥¥Ìò∏Îßâ ÌôúÏÑ±Ìôî ÏÉÅÌÉú
    this.postDodgeShieldElements = []; // Î≥¥Ìò∏Îßâ Í∑∏ÎûòÌîΩ ÏöîÏÜåÎì§
    this.postDodgeShieldTimer = null; // Î≥¥Ìò∏Îßâ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    this.shieldParticles = null; // ÌöåÏ†Ñ ÌååÌã∞ÌÅ¥Îì§

    // ========== ÏïàÍ∞ú Î≥¥Ïä§ ÏãúÏä§ÌÖú (Fog Boss - Nocturn) ==========
    this.fogBossMode = false; // ÏïàÍ∞ú Î≥¥Ïä§ Î™®Îìú ÌôúÏÑ±Ìôî
    this.fogBossPhase = 'none'; // 'none' | 'intro' | 'shadow' | 'hallucination' | 'eclipse' | 'victory'
    this.fogBossPosition = null; // Î≥¥Ïä§ ÏúÑÏπò {x, y}
    this.fogBossElement = null; // Î≥¥Ïä§ Í∑∏ÎûòÌîΩ Ïª®ÌÖåÏù¥ÎÑà (Ïó∞Í∏∞ + Îàà)
    this.fogBossHitCount = 0; // Î≥¥Ïä§ HIT ÌöüÏàò (4Î≤à ÌÅ¥Î¶¨Ïñ¥)
    this.fogBossVisible = false; // Î≥¥Ïä§ Í∞ÄÏãú ÏÉÅÌÉú
    this.testFogBossStage = 9; // Stage 9 (World 2 Î≥¥Ïä§ - ÎÖπÌÑ¥)
    this.fogBossBonus = 1500; // ÌÅ¥Î¶¨Ïñ¥ Î≥¥ÎÑàÏä§ Ï†êÏàò
    this.fogBossElements = []; // Î≥¥Ïä§ Í¥ÄÎ†® UI ÏöîÏÜåÎì§ (Ï†ïÎ¶¨Ïö©)
    this.fogBossInputBlocked = false; // Ïù∏Ìä∏Î°ú Ï§ë ÏûÖÎ†• Ï∞®Îã®
    this.savedFogBossCombo = 0; // Î≥¥Ïä§Ï†Ñ Ï†Ñ ÏΩ§Î≥¥ Ï†ÄÏû•
    this.savedFogBossShieldCount = 0; // Î≥¥Ïä§Ï†Ñ Ï†Ñ Ïã§Îìú Ï†ÄÏû•

    // Ï°∞Î™ÖÌÉÑ ÏãúÏä§ÌÖú (Flare - ÌîåÎ†àÏù¥Ïñ¥ Í≥µÍ≤©)
    this.flares = []; // ÌôúÏÑ± Ï°∞Î™ÖÌÉÑ Î∞∞Ïó¥ [{x, y, container, glow, core}]
    this.flareCount = 0; // ÏàòÏßëÌïú Ï°∞Î™ÖÌÉÑ Í∞úÏàò
    this.flareLightRadius = 6; // Ï°∞Î™ÖÌÉÑ Ìè≠Î∞ú Î∞òÍ≤Ω (ÌÉÄÏùº)
    this.flareActive = false; // Ï°∞Î™ÖÌÉÑ Ìè≠Î∞ú ÌôúÏÑ±Ìôî
    this.flareSpawnTimer = null; // Ï°∞Î™ÖÌÉÑ ÏÉùÏÑ± ÌÉÄÏù¥Î®∏
    this.flareSpawnInterval = 8000; // Ï°∞Î™ÖÌÉÑ ÏÉùÏÑ± Í∞ÑÍ≤© (ms)

    // Shadow Strike ÌéòÏù¥Ï¶à (1Îã®Í≥Ñ)
    this.shadowStrikeWarningActive = false; // Îπ®Í∞Ñ Îàà Í≤ΩÍ≥† ÌôúÏÑ±Ìôî
    this.shadowStrikeTimer = null; // Í≥µÍ≤© ÌÉÄÏù¥Î®∏
    this.shadowStrikeInterval = [3000, 5000]; // Í≥µÍ≤© Í∞ÑÍ≤© Î≤îÏúÑ (ms)
    this.shadowStrikeWarningTime = 1000; // Í≤ΩÍ≥† ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
    this.shadowStrikeTargetPos = null; // Í≥µÍ≤© Î™©Ìëú ÏúÑÏπò

    // üÜï Stalking & Jump Scare ÏãúÏä§ÌÖú
    this.stalkingActive = false; // Ïû†Î≥µ Îã®Í≥Ñ ÌôúÏÑ±Ìôî
    this.stalkingEyes = null; // Ïä§ÌÜ†ÌÇπ Îàà ÏöîÏÜå
    this.stalkingTimer = null; // Îàà ÍπúÎπ°ÏûÑ ÌÉÄÏù¥Î®∏
    this.stalkingIntensity = 0; // Í∏¥Ïû•ÎèÑ (0-100)
    this.tensionBuildupTimer = null; // Í∏¥Ïû• Í≥†Ï°∞ ÌÉÄÏù¥Î®∏
    this.vignetteOverlay = null; // Îπ®Í∞Ñ ÎπÑÎÑ§Ìä∏ Ïò§Î≤ÑÎ†àÏù¥
    this.heartbeatTimer = null; // Ïã¨Ïû•Î∞ïÎèô Ìö®Í≥º ÌÉÄÏù¥Î®∏
    this.whisperTexts = ['...behind you...', '...closer...', '...run...', '...watching...'];
    this.currentWhisperIndex = 0;
    this.jumpScareActive = false; // Ï†êÌîÑ Ïä§ÏºÄÏñ¥ ÏßÑÌñâ Ï§ë
    this.jumpScareDodgeWindow = 500; // ÌöåÌîº Í∞ÄÎä• ÏãúÍ∞Ñ (ms)
    this.fakeOutChance = 0.3; // Í∞ÄÏßú Îì±Ïû• ÌôïÎ•† (30%)
    this.lastStalkingEyePos = null; // ÎßàÏßÄÎßâ Ïä§ÌÜ†ÌÇπ Îàà ÏúÑÏπò

    // üÜï ÏΩ§Î≥¥ Í≥µÍ≤© ÏãúÏä§ÌÖú (HIT 2+ Ïó∞ÏÜç Í≥µÍ≤©)
    this.comboAttackCount = 0; // ÌòÑÏû¨ ÏΩ§Î≥¥ Í≥µÍ≤© ÌöüÏàò
    this.maxComboAttacks = 0; // ÏµúÎåÄ ÏΩ§Î≥¥ Í≥µÍ≤© ÌöüÏàò
    this.comboAttackActive = false; // ÏΩ§Î≥¥ Í≥µÍ≤© ÏßÑÌñâ Ï§ë

    // üÜï Rage Mode ÏãúÏä§ÌÖú (HIT 3 Î∂ÑÎÖ∏ Î™®Îìú)
    this.rageModeActive = false; // Î∂ÑÎÖ∏ Î™®Îìú ÌôúÏÑ±Ìôî
    this.rageFlickerTimer = null; // ÌôîÎ©¥ ÍπúÎπ°ÏûÑ ÌÉÄÏù¥Î®∏
    this.rageGlitchTimer = null; // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º ÌÉÄÏù¥Î®∏
    this.rageWhisperTexts = ['...KILL...', '...DIE...', '...PAIN...', '...END YOU...', '...SUFFER...'];

    // üÜï Í∑πÌïú Í≥µÌè¨ ÏãúÏä§ÌÖú (The Presence - Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏ≤¥ Ïñ¥Îë†)
    this.presenceActive = false; // Ï°¥Ïû¨Í∞ê ÏãúÏä§ÌÖú ÌôúÏÑ±Ìôî
    this.presenceLevel = 0; // Ï°¥Ïû¨Í∞ê Î†àÎ≤® (0-100) - ÎÜíÏùÑÏàòÎ°ù Í≥µÌè¨
    this.browserDarkOverlay = null; // Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤Ω Ïñ¥Îë† Ïò§Î≤ÑÎ†àÏù¥ (DOM)
    this.browserShakeActive = false; // Î∏åÎùºÏö∞Ï†Ä ÌùîÎì§Î¶º Ìö®Í≥º
    this.attackDirection = null; // Í≥µÍ≤© Î∞©Ìñ• ('up', 'down', 'left', 'right')
    this.dodgeWindowActive = false; // ÌöåÌîº Ï∞Ω ÌôúÏÑ±Ìôî (SPACE ÎàåÎü¨Ïïº Ìï®)
    this.dodgeWindowTimer = null; // ÌöåÌîº Ï∞Ω ÌÉÄÏù¥Î®∏
    this.correctDodgeDirection = null; // Ï†ïÎãµ ÌöåÌîº Î∞©Ìñ•
    this.attackWarningElement = null; // Í≥µÍ≤© Í≤ΩÍ≥† UI
    this.presenceTimer = null; // Ï°¥Ïû¨Í∞ê Ï¶ùÍ∞Ä ÌÉÄÏù¥Î®∏
    this.lastAttackTime = 0; // ÎßàÏßÄÎßâ Í≥µÍ≤© ÏãúÍ∞Ñ
    this.attackCooldown = 8000; // Í≥µÍ≤© Ïø®Îã§Ïö¥ (8Ï¥à)
    this.presenceAttackCount = 0; // Í≥µÍ≤© ÌöüÏàò (Ï≤´ Í≥µÍ≤©ÏùÄ ÌöåÌîº ÏãúÍ∞Ñ 10Ï¥à)
    this.fogBossFirstDodgeGraceUsed = false; // Ï≤´ ÌöåÌîº 10Ï¥à Ïú†Ïòà ÏÇ¨Ïö© Ïó¨Î∂Ä
    this.dodgeAttemptCount = 0; // QTE ÌöåÌîº ÏãúÎèÑ ÌöüÏàò
    this.presencePulseTimer = null; // Î∏åÎùºÏö∞Ï†Ä ÌéÑÏä§ ÌÉÄÏù¥Î®∏
    this.playerDodged = false; // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Îã∑ÏßÄÎ•º ÎàåÎ†ÄÎäîÏßÄ (QTE)
    this.dodgeQTEActive = false; // QTE Îã∑ÏßÄ ÌôúÏÑ±Ìôî ÏÉÅÌÉú
    this.creepyCreatures = []; // Î¨¥ÏÑúÏö¥ ÏÉùÎ¨ºÎì§ Î∞∞Ïó¥
    this.creatureSpawnTimer = null; // ÏÉùÎ¨º Ïä§Ìè∞ ÌÉÄÏù¥Î®∏

    // Hallucination ÌéòÏù¥Ï¶à (2Îã®Í≥Ñ)
    this.hallucinationFoods = []; // ÌôòÍ∞Å Î®πÏù¥ Î∞∞Ïó¥ (4Í∞ú Í∞ÄÏßú + 1Í∞ú ÏßÑÏßú)
    this.realFoodIndex = 0; // ÏßÑÏßú Î®πÏù¥ Ïù∏Îç±Ïä§

    // Eclipse ÌéòÏù¥Ï¶à (3Îã®Í≥Ñ)
    this.eclipseActive = false; // ÏôÑÏ†ÑÌïú Ïñ¥Îë† ÌôúÏÑ±Ìôî
    this.lightOrb = null; // Íµ¨ÏõêÏùò Îπõ Ïò§Î∏å
    this.originalFogVisibleTiles = 4.0; // ÏõêÎûò ÏãúÏïº Î∞òÍ≤Ω Ï†ÄÏû•
    this.eclipseVisibility = 1.0; // Ïù¥ÌÅ¥Î¶ΩÏä§ Ï§ë ÏãúÏïº (ÌÉÄÏùº)

    // ========== Í∞úÎ∞úÏûê ÌÖåÏä§Ìä∏ Î™®Îìú (KK) ==========
    this.devModeEnabled = false; // Í∞úÎ∞úÏûê Î™®Îìú ÌôúÏÑ±Ìôî
    this.devModeElements = []; // Í∞úÎ∞úÏûê Î™®Îìú UI ÏöîÏÜåÎì§
    this.devStageButtons = []; // Ïä§ÌÖåÏù¥ÏßÄ ÏÑ†ÌÉù Î≤ÑÌäºÎì§
    this.lastKPressTime = 0; // ÎßàÏßÄÎßâ K ÌÇ§ ÏûÖÎ†• ÏãúÍ∞Ñ
    this.kPressThreshold = 300; // ÎçîÎ∏î ÌîÑÎ†àÏä§ Ïù∏Ïãù ÏãúÍ∞Ñ (ms)
    this.selectedDevStage = 1; // ÏÑ†ÌÉùÎêú Ïä§ÌÖåÏù¥ÏßÄ
    this.devScrollOffset = 0; // Ïä§ÌÅ¨Î°§ Ïò§ÌîÑÏÖã

    // ÌÇ§ ÏûÖÎ†• (ÏûÖÎ†• ÌÅê ÏãúÏä§ÌÖú)
    this.input.keyboard.on('keydown-LEFT', () => {
      if (this.devModeEnabled) return; // Í∞úÎ∞úÏûê Î™®ÎìúÏóêÏÑúÎäî Î¨¥Ïãú
      if (this.bossInputBlocked || this.fogBossInputBlocked) return;
      if (this.loanUIOpen) return;
      if (this.shopOpen) {
        this.handleShopInput('LEFT');
        return;
      }
      // Phase 3: ÌôîÏÇ¥ÌëúÎäî Îëê Î≤àÏß∏ Î®∏Î¶¨ Ï°∞Ïûë
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(2, 'LEFT');
        return;
      }
      this.startMusicOnFirstInput();
      this.addDirectionToQueue('LEFT');
    });
    this.input.keyboard.on('keydown-RIGHT', () => {
      if (this.devModeEnabled) return; // Í∞úÎ∞úÏûê Î™®ÎìúÏóêÏÑúÎäî Î¨¥Ïãú
      if (this.bossInputBlocked || this.fogBossInputBlocked) return;
      if (this.loanUIOpen) return;
      if (this.shopOpen) {
        this.handleShopInput('RIGHT');
        return;
      }
      // Phase 3: ÌôîÏÇ¥ÌëúÎäî Îëê Î≤àÏß∏ Î®∏Î¶¨ Ï°∞Ïûë
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(2, 'RIGHT');
        return;
      }
      this.startMusicOnFirstInput();
      this.addDirectionToQueue('RIGHT');
    });
    this.input.keyboard.on('keydown-UP', () => {
      if (this.devModeEnabled) return; // Í∞úÎ∞úÏûê Î™®ÎìúÏóêÏÑúÎäî Î¨¥Ïãú
      if (this.bossInputBlocked || this.fogBossInputBlocked) return;
      if (this.loanUIOpen) {
        this.handleLoanInput('UP');
        return;
      }
      if (this.shopOpen) {
        this.handleShopInput('UP');
        return;
      }
      // Phase 3: ÌôîÏÇ¥ÌëúÎäî Îëê Î≤àÏß∏ Î®∏Î¶¨ Ï°∞Ïûë
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(2, 'UP');
        return;
      }
      this.startMusicOnFirstInput();
      this.addDirectionToQueue('UP');
    });
    this.input.keyboard.on('keydown-DOWN', () => {
      if (this.devModeEnabled) return; // Í∞úÎ∞úÏûê Î™®ÎìúÏóêÏÑúÎäî Î¨¥Ïãú
      if (this.bossInputBlocked || this.fogBossInputBlocked) return;
      if (this.loanUIOpen) {
        this.handleLoanInput('DOWN');
        return;
      }
      if (this.shopOpen) {
        this.handleShopInput('DOWN');
        return;
      }
      // Phase 3: ÌôîÏÇ¥ÌëúÎäî Îëê Î≤àÏß∏ Î®∏Î¶¨ Ï°∞Ïûë
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(2, 'DOWN');
        return;
      }
      this.startMusicOnFirstInput();
      this.addDirectionToQueue('DOWN');
    });

    // ========== WASD ÌÇ§ (Phase 3: Become One - Ï≤´ Î≤àÏß∏ Î®∏Î¶¨ Ï°∞Ïûë) ==========
    this.input.keyboard.on('keydown-W', () => {
      if (this.devModeEnabled) return;
      if (this.bossInputBlocked) return;
      if (this.shopOpen || this.loanUIOpen) return;
      // Phase 3 ÏúµÌï© Î±Ä Î™®ÎìúÏóêÏÑúÎßå WASD ÏÇ¨Ïö©
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(1, 'UP');
      }
    });
    this.input.keyboard.on('keydown-A', () => {
      if (this.devModeEnabled) return;
      if (this.bossInputBlocked) return;
      if (this.shopOpen || this.loanUIOpen) return;
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(1, 'LEFT');
      }
    });
    this.input.keyboard.on('keydown-S', () => {
      if (this.devModeEnabled) return;
      if (this.bossInputBlocked) return;
      if (this.shopOpen || this.loanUIOpen) return;
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(1, 'DOWN');
      }
    });
    this.input.keyboard.on('keydown-D', () => {
      if (this.devModeEnabled) return;
      if (this.bossInputBlocked) return;
      if (this.shopOpen || this.loanUIOpen) return;
      if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
        this.handleFusionInput(1, 'RIGHT');
      }
    });

    // ENTER ÌÇ§ (ÏÉÅÏ†êÏóêÏÑú Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ)
    this.input.keyboard.on('keydown-ENTER', () => {
      if (this.devModeEnabled) return; // Í∞úÎ∞úÏûê Î™®ÎìúÏóêÏÑúÎäî Î¨¥Ïãú
      if (this.loanUIOpen) {
        this.handleLoanInput('ENTER');
        return;
      }
      if (this.shopOpen) {
        this.handleShopInput('ENTER');
      }
    });

    // SPACE ÌÇ§ (ÌöåÌîº - ÌÉÑÎßâ Î≥¥Ïä§Ï†ÑÏóêÏÑúÎßå ÌôúÏÑ±Ìôî)
    this.input.keyboard.on('keydown-SPACE', () => {
      if (this.gameOver) return;
      if (this.shopOpen || this.loanUIOpen) return;
      if (this.bossInputBlocked) return;
      if (this.isEscPaused) return;
      // ÌäúÌÜ†Î¶¨Ïñº Ï§ëÏóêÎäî Îã∑ÏßÄ ÎπÑÌôúÏÑ±Ìôî (Ïä§ÌÇµÎßå Îê®)
      if (this.tutorialOpen) return;

      // NEXUS v2: ÎåÄÏãú ÏãúÏä§ÌÖú Ï†úÍ±∞Îê® - Î∞îÏù¥ÎÑàÎ¶¨ ÏãúÌÄÄÏä§Î°ú ÎåÄÏ≤¥
      // if (this.nexusMode && this.nexusPhase !== 'intro' && this.nexusPhase !== 'victory') {
      //   this.startNexusDashCharge();
      // }

      // ÌÉÑÎßâ Î≥¥Ïä§ Î™®ÎìúÏóêÏÑú ÌöåÌîº Í∞ÄÎä• (6ÌÉÑ - ÎåÄÏãú + QTE)
      if (this.bulletBossMode && this.bulletBossPhase !== 'intro' && this.bulletBossPhase !== 'victory') {
        this.handleDodge();
      }
      // 9ÌÉÑ(ÏïàÍ∞ú Î≥¥Ïä§)ÏóêÏÑúÎäî QTE ÌöåÌîºÎßå Í∞ÄÎä• (ÎåÄÏãú ÎπÑÌôúÏÑ±Ìôî)
      if (this.fogBossMode && this.dodgeQTEActive) {
        this.handleDodgeQTEInput();
      }
    });

    // ESC ÌÇ§ (Ïù∏Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ - ÏÉÅÏ†ê/ÎåÄÏ∂ú UI Ï†úÏô∏)
    this.input.keyboard.on('keydown-ESC', () => {
      // Ïù¥ÎØ∏ ÏùºÏãúÏ†ïÏßÄ ÏÉÅÌÉúÎ©¥ Ïñ∏Ï†úÎì† Î≥µÍ∑Ä
      if (this.isEscPaused) {
        this.resumeFromEscPause();
        return;
      }

      if (this.devModeEnabled) return;
      if (this.gameOver || this.isReviving) return;
      if (this.shopOpen || this.loanUIOpen) return;
      if (this.bossInputBlocked || this.fogBossInputBlocked) return;
      if (this.tutorialOpen) return;
      if (this.fogIntroPlaying) return;
      if (this.isStageClearingAnimation) return;

      this.pauseFromEsc();
    });

    // NEXUS v2: ÎåÄÏãú ÏãúÏä§ÌÖú Ï†úÍ±∞Îê® - Î∞îÏù¥ÎÑàÎ¶¨ ÏãúÌÄÄÏä§Î°ú ÎåÄÏ≤¥
    // this.input.keyboard.on('keyup-SPACE', () => {
    //   if (this.nexusMode && this.nexusDashCharging) {
    //     this.executeNexusDash();
    //   }
    // });

    // K ÌÇ§ (Í∞úÎ∞úÏûê Î™®Îìú - ÎçîÎ∏î ÌîÑÎ†àÏä§)
    this.input.keyboard.on('keydown-K', () => {
      // Í∞úÎ∞úÏûê Î™®Îìú UIÍ∞Ä Ïó¥Î†§ÏûàÏùÑ ÎïåÎäî Î¨¥Ïãú
      if (this.devModeEnabled) return;

      const now = Date.now();
      if (now - this.lastKPressTime < this.kPressThreshold) {
        // ÎçîÎ∏î ÌîÑÎ†àÏä§ Í∞êÏßÄ - Í∞úÎ∞úÏûê Î™®Îìú Ïó¥Í∏∞
        this.openDevMode();
      }
      this.lastKPressTime = now;
    });

    // Í≤åÏûÑ Ïò§Î≤Ñ ÌîåÎûòÍ∑∏
    this.gameOver = false;

    // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ë ÌîåÎûòÍ∑∏
    this.isStageClearingAnimation = false;

    // Î∞∞Í≤Ω Í∑∏Î¶¨Îìú Í∑∏Î¶¨Í∏∞
    this.drawGrid();

    // Ï¥àÍ∏∞ Î±ÄÍ≥º Î®πÏù¥ Í∑∏Î¶¨Í∏∞
    this.draw();

    // ÌÉÄÏù¥Î®∏ Ïù¥Î≤§Ìä∏Î°ú Î±Ä Ïù¥Îèô (90ms Í∏∞Î≥∏ÏÜçÎèÑ)
    this.moveTimer = this.time.addEvent({
      delay: 90,
      callback: this.moveSnake,
      callbackScope: this,
      loop: true
    });

    // ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ ÌëúÏãú (ÌÅ¨Î†àÎîß ÌõÑ Î≥µÍ∑Ä Ïãú)
    if (SnakeGame.showTitleOnRestart) {
      SnakeGame.showTitleOnRestart = false;
      this.showTitleScreen();
    }

    this.startFogIntroIfNeeded();

    // ÌÉÑÎßâ Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 6)
    if (this.isBulletBossStage()) {
      // ÏßßÏùÄ ÏßÄÏó∞ ÌõÑ ÌÉÑÎßâ Î≥¥Ïä§ ÏãúÏûë
      this.time.delayedCall(500, () => {
        this.startBulletBoss();
      });
    }

    // ÏïàÍ∞ú Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 9 - World 2 ÎÖπÌÑ¥ Î≥¥Ïä§)
    if (this.isFogBossStage()) {
      // ÏßßÏùÄ ÏßÄÏó∞ ÌõÑ ÏïàÍ∞ú Î≥¥Ïä§ ÏãúÏûë
      this.time.delayedCall(500, () => {
        this.startFogBoss();
      });
    }

    // Ïä§ÌÖåÏù¥ÏßÄ 1 ÌäúÌÜ†Î¶¨Ïñº ÌëúÏãú
    if (this.currentStage === 1) {
      this.showInGameTutorial();
    }
  }

  showInGameTutorial() {
    // Ïù¥ÎØ∏ ÌäúÌÜ†Î¶¨ÏñºÏùÑ Î≥∏ Ï†ÅÏù¥ ÏûàÏúºÎ©¥ Ïä§ÌÇµ
    if (localStorage.getItem('snake2026_tutorial_shown')) {
      return;
    }

    // ÌäúÌÜ†Î¶¨Ïñº Î≥∏ Í≤ÉÏúºÎ°ú ÌëúÏãú
    localStorage.setItem('snake2026_tutorial_shown', 'true');

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = this.gameAreaY + (height - this.gameAreaY) / 2;

    // ÌäúÌÜ†Î¶¨Ïñº ÏöîÏÜåÎì§ Ï†ÄÏû•
    this.tutorialElements = [];

    // ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥ ÌõÑ ÌäúÌÜ†Î¶¨Ïñº ÌëúÏãú
    this.time.delayedCall(400, () => {
      // Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
      const container = this.add.container(0, 0).setDepth(8000);
      this.tutorialElements.push(container);

      // Ìå®ÎÑê ÏÑ§Ï†ï (ÎÜíÏù¥ Ï¶ùÍ∞Ä)
      const panelW = 320;
      const panelH = 220;
      const panelX = centerX;
      const panelY = centerY;

      // Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞
      const outerGlow = this.add.graphics();
      outerGlow.fillStyle(0x00ff00, 0.04);
      outerGlow.fillRoundedRect(panelX - panelW / 2 - 15, panelY - panelH / 2 - 15, panelW + 30, panelH + 30, 16);
      outerGlow.setBlendMode(Phaser.BlendModes.ADD);
      container.add(outerGlow);

      // Î©îÏù∏ Ìå®ÎÑê
      const panelBg = this.add.graphics();
      panelBg.fillStyle(0x0a0f14, 0.92);
      panelBg.fillRoundedRect(panelX - panelW / 2, panelY - panelH / 2, panelW, panelH, 10);
      panelBg.lineStyle(2, 0x00ff88, 0.9);
      panelBg.strokeRoundedRect(panelX - panelW / 2, panelY - panelH / 2, panelW, panelH, 10);
      container.add(panelBg);

      // ÏΩîÎÑà Ïû•Ïãù
      const corners = this.add.graphics();
      corners.lineStyle(2, 0x00ffff, 0.8);
      const cs = 12;
      const left = panelX - panelW / 2;
      const right = panelX + panelW / 2;
      const top = panelY - panelH / 2;
      const bottom = panelY + panelH / 2;
      corners.lineBetween(left, top + cs, left, top);
      corners.lineBetween(left, top, left + cs, top);
      corners.lineBetween(right - cs, top, right, top);
      corners.lineBetween(right, top, right, top + cs);
      corners.lineBetween(left, bottom - cs, left, bottom);
      corners.lineBetween(left, bottom, left + cs, bottom);
      corners.lineBetween(right - cs, bottom, right, bottom);
      corners.lineBetween(right, bottom - cs, right, bottom);
      container.add(corners);

      // Ìó§Îçî
      const header = this.add.text(panelX, panelY - panelH / 2 + 28, 'HOW TO PLAY', {
        fontFamily: 'monospace',
        fontSize: '16px',
        fontStyle: 'bold',
        color: '#00ff88',
        letterSpacing: 3
      }).setOrigin(0.5);
      container.add(header);

      // ÏÑ§Î™Ö ÌÖçÏä§Ìä∏ (ÏúÑÎ°ú Ïù¥Îèô)
      const desc = this.add.text(panelX, panelY - 50, 'Use arrow keys to move', {
        fontFamily: 'monospace',
        fontSize: '14px',
        color: '#ffffff'
      }).setOrigin(0.5);
      container.add(desc);

      // ÌÇ§Ï∫° (ÏïÑÎûòÎ°ú Ïù¥Îèô)
      const keyW = 36;
      const keyH = 32;
      const gap = 4;
      const keysY = panelY + 20;

      const makeKey = (x, y, direction) => {
        const keyBg = this.add.graphics();
        keyBg.fillStyle(0x1a2a1a, 1);
        keyBg.fillRoundedRect(x - keyW / 2, y - keyH / 2 + 2, keyW, keyH, 4);
        keyBg.fillStyle(0x0d1a0d, 1);
        keyBg.fillRoundedRect(x - keyW / 2, y - keyH / 2, keyW, keyH - 2, 4);
        keyBg.lineStyle(1, 0x00ff88, 0.7);
        keyBg.strokeRoundedRect(x - keyW / 2, y - keyH / 2, keyW, keyH - 2, 4);
        container.add(keyBg);

        const arrow = this.add.graphics();
        arrow.fillStyle(0x00ffff, 1);
        const size = 8;
        const cx = x, cy = y - 1;
        if (direction === 'up') arrow.fillTriangle(cx, cy - size, cx - size, cy + size / 2, cx + size, cy + size / 2);
        else if (direction === 'down') arrow.fillTriangle(cx, cy + size, cx - size, cy - size / 2, cx + size, cy - size / 2);
        else if (direction === 'left') arrow.fillTriangle(cx - size, cy, cx + size / 2, cy - size, cx + size / 2, cy + size);
        else if (direction === 'right') arrow.fillTriangle(cx + size, cy, cx - size / 2, cy - size, cx - size / 2, cy + size);
        container.add(arrow);

        return { keyBg, arrow };
      };

      makeKey(panelX, keysY - keyH - gap, 'up');
      makeKey(panelX - keyW - gap, keysY, 'left');
      makeKey(panelX, keysY, 'down');
      makeKey(panelX + keyW + gap, keysY, 'right');

      // ÌûåÌä∏
      const hint = this.add.text(panelX, panelY + panelH / 2 - 24, '[ PRESS ANY KEY ]', {
        fontFamily: 'monospace',
        fontSize: '12px',
        color: '#00ff00',
        letterSpacing: 1
      }).setOrigin(0.5);
      container.add(hint);

      // ÌûåÌä∏ ÍπúÎπ°ÏûÑ
      this.tweens.add({
        targets: hint,
        alpha: 0.4,
        yoyo: true,
        duration: 600,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      // Í∏ÄÎ°úÏö∞ ÌéÑÏä§
      this.tweens.add({
        targets: outerGlow,
        alpha: 0.6,
        yoyo: true,
        duration: 1200,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });

      // ÌîåÎ°úÌåÖ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
      container.setAlpha(0);
      container.y = 20;
      this.tweens.add({
        targets: container,
        alpha: 1,
        y: 0,
        duration: 400,
        ease: 'Back.easeOut'
      });

      // ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàÑÎ•¥Î©¥ ÌäúÌÜ†Î¶¨Ïñº Îã´Í∏∞
      const closeTutorial = () => {
        this.input.keyboard.off('keydown', closeTutorial);

        // ÌéòÏù¥ÎìúÏïÑÏõÉ Ïï†ÎãàÎ©îÏù¥ÏÖò
        this.tweens.add({
          targets: container,
          alpha: 0,
          y: -20,
          duration: 250,
          ease: 'Quad.easeIn',
          onComplete: () => {
            container.destroy();
            this.tutorialElements = [];
            // Í≤åÏûÑ Ïû¨Í∞ú
            this.moveTimer.paused = false;
          }
        });
      };

      this.input.keyboard.on('keydown', closeTutorial);
    });
  }

  drawGrid() {
    this.gridGraphics = this.add.graphics();
    const graphics = this.gridGraphics;
    graphics.lineStyle(1, 0x444444, 0.3);

    for (let x = 0; x <= this.cols; x++) {
      graphics.moveTo(x * this.gridSize, this.gameAreaY);
      graphics.lineTo(x * this.gridSize, this.cameras.main.height);
    }

    for (let y = 0; y <= this.rows; y++) {
      graphics.moveTo(0, y * this.gridSize + this.gameAreaY);
      graphics.lineTo(this.cameras.main.width, y * this.gridSize + this.gameAreaY);
    }

    graphics.strokePath();
  }

  startMusicOnFirstInput() {
    if (!this.musicStarted) {
      this.musicStarted = true;
      if (this.bgMusic) {
        this.bgMusic.play();
      }
    }
  }

  // Î∞òÎåÄ Î∞©Ìñ•Ïù∏ÏßÄ Ï≤¥ÌÅ¨
  isOppositeDirection(dir1, dir2) {
    return (
      (dir1 === 'LEFT' && dir2 === 'RIGHT') ||
      (dir1 === 'RIGHT' && dir2 === 'LEFT') ||
      (dir1 === 'UP' && dir2 === 'DOWN') ||
      (dir1 === 'DOWN' && dir2 === 'UP')
    );
  }

  // ÏûÖÎ†• ÌÅêÏóê Î∞©Ìñ• Ï∂îÍ∞Ä
  addDirectionToQueue(newDirection) {
    if (this.isEscPaused) return;
    // ÌÅêÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÌòÑÏû¨ Î∞©Ìñ• Í∏∞Ï§ÄÏúºÎ°ú Ï≤¥ÌÅ¨
    if (this.inputQueue.length === 0) {
      // ÌòÑÏû¨ Î∞©Ìñ•Í≥º Î∞òÎåÄ Î∞©Ìñ•Ïù¥Î©¥ Î¨¥Ïãú
      if (this.isOppositeDirection(this.direction, newDirection)) {
        return;
      }
      // ÌòÑÏû¨ Î∞©Ìñ•Í≥º Í∞ôÏúºÎ©¥ Î¨¥Ïãú
      if (this.direction === newDirection) {
        return;
      }
      // Ïú†Ìö®Ìïú ÏûÖÎ†•Ïù¥Î©¥ Ï∂îÍ∞Ä
      this.inputQueue.push(newDirection);
      if (this.movingSound) this.movingSound.play();
      this.directionChangesCount++;
      this.checkComboShieldOnDirectionChange();
      this.showDirectionChangeCounter();
    }
    // ÌÅêÏóê Ïù¥ÎØ∏ ÏûÖÎ†•Ïù¥ ÏûàÏúºÎ©¥ ÎßàÏßÄÎßâ ÏûÖÎ†• Í∏∞Ï§ÄÏúºÎ°ú Ï≤¥ÌÅ¨
    else if (this.inputQueue.length < 2) {
      const lastQueuedDirection = this.inputQueue[this.inputQueue.length - 1];
      // ÌÅêÏùò ÎßàÏßÄÎßâ Î∞©Ìñ•Í≥º Î∞òÎåÄ Î∞©Ìñ•Ïù¥Î©¥ Î¨¥Ïãú
      if (this.isOppositeDirection(lastQueuedDirection, newDirection)) {
        return;
      }
      // ÌÅêÏùò ÎßàÏßÄÎßâ Î∞©Ìñ•Í≥º Í∞ôÏúºÎ©¥ Î¨¥Ïãú
      if (lastQueuedDirection === newDirection) {
        return;
      }
      // Ïú†Ìö®Ìïú ÏûÖÎ†•Ïù¥Î©¥ Ï∂îÍ∞Ä (ÏµúÎåÄ 2Í∞úÍπåÏßÄ)
      this.inputQueue.push(newDirection);
      if (this.movingSound) this.movingSound.play();
      this.directionChangesCount++;
      this.checkComboShieldOnDirectionChange();
      this.showDirectionChangeCounter();
    }
  }

  // Î∞©Ìñ•Ï†ÑÌôò Ïãú ÏΩ§Î≥¥ Ïã§Îìú Ï≤¥ÌÅ¨ (4Î≤àÏß∏Î∂ÄÌÑ∞ Îß§Î≤à 1Í∞úÏî© ÏÜåÎ™®)
  checkComboShieldOnDirectionChange() {
    // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑúÎäî Ïã§Îìú ÏÜåÎ™® ÏïàÌï®
    if (this.bossMode) return;

    // Ïù¥ÎØ∏ ÎÅäÏñ¥Ï°åÏúºÎ©¥ Ï≤¥ÌÅ¨ Î∂àÌïÑÏöî (ÏΩ§Î≥¥Í∞Ä 0Ïù¥Ïñ¥ÎèÑ Ïã§ÎìúÎäî ÏÜåÎ™®Îê®)
    if (this.comboLost) return;

    // 4Î≤àÏß∏ Î∞©Ìñ•Ï†ÑÌôòÎ∂ÄÌÑ∞ Ïã§Îìú ÌïÑÏöî
    if (this.directionChangesCount >= 4) {
      if (this.comboShieldCount > 0) {
        // Ïã§Îìú ÏÜåÎ™®
        this.comboShieldCount--;
        this.shieldsUsedThisCycle = true; // Ïã§Îìú ÏÇ¨Ïö© ÌëúÏãú
        this.showShieldConsumedEffect();
        this.updateItemStatusUI();

        // ÎßàÏßÄÎßâ Ïã§Îìú ÏÜåÎ™® Ïãú ÏàòÌä∏ Ìï¥Ï†ú Ïï†ÎãàÎ©îÏù¥ÏÖò
        if (this.comboShieldCount === 0) {
          this.showSuitRemovalEffect();
        }
      } else {
        // Ïã§Îìú ÏóÜÏùå - ÏΩ§Î≥¥ ÎÅäÍπÄ ÏòàÍ≥†
        this.comboLost = true;
        // Ïã§ÎìúÎ•º Í∞ÄÏ°åÎã§Í∞Ä Îã§ Ïì¥ Í≤ΩÏö∞ÏóêÎßå NO SHIELD ÌëúÏãú (ÏµúÏ¥à 1ÌöåÎßå)
        if (this.hasHadShield) {
          this.showComboLostWarning();
          this.hasHadShield = false; // Ìïú Î≤à ÌëúÏãú ÌõÑ Î¶¨ÏÖã
        }
      }
    }
  }

  generateFood() {
    // NEXUS Î≥¥Ïä§ Î™®ÎìúÏóêÏÑúÎäî Î®πÏù¥ ÏÉùÏÑ± ÏïàÌï®
    if (this.nexusMode) {
      return null;
    }

    let foodPos;
    let validPosition = false;

    // 9Î≤àÏß∏ Î®πÏù¥(foodCount === 8)Îäî Ï§ëÏïô Î∂ÄÍ∑ºÏóê ÏÉùÏÑ± (Îç∞ÎìúÏ°¥ ÏÉùÏÑ±Ïö©)
    const shouldSpawnCenter = this.foodCount === 8;

    while (!validPosition) {
      if (shouldSpawnCenter) {
        // Ï§ëÏïô Î∂ÄÍ∑ºÏóê ÏÉùÏÑ± (ÌôîÎ©¥ Ï§ëÏïô ¬±5Ïπ∏ Î≤îÏúÑ)
        const centerX = Math.floor(this.cols / 2);
        const centerY = Math.floor(this.rows / 2);
        foodPos = {
          x: Phaser.Math.Between(Math.max(5, centerX - 5), Math.min(this.cols - 6, centerX + 5)),
          y: Phaser.Math.Between(Math.max(5, centerY - 5), Math.min(this.rows - 6, centerY + 5))
        };
      } else {
        // Îßµ Ï†ÑÏ≤¥ ÏòÅÏó≠Ïóê ÎûúÎç§ ÏÉùÏÑ±
        foodPos = {
          x: Phaser.Math.Between(0, this.cols - 1),
          y: Phaser.Math.Between(0, this.rows - 1)
        };
      }

      // Î±ÄÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ Ï≤¥ÌÅ¨
      const notOnSnake = !this.snake.some(segment =>
        segment.x === foodPos.x && segment.y === foodPos.y
      );

      // Îç∞ÎìúÏ°¥Í≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ Ï≤¥ÌÅ¨
      const notOnDeadZone = !this.deadZones.some(dz =>
        dz.x === foodPos.x && dz.y === foodPos.y
      );

      // ÎèÖÍ∞ÄÏä§ ÏòÅÏó≠Í≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ Ï≤¥ÌÅ¨
      const notOnGasZone = !this.isInGasZone(foodPos.x, foodPos.y);
      const notOnSaw = !this.isSawOccupyingTile(foodPos.x, foodPos.y);

      // ÏûêÏÑù ÌÉëÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ Ï≤¥ÌÅ¨ (Flux Maze)
      const notOnTurret = !this.isTurretAtPosition(foodPos.x, foodPos.y);

      // Îñ†Îã§ÎãàÎäî Í∏∞Î¢∞ÏôÄ Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ Ï≤¥ÌÅ¨ (Flux Maze)
      const notOnMine = !this.floatingMines.some(mine =>
        mine.x === foodPos.x && mine.y === foodPos.y
      );

      validPosition = notOnSnake && notOnDeadZone && notOnGasZone && notOnSaw && notOnTurret && notOnMine;
    }

    // Î®πÏù¥Í∞Ä Î≤ΩÏóê Î∂ôÏñ¥ÏûàÏúºÎ©¥ ÎßêÌíçÏÑ† ÌëúÏãú
    this.checkAndShowFoodBubble(foodPos);

    // 6~15Î≤àÏß∏ Î®πÏù¥Ïùº Îïå Ïã≠ÏûêÍ∞Ä ÌõÑÎ†àÏâ¨ Ìö®Í≥º
    this.showCrosshairEffect(foodPos);

    return foodPos;
  }

  checkAndShowFoodBubble(foodPos) {
    // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑúÎäî ÎßêÌíçÏÑ† ÎπÑÌôúÏÑ±Ìôî
    if (this.bossMode) return;

    // Í∏∞Ï°¥ ÎßêÌíçÏÑ† Ï†úÍ±∞
    if (this.foodBubble) {

      // Ï¶âÏãú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å + alpha 0ÏúºÎ°ú ÏÑ§Ï†ï
      if (this.foodBubble.image) {
        this.foodBubble.image.setVisible(false);
        this.foodBubble.image.setAlpha(0);
      }
      if (this.foodBubble.text) {
        this.foodBubble.text.setVisible(false);
        this.foodBubble.text.setAlpha(0);
      }

      // TweenManagerÏóêÏÑú ÏôÑÏ†ÑÌûà Ï†úÍ±∞
      if (this.foodBubble.image && this.foodBubble.text) {
        this.tweens.killTweensOf([this.foodBubble.image, this.foodBubble.text]);
      }

      // Í∞ùÏ≤¥ Ï†úÍ±∞
      if (this.foodBubble.image) {
        this.foodBubble.image.destroy();
      }
      if (this.foodBubble.text) {
        this.foodBubble.text.destroy();
      }
    }
    this.foodBubble = null;

    // Î≤ΩÏóê Î∂ôÏñ¥ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨
    const isOnLeftWall = foodPos.x === 0;
    const isOnRightWall = foodPos.x === this.cols - 1;
    const isOnTopWall = foodPos.y === 0;
    const isOnBottomWall = foodPos.y === this.rows - 1;

    if (!isOnLeftWall && !isOnRightWall && !isOnTopWall && !isOnBottomWall) {
      return; // Î≤ΩÏóê Ïïà Î∂ôÏñ¥ÏûàÏúºÎ©¥ Î¶¨ÌÑ¥
    }

    // Ïû¨ÏπòÏûàÎäî Î©îÏãúÏßÄ ÎûúÎç§ ÏÑ†ÌÉù
    const messages = ['Oops!', 'Sorry!', 'My bad!', 'Whoops!', 'Uh-oh!'];
    const message = Phaser.Utils.Array.GetRandom(messages);

    // Î®πÏù¥ ÏúÑÏπò Í≥ÑÏÇ∞ (ÌîΩÏÖÄ Ï¢åÌëú)
    const foodX = foodPos.x * this.gridSize + this.gridSize / 2;
    const foodY = foodPos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎßêÌíçÏÑ† ÏúÑÏπò Î∞è Î∞©Ìñ• Í≤∞Ï†ï
    let bubbleX = foodX;
    let bubbleY = foodY;
    let offsetX = 0;
    let offsetY = 0;
    let rotation = 0;
    let flipX = false;
    let flipY = false;

    // Î≤Ω ÏúÑÏπòÏóê Îî∞Î•∏ ÎßêÌíçÏÑ† Î∞∞Ïπò
    let originX = 0.5;
    let originY = 0.5;
    let textOffsetX = 0;
    let textOffsetY = 0;

    if (isOnLeftWall) {
      // ÏôºÏ™Ω Î≤Ω
      if (isOnTopWall) {
        // ÏôºÏ™Ω ÏúÑ Î™®ÏÑúÎ¶¨: ÎßêÌíçÏÑ†ÏùÑ Ïò§Î•∏Ï™Ω ÏïÑÎûòÎ°ú
        offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú Î≥ÄÍ≤Ω
        originX = 1;
        originY = 0.5;
        textOffsetX = 38;
        textOffsetY = 2;
        rotation = -Math.PI;
      } else if (foodPos.x === 0 && foodPos.y === 1) {
        // ÏôºÏ™Ω ÏúÑ Î™®ÏÑúÎ¶¨ Ìïú Ïπ∏ ÏïÑÎûò (0, 1)
        offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú Î≥ÄÍ≤Ω
        originX = 1;
        originY = 0.5;
        textOffsetX = 38;
        textOffsetY = 2;
        rotation = -Math.PI;
      } else if (foodPos.x === 0 && foodPos.y === 2) {
        // ÏôºÏ™Ω ÏúÑ Î™®ÏÑúÎ¶¨ Ìïú Ïπ∏ ÏïÑÎûò (0, 1)
        offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú Î≥ÄÍ≤Ω
        originX = 1;
        originY = 0.5;
        textOffsetX = 38;
        textOffsetY = 2;
        rotation = -Math.PI;
      } else if (isOnBottomWall) {
        // ÏôºÏ™Ω ÏïÑÎûò Î™®ÏÑúÎ¶¨: ÎßêÌíçÏÑ†ÏùÑ Ïò§Î•∏Ï™Ω ÏúÑÎ°ú
        offsetX = 70;
        offsetY = -30;
        originX = 1;
        originY = 0.5;
        textOffsetX = -35;
        textOffsetY = -5;
        flipX = true;
      } else {
        // ÏôºÏ™Ω Î≤Ω Ï§ëÍ∞Ñ: Í∏∞Î≥∏Í∞í (Ïò§Î•∏Ï™Ω ÏúÑÎ°ú)
        offsetX = 70;
        offsetY = -30;
        originX = 1;
        originY = 0.5;
        textOffsetX = -35;
        textOffsetY = -5;
        flipX = true;
      }
    } else if (isOnRightWall) {
      // Ïò§Î•∏Ï™Ω Î≤Ω
      if (isOnTopWall) {
        // Ïò§Î•∏Ï™Ω ÏúÑ Î™®ÏÑúÎ¶¨: ÎßêÌíçÏÑ†ÏùÑ ÏôºÏ™Ω ÏïÑÎûòÎ°ú
        offsetX = 5;
        offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú Î≥ÄÍ≤Ω
        originX = 0;
        originY = 0.5;
        textOffsetX = -35;
        textOffsetY = 5;
        rotation = -Math.PI;
        flipX = true;
      } else if (foodPos.x === this.cols - 1 && foodPos.y === 1) {
        offsetX = 5;
        offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú Î≥ÄÍ≤Ω
        originX = 0;
        originY = 0.5;
        textOffsetX = -35;
        textOffsetY = 5;
        rotation = -Math.PI;
        flipX = true;
      } else if (foodPos.x === this.cols - 1 && foodPos.y === 2) {
        offsetX = 5;
        offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú Î≥ÄÍ≤Ω
        originX = 0;
        originY = 0.5;
        textOffsetX = -35;
        textOffsetY = 5;
        rotation = -Math.PI;
        flipX = true;
      } else if (isOnBottomWall) {
        // Ïò§Î•∏Ï™Ω ÏïÑÎûò Î™®ÏÑúÎ¶¨: ÎßêÌíçÏÑ†ÏùÑ ÏôºÏ™Ω ÏúÑÎ°ú
        offsetX = -70;
        offsetY = -30;
        originX = 0;
        originY = 0.5;
        textOffsetX = 35;
        textOffsetY = -5;
        flipX = false;
      } else {
        // Ïò§Î•∏Ï™Ω Î≤Ω Ï§ëÍ∞Ñ: Í∏∞Î≥∏Í∞í (ÏôºÏ™Ω ÏúÑÎ°ú)
        offsetX = -70;
        offsetY = -30;
        originX = 0;
        originY = 0.5;
        textOffsetX = 35;
        textOffsetY = -5;
        flipX = false;
      }
    } else if (isOnTopWall) {
      // ÏúÑÏ™Ω Î≤Ω
      if (foodPos.x === this.cols - 2 && foodPos.y === 0) {
        // Ïò§Î•∏Ï™Ω ÏúÑ Î™®ÏÑúÎ¶¨ Ìïú Ïπ∏ ÏôºÏ™Ω (cols-2, 0)
        offsetY = 30;
        offsetX = -28;
        textOffsetY = 5;
        rotation = -Math.PI;
        flipX = true;
      } else if (foodPos.x === this.cols - 3 && foodPos.y === 0) {
        // Ïò§Î•∏Ï™Ω ÏúÑ Î™®ÏÑúÎ¶¨ Îëê Ïπ∏ ÏôºÏ™Ω (cols-2, 0)
        offsetY = 30;
        offsetX = -28;
        textOffsetY = 5;
        rotation = -Math.PI;
        flipX = true;
      } else {
        // ÏúÑÏ™Ω Î≤Ω ÎÇòÎ®∏ÏßÄ: -180ÎèÑ ÌöåÏ†Ñ (Íº¨Î¶¨Í∞Ä ÏúÑ)
        offsetY = 30;
        offsetX = 32;
        textOffsetY = 5;
        rotation = -Math.PI;
      }
    } else if (isOnBottomWall) {
      // ÏïÑÎûòÏ™Ω Î≤Ω
      if (foodPos.x === 1 && foodPos.y === this.rows - 1) {
        // ÏôºÏ™Ω ÏïÑÎûò Î™®ÏÑúÎ¶¨ Ïò§Î•∏Ï™Ω Ìïú Ïπ∏ (1, rows-1)
        offsetY = -35;
        offsetX = 20;
        textOffsetY = -5;
        rotation = 0;
        flipX = true;
      } else if (foodPos.x === 2 && foodPos.y === this.rows - 1) {
        // ÏôºÏ™Ω ÏïÑÎûò Î™®ÏÑúÎ¶¨ Ïò§Î•∏Ï™Ω Îëê Ïπ∏ (2, rows-1)
        offsetY = -35;
        offsetX = 20;
        textOffsetY = -5;
        rotation = 0;
        flipX = true;
      } else {
        // ÏïÑÎûòÏ™Ω Î≤Ω ÎÇòÎ®∏ÏßÄ: ÌöåÏ†Ñ ÏóÜÏù¥ ÏúÑÏóê ÌëúÏãú
        offsetY = -30;
        offsetX = -25;
        textOffsetY = -5;
        rotation = 0;
        flipX = false;
      }
    }

    bubbleX = foodX + offsetX;
    bubbleY = foodY + offsetY;

    // ÎßêÌíçÏÑ† Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
    const bubbleImage = this.add.image(bubbleX, bubbleY, 'bubble')
      .setOrigin(originX, originY)
      .setDepth(1000)
      .setAlpha(0)
      .setScale(0.07); // ÌÅ¨Í∏∞ Îçî Ï∂ïÏÜå (0.09 -> 0.07)

    // ÌöåÏ†Ñ Î∞è Î∞òÏ†Ñ Ï†ÅÏö©
    bubbleImage.setRotation(rotation);
    bubbleImage.setFlipX(flipX);

    // Îπ®Í∞ÑÏÉâ ÌÖçÏä§Ìä∏ ÏÉùÏÑ± (ÎßêÌíçÏÑ† ÏïàÏóê)
    const bubbleText = this.add.text(bubbleX + textOffsetX, bubbleY + textOffsetY, message, {
      fontSize: '11px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1001).setAlpha(0);

    // ÌéòÏù¥ÎìúÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: [bubbleImage, bubbleText],
      alpha: 1,
      duration: 300,
      ease: 'Power2'
    });

    // ÎßêÌíçÏÑ† Í∞ùÏ≤¥ Ï†ÄÏû•
    this.foodBubble = {
      image: bubbleImage,
      text: bubbleText
    };
  }

  showCrosshairEffect(foodPos) {
    // Í∏∞Ï°¥ Ïã≠ÏûêÍ∞Ä ÎùºÏù∏ Ï†úÍ±∞
    if (this.crosshairLines) {
      // Î™®Îì† Í∞ùÏ≤¥ÏôÄ Ìä∏Ïúà Ï†úÍ±∞
      this.crosshairLines.forEach(obj => {
        this.tweens.killTweensOf(obj);
        obj.destroy();
      });
      this.crosshairLines = null;
    }

    // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑúÎäî Ïã≠ÏûêÍ∞Ä Ìö®Í≥º ÎπÑÌôúÏÑ±Ìôî
    if (this.bossMode) {
      return;
    }

    // Stage 1, 2ÏóêÏÑúÎßå Ïã≠ÏûêÍ∞Ä ÌõÑÎ†àÏâ¨ Ìö®Í≥º (ÌÖåÏä§Ìä∏ Ïä§ÌÖåÏù¥ÏßÄ Ìè¨Ìï® ÏïàÌï®)
    if (this.currentStage !== 1 && this.currentStage !== 2) {
      return;
    }

    // 0~4Î≤àÏß∏ Î®πÏù¥Í∞Ä ÏïÑÎãàÎ©¥ Î¶¨ÌÑ¥ (Ï≤´ Î≤àÏß∏ Î®πÏù¥Î∂ÄÌÑ∞ 5Î≤àÏß∏ Î®πÏù¥ÍπåÏßÄ)
    if (this.foodCount >= 5) {
      return;
    }

    const foodX = foodPos.x * this.gridSize + this.gridSize / 2;
    const foodY = foodPos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    this.crosshairLines = [];

    // 1. Ï§ëÏã¨ÏóêÏÑú ÌçºÏßÄÎäî Îπõ ÏõêÌòï ÌéÑÏä§ (Î®πÏù¥ Ï£ºÎ≥Ä) - ÌïòÎäòÏÉâ
    const pulseCircle = this.add.circle(foodX, foodY, 20, 0x4dd0e1, 0.12);
    pulseCircle.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(pulseCircle);

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò (ÌÅ¨Í∏∞ Î≥ÄÌôî)
    this.tweens.add({
      targets: pulseCircle,
      scale: 1.8,
      alpha: 0,
      duration: 1200,
      ease: 'Cubic.easeOut',
      repeat: -1
    });

    // 2. Í∏ÄÎ°úÏö∞ Ìö®Í≥ºÎ•º ÏúÑÌïú Îã§Ï∏µ ÎùºÏù∏ (ÏÑ∏Î°ú) - ÌïòÎäòÏÉâ, Îçî ÌùêÎ¶øÌïòÍ≤å
    const verticalX = foodPos.x * this.gridSize + this.gridSize / 2;

    // ÏÑ∏Î°ú - Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞ (Îß§Ïö∞ ÎëêÍªçÍ≥† Îß§Ïö∞ ÌùêÎ¶øÌï®)
    const vGlow = this.add.rectangle(
      verticalX,
      this.gameAreaY + (this.rows * this.gridSize / 2),
      15, // 20 ‚Üí 15Î°ú Ï°∞Ï†ï
      this.rows * this.gridSize,
      0x4dd0e1, // ÌïòÎäòÏÉâ
      0.04 // 0.08 ‚Üí 0.04Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
    );
    vGlow.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(vGlow);

    // ÏÑ∏Î°ú - Ï§ëÍ∞Ñ Î†àÏù¥Ïñ¥
    const vMid = this.add.rectangle(
      verticalX,
      this.gameAreaY + (this.rows * this.gridSize / 2),
      12,
      this.rows * this.gridSize,
      0x80deea, // Î∞ùÏùÄ ÌïòÎäòÏÉâ
      0.08 // 0.12 ‚Üí 0.08Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
    );
    vMid.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(vMid);

    // ÏÑ∏Î°ú - Ï§ëÏã¨ ÎùºÏù∏
    const vCore = this.add.rectangle(
      verticalX,
      this.gameAreaY + (this.rows * this.gridSize / 2),
      3, // 6 ‚Üí 3ÏúºÎ°ú ÏñáÍ≤å
      this.rows * this.gridSize,
      0xb3e5fc, // Îß§Ïö∞ Î∞ùÏùÄ ÌïòÎäòÏÉâ
      0.15 // 0.25 ‚Üí 0.15Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
    );
    vCore.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(vCore);

    // 3. Í∏ÄÎ°úÏö∞ Ìö®Í≥ºÎ•º ÏúÑÌïú Îã§Ï∏µ ÎùºÏù∏ (Í∞ÄÎ°ú) - ÌïòÎäòÏÉâ, Îçî ÌùêÎ¶øÌïòÍ≤å
    const horizontalY = foodPos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Í∞ÄÎ°ú - Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞
    const hGlow = this.add.rectangle(
      this.cols * this.gridSize / 2,
      horizontalY,
      this.cols * this.gridSize,
      15, // 20 ‚Üí 15Î°ú Ï°∞Ï†ï
      0x4dd0e1, // ÌïòÎäòÏÉâ
      0.04 // 0.08 ‚Üí 0.04Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
    );
    hGlow.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(hGlow);

    // Í∞ÄÎ°ú - Ï§ëÍ∞Ñ Î†àÏù¥Ïñ¥
    const hMid = this.add.rectangle(
      this.cols * this.gridSize / 2,
      horizontalY,
      this.cols * this.gridSize,
      12,
      0x80deea, // Î∞ùÏùÄ ÌïòÎäòÏÉâ
      0.08 // 0.12 ‚Üí 0.08Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
    );
    hMid.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(hMid);

    // Í∞ÄÎ°ú - Ï§ëÏã¨ ÎùºÏù∏
    const hCore = this.add.rectangle(
      this.cols * this.gridSize / 2,
      horizontalY,
      this.cols * this.gridSize,
      3, // 6 ‚Üí 3ÏúºÎ°ú ÏñáÍ≤å
      0xb3e5fc, // Îß§Ïö∞ Î∞ùÏùÄ ÌïòÎäòÏÉâ
      0.15 // 0.25 ‚Üí 0.15Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
    );
    hCore.setDepth(1); // Î®πÏù¥ Îí§Î°ú
    this.crosshairLines.push(hCore);

    // 4. ÍπúÎπ°Ïù¥Îäî Ïï†ÎãàÎ©îÏù¥ÏÖò (Î∂ÄÎìúÎü¨Ïö¥ Ìò∏Ìù°)
    this.tweens.add({
      targets: [vCore, hCore],
      alpha: 0.06, // 0.1 ‚Üí 0.06ÏúºÎ°ú Îçî ÌùêÎ¶øÌïòÍ≤å
      duration: 1000,
      ease: 'Sine.easeInOut',
      yoyo: true,
      repeat: -1
    });

    this.tweens.add({
      targets: [vMid, hMid],
      alpha: 0.03, // 0.04 ‚Üí 0.03ÏúºÎ°ú Îçî ÌùêÎ¶øÌïòÍ≤å
      duration: 1000,
      ease: 'Sine.easeInOut',
      yoyo: true,
      repeat: -1,
      delay: 150 // ÏïΩÍ∞Ñ ÏãúÏ∞®Î•º ÎëêÏñ¥ ÌååÎèô Ìö®Í≥º
    });

    this.tweens.add({
      targets: [vGlow, hGlow],
      alpha: 0.01, // 0.02 ‚Üí 0.01Î°ú Îçî ÌùêÎ¶øÌïòÍ≤å
      duration: 1000,
      ease: 'Sine.easeInOut',
      yoyo: true,
      repeat: -1,
      delay: 300
    });
  }

  moveSnake() {
    if (this.gameOver) return;

    // Quantum Split Î™®ÎìúÏóêÏÑúÎäî Î≥ÑÎèÑ Ïù¥Îèô Ï≤òÎ¶¨
    if (this.quantumSplitMode) {
      this.handleQuantumMovement();
      return;
    }

    // Multiverse Collapse Î™®Îìú Ï≤òÎ¶¨
    if (this.multiverseCollapseMode) {
      // Phase 2 (fourthwall): ÏùºÎ∞ò Ïù¥Îèô + Í∏ÄÏûê Ï∂©Îèå Ï≤¥ÌÅ¨
      if (this.multiverseCollapsePhase === 'fourthwall') {
        // ÏùºÎ∞ò Ïù¥Îèô Î°úÏßÅ Í≥ÑÏÜç ÏßÑÌñâ (return Ïïà Ìï®)
        // Ïù¥Îèô ÌõÑ Í∏ÄÏûê Ï∂©Îèå Ï≤¥ÌÅ¨Îäî ÏïÑÎûòÏóêÏÑú Ï≤òÎ¶¨
      }
      // Î†àÍ±∞Ïãú: Phase 2 (becomeone): ÏúµÌï© Î±Ä Ïù¥Îèô
      else if (this.multiverseCollapsePhase === 'becomeone') {
        this.moveFusionSnake();
        return;
      }
      // Î†àÍ±∞Ïãú: Phase 2 (doppelganger): ÏûÖÎ†• Í∏∞Î°ù
      if (this.multiverseCollapsePhase === 'doppelganger' && this.inputQueue.length > 0) {
        const nextDir = this.inputQueue[0]; // peek (shiftÎäî ÏïÑÎûòÏóêÏÑú)
        this.doppelInputHistory.push({
          direction: nextDir,
          time: Date.now()
        });
      }
    }

    // Î≥¥Ïä§ Ïù∏Ìä∏Î°ú Ï§ë Ïù¥Îèô Ïπ¥Ïö¥Ìä∏ Ï≤¥ÌÅ¨ (3Ïπ∏ Ïù¥Îèô ÌõÑ ÎåÄÏÇ¨)
    if (this.bossMode && this.bossPhase === 'intro' && this.bossIntroMoveCount !== undefined) {
      this.bossIntroMoveCount++;
      if (this.bossIntroMoveCount >= 5) {
        this.bossIntroMoveCount = undefined;
        this.moveTimer.paused = true;
        this.bossInputBlocked = true; // ÏûÖÎ†• Ï∞®Îã®
        this.showSnakeDialogue();
        return;
      }
    }

    // Î®πÏù¥ ÌÖîÎ†àÌè¨Ìä∏ Ï≤¥ÌÅ¨ (Stage 1: 1Î≤à, Stage 2+: 2Î≤à)
    const maxTeleports = this.currentStage === 1 ? 1 : 2;
    if (this.foodTeleportEnabled && this.currentFoodTeleportCount < maxTeleports && this.nextTeleportStep > 0) {
      this.nextTeleportStep--;
      if (this.nextTeleportStep === 0) {
        this.teleportFood();
        this.currentFoodTeleportCount++;

        // ÏµúÎåÄ ÌÖîÎ†àÌè¨Ìä∏ ÌöüÏàòÍ∞Ä ÏïÑÎãàÎ©¥ Îã§Ïùå ÌÖîÎ†àÌè¨Ìä∏ Ï§ÄÎπÑ
        if (this.currentFoodTeleportCount < maxTeleports) {
          this.nextTeleportStep = Phaser.Math.Between(1, 5);
        }
      }
    }

    // ÌÅêÏóêÏÑú Îã§Ïùå Î∞©Ìñ• Í∫ºÎÇ¥Í∏∞
    if (this.inputQueue.length > 0) {
      this.direction = this.inputQueue.shift(); // ÌÅêÏùò Ï≤´ Î≤àÏß∏ ÏöîÏÜå Í∫ºÎÇ¥Í∏∞
    }

    // ÏÉàÎ°úÏö¥ Î®∏Î¶¨ ÏúÑÏπò Í≥ÑÏÇ∞
    const head = this.snake[0];
    let newHead = { x: head.x, y: head.y };

    switch (this.direction) {
      case 'LEFT':
        newHead.x -= 1;
        break;
      case 'RIGHT':
        newHead.x += 1;
        break;
      case 'UP':
        newHead.y -= 1;
        break;
      case 'DOWN':
        newHead.y += 1;
        break;
    }

    // Î≤Ω Ï∂©Îèå Ï≤¥ÌÅ¨
    if (newHead.x < 0 || newHead.x >= this.cols ||
        newHead.y < 0 || newHead.y >= this.rows) {
      this.endGame();
      return;
    }

    // Îç∞ÎìúÏ°¥ Ï∂©Îèå Ï≤¥ÌÅ¨
    const hitDeadZone = this.deadZones.some(dz =>
      dz.x === newHead.x && dz.y === newHead.y
    );
    if (hitDeadZone) {
      this.endGame();
      return;
    }

    if (this.isSawTileDanger(newHead.x, newHead.y)) {
      this.endGame();
      return;
    }

    // ÎèÖÍ∞ÄÏä§ ÏòÅÏó≠ Ï∂©Îèå Ï≤¥ÌÅ¨
    if (this.isInGasZone(newHead.x, newHead.y)) {
      this.endGame();
      return;
    }

    // ÏûêÏÑù ÌÉë Ï∂©Îèå Ï≤¥ÌÅ¨ (Flux Maze)
    if (this.isTurretAtPosition(newHead.x, newHead.y)) {
      this.endGame();
      return;
    }

    // Îñ†Îã§ÎãàÎäî Í∏∞Î¢∞ Ï∂©Îèå Ï≤¥ÌÅ¨ (Flux Maze)
    if (this.checkMineCollision(newHead.x, newHead.y)) {
      // checkMineCollision handles the damage/death internally
      if (this.gameOver) return;
    }

    // Î†àÏù¥Ï†Ä ÌÑ∞Î†õ Ï∂©Îèå Ï≤¥ÌÅ¨ (Flux Maze - Stage 14)
    if (this.checkLaserCollision(newHead.x, newHead.y)) {
      this.endGame();
      return;
    }

    // EMP Î†àÏù¥Ï†Ä Ï∂©Îèå Ï≤¥ÌÅ¨ (Magnetar Phase 2) - Î†àÍ±∞Ïãú, NEXUSÎ°ú ÎåÄÏ≤¥Îê®
    // NEXUS Ï∂©Îèå Ï≤¥ÌÅ¨Îäî ÏïÑÎûò Î≥ÑÎèÑ Î∏îÎ°ùÏóêÏÑú Ï≤òÎ¶¨

    // ÏûêÍ∏∞ Î™∏ Ï∂©Îèå Ï≤¥ÌÅ¨
    if (this.snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
      this.endGame();
      return;
    }

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ Î™∏ Ï∂©Îèå Ï≤¥ÌÅ¨ (ÎåÄÏãú/Î¨¥Ï†Å ÏÉÅÌÉúÍ∞Ä ÏïÑÎãê Îïå)
    if (this.gearTitanMode && this.gearTitanPosition && !this.isDashing && !this.isInvincible) {
      const distToBoss = Math.abs(newHead.x - this.gearTitanPosition.x) + Math.abs(newHead.y - this.gearTitanPosition.y);
      if (distToBoss <= 2) {
        // vulnerable ÏÉÅÌÉúÎ©¥ HIT Ï≤òÎ¶¨
        if (this.gearTitanVulnerable) {
          this.handleGearTitanHit();
          return;
        } else {
          // vulnerable ÏïÑÎãàÎ©¥ Í≤åÏûÑ Ïò§Î≤Ñ
          this.endGame();
          return;
        }
      }
    }

    // Î±Ä Ïù¥Îèô
    this.snake.unshift(newHead);

    // Stage 8 Í∑ÄÏã† Î™π Ï∂©Îèå Ï≤¥ÌÅ¨
    this.checkStage8GhostCollision(newHead);

    // ÌÉÑÎßâ Î≥¥Ïä§ HIT Ï≤¥ÌÅ¨ (vulnerable ÏÉÅÌÉúÏóêÏÑú Î≥¥Ïä§ ÏúÑÏπòÏóê ÎèÑÎã¨)
    if (this.bulletBossMode && this.bulletBossPosition &&
        newHead.x === this.bulletBossPosition.x && newHead.y === this.bulletBossPosition.y) {
      if (this.bulletBossPhase === 'vulnerable') {
        this.handleBulletBossHit();
        this.draw();
        return;
      }
    }

    // Magnetar Î≥¥Ïä§ Í¥ÄÎ†® Ï∂©Îèå Ï≤¥ÌÅ¨ (Î†àÍ±∞Ïãú - ÏÇ¨Ïö© ÏïàÌï®)
    if (this.magnetarMode) {
      // Phase 3: Î≥¥Ìò∏Îßâ ÏÉùÏÑ±Í∏∞ Ï∂©Îèå Ï≤¥ÌÅ¨
      if (this.checkGeneratorCollision && this.checkGeneratorCollision(newHead.x, newHead.y)) {
        this.draw();
        return;
      }

      // Magnetar hazard check
      if (this.checkMagnetarHazardCollision && this.checkMagnetarHazardCollision(newHead.x, newHead.y)) {
        this.endGame();
        return;
      }

      if (this.magnetarPosition &&
          newHead.x === this.magnetarPosition.x && newHead.y === this.magnetarPosition.y) {
        if (this.magnetarVulnerable) {
          this.handleMagnetarHit();
          this.draw();
          return;
        } else {
          this.endGame();
          return;
        }
      }
    }

    // NEXUS Î≥¥Ïä§ Í¥ÄÎ†® Ï∂©Îèå Ï≤¥ÌÅ¨
    if (this.nexusMode && this.nexusPhase !== 'intro' && this.nexusPhase !== 'victory') {
      // NEXUS v2: Î∞îÏù¥ÎÑàÎ¶¨ ÎÖ∏Îìú Ï∂©Îèå Ï≤¥ÌÅ¨
      this.checkBinaryNodeCollision();

      // NEXUS ÏúÑÌóò ÏöîÏÜå Ï∂©Îèå Ï≤¥ÌÅ¨ (Í≥†Ïä§Ìä∏ Î±Ä, Î∏îÎ°ù, Ï∂îÏ†ÅÌÉÑ, EMP ÏÑúÏßÄ, ÏßÄÎ¢∞)
      if (this.checkNexusHazardCollision(newHead.x, newHead.y)) {
        this.endGame();
        return;
      }
    }

    // ÏïàÍ∞ú Î≥¥Ïä§ Í¥ÄÎ†® Ï∂©Îèå Ï≤¥ÌÅ¨
    if (this.fogBossMode) {
      // Ï°∞Î™ÖÌÉÑ ÏàòÏßë Ï≤¥ÌÅ¨
      for (let i = this.flares.length - 1; i >= 0; i--) {
        const flare = this.flares[i];
        if (newHead.x === flare.x && newHead.y === flare.y) {
          this.collectFlare(flare);
          break;
        }
      }

      // ÌôòÍ∞Å Î®πÏù¥ Ï∂©Îèå Ï≤¥ÌÅ¨ (Hallucination ÌéòÏù¥Ï¶à)
      if (this.fogBossPhase === 'hallucination' && this.hallucinationFoods.length > 0) {
        for (const food of this.hallucinationFoods) {
          if (newHead.x === food.x && newHead.y === food.y) {
            this.handleHallucinationFood(food);
            this.draw();
            return;
          }
        }
      }

      // Îπõ Ïò§Î∏å ÏàòÏßë Ï≤¥ÌÅ¨ (Eclipse ÌéòÏù¥Ï¶à)
      if (this.lightOrb && newHead.x === this.lightOrb.x && newHead.y === this.lightOrb.y) {
        this.collectLightOrb();
      }

      // Î≥¥Ïä§ HIT Ï≤¥ÌÅ¨ (vulnerable ÏÉÅÌÉúÏóêÏÑú Î≥¥Ïä§ ÏúÑÏπòÏóê ÎèÑÎã¨)
      if (this.fogBossPosition &&
          newHead.x === this.fogBossPosition.x && newHead.y === this.fogBossPosition.y) {
        if (this.fogBossPhase === 'vulnerable' || (this.fogBossVisible && this.flareActive)) {
          this.handleFogBossHit();
          this.draw();
          return;
        }
      }
    }

    // Meta Universe: ÏõúÌôÄ Ï∂©Îèå Ï≤¥ÌÅ¨
    if (this.metaUniverseMode && this.wormholes.length > 0) {
      const hitWormhole = this.checkWormholeCollision();
      if (hitWormhole) {
        this.startUniverseTransition(hitWormhole.targetUniverse, newHead.x, newHead.y);
        this.draw();
        return;
      }
    }

    // Multiverse Collapse Ï∂©Îèå Ï≤¥ÌÅ¨
    if (this.multiverseCollapseMode) {
      // Phase 1: Í≥†Ïä§Ìä∏ Î±Ä Ï∂©Îèå Ï≤¥ÌÅ¨
      if (this.multiverseCollapsePhase === 'fiveselves' && this.ghostSnakes.length > 0) {
        this.checkGhostCollision();
        if (this.gameOver) return;
      }
      // Phase 2: ÎèÑÌîåÍ∞±Ïñ¥ Ïù¥Îèô + Ï∂©Îèå Ï≤¥ÌÅ¨
      if (this.multiverseCollapsePhase === 'doppelganger' && this.doppelganger) {
        this.moveDoppelganger(); // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥ÎèôÍ≥º ÎèôÏãúÏóê ÎèÑÌîåÍ∞±Ïñ¥ÎèÑ Ïù¥Îèô
        if (this.gameOver) return;
      }

      // Phase 2 (Fourth Wall): GAME OVER Í∏ÄÏûê Ï∂©Îèå Ï≤¥ÌÅ¨
      if (this.multiverseCollapsePhase === 'fourthwall') {
        this.checkGameOverLetterCollision();
      }
    }

    // Î®πÏù¥Î•º Î®πÏóàÎäîÏßÄ Ï≤¥ÌÅ¨ (NEXUS Î™®ÎìúÏóêÏÑúÎäî foodÍ∞Ä nullÏùº Ïàò ÏûàÏùå)
    if (this.food && newHead.x === this.food.x && newHead.y === this.food.y) {
      this.triggerFogFlash();

      // Î®πÏù¥ Î®πÎäî Ìö®Í≥ºÏùå Ïû¨ÏÉù
      if (this.eatingSound) {
        this.eatingSound.play();
      }

      // ÎßêÌíçÏÑ† Ï†úÍ±∞
      if (this.foodBubble) {
        // Ï¶âÏãú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å + alpha 0ÏúºÎ°ú ÏÑ§Ï†ï
        if (this.foodBubble.image) {
          this.foodBubble.image.setVisible(false);
          this.foodBubble.image.setAlpha(0);
        }
        if (this.foodBubble.text) {
          this.foodBubble.text.setVisible(false);
          this.foodBubble.text.setAlpha(0);
        }

        // TweenManagerÏóêÏÑú ÏôÑÏ†ÑÌûà Ï†úÍ±∞
        if (this.foodBubble.image && this.foodBubble.text) {
          this.tweens.killTweensOf([this.foodBubble.image, this.foodBubble.text]);
        }

        // Í∞ùÏ≤¥ Ï†úÍ±∞
        if (this.foodBubble.image) {
          this.foodBubble.image.destroy();
        }
        if (this.foodBubble.text) {
          this.foodBubble.text.destroy();
        }
      }
      this.foodBubble = null;

      // Î≥¥Ïä§Ï†Ñ Ï≤òÎ¶¨
      if (this.bossMode) {
        if (this.bossPhase === 'trap') {
          // Ìï®Ï†ï Î®πÏù¥ - ÎèÖ Ìö®Í≥º ÏãúÏûë
          this.handleBossTrap();
          this.draw();
          return;
        } else if (this.bossPhase === 'battle') {
          // Î≥¥Ïä§ Ï†ÅÏ§ë
          if (this.bossHitCount === 3) {
            // ÎßàÏßÄÎßâ ÌûàÌä∏ - Ïä¨Î°úÏö∞Î™®ÏÖò
            this.handleBossFinalHit();
          } else {
            this.handleBossHit();
          }
          this.draw();
          return;
        }
      }

      // ÌÉÑÎßâ Î≥¥Ïä§ HIT Ï≤¥ÌÅ¨ (food ÏúÑÏπòÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏúºÎØÄÎ°ú Î≥ÑÎèÑ Ï≤¥ÌÅ¨)
      // (Ïù¥ Î∏îÎ°ùÏùÄ food ÏúÑÏπòÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎäî Ïã§ÌñâÎêòÏßÄ ÏïäÏùå)

      // Meta Universe Î®πÏù¥ Ï≤òÎ¶¨
      if (this.metaUniverseMode) {
        this.playFoodEffect();
        const cleared = this.handleMetaUniverseFood();
        if (cleared) {
          this.draw();
          return;
        }
        // Meta UniverseÏóêÏÑúÎäî ÏùºÎ∞ò Î°úÏßÅ Ïä§ÌÇµ
        this.draw();
        return;
      }

      this.foodCount++;
      this.startStage8BlackoutCycleIfNeeded();
      this.startDarkCreepCycleIfNeeded();
      this.startStage8GhostSpawnIfNeeded();

      // World 3 (Stage 10-12): ÌÜ±Îãà ÏÉùÏÑ± (Îß§ Î®πÏù¥ÎßàÎã§ 1Í∞úÏî©, ÏµúÎåÄ 5Í∞ú)
      if (shouldHaveSaws(this.currentStage) && !this.bossMode) {
        this.spawnSaw();
      }

      // 9Î≤àÏß∏ Î®πÏù¥ Î®πÏúºÎ©¥ Îç∞ÎìúÏ°¥ ÏÉùÏÑ± ÏãúÌÄÄÏä§ ÏãúÏûë (stage 4ÏóêÎßå)
      if (this.foodCount === 9 && this.currentStage === 4) {
        // Î®ºÏ†Ä ÏÉà Î®πÏù¥ ÏÉùÏÑ± Î∞è ÌååÌã∞ÌÅ¥ Ìö®Í≥º
        this.playFoodEffect();

        // ÎßêÌíçÏÑ† Ï†úÍ±∞ (ÏÉà Î®πÏù¥ ÏÉùÏÑ± Ï†Ñ)
        if (this.foodBubble) {
          if (this.foodBubble.image && this.foodBubble.text) {
            this.tweens.killTweensOf([this.foodBubble.image, this.foodBubble.text]);
          }
          if (this.foodBubble.image) {
            this.foodBubble.image.setVisible(false);
            this.foodBubble.image.setAlpha(0);
          }
          if (this.foodBubble.text) {
            this.foodBubble.text.setVisible(false);
            this.foodBubble.text.setAlpha(0);
          }
          if (this.foodBubble.image) {
            this.foodBubble.image.destroy();
          }
          if (this.foodBubble.text) {
            this.foodBubble.text.destroy();
          }
        }
        this.foodBubble = null;

        // ÏÉà Î®πÏù¥ ÏÉùÏÑ±
        this.food = this.generateFood();

        // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
        this.createFoodParticles();

        // Îç∞ÎìúÏ°¥ ÏãúÌÄÄÏä§ ÏãúÏûë
        this.startDeadZoneSequence();
        return; // ÏãúÌÄÄÏä§Í∞Ä ÎÅùÎÇòÎ©¥ Í≤åÏûÑÏù¥ Ïû¨Í∞úÎêòÎØÄÎ°ú Ïó¨Í∏∞ÏÑú Î¶¨ÌÑ¥
      }

      // ÏïÑÏù¥ÌÖú ÏÉùÏÑ± (Îç∞ÎìúÏ°¥Ïù¥ ÏïÑÎãê Îïå)
      if (this.foodCount === 10) {
        this.spawnItem();
        // Îã§Ïùå ÏïÑÏù¥ÌÖú ÌÉÄÏù¥Î®∏ ÏãúÏûë
        this.startItemSpawnTimer();
      }

      // ÏΩ§Î≥¥ Ï≤¥ÌÅ¨ (Ïã§Îìú Î∂ÄÏ°±ÏúºÎ°ú ÎÅäÏñ¥Ï°åÎäîÏßÄ ÌôïÏù∏)
      if (this.comboLost) {
        // Ïã§Îìú Î∂ÄÏ°±ÏúºÎ°ú ÏΩ§Î≥¥Í∞Ä ÎÅäÏñ¥ÏßÑ Í≤ΩÏö∞
        this.showComboBroken();
        this.combo = 0;
        this.comboText.setText('');
        this.comboLost = false;
      } else {
        // ÏΩ§Î≥¥ Ïú†ÏßÄ/Ï¶ùÍ∞Ä (3Ìöå Ïù¥ÎÇ¥ ÎòêÎäî Ïã§ÎìúÎ°ú Î∞©Ïñ¥Îê®)
        this.combo++;
        // ÏµúÎåÄ ÏΩ§Î≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        if (this.combo > this.maxCombo) {
          this.maxCombo = this.combo;
        }
        this.showComboEffect();

        // Ïã§ÎìúÎ°ú Î∞©Ïñ¥Îêú Í≤ΩÏö∞ Î∞©Ìå® Ìö®Í≥º Ï∂îÍ∞Ä
        if (this.shieldsUsedThisCycle) {
          this.showComboShieldEffect();
        }

        // ÏΩ§Î≥¥ ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        this.comboText.setText(`x${this.combo}`);
        // ÏΩ§Î≥¥ ÌÖçÏä§Ìä∏ ÌéÑÏä§ Ìö®Í≥º
        this.tweens.add({
          targets: this.comboText,
          scaleX: 1.3,
          scaleY: 1.3,
          duration: 100,
          yoyo: true,
          ease: 'Power2'
        });
      }

      // ÏΩ§Î≥¥Ïóê Îî∞Î•∏ Ï†êÏàò Î∞∞Ïú®
      const comboMultiplier = this.combo > 0 ? 1 + ((this.combo - 1) * 0.5) : 1;
      const earnedScore = Math.floor(10 * comboMultiplier);
      this.score += earnedScore;

      // Ï†êÏàò UI ÏóÖÎç∞Ïù¥Ìä∏ + Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.scoreText.setText(this.score.toString());
      this.tweens.add({
        targets: this.scoreText,
        scaleX: 1.3,
        scaleY: 1.3,
        duration: 100,
        yoyo: true,
        ease: 'Power2'
      });

      // Î®πÏù¥ Í∞úÏàò UI ÏóÖÎç∞Ïù¥Ìä∏ + Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.foodCountText.setText(this.foodCount.toString());
      this.tweens.add({
        targets: this.foodCountText,
        scaleX: 1.3,
        scaleY: 1.3,
        duration: 100,
        yoyo: true,
        ease: 'Power2'
      });

      // Î∞©Ìñ• Ï†ÑÌôò Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã (0ÏúºÎ°ú ÎêòÎèåÎ¶º)
      this.directionChangesCount = 0;
      this.shieldsUsedThisCycle = false; // Ïã§Îìú ÏÇ¨Ïö© ÌîåÎûòÍ∑∏ Î¶¨ÏÖã

      // Î®πÏù¥ Î®πÏùÄ Ìö®Í≥º Ïã§Ìñâ
      this.playFoodEffect();

      // ÎßêÌíçÏÑ† Ï†úÍ±∞ (ÏÉà Î®πÏù¥ ÏÉùÏÑ± Ï†Ñ)
      if (this.foodBubble) {
        // Ï¶âÏãú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å + alpha 0ÏúºÎ°ú ÏÑ§Ï†ï
        if (this.foodBubble.image) {
          this.foodBubble.image.setVisible(false);
          this.foodBubble.image.setAlpha(0);
        }
        if (this.foodBubble.text) {
          this.foodBubble.text.setVisible(false);
          this.foodBubble.text.setAlpha(0);
        }

        // TweenManagerÏóêÏÑú ÏôÑÏ†ÑÌûà Ï†úÍ±∞
        if (this.foodBubble.image && this.foodBubble.text) {
          this.tweens.killTweensOf([this.foodBubble.image, this.foodBubble.text]);
        }

        // Í∞ùÏ≤¥ Ï†úÍ±∞
        if (this.foodBubble.image) {
          this.foodBubble.image.destroy();
        }
        if (this.foodBubble.text) {
          this.foodBubble.text.destroy();
        }
      }
      this.foodBubble = null;

      this.food = this.generateFood();

      // 16Î≤àÏß∏ Î®πÏù¥Î∂ÄÌÑ∞ 20Î≤àÏß∏ÍπåÏßÄ ÌÖîÎ†àÌè¨Ìä∏ ÌôúÏÑ±Ìôî
      if (this.foodCount >= 15 && this.foodCount < 20) {
        this.foodTeleportEnabled = true;
        // ÏÉà Î®πÏù¥Ïóê ÎåÄÌïú ÌÖîÎ†àÌè¨Ìä∏ Ï§ÄÎπÑ
        this.currentFoodTeleportCount = 0; // ÏÉà Î®πÏù¥Îäî ÏïÑÏßÅ ÌÖîÎ†àÌè¨Ìä∏ ÏïàÎê®
        this.nextTeleportStep = Phaser.Math.Between(1, 5); // 1~5 Ïä§ÌÖù ÎûúÎç§
      } else {
        // 20Î≤àÏß∏ Ïù¥ÌõÑÎäî ÌÖîÎ†àÌè¨Ìä∏ ÎπÑÌôúÏÑ±Ìôî
        this.foodTeleportEnabled = false;
      }

      // 6Î≤àÏß∏Î∂ÄÌÑ∞ Î®πÏù¥ ÌååÌã∞ÌÅ¥ Ìö®Í≥º (ÎßàÏßÄÎßâ Î®πÏù¥ Ï†úÏô∏)
      if (this.foodCount >= 5 && this.foodCount < 19) {
        this.createFoodParticles();
      }

      // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ï≤¥ÌÅ¨ - Î≥¥Ïä§Ï†Ñ Ï§ëÏóêÎäî ÎπÑÌôúÏÑ±Ìôî
      // TODO: ÌÖåÏä§Ìä∏ ÏôÑÎ£å ÌõÑ 20ÏúºÎ°ú ÏõêÎ≥µ
      if (!this.bossMode && this.foodCount >= 5) {
        this.stageClear();
        return; // ÌÅ¥Î¶¨Ïñ¥ ÏãúÌÄÄÏä§ ÏãúÏûëÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑú Î¶¨ÌÑ¥
      }

      // ÏÜçÎèÑ Ï¶ùÍ∞Ä (ÏµúÎåÄ ÏÜçÎèÑ 50ms)
      if (this.moveTimer.delay > 50) {
        this.moveTimer.delay -= 5;

        // ÏÜçÎèÑ UI ÏóÖÎç∞Ïù¥Ìä∏ + Ïï†ÎãàÎ©îÏù¥ÏÖò
        this.speedText.setText(this.moveTimer.delay + 'ms');
        this.tweens.add({
          targets: this.speedText,
          scaleX: 1.3,
          scaleY: 1.3,
          duration: 100,
          yoyo: true,
          ease: 'Power2'
        });
        // ÏÉâÏÉÅ ÌîåÎûòÏãú Ìö®Í≥º
        this.speedText.setColor('#ffff00');
        this.time.delayedCall(200, () => {
          this.speedText.setColor('#00aaff');
        });
      }
    } else {
      // ÎèÖ ÏÑ±Ïû• Ï§ëÏù¥Î©¥ Íº¨Î¶¨ Ï†úÍ±∞ ÏïàÌï® (ÏÑ±Ïû•)
      if (this.poisonGrowthActive && this.poisonGrowthData) {
        const data = this.poisonGrowthData;
        if (data.currentGrowth < data.growthNeeded) {
          // ÏÜçÎèÑ Ï¶ùÍ∞Ä
          this.moveTimer.delay = Math.max(data.targetSpeed, this.moveTimer.delay - data.speedDecrease);
          data.currentGrowth++;

          // ÏÑ±Ïû• ÏôÑÎ£å Ï≤¥ÌÅ¨
          if (data.currentGrowth >= data.growthNeeded) {
            this.poisonGrowthActive = false;
            // Î≥¥Ïä§Ï†Ñ Î≥∏Í≤© ÏãúÏûë
            this.time.delayedCall(500, () => {
              this.startBossBattle();
            });
          }
        } else {
          this.snake.pop();
        }
      } else {
        // Î®πÏù¥Î•º Ïïà Î®πÏóàÏúºÎ©¥ Íº¨Î¶¨ Ï†úÍ±∞
        // ÏõúÌôÄ Ïä§Ìè∞ Ï§ëÏù¥Î©¥ Íº¨Î¶¨ Ï†úÍ±∞ ÎåÄÏã† ÏõúÌôÄÏóêÏÑú ÏÑ∏Í∑∏Î®ºÌä∏ Ï∂îÍ∞Ä
        if (this.wormholeSpawnData && this.wormholeSpawnData.remaining > 0) {
          this.handleWormholeSpawn();
        } else {
          this.snake.pop();
        }
      }
    }

    // ÏïÑÏù¥ÌÖú ÏóÖÎç∞Ïù¥Ìä∏ Î∞è Ï∂©Îèå Ï≤¥ÌÅ¨ (Î≥¥Ïä§Ï†Ñ Ï§ëÏóêÎäî ÏïÑÏù¥ÌÖú ÎπÑÌôúÏÑ±Ìôî)
    if (!this.bossMode) {
      this.updateItems(newHead);
    }

    // Í∑πÏÑ± ÎßàÏª§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (Flux Maze)
    if (this.polarityEnabled) {
      this.updatePolarityMarkerPosition();
    }

    // ÏûêÍ∏∞Î†•Ïóê ÏùòÌïú ÏÜçÎèÑ ÏòÅÌñ• Ï†ÅÏö© (Flux Maze)
    if (this.magneticTurrets.length > 0) {
      this.applyMagneticSpeedEffect();
    }

    // ÌôîÎ©¥ Îã§Ïãú Í∑∏Î¶¨Í∏∞
    this.draw();
  }

  // ==================== ÏïÑÏù¥ÌÖú ÏãúÏä§ÌÖú ====================

  startItemSpawnTimer() {
    if (this.itemSpawnTimer) {
      this.itemSpawnTimer.remove();
    }

    // ÌòÑÏû¨ ÎîúÎ†àÏù¥ Ïù∏Îç±Ïä§Ïóê Îî∞Î•∏ ÎåÄÍ∏∞ ÏãúÍ∞Ñ
    const delay = this.itemDelayIndex < this.itemDelays.length
      ? this.itemDelays[this.itemDelayIndex]
      : 2000; // ÎßàÏßÄÎßâ Ïù¥ÌõÑÎäî Í≥ÑÏÜç 2Ï¥à

    this.itemSpawnTimer = this.time.addEvent({
      delay: delay,
      callback: () => {
        this.spawnItem();
        this.itemDelayIndex++;
        this.startItemSpawnTimer(); // Îã§Ïùå ÌÉÄÏù¥Î®∏ ÏãúÏûë
      },
      callbackScope: this
    });
  }

  spawnItem() {
    // ÎûúÎç§ ÏãúÏûë ÏúÑÏπò (Í≤©Ïûê Í∏∞Ï§Ä)
    const startX = Phaser.Math.Between(0, this.cols - 2);
    const startY = Phaser.Math.Between(0, this.rows - 2);

    // ÎûúÎç§ Ïù¥Îèô Î∞©Ìñ• Î∞è ÏÜçÎèÑ
    const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
    const speed = this.moveTimer.delay / 2; // Î±Ä ÏÜçÎèÑÏùò Ï†àÎ∞ò

    // TODO: ÏïÑÏù¥ÌÖú ÌÉÄÏûÖ ÏÑ†ÌÉù Î°úÏßÅ (Ïó¨Í∏∞Ïóê ÎûúÎç§ ÎòêÎäî Í∞ÄÏ§ëÏπò Í∏∞Î∞ò ÏÑ†ÌÉù)
    const itemType = null; // ÌòÑÏû¨ ÏïÑÏù¥ÌÖú ÏóÜÏùå

    if (!itemType) return; // ÏïÑÏù¥ÌÖú ÌÉÄÏûÖÏù¥ ÏóÜÏúºÎ©¥ ÏÉùÏÑ±ÌïòÏßÄ ÏïäÏùå

    // ÏïÑÏù¥ÌÖú ÏÉùÏÑ±
    const item = {
      type: itemType,
      gridX: startX,
      gridY: startY,
      pixelX: startX * this.gridSize,
      pixelY: startY * this.gridSize + this.gameAreaY,
      velocityX: Math.cos(angle) * (this.gridSize / speed),
      velocityY: Math.sin(angle) * (this.gridSize / speed),
      graphics: null,
      size: 2 // 2x2 Í≤©Ïûê ÌÅ¨Í∏∞
    };

    // ÏïÑÏù¥ÌÖú Í∑∏ÎûòÌîΩ ÏÉùÏÑ±
    this.createItemGraphics(item);

    this.items.push(item);
  }

  createItemGraphics(item) {
    this.gridGraphics = this.add.graphics();
    const graphics = this.gridGraphics;
    graphics.setDepth(500);
    item.graphics = graphics;

    // TODO: Ïó¨Í∏∞Ïóê Í∞Å ÏïÑÏù¥ÌÖú ÌÉÄÏûÖÎ≥Ñ Í∑∏ÎûòÌîΩ ÏÉùÏÑ± ÏΩîÎìú Ï∂îÍ∞Ä
    // ÏòàÏãú:
    // if (item.type === 'item_name') {
    //   // ÏïÑÏù¥ÌÖú ÎπÑÏ£ºÏñº Í∑∏Î¶¨Í∏∞
    // }
  }

  updateItems(snakeHead) {
    const itemsToRemove = [];

    this.items.forEach((item, index) => {
      // ÏïÑÏù¥ÌÖú Ïù¥Îèô
      item.pixelX += item.velocityX;
      item.pixelY += item.velocityY;

      // Í≤©Ïûê Ï¢åÌëú ÏóÖÎç∞Ïù¥Ìä∏
      item.gridX = Math.floor(item.pixelX / this.gridSize);
      item.gridY = Math.floor((item.pixelY - this.gameAreaY) / this.gridSize);

      // Í∑∏ÎûòÌîΩ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
      if (item.graphics) {
        item.graphics.clear();

        // TODO: Ïó¨Í∏∞Ïóê Í∞Å ÏïÑÏù¥ÌÖú ÌÉÄÏûÖÎ≥Ñ Í∑∏ÎûòÌîΩ ÏóÖÎç∞Ïù¥Ìä∏ ÏΩîÎìú Ï∂îÍ∞Ä
        // if (item.type === 'item_name') {
        //   // ÏïÑÏù¥ÌÖú ÎπÑÏ£ºÏñº Îã§Ïãú Í∑∏Î¶¨Í∏∞
        // }

        // ÌÖçÏä§Ìä∏ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        if (item.text) {
          const centerX = item.pixelX + (this.gridSize * item.size) / 2;
          const centerY = item.pixelY + (this.gridSize * item.size) / 2;
          item.text.setPosition(centerX, centerY);
        }
      }

      // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞îÎäîÏßÄ Ï≤¥ÌÅ¨
      const { width, height } = this.cameras.main;
      if (item.pixelX < -this.gridSize * item.size ||
          item.pixelX > width ||
          item.pixelY < this.gameAreaY - this.gridSize * item.size ||
          item.pixelY > height) {
        itemsToRemove.push(index);
        return;
      }

      // Î±ÄÍ≥º Ï∂©Îèå Ï≤¥ÌÅ¨ (2x2 Í≤©Ïûê)
      for (let dx = 0; dx < item.size; dx++) {
        for (let dy = 0; dy < item.size; dy++) {
          if (snakeHead.x === item.gridX + dx && snakeHead.y === item.gridY + dy) {
            this.collectItem(item);
            itemsToRemove.push(index);
            return;
          }
        }
      }
    });

    // Ï†úÍ±∞Ìï† ÏïÑÏù¥ÌÖú Ï≤òÎ¶¨
    itemsToRemove.reverse().forEach(index => {
      const item = this.items[index];
      if (item.graphics) item.graphics.destroy();
      if (item.text) item.text.destroy();
      this.items.splice(index, 1);
    });
  }

  collectItem(item) {
    const centerX = item.pixelX + (this.gridSize * item.size) / 2;
    const centerY = item.pixelY + (this.gridSize * item.size) / 2;

    // TODO: Ïó¨Í∏∞Ïóê Í∞Å ÏïÑÏù¥ÌÖú ÌÉÄÏûÖÎ≥Ñ Ìö®Í≥º ÏΩîÎìú Ï∂îÍ∞Ä
    // if (item.type === 'item_name') {
    //   // ÏïÑÏù¥ÌÖú Ìö®Í≥º Ï†ÅÏö©
    //   // ÏàòÏßë ÎπÑÏ£ºÏñº Ìö®Í≥º
    // }
  }

  teleportFood() {
    const oldFood = { ...this.food };
    const foodPixelPos = {
      x: oldFood.x * this.gridSize + this.gridSize / 2,
      y: oldFood.y * this.gridSize + this.gridSize / 2 + this.gameAreaY
    };

    // ÏÇ¨ÎùºÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò (Îπ†Î•¥Í≤å)
    const disappearCircle = this.add.circle(foodPixelPos.x, foodPixelPos.y, this.gridSize / 2, 0xff0000, 1);
    this.tweens.add({
      targets: disappearCircle,
      scaleX: 0,
      scaleY: 0,
      alpha: 0,
      duration: 150,
      ease: 'Power2',
      onComplete: () => disappearCircle.destroy()
    });

    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 8; i++) {
      const angle = (Math.PI * 2 * i) / 8;
      const particle = this.add.circle(foodPixelPos.x, foodPixelPos.y, 3, 0xff0000, 1);
      this.tweens.add({
        targets: particle,
        x: foodPixelPos.x + Math.cos(angle) * 30,
        y: foodPixelPos.y + Math.sin(angle) * 30,
        alpha: 0,
        duration: 200,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // ÏÉà ÏúÑÏπò ÏÉùÏÑ±
    this.food = this.generateFood();
    const newFoodPixelPos = {
      x: this.food.x * this.gridSize + this.gridSize / 2,
      y: this.food.y * this.gridSize + this.gridSize / 2 + this.gameAreaY
    };

    // ÎÇòÌÉÄÎÇòÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò (Ï§ëÍ∞Ñ ÏÜçÎèÑÎ°ú ÌéòÏù¥ÎìúÏù∏)
    const appearCircle = this.add.circle(newFoodPixelPos.x, newFoodPixelPos.y, this.gridSize / 2, 0xff0000, 0);
    appearCircle.setScale(0.5);
    this.tweens.add({
      targets: appearCircle,
      scaleX: 1,
      scaleY: 1,
      alpha: 1,
      duration: 300,
      ease: 'Back.out',
      onComplete: () => appearCircle.destroy()
    });

    // ÎßÅ Ìö®Í≥º
    const ring = this.add.circle(newFoodPixelPos.x, newFoodPixelPos.y, this.gridSize / 2, 0xff6600, 0);
    ring.setStrokeStyle(2, 0xff0000, 0.8);
    this.tweens.add({
      targets: ring,
      scaleX: 3,
      scaleY: 3,
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => ring.destroy()
    });

    // ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    this.createFoodParticles();
  }

  createFoodParticles() {
    const foodPixelPos = {
      x: this.food.x * this.gridSize + this.gridSize / 2,
      y: this.food.y * this.gridSize + this.gridSize / 2 + this.gameAreaY
    };

    // Î®πÏù¥ ÏÉùÏÑ± Ìö®Í≥º - Ï≤≠Î°ùÏÉâ/ÏãúÏïà Í≥ÑÏó¥Î°ú Í∞ïÎ†¨ÌïòÍ≤å

    // 1. Í∞ïÎ†•Ìïú Ï§ëÏïô ÌîåÎûòÏãú (ÌÅ¨Í≥† Î∞ùÍ≤å)
    const bigFlash = this.add.circle(foodPixelPos.x, foodPixelPos.y, this.gridSize * 2, 0x00ffff, 0.9);
    this.tweens.add({
      targets: bigFlash,
      scaleX: 3.5,
      scaleY: 3.5,
      alpha: 0,
      duration: 500,
      ease: 'Power3',
      onComplete: () => bigFlash.destroy()
    });

    // 2. Ï§ëÏïôÏóêÏÑú ÌçºÏßÄÎäî ÎßÅ 5Í∞ú (Îçî ÎßéÏù¥, Îçî Í∞ïÌïòÍ≤å)
    for (let i = 0; i < 5; i++) {
      const ring = this.add.circle(foodPixelPos.x, foodPixelPos.y, 8, 0x00ffff, 0);
      ring.setStrokeStyle(3, 0x00ffff, 1);
      this.tweens.add({
        targets: ring,
        scaleX: 5,
        scaleY: 5,
        alpha: 0,
        duration: 700,
        delay: i * 120,
        ease: 'Power2',
        onComplete: () => ring.destroy()
      });
    }

    // 3. Ïã≠ÏûêÍ∞Ä Î™®Ïñë Î†àÏù¥Ï†Ä Ìö®Í≥º
    const crossColors = [0x00ffff, 0x00ddff, 0x00bbff, 0x0099ff];
    for (let i = 0; i < 4; i++) {
      const angle = (Math.PI / 2) * i; // 90ÎèÑÏî©
      const beam = this.add.rectangle(
        foodPixelPos.x,
        foodPixelPos.y,
        60,
        4,
        crossColors[i],
        0.8
      );
      beam.setRotation(angle);
      beam.setDepth(1000);

      this.tweens.add({
        targets: beam,
        scaleX: 0,
        alpha: 0,
        duration: 400,
        ease: 'Power2',
        onComplete: () => beam.destroy()
      });
    }

    // 4. Î≥Ñ Î™®Ïñë ÌååÌã∞ÌÅ¥ 12Í∞ú (ÏÇ¨Î∞©ÏúºÎ°ú ÌçºÏßê, Îçî ÎßéÏù¥)
    for (let i = 0; i < 12; i++) {
      const angle = (Math.PI * 2 * i) / 12;
      const star = this.add.text(foodPixelPos.x, foodPixelPos.y, '‚òÖ', {
        fontSize: '20px',
        fill: '#00ffff'
      }).setOrigin(0.5).setAlpha(0).setDepth(1001);

      this.tweens.add({
        targets: star,
        x: foodPixelPos.x + Math.cos(angle) * 50,
        y: foodPixelPos.y + Math.sin(angle) * 50,
        alpha: 1,
        angle: 360,
        duration: 400,
        ease: 'Power2',
        onComplete: () => {
          this.tweens.add({
            targets: star,
            alpha: 0,
            scaleX: 0,
            scaleY: 0,
            duration: 200,
            onComplete: () => star.destroy()
          });
        }
      });
    }

    // 5. Î∞òÏßùÏù¥Îäî ÏûëÏùÄ ÌååÌã∞ÌÅ¥Îì§ (16Í∞ú, Îëê Í≤πÏùò ÏõêÌòïÏúºÎ°ú)
    for (let i = 0; i < 16; i++) {
      const angle = (Math.PI * 2 * i) / 16;
      const distance = this.gridSize * (i % 2 === 0 ? 1.5 : 2);
      const particle = this.add.circle(
        foodPixelPos.x + Math.cos(angle) * distance,
        foodPixelPos.y + Math.sin(angle) * distance,
        2,
        0x00ffff,
        0
      );
      particle.setDepth(1002);

      this.tweens.add({
        targets: particle,
        alpha: 1,
        scaleX: 3,
        scaleY: 3,
        duration: 250,
        delay: i * 20,
        yoyo: true,
        onComplete: () => particle.destroy()
      });
    }

    // 6. ÌéÑÏä§ Ìö®Í≥º (ÏïàÏ™ΩÏóêÏÑú Î∞îÍπ•ÏúºÎ°ú)
    const pulse = this.add.circle(foodPixelPos.x, foodPixelPos.y, this.gridSize / 2, 0xffffff, 0.5);
    pulse.setDepth(999);
    this.tweens.add({
      targets: pulse,
      scaleX: 4,
      scaleY: 4,
      alpha: 0,
      duration: 600,
      ease: 'Cubic.out',
      onComplete: () => pulse.destroy()
    });
  }

  showDirectionChangeCounter() {
    // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑúÎäî Î∞©Ìñ• Ï†ÑÌôò Ïπ¥Ïö¥ÌÑ∞ ÎπÑÌôúÏÑ±Ìôî
    if (this.bossMode) return;

    // Meta UniverseÏóêÏÑúÎäî ÏΩ§Î≥¥ ÎπÑÌôúÏÑ±Ìôî ‚Üí Ïπ¥Ïö¥ÌÑ∞ÎèÑ ÎπÑÌôúÏÑ±Ìôî
    if (this.metaUniverseMode || this.comboDisabled) return;

    // Î±Ä Î®∏Î¶¨ ÏúÑÏπò
    const head = this.snake[0];
    const headPixelX = head.x * this.gridSize + this.gridSize / 2;
    const headPixelY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎÇ®ÏùÄ Í∏∞Ìöå Í≥ÑÏÇ∞
    const movesLeft = 4 - this.directionChangesCount;
    let displayText = '';
    let textColor = '';
    let strokeColor = '';

    if (movesLeft === 3) {
      displayText = '3';
      textColor = '#00ff00'; // Ï¥àÎ°ù
      strokeColor = '#004400';
    } else if (movesLeft === 2) {
      displayText = '2';
      textColor = '#ffaa00'; // Ï£ºÌô©
      strokeColor = '#664400';
    } else if (movesLeft === 1) {
      displayText = '1';
      textColor = '#ff0000'; // Îπ®Í∞ï
      strokeColor = '#660000';
    } else if (movesLeft === 0) {
      // ÏΩ§Î≥¥ Ïã§ÎìúÍ∞Ä ÏûàÏúºÎ©¥ SHIELD! ÌëúÏãú
      if (this.comboShieldCount > 0) {
        displayText = 'SHIELD!';
        textColor = '#ffd700'; // Í≥®Îìú
        strokeColor = '#665500';
      } else {
        displayText = 'X';
        textColor = '#666666'; // ÌöåÏÉâ
        strokeColor = '#222222';
      }
    } else {
      return; // 4 Ïù¥ÏÉÅÏù¥Î©¥ ÌëúÏãú Ïïà Ìï®
    }

    // ÌôîÎ©¥ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨Î•º ÏúÑÌïú Ïó¨Ïú† Í≥µÍ∞Ñ
    const margin = 50;
    const { width, height } = this.cameras.main;

    // Í∏∞Î≥∏ Ïò§ÌîÑÏÖã (Ïò§Î•∏Ï™Ω ÏúÑ)
    let offsetX = 30;
    let offsetY = -30;

    // ÏÉÅÎã® Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (UI ÏòÅÏó≠ + Ïó¨Ïú†)
    if (headPixelY - margin < this.gameAreaY + 40) {
      offsetY = 30; // ÏïÑÎûòÏ™ΩÏúºÎ°ú
    }

    // Ïö∞Ï∏° Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
    if (headPixelX + margin > width - 40) {
      offsetX = -30; // ÏôºÏ™ΩÏúºÎ°ú
    }

    // Ï¢åÏ∏° Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
    if (headPixelX - margin < 40) {
      offsetX = 30; // Ïò§Î•∏Ï™ΩÏúºÎ°ú (Í∏∞Î≥∏Í∞í Ïú†ÏßÄ)
    }

    // ÌïòÎã® Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
    if (headPixelY + margin > height - 40) {
      offsetY = -30; // ÏúÑÏ™ΩÏúºÎ°ú (Í∏∞Î≥∏Í∞í Ïú†ÏßÄ)
    }

    const counterText = this.add.text(headPixelX + offsetX, headPixelY + offsetY, displayText, {
      fontSize: '32px',
      fill: textColor,
      fontStyle: 'bold',
      stroke: strokeColor,
      strokeThickness: 4
    }).setOrigin(0.5, 0.5).setDepth(1500).setAlpha(0).setScale(0.5);

    // Ïï†ÎãàÎ©îÏù¥ÏÖò Î∞©Ìñ• Í≥ÑÏÇ∞ (offset Î∞©Ìñ•ÏúºÎ°ú)
    const animOffsetY = offsetY > 0 ? 10 : -10;

    // Ïû¨Î∞åÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò: Îπ†Î•¥Í≤å ÌéòÏù¥ÎìúÏù∏ + Ïä§ÏºÄÏùº + ÏúÑÎ°ú Îñ†Ïò§Î¶Ñ
    this.tweens.add({
      targets: counterText,
      alpha: 1,
      scaleX: 1.2,
      scaleY: 1.2,
      y: headPixelY + offsetY + animOffsetY,
      duration: 150,
      ease: 'Back.out',
      onComplete: () => {
        // Ïû†Ïãú Ïú†ÏßÄ ÌõÑ Îπ†Î•¥Í≤å ÌéòÏù¥ÎìúÏïÑÏõÉ
        this.tweens.add({
          targets: counterText,
          alpha: 0,
          scaleX: 0.8,
          scaleY: 0.8,
          y: headPixelY + offsetY + animOffsetY * 2,
          duration: 200,
          delay: 100,
          ease: 'Power2',
          onComplete: () => counterText.destroy()
        });
      }
    });

    // Ï∂îÍ∞Ä Ìö®Í≥º: ÎßÅ ÌôïÏÇ∞
    const ring = this.add.circle(headPixelX + offsetX, headPixelY + offsetY, 10, 0xffffff, 0);
    ring.setStrokeStyle(2, textColor.replace('#', '0x'), 0.8);
    ring.setDepth(1499);
    this.tweens.add({
      targets: ring,
      scaleX: 2.5,
      scaleY: 2.5,
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => ring.destroy()
    });
  }

  showComboEffect() {
    const { width, height } = this.cameras.main;

    // ÏΩ§Î≥¥ Î†àÎ≤®Ïóê Îî∞Î•∏ Ìö®Í≥º
    let comboLevel = 1;
    if (this.combo >= 10) comboLevel = 4;
    else if (this.combo >= 5) comboLevel = 3;
    else if (this.combo >= 3) comboLevel = 2;

    // ÏΩ§Î≥¥ ÏÉâÏÉÅ - ÎÖ∏ÎûÄÏÉâ/Ï£ºÌô©ÏÉâ Í≥ÑÏó¥ (Î®πÏù¥ Ìö®Í≥ºÏôÄ Íµ¨Î∂Ñ)
    const comboColors = {
      text: '#ffdd00',
      stroke: '#ff6600',
      particle: '#ff9900',
      flash: 0xffaa00
    };

    // ÏΩ§Î≥¥ Îã¨ÏÑ± ÌÖçÏä§Ìä∏
    const comboAnnounce = this.add.text(width / 2, height / 2, `COMBO x${this.combo}!`, {
      fontSize: 48 + (comboLevel * 12) + 'px',
      fill: comboColors.text,
      fontStyle: 'bold',
      stroke: comboColors.stroke,
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(1000);

    this.tweens.add({
      targets: comboAnnounce,
      scaleX: 1.5,
      scaleY: 1.5,
      alpha: 0,
      y: height / 2 - 50,
      duration: 800,
      ease: 'Power2',
      onComplete: () => comboAnnounce.destroy()
    });

    // Î†àÎ≤®Î≥Ñ Ï∂îÍ∞Ä Ìö®Í≥º
    if (comboLevel >= 2) {
      // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ ÎπõÎÇòÎäî Ìö®Í≥º (Ï£ºÌô©ÏÉâ)
      const border = this.add.rectangle(width / 2, height / 2, width, height, comboColors.flash, 0)
        .setStrokeStyle(5, comboColors.flash, 0.8);

      this.tweens.add({
        targets: border,
        alpha: 0,
        duration: 500,
        onComplete: () => border.destroy()
      });
    }

    if (comboLevel >= 3) {
      // ÌôîÎ©¥ ÌùîÎì§Î¶º
      this.cameras.main.shake(200, 0.003);

      // Î≥Ñ ÌååÌã∞ÌÅ¥ (Ï£ºÌô©ÏÉâ Í≥ÑÏó¥)
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const star = this.add.text(width / 2, height / 2, '‚òÖ', {
          fontSize: '32px',
          fill: comboColors.particle
        }).setOrigin(0.5);

        this.tweens.add({
          targets: star,
          x: width / 2 + Math.cos(angle) * 150,
          y: height / 2 + Math.sin(angle) * 100,
          alpha: 0,
          angle: 360,
          duration: 600,
          ease: 'Power2',
          onComplete: () => star.destroy()
        });
      }
    }

    if (comboLevel >= 4) {
      // Í∞ïÌïú Î∞∞Í≤Ω Î≤àÏ©çÏûÑ (Ï£ºÌô©ÏÉâ)
      const megaFlash = this.add.rectangle(0, 0, width, height, comboColors.flash, 0.4).setOrigin(0);
      this.tweens.add({
        targets: megaFlash,
        alpha: 0,
        duration: 400,
        onComplete: () => megaFlash.destroy()
      });
    }
  }

  showComboBroken() {
    const { width, height } = this.cameras.main;

    // ÏΩ§Î≥¥ ÎÅäÍπÄ ÏïåÎ¶º
    const brokenText = this.add.text(width / 2, height / 2, 'COMBO BROKEN!', {
      fontSize: '36px',
      fill: '#888888',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(1000);

    this.tweens.add({
      targets: brokenText,
      alpha: 0,
      y: height / 2 + 30,
      duration: 600,
      ease: 'Power2',
      onComplete: () => brokenText.destroy()
    });
  }

  showComboShieldEffect() {
    const { width, height } = this.cameras.main;

    // 1. ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌîåÎûòÏãú (Í≥®Îìú ‚Üí ÌôîÏù¥Ìä∏ ‚Üí ÌéòÏù¥Îìú)
    const flash = this.add.rectangle(width / 2, height / 2, width, height, 0xffffff, 0.8)
      .setDepth(1000);
    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 150,
      onComplete: () => flash.destroy()
    });

    // 2. Î∞©Ìå® ÏïÑÏù¥ÏΩò ÌôïÎåÄ Ìö®Í≥º (Ï§ëÏïôÏóêÏÑú Ïª§ÏßÄÎ©¥ÏÑú Îì±Ïû•)
    const shieldIcon = this.add.text(width / 2, height / 2 - 60, 'üõ°Ô∏è', {
      fontSize: '80px'
    }).setOrigin(0.5).setDepth(1002).setScale(0).setAlpha(0);

    this.tweens.add({
      targets: shieldIcon,
      scale: 1.5,
      alpha: 1,
      duration: 200,
      ease: 'Back.easeOut',
      onComplete: () => {
        // Î∞©Ìå® ÌöåÏ†Ñ + Ï∂ïÏÜå ÌéòÏù¥Îìú
        this.tweens.add({
          targets: shieldIcon,
          scale: 0,
          alpha: 0,
          angle: 360,
          duration: 400,
          ease: 'Power2',
          onComplete: () => shieldIcon.destroy()
        });
      }
    });

    // 3. "COMBO SHIELD!!" ÌÖçÏä§Ìä∏ - Í∏ÄÏûêÎ≥Ñ Îì±Ïû•
    const text = 'COMBO SHIELD!!';
    const letters = [];
    const startX = width / 2 - (text.length * 12);

    for (let i = 0; i < text.length; i++) {
      const letter = this.add.text(startX + i * 24, height / 2 + 20, text[i], {
        fontSize: '36px',
        fill: '#ffd700',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5).setDepth(1001).setScale(0).setAlpha(0);
      letters.push(letter);

      // ÏàúÏ∞®Ï†Å Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: letter,
        scale: 1.2,
        alpha: 1,
        y: height / 2 + 10,
        duration: 100,
        delay: i * 30,
        ease: 'Back.easeOut'
      });
    }

    // Í∏ÄÏûê Ï†ÑÏ≤¥ ÌéÑÏä§ + ÌéòÏù¥Îìú ÏïÑÏõÉ
    this.time.delayedCall(text.length * 30 + 200, () => {
      // ÌéÑÏä§
      this.tweens.add({
        targets: letters,
        scale: 1.4,
        duration: 100,
        yoyo: true,
        repeat: 1,
        onComplete: () => {
          // ÌéòÏù¥Îìú ÏïÑÏõÉ
          this.tweens.add({
            targets: letters,
            alpha: 0,
            y: height / 2 - 30,
            duration: 300,
            ease: 'Power2',
            onComplete: () => letters.forEach(l => l.destroy())
          });
        }
      });
    });

    // 4. Ïõ®Ïù¥Î∏å ÎßÅ Ìö®Í≥º (3Í≤π)
    for (let r = 0; r < 3; r++) {
      const ring = this.add.circle(width / 2, height / 2, 10, 0x000000, 0)
        .setStrokeStyle(4, 0xffd700, 1)
        .setDepth(1000);
      this.tweens.add({
        targets: ring,
        radius: 200 + r * 50,
        alpha: 0,
        duration: 600,
        delay: r * 100,
        ease: 'Power2',
        onComplete: () => ring.destroy()
      });
    }

    // 5. Ïä§ÌååÌÅ¥ ÌååÌã∞ÌÅ¥ (Î≥Ñ Î™®Ïñë)
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = 50 + Math.random() * 100;
      const sparkle = this.add.text(
        width / 2 + Math.cos(angle) * 30,
        height / 2 + Math.sin(angle) * 30,
        '‚ú¶',
        { fontSize: '16px', fill: '#ffd700' }
      ).setOrigin(0.5).setDepth(1001).setAlpha(1);

      this.tweens.add({
        targets: sparkle,
        x: width / 2 + Math.cos(angle) * distance,
        y: height / 2 + Math.sin(angle) * distance,
        alpha: 0,
        scale: 0,
        duration: 400 + Math.random() * 200,
        ease: 'Power2',
        onComplete: () => sparkle.destroy()
      });
    }

    // 6. ÌôîÎ©¥ ÌÖåÎëêÎ¶¨ Í≥®Îìú Í∏ÄÎ°úÏö∞ (ÌéÑÏä§)
    const border = this.add.rectangle(width / 2, height / 2, width - 10, height - 10, 0x000000, 0)
      .setStrokeStyle(10, 0xffd700, 1)
      .setDepth(1000);
    this.tweens.add({
      targets: border,
      strokeAlpha: { from: 1, to: 0 },
      duration: 600,
      ease: 'Sine.easeOut',
      onComplete: () => border.destroy()
    });

    // 7. ÌôîÎ©¥ ÌùîÎì§Î¶º
    this.cameras.main.shake(200, 0.01);
  }

  showSuitRemovalEffect() {
    // ÏàòÌä∏ Ìï¥Ï†ú Ìö®Í≥º: ÎÖ∏ÎûÄ Î®∏Î¶¨Í∞Ä ÌååÌã∞ÌÅ¥Î°ú Íπ®ÏßÄÎ©¥ÏÑú ÎÖπÏÉâÏúºÎ°ú Î≥µÏõê
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 1. ÎÖ∏ÎûÄÏÉâ ÌååÌã∞ÌÅ¥Ïù¥ Íπ®ÏßÄÎ©¥ÏÑú ÎÇ†ÏïÑÍ∞ê
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      const particle = this.add.rectangle(
        headX,
        headY,
        4,
        4,
        0xffff00
      ).setDepth(500).setAlpha(1);

      this.tweens.add({
        targets: particle,
        x: headX + Math.cos(angle) * 50,
        y: headY + Math.sin(angle) * 50,
        alpha: 0,
        scale: 0,
        rotation: Math.random() * Math.PI * 2,
        duration: 400,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // 2. ÎÖπÏÉâ Î≥µÏõê Í∏ÄÎ°úÏö∞
    const glow = this.add.circle(headX, headY, 5, 0x00ff00, 0.8)
      .setDepth(499);
    this.tweens.add({
      targets: glow,
      radius: 25,
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => glow.destroy()
    });

    // 3. "SUIT OFF" ÌÖçÏä§Ìä∏ (ÏûëÍ≤å)
    const text = this.add.text(headX, headY - 30, 'SUIT OFF', {
      fontSize: '14px',
      fill: '#ffffff',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(501).setAlpha(0);

    this.tweens.add({
      targets: text,
      alpha: 1,
      y: headY - 50,
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        this.tweens.add({
          targets: text,
          alpha: 0,
          y: headY - 70,
          duration: 300,
          delay: 200,
          onComplete: () => text.destroy()
        });
      }
    });
  }

  // Ïã§Îìú ÏÜåÎ™® Ïãú ÏûëÏùÄ Ïï†ÎãàÎ©îÏù¥ÏÖò (4Î≤àÏß∏ Î∞©Ìñ•Ï†ÑÌôòÎßàÎã§)
  showShieldConsumedEffect() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÏûëÏùÄ Ïã§Îìú ÏïÑÏù¥ÏΩòÏù¥ Íπ®ÏßÄÎäî Ìö®Í≥º
    const shieldIcon = this.add.text(headX, headY - 20, 'üõ°Ô∏è', {
      fontSize: '20px'
    }).setOrigin(0.5).setDepth(500).setAlpha(1);

    // Ïã§ÎìúÍ∞Ä ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎ©¥ÏÑú Íπ®ÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: shieldIcon,
      y: headY - 50,
      alpha: 0,
      scale: 0.3,
      angle: 360,
      duration: 400,
      ease: 'Power2',
      onComplete: () => shieldIcon.destroy()
    });

    // ÏûëÏùÄ ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const particle = this.add.circle(headX, headY - 20, 2, 0xffd700)
        .setDepth(499).setAlpha(0.8);
      this.tweens.add({
        targets: particle,
        x: headX + Math.cos(angle) * 25,
        y: headY - 20 + Math.sin(angle) * 25,
        alpha: 0,
        duration: 300,
        onComplete: () => particle.destroy()
      });
    }

    // "-1" ÌÖçÏä§Ìä∏
    const minusText = this.add.text(headX + 15, headY - 30, '-1', {
      fontSize: '12px',
      fill: '#ff6666',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(501).setAlpha(0);

    this.tweens.add({
      targets: minusText,
      alpha: 1,
      y: headY - 45,
      duration: 200,
      ease: 'Power2',
      onComplete: () => {
        this.tweens.add({
          targets: minusText,
          alpha: 0,
          duration: 200,
          delay: 100,
          onComplete: () => minusText.destroy()
        });
      }
    });
  }

  // Ïã§Îìú Î∂ÄÏ°±ÏúºÎ°ú ÏΩ§Î≥¥ ÎÅäÍπÄ ÏòàÍ≥† (X ÌëúÏãú + Îπ†Î•∏ Î®∏Î¶¨ÏÉâ Î≥µÏõê)
  showComboLostWarning() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 1. ÌÅ∞ X ÌëúÏãú
    const xMark = this.add.text(headX, headY - 30, '‚úó', {
      fontSize: '40px',
      fill: '#ff0000',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(502).setScale(0).setAlpha(0);

    this.tweens.add({
      targets: xMark,
      scale: 1.5,
      alpha: 1,
      duration: 150,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: xMark,
          scale: 0,
          alpha: 0,
          duration: 200,
          delay: 200,
          onComplete: () => xMark.destroy()
        });
      }
    });

    // 2. Îπ†Î•∏ Î®∏Î¶¨ÏÉâ Î≥µÏõê (ÎÖ∏ÎûÄÏÉâ ‚Üí ÎÖπÏÉâ)
    // ÎÖ∏ÎûÄÏÉâ ÌååÌã∞ÌÅ¥Ïù¥ Îπ†Î•¥Í≤å ÌäÄÏñ¥ÎÇòÍ∞ê
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      const particle = this.add.rectangle(headX, headY, 3, 3, 0xffff00)
        .setDepth(501).setAlpha(1);
      this.tweens.add({
        targets: particle,
        x: headX + Math.cos(angle) * 40,
        y: headY + Math.sin(angle) * 40,
        alpha: 0,
        rotation: Math.random() * Math.PI * 2,
        duration: 250,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // 3. ÎÖπÏÉâ ÌîåÎûòÏãú
    const flash = this.add.circle(headX, headY, 8, 0x00ff00, 0.9)
      .setDepth(500);
    this.tweens.add({
      targets: flash,
      radius: 30,
      alpha: 0,
      duration: 300,
      ease: 'Power2',
      onComplete: () => flash.destroy()
    });

    // 4. ÌôîÎ©¥ ÌùîÎì§Î¶º (ÏûëÍ≤å)
    this.cameras.main.shake(100, 0.005);

    // 5. "NO SHIELD!" ÌÖçÏä§Ìä∏
    const text = this.add.text(headX, headY + 30, 'NO SHIELD!', {
      fontSize: '12px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(501).setAlpha(0);

    this.tweens.add({
      targets: text,
      alpha: 1,
      y: headY + 40,
      duration: 200,
      onComplete: () => {
        this.tweens.add({
          targets: text,
          alpha: 0,
          duration: 300,
          delay: 300,
          onComplete: () => text.destroy()
        });
      }
    });
  }

  // Ïù∏Í≤åÏûÑ ÏïÑÏù¥ÌÖú ÏÉÅÌÉú UI ÏÉùÏÑ± (ÌïòÎã® UI ÏòÅÏó≠)
  createItemStatusUI() {
    const { height } = this.cameras.main;

    // ÌïòÎã® UI ÏòÅÏó≠ Ï§ëÏïô Y Ï¢åÌëú
    const bottomUIY = height - this.bottomUIHeight / 2;

    // Ïã§Îìú ÏïÑÏù¥ÌÖú ÏúÑÏπò (ÏôºÏ™ΩÏóêÏÑú Ï≤´Î≤àÏß∏ Ïä¨Î°Ø)
    const shieldX = 80;

    // ÏïÑÏù¥ÌÖú Ïä¨Î°Ø Î∞∞Í≤Ω
    this.itemStatusBg = this.add.rectangle(shieldX, bottomUIY, 100, 44, 0x000000, 0.5)
      .setDepth(2001)
      .setStrokeStyle(2, 0x333333)
      .setAlpha(0);

    // Ïã§Îìú ÏïÑÏù¥ÏΩò
    this.itemStatusIcon = this.add.text(shieldX - 30, bottomUIY, 'üõ°Ô∏è', {
      fontSize: '20px'
    }).setOrigin(0.5).setDepth(2002).setAlpha(0);

    // Ïã§Îìú Í∞úÏàò
    this.itemStatusCount = this.add.text(shieldX + 10, bottomUIY, '√ó0', {
      fontSize: '18px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0, 0.5).setDepth(2002).setAlpha(0);

    // ÏÉÅÌÉú ÎùºÎ≤®
    this.itemStatusLabel = this.add.text(shieldX, bottomUIY - 18, 'SHIELDS', {
      fontSize: '8px',
      fill: '#888888'
    }).setOrigin(0.5).setDepth(2002).setAlpha(0);
  }

  // ÏïÑÏù¥ÌÖú ÏÉÅÌÉú UI ÏóÖÎç∞Ïù¥Ìä∏
  updateItemStatusUI() {
    // Ïã§ÎìúÍ∞Ä 0Í∞úÎ©¥ UI Ïà®Í∏∞Í∏∞
    if (this.comboShieldCount === 0) {
      // ÌéòÏù¥ÎìúÏïÑÏõÉ
      this.tweens.add({
        targets: [this.itemStatusBg, this.itemStatusIcon, this.itemStatusCount, this.itemStatusLabel],
        alpha: 0,
        duration: 300,
        ease: 'Power2'
      });
      return;
    }

    // Ïã§ÎìúÍ∞Ä ÏûàÏúºÎ©¥ UI ÌëúÏãú
    const isNewlyVisible = this.itemStatusBg.alpha === 0;

    // Í∞úÏàò ÏóÖÎç∞Ïù¥Ìä∏
    this.itemStatusCount.setText(`√ó${this.comboShieldCount}`);

    // ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏ (Í∞úÏàòÏóê Îî∞Îùº)
    if (this.comboShieldCount >= 3) {
      this.itemStatusCount.setFill('#00ff00'); // ÎÖπÏÉâ - Ïó¨Ïú†
      this.itemStatusBg.setStrokeStyle(2, 0x00ff00);
    } else if (this.comboShieldCount === 2) {
      this.itemStatusCount.setFill('#ffff00'); // ÎÖ∏ÎûÄÏÉâ - Î≥¥ÌÜµ
      this.itemStatusBg.setStrokeStyle(2, 0xffff00);
    } else {
      this.itemStatusCount.setFill('#ff4444'); // Îπ®Í∞ÑÏÉâ - ÏúÑÌóò
      this.itemStatusBg.setStrokeStyle(2, 0xff4444);
    }

    if (isNewlyVisible) {
      // Ï≤´ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: this.itemStatusBg,
        alpha: 1,
        scaleX: { from: 0.5, to: 1 },
        scaleY: { from: 0.5, to: 1 },
        duration: 300,
        ease: 'Back.easeOut'
      });
      this.tweens.add({
        targets: [this.itemStatusIcon, this.itemStatusCount, this.itemStatusLabel],
        alpha: 1,
        duration: 300,
        delay: 100,
        ease: 'Power2'
      });
    } else {
      // Í∞úÏàò Î≥ÄÍ≤Ω Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: this.itemStatusCount,
        scaleX: 1.3,
        scaleY: 1.3,
        duration: 100,
        yoyo: true,
        ease: 'Power2'
      });
    }
  }

  playFoodEffect() {
    const { width, height } = this.cameras.main;
    const foodPos = {
      x: this.food.x * this.gridSize + this.gridSize / 2,
      y: this.food.y * this.gridSize + this.gridSize / 2 + this.gameAreaY
    };

    // 1~3Í∞ú: Ìö®Í≥º ÏóÜÏùå
    if (this.foodCount <= 3) {
      return;
    }

    // 4~10Í∞ú: ÏïΩÌïú Ìö®Í≥º
    if (this.foodCount >= 4 && this.foodCount <= 10) {
      // Î®πÏù¥ ÏúÑÏπòÏóêÏÑú ÏûëÏùÄ Ïä§ÌîåÎûòÏãú
      const splash = this.add.circle(foodPos.x, foodPos.y, 10, 0xff0000, 0.6);
      this.tweens.add({
        targets: splash,
        scaleX: 3,
        scaleY: 3,
        alpha: 0,
        duration: 300,
        ease: 'Power2',
        onComplete: () => splash.destroy()
      });

      // Î±Ä Î®∏Î¶¨ Îπ®Í∞ÑÏÉâ ÍπúÎπ°ÏûÑ
      this.snakeHeadTint = 0xff0000;
      this.time.delayedCall(100, () => {
        this.snakeHeadTint = null;
      });
    }

    // 11~20Í∞ú: Ï§ëÍ∞Ñ Ìö®Í≥º
    if (this.foodCount >= 11 && this.foodCount <= 20) {
      // ÌÅ∞ Ïä§ÌîåÎûòÏãú + ÎßÅ Ìö®Í≥º
      const splash = this.add.circle(foodPos.x, foodPos.y, 15, 0xff0000, 0.8);
      this.tweens.add({
        targets: splash,
        scaleX: 5,
        scaleY: 5,
        alpha: 0,
        duration: 400,
        ease: 'Power2',
        onComplete: () => splash.destroy()
      });

      // ÎßÅ Ìö®Í≥º
      for (let i = 0; i < 3; i++) {
        const ring = this.add.circle(foodPos.x, foodPos.y, 20, 0xff6600, 0);
        ring.setStrokeStyle(3, 0xff0000, 0.7);
        this.tweens.add({
          targets: ring,
          scaleX: 4,
          scaleY: 4,
          alpha: 0,
          duration: 600,
          delay: i * 100,
          ease: 'Cubic.out',
          onComplete: () => ring.destroy()
        });
      }

      // Î±Ä Ï†ÑÏ≤¥ ÏÉâÏÉÅ Î≥ÄÌôî
      this.snakeBodyTint = 0xff6600;
      this.time.delayedCall(200, () => {
        this.snakeBodyTint = null;
      });

      // Î∞∞Í≤Ω ÏïΩÌïú Î≤àÏ©çÏûÑ
      const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.15).setOrigin(0);
      this.tweens.add({
        targets: flash,
        alpha: 0,
        duration: 200,
        onComplete: () => flash.destroy()
      });
    }

    // 16Í∞ú Ïù¥ÏÉÅ: Í∞ïÌïú Ìö®Í≥º
    if (this.foodCount >= 16) {
      // Í∞ïÎ†•Ìïú Ïä§ÌîåÎûòÏãú Ìè≠Î∞ú
      const splash = this.add.circle(foodPos.x, foodPos.y, 20, 0xff0000, 1);
      this.tweens.add({
        targets: splash,
        scaleX: 8,
        scaleY: 8,
        alpha: 0,
        duration: 500,
        ease: 'Power3',
        onComplete: () => splash.destroy()
      });

      // Îã§Ï§ë ÎßÅ Ìö®Í≥º
      for (let i = 0; i < 5; i++) {
        const ring = this.add.circle(foodPos.x, foodPos.y, 25, 0xff0000, 0);
        ring.setStrokeStyle(4, 0xff0000, 0.9);
        this.tweens.add({
          targets: ring,
          scaleX: 6,
          scaleY: 6,
          alpha: 0,
          duration: 700,
          delay: i * 80,
          ease: 'Cubic.out',
          onComplete: () => ring.destroy()
        });
      }

      // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
      for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 * i) / 12;
        const particle = this.add.circle(foodPos.x, foodPos.y, 4, 0xff0000, 1);
        this.tweens.add({
          targets: particle,
          x: foodPos.x + Math.cos(angle) * 60,
          y: foodPos.y + Math.sin(angle) * 60,
          alpha: 0,
          duration: 500,
          ease: 'Power2',
          onComplete: () => particle.destroy()
        });
      }

      // Î±Ä Ï†ÑÏ≤¥ Í∞ïÌïú ÏÉâÏÉÅ Î≥ÄÌôî + Í∑∏Î¶ºÏûê
      this.snakeBodyTint = 0xff0000;
      this.snakeGlow = true;
      this.time.delayedCall(300, () => {
        this.snakeBodyTint = null;
        this.snakeGlow = false;
      });

      // Í∞ïÌïú Î∞∞Í≤Ω Î≤àÏ©çÏûÑ
      const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.3).setOrigin(0);
      this.tweens.add({
        targets: flash,
        alpha: 0,
        duration: 300,
        onComplete: () => flash.destroy()
      });

      // ÌôîÎ©¥ ÌùîÎì§Î¶º
      this.cameras.main.shake(150, 0.005);
    }
  }

  // ==================== Îç∞ÎìúÏ°¥ ÏãúÏä§ÌÖú ====================

  // ==================== Moving Dead Zone (Saw) ====================
  ensureSawTexture() {
    if (this.textures.exists(this.sawTextureKey)) return;

    const size = 96;
    const center = size / 2;
    const spikes = 16;
    const g = this.make.graphics({ x: 0, y: 0, add: false });

    g.fillStyle(0xdedede, 1);
    g.lineStyle(3, 0x550000, 0.6);
    g.beginPath();
    for (let i = 0; i < spikes; i++) {
      const angle = (Math.PI * 2 * i) / spikes;
      const radius = i % 2 === 0 ? size * 0.48 : size * 0.32;
      const px = center + Math.cos(angle) * radius;
      const py = center + Math.sin(angle) * radius;
      if (i === 0) {
        g.moveTo(px, py);
      } else {
        g.lineTo(px, py);
      }
    }
    g.closePath();
    g.fillPath();
    g.strokePath();

    g.fillStyle(0x3c3c3c, 1);
    g.fillCircle(center, center, size * 0.18);
    g.fillStyle(0xff0000, 0.85);
    g.fillCircle(center, center, size * 0.08);
    g.lineStyle(2, 0xffffff, 0.2);
    g.strokeCircle(center, center, size * 0.42);

    g.generateTexture(this.sawTextureKey, size, size);
    g.destroy();
  }

  isSawOccupyingTile(x, y) {
    // ÏùºÎ∞ò ÌÜ±Îãà Ï≤¥ÌÅ¨
    const normalSawOccupied = this.saws.some(saw => {
      if (!saw) return false;
      if (saw.x === x && saw.y === y) return true;
      if (saw.nextPosition && saw.nextPosition.x === x && saw.nextPosition.y === y) return true;
      return false;
    });

    // Í∞ïÌôî ÌÜ±Îãà Ï≤¥ÌÅ¨
    const enhancedSawOccupied = this.enhancedSaws.some(saw => {
      if (!saw) return false;
      if (saw.x === x && saw.y === y) return true;
      if (saw.nextPosition && saw.nextPosition.x === x && saw.nextPosition.y === y) return true;
      return false;
    });

    return normalSawOccupied || enhancedSawOccupied;
  }

  isSawTileDanger(x, y) {
    // ÏùºÎ∞ò ÌÜ±Îãà ÏúÑÌóò Ï≤¥ÌÅ¨
    const normalSawDanger = this.saws.some(saw => saw && saw.canKill && (
      (saw.x === x && saw.y === y) ||
      (saw.nextPosition && saw.nextPosition.x === x && saw.nextPosition.y === y)
    ));

    // Í∞ïÌôî ÌÜ±Îãà ÏúÑÌóò Ï≤¥ÌÅ¨
    const enhancedSawDanger = this.enhancedSaws.some(saw => saw && saw.canKill && (
      (saw.x === x && saw.y === y) ||
      (saw.nextPosition && saw.nextPosition.x === x && saw.nextPosition.y === y)
    ));

    return normalSawDanger || enhancedSawDanger;
  }

  getSawSpawnPosition() {
    const attempts = 100;
    for (let i = 0; i < attempts; i++) {
      const pos = {
        x: Phaser.Math.Between(0, this.cols - 1),
        y: Phaser.Math.Between(0, this.rows - 1)
      };

      if (this.isSawOccupyingTile(pos.x, pos.y)) continue;

      const notOnSnake = !this.snake.some(segment =>
        segment.x === pos.x && segment.y === pos.y
      );
      const notOnFood = !(pos.x === this.food.x && pos.y === this.food.y);
      const notOnGas = !this.isInGasZone(pos.x, pos.y);
      const notOnDeadZone = !this.deadZones.some(dz => dz.x === pos.x && dz.y === pos.y);

      const snakeHead = this.snake[0];
      let nextX = snakeHead.x;
      let nextY = snakeHead.y;
      switch (this.direction) {
        case 'LEFT': nextX -= 1; break;
        case 'RIGHT': nextX += 1; break;
        case 'UP': nextY -= 1; break;
        case 'DOWN': nextY += 1; break;
      }
      const notInFrontOfSnake = !(pos.x === nextX && pos.y === nextY);

      if (notOnSnake && notOnFood && notOnGas && notOnDeadZone && notInFrontOfSnake) {
        return pos;
      }
    }

    return null;
  }

  spawnSaw() {
    if (this.gameOver) return;
    if (this.saws.length >= this.maxSaws) return;

    this.ensureSawTexture();

    const pos = this.getSawSpawnPosition();
    if (!pos) return;

    const centerX = pos.x * this.gridSize + this.gridSize / 2;
    const centerY = pos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const container = this.add.container(centerX, centerY);
    container.setDepth(120);
    container.setScale(0.2);
    container.setAlpha(0);

    const shadow = this.add.ellipse(0, this.gridSize * 0.18, this.gridSize + 10, this.gridSize / 2, 0x000000, 0.45);
    const aura = this.add.circle(0, 0, this.gridSize * 0.8, 0x5c0000, 0.32);
    aura.setBlendMode(Phaser.BlendModes.ADD);
    const warningRing = this.add.circle(0, 0, this.gridSize * 0.9, 0xff0000, 0);
    warningRing.setStrokeStyle(2, 0xff0000, 1);
    warningRing.setScale(1.8);

    const blade = this.add.image(0, 0, this.sawTextureKey);
    blade.setScale(this.gridSize / 78);
    blade.setTint(0xffffff);

    const core = this.add.circle(0, 0, this.gridSize * 0.22, 0xffffff, 0.9);
    core.setStrokeStyle(1, 0xff0000, 0.8);

    container.add([shadow, aura, warningRing, blade, core]);

    const saw = {
      x: pos.x,
      y: pos.y,
      container,
      blade,
      warningRing,
      moveDelay: this.sawBaseDelay,
      canKill: false,
      nextPosition: null,
      lastDirection: null,
      nextStepSize: 1,
      spinTween: null,
      pulseTween: null,
      breathTween: null,
      moveTimer: null
    };

    this.saws.push(saw);
    this.animateSawSpawn(saw);
  }

  animateSawSpawn(saw) {
    if (!saw) return;

    const { container, blade, warningRing } = saw;

    const spawnFlash = this.add.rectangle(container.x, container.y, this.gridSize * 3.2, this.gridSize * 3.2, 0xff0000, 0.55)
      .setDepth(140)
      .setBlendMode(Phaser.BlendModes.ADD);
    this.tweens.add({
      targets: spawnFlash,
      alpha: 0,
      scaleX: 2.2,
      scaleY: 2.2,
      duration: 220,
      ease: 'Quad.easeOut',
      onComplete: () => spawnFlash.destroy()
    });

    saw.spinTween = this.tweens.add({
      targets: blade,
      angle: 360,
      duration: 260,
      repeat: -1,
      ease: 'Linear'
    });

    saw.pulseTween = this.tweens.add({
      targets: container,
      scaleX: { from: 0.2, to: 1.2 },
      scaleY: { from: 0.2, to: 1.2 },
      alpha: { from: 0, to: 1 },
      duration: 420,
      ease: 'Back.easeOut',
      onComplete: () => {
        warningRing.setScale(1);
        this.tweens.add({
          targets: warningRing,
          scale: { from: 1.4, to: 1 },
          alpha: { from: 1, to: 0 },
          duration: 320,
          ease: 'Quad.easeOut'
        });
        saw.canKill = true;
        this.startSawMovement(saw);
      }
    });

    saw.breathTween = this.tweens.add({
      targets: container,
      scaleX: 1.02,
      scaleY: 0.98,
      duration: 260,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut',
      delay: 300
    });

    this.tweens.add({
      targets: container,
      angle: { from: Phaser.Math.Between(-65, 65), to: Phaser.Math.Between(-5, 5) },
      duration: 520,
      ease: 'Sine.easeOut'
    });

    this.tweens.add({
      targets: warningRing,
      alpha: { from: 0, to: 0.7 },
      duration: 180,
      yoyo: true,
      ease: 'Quad.easeIn'
    });

    const impactRing = this.add.circle(container.x, container.y, this.gridSize * 1.4, 0xff0000, 0.12).setDepth(135);
    impactRing.setStrokeStyle(4, 0xffffff, 0.8);
    this.tweens.add({
      targets: impactRing,
      scale: 2.3,
      alpha: 0,
      duration: 360,
      ease: 'Cubic.easeOut',
      onComplete: () => impactRing.destroy()
    });

    this.time.delayedCall(120, () => {
      if (!this.cameras || !this.cameras.main) return;
      this.cameras.main.shake(110, 0.003);
    });
  }

  flashSawEnraged(saw) {
    if (!saw) return;

    const { container, warningRing } = saw;

    this.tweens.add({
      targets: container,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 100,
      yoyo: true,
      ease: 'Quad.easeOut'
    });

    if (warningRing) {
      this.tweens.add({
        targets: warningRing,
        scale: { from: 1, to: 1.6 },
        alpha: { from: 0.8, to: 0 },
        duration: 200,
        ease: 'Quad.easeOut'
      });
    }

    if (saw.spinTween) {
      saw.spinTween.timeScale = 1.5;
      this.time.delayedCall(200, () => {
        if (saw && saw.spinTween) {
          saw.spinTween.timeScale = 1;
        }
      });
    }
  }

  startSawMovement(saw) {
    if (!saw) return;

    if (saw.moveTimer) {
      saw.moveTimer.remove();
    }

    saw.moveTimer = this.time.addEvent({
      delay: saw.moveDelay,
      loop: true,
      callback: () => this.moveSaw(saw)
    });
  }

  // Î™®Îì† ÌÜ±Îãà ÏùºÏãúÏ†ïÏßÄ
  pauseAllSaws() {
    // Í∏∞Î≥∏ ÌÜ±Îãà
    for (const saw of this.saws) {
      if (saw && saw.moveTimer) {
        saw.moveTimer.paused = true;
      }
    }
    // Í∞ïÌôî ÌÜ±Îãà
    for (const saw of this.enhancedSaws) {
      if (saw && saw.moveTimer) {
        saw.moveTimer.paused = true;
      }
    }
  }

  // Î™®Îì† ÌÜ±Îãà Ïû¨Í∞ú
  resumeAllSaws() {
    // Í∏∞Î≥∏ ÌÜ±Îãà
    for (const saw of this.saws) {
      if (saw && saw.moveTimer) {
        saw.moveTimer.paused = false;
      }
    }
    // Í∞ïÌôî ÌÜ±Îãà
    for (const saw of this.enhancedSaws) {
      if (saw && saw.moveTimer) {
        saw.moveTimer.paused = false;
      }
    }
  }

  // Î™®Îì† Í∞ïÌôî ÌÜ±Îãà Ïù¥Îèô ÏãúÏûë
  startAllEnhancedSawMovement() {
    for (const saw of this.enhancedSaws) {
      if (saw && saw.canKill && !saw.moveTimer) {
        this.startEnhancedSawMovement(saw);
      }
    }
  }

  // Î™®Îì† ÌÜ±ÎãàÎ•º Îßµ Î∞ñÏúºÎ°ú ÎÇ†Î†§Î≥¥ÎÇ¥Îäî Ïï†ÎãàÎ©îÏù¥ÏÖò
  animateSawsFlyOut(callback) {
    const { width, height } = this.cameras.main;

    // Î±Ä Ïà®Í∏∞Í∏∞ (Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ ÏÉÅÌÉúÏùò Î±ÄÏù¥ Î≥¥Ïù¥ÏßÄ ÏïäÎèÑÎ°ù)
    this.hideSnakeGraphics();

    // Î™®Îì† ÌÜ±Îãà Ïª®ÌÖåÏù¥ÎÑà ÏàòÏßë
    const allSawContainers = [];
    this.saws.forEach(saw => {
      if (saw && saw.container && saw.container.active) {
        // Ïù¥Îèô ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ
        if (saw.moveTimer) {
          saw.moveTimer.remove();
          saw.moveTimer = null;
        }
        allSawContainers.push({ container: saw.container, isEnhanced: false });
      }
    });
    this.enhancedSaws.forEach(saw => {
      if (saw && saw.container && saw.container.active) {
        // Ïù¥Îèô ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ
        if (saw.moveTimer) {
          saw.moveTimer.remove();
          saw.moveTimer = null;
        }
        allSawContainers.push({ container: saw.container, isEnhanced: true });
      }
    });

    // ÌÜ±ÎãàÍ∞Ä ÏóÜÏúºÎ©¥ Î∞îÎ°ú ÏΩúÎ∞±
    if (allSawContainers.length === 0) {
      if (callback) callback();
      return;
    }

    // ÌôîÎ©¥ Ïñ¥Îë°Í≤å
    const overlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0);
    overlay.setDepth(199);
    this.tweens.add({
      targets: overlay,
      fillAlpha: 0.5,
      duration: 300
    });

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2 - 80, 'SAWS RETREATING...', {
      fontSize: '28px',
      fill: '#ff6600',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    this.tweens.add({
      targets: warningText,
      alpha: 1,
      duration: 300
    });

    // Ïπ¥Î©îÎùº ÏïΩÍ∞Ñ ÌùîÎì§Î¶º
    this.cameras.main.shake(500, 0.015);

    // Í∞Å ÌÜ±ÎãàÎ•º ÎûúÎç§ Î∞©Ìñ•ÏúºÎ°ú ÎÇ†Î†§Î≥¥ÎÉÑ
    let completed = 0;
    const total = allSawContainers.length;

    allSawContainers.forEach((sawData, index) => {
      const container = sawData.container;

      // ÎûúÎç§ Î∞©Ìñ• ÏÑ†ÌÉù (ÏÉÅÌïòÏ¢åÏö∞)
      const directions = [
        { x: -150, y: container.y }, // ÏôºÏ™Ω
        { x: width + 150, y: container.y }, // Ïò§Î•∏Ï™Ω
        { x: container.x, y: -150 }, // ÏúÑ
        { x: container.x, y: height + 150 } // ÏïÑÎûò
      ];
      const targetPos = Phaser.Math.RND.pick(directions);

      // ÌöåÏ†ÑÌïòÎ©∞ ÎÇ†ÏïÑÍ∞ê
      this.tweens.add({
        targets: container,
        rotation: container.rotation + Math.PI * 6,
        duration: 800,
        ease: 'Quad.easeIn'
      });

      // ÏúÑÏπò Ïù¥Îèô (ÎÇ†ÏïÑÍ∞ê)
      this.tweens.add({
        targets: container,
        x: targetPos.x,
        y: targetPos.y,
        scaleX: sawData.isEnhanced ? 0.5 : 0.3,
        scaleY: sawData.isEnhanced ? 0.5 : 0.3,
        alpha: 0.3,
        duration: 800,
        delay: index * 80,
        ease: 'Quad.easeIn',
        onComplete: () => {
          // ÎÇ†ÏïÑÍ∞ÄÎäî Í∂§Ï†ÅÏóê Ïä§ÌååÌÅ¨ Ìö®Í≥º
          const sparkCount = sawData.isEnhanced ? 5 : 3;
          for (let i = 0; i < sparkCount; i++) {
            const spark = this.add.graphics().setDepth(200);
            spark.fillStyle(sawData.isEnhanced ? 0xff4400 : 0xcccccc, 0.8);
            spark.fillCircle(0, 0, Phaser.Math.Between(2, 5));
            spark.x = targetPos.x + Phaser.Math.Between(-20, 20);
            spark.y = targetPos.y + Phaser.Math.Between(-20, 20);
            this.tweens.add({
              targets: spark,
              alpha: 0,
              scaleX: 2,
              scaleY: 2,
              duration: 300,
              delay: i * 50,
              onComplete: () => spark.destroy()
            });
          }

          container.destroy();
          completed++;

          // Î™®Îì† ÌÜ±ÎãàÍ∞Ä ÎÇ†ÏïÑÍ∞ÄÎ©¥ ÏôÑÎ£å
          if (completed >= total) {
            // Î∞∞Ïó¥ ÎπÑÏö∞Í∏∞
            this.saws = [];
            this.enhancedSaws = [];

            // UI Ï†ïÎ¶¨
            this.time.delayedCall(300, () => {
              this.tweens.add({
                targets: [overlay, warningText],
                alpha: 0,
                duration: 300,
                onComplete: () => {
                  overlay.destroy();
                  warningText.destroy();
                  if (callback) callback();
                }
              });
            });
          }
        }
      });
    });
  }

  chooseSawTarget(saw, stepSize = 1) {
    if (!saw) return null;

    const dirs = Phaser.Utils.Array.Shuffle([
      { dx: 1, dy: 0 },
      { dx: -1, dy: 0 },
      { dx: 0, dy: 1 },
      { dx: 0, dy: -1 }
    ]);

    for (const dir of dirs) {
      let tx = saw.x;
      let ty = saw.y;
      let valid = true;

      for (let i = 0; i < stepSize; i++) {
        tx += dir.dx;
        ty += dir.dy;

        if (tx < 0 || tx >= this.cols || ty < 0 || ty >= this.rows) {
          valid = false;
          break;
        }

        if (this.isInGasZone(tx, ty)) {
          valid = false;
          break;
        }
      }

      if (!valid) continue;

      if (this.deadZones.some(dz => dz.x === tx && dz.y === ty)) {
        continue;
      }

      if (this.isSawOccupyingTile(tx, ty)) {
        continue;
      }

      return { x: tx, y: ty, dx: dir.dx, dy: dir.dy };
    }

    if (stepSize > 1) {
      return this.chooseSawTarget(saw, 1);
    }

    return null;
  }

  createSawTrail(fromX, fromY, toX, toY) {
    const angle = Math.atan2(toY - fromY, toX - fromX);
    const midX = Phaser.Math.Linear(fromX, toX, 0.5);
    const midY = Phaser.Math.Linear(fromY, toY, 0.5);
    const length = Phaser.Math.Distance.Between(fromX, fromY, toX, toY) + this.gridSize * 0.9;

    const slash = this.add.rectangle(midX, midY, length, 8, 0xff0000, 0.9)
      .setDepth(115)
      .setAngle(Phaser.Math.RadToDeg(angle));
    slash.setBlendMode(Phaser.BlendModes.ADD);

    this.tweens.add({
      targets: slash,
      alpha: 0,
      scaleY: 2.4,
      duration: 200,
      ease: 'Quad.easeOut',
      onComplete: () => slash.destroy()
    });

    const spark = this.add.circle(toX, toY, 6, 0xffffff, 0.95).setDepth(115);
    this.tweens.add({
      targets: spark,
      alpha: 0,
      scale: 0.3,
      duration: 150,
      ease: 'Cubic.easeOut',
      onComplete: () => spark.destroy()
    });

    const echo = this.add.rectangle(midX, midY, length * 0.8, 4, 0xff8800, 0.35)
      .setDepth(110)
      .setAngle(Phaser.Math.RadToDeg(angle));
    echo.setBlendMode(Phaser.BlendModes.SCREEN);
    this.tweens.add({
      targets: echo,
      alpha: 0,
      scaleY: 1.8,
      duration: 260,
      ease: 'Quad.easeOut',
      onComplete: () => echo.destroy()
    });
  }

  moveSaw(saw, forceLunge = false) {
    if (!saw || this.gameOver) return;
    if (this.moveTimer && this.moveTimer.paused) return;

    const stepSize = Math.max(1, forceLunge ? Math.max(2, saw.nextStepSize || 1) : (saw.nextStepSize || 1));
    saw.nextStepSize = 1;

    const target = this.chooseSawTarget(saw, stepSize);
    if (!target) return;

    saw.nextPosition = { x: target.x, y: target.y };
    saw.lastDirection = { dx: target.dx, dy: target.dy };

    const fromX = saw.container.x;
    const fromY = saw.container.y;
    const toX = target.x * this.gridSize + this.gridSize / 2;
    const toY = target.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    this.createSawTrail(fromX, fromY, toX, toY);

    this.tweens.add({
      targets: saw.container,
      x: toX,
      y: toY,
      duration: Math.max(150, saw.moveDelay * 0.55),
      ease: 'Sine.easeInOut',
      onStart: () => {
        this.tweens.add({
          targets: saw.container,
          scaleX: 1.12,
          scaleY: 0.9,
          duration: 110,
          yoyo: true,
          repeat: 1
        });
        if (saw.spinTween) {
          saw.spinTween.timeScale = 1.3;
        }
      },
      onComplete: () => {
        if (saw.spinTween) {
          saw.spinTween.timeScale = 1;
        }
        saw.x = target.x;
        saw.y = target.y;
        saw.nextPosition = null;
        this.handleSawCrossedFood(saw, target);
        this.checkSawCollisionWithSnake(saw);
      }
    });

    this.time.delayedCall(40, () => {
      if (!this.cameras || !this.cameras.main) return;
      this.cameras.main.shake(60, 0.0015);
    });
  }

  handleSawCrossedFood(saw, target) {
    if (!saw || !this.food) return;

    if (target.x === this.food.x && target.y === this.food.y) {
      saw.moveDelay = Math.max(60, saw.moveDelay - 5);
      if (saw.moveTimer) {
        saw.moveTimer.delay = saw.moveDelay;
      }
      saw.nextStepSize = 2;
      this.flashSawEnraged(saw);

      this.time.delayedCall(80, () => this.moveSaw(saw, true));
    }
  }

  checkSawCollisionWithSnake(saw) {
    if (!saw || !saw.canKill) return;
    // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ï§ëÏóêÎäî Ï∂©Îèå Î¨¥Ïãú
    if (this.isStageClearingAnimation) return;

    const hitSnake = this.snake.some(segment => segment.x === saw.x && segment.y === saw.y);
    if (hitSnake) {
      this.endGame();
    }
  }

  destroySaw(saw) {
    if (!saw) return;

    if (saw.moveTimer) {
      saw.moveTimer.remove();
      saw.moveTimer = null;
    }

    if (saw.spinTween) {
      saw.spinTween.remove();
    }
    if (saw.pulseTween) {
      saw.pulseTween.remove();
    }
    if (saw.breathTween) {
      saw.breathTween.remove();
    }

    if (saw.container) {
      saw.container.destroy(true);
    }

    const idx = this.saws.indexOf(saw);
    if (idx >= 0) {
      this.saws.splice(idx, 1);
    }
  }

  destroyAllSaws() {
    const clones = [...this.saws];
    clones.forEach(saw => this.destroySaw(saw));
    this.saws = [];
  }

  // =====================
  // ÌÜ±Îãà Î≥¥Ï°¥ ÏãúÏä§ÌÖú
  // =====================

  shouldPreserveSaws() {
    // World 3 (Stage 10-12) ÎÇ¥ÏóêÏÑúÎäî ÌÜ±Îãà Î≥¥Ï°¥
    // resetStage Ìò∏Ï∂ú ÏãúÏ†êÏóê currentStageÎäî Ïù¥ÎØ∏ Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ
    // Stage 11, 12Î°ú Ï†ÑÌôòÎê† Îïå ÌÜ±Îãà Ïú†ÏßÄ (10->11, 11->12)
    const preserveOnStages = [11, 12];
    return preserveOnStages.includes(this.currentStage) || this.preserveSawsForNextStage;
  }

  // =====================
  // Í∞ïÌôî ÌÜ±Îãà ÏãúÏä§ÌÖú (Stage 14)
  // =====================

  destroyEnhancedSaw(saw) {
    if (!saw) return;

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (saw.moveTimer) saw.moveTimer.remove();
    if (saw.spinTween) saw.spinTween.remove();
    if (saw.pulseTween) saw.pulseTween.remove();
    if (saw.breathTween) saw.breathTween.remove();
    if (saw.glowTween) saw.glowTween.remove();
    if (saw.trailTimer) saw.trailTimer.remove();

    // Ïª®ÌÖåÏù¥ÎÑà ÌååÍ¥¥
    if (saw.container) saw.container.destroy(true);

    // Î∞∞Ïó¥ÏóêÏÑú Ï†úÍ±∞
    const idx = this.enhancedSaws.indexOf(saw);
    if (idx >= 0) this.enhancedSaws.splice(idx, 1);
  }

  destroyAllEnhancedSaws() {
    const clones = [...this.enhancedSaws];
    clones.forEach(saw => this.destroyEnhancedSaw(saw));
    this.enhancedSaws = [];
  }

  getEnhancedSawSpawnPosition() {
    // ÏïàÏ†ÑÌïú ÏúÑÏπò Ï∞æÍ∏∞
    for (let attempt = 0; attempt < 100; attempt++) {
      const x = Phaser.Math.Between(3, this.cols - 4);
      const y = Phaser.Math.Between(3, this.rows - 4);

      // Î±ÄÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnSnake = !this.snake.some(seg => seg.x === x && seg.y === y);
      // Î®πÏù¥ÏôÄ Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnFood = !(this.food && this.food.x === x && this.food.y === y);
      // Îç∞ÎìúÏ°¥Í≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnDeadZone = !this.deadZones.some(dz => dz.x === x && dz.y === y);
      // Í∏∞Ï°¥ ÌÜ±ÎãàÏôÄ Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnSaw = !this.saws.some(s => Math.abs(s.x - x) < 3 && Math.abs(s.y - y) < 3);
      // Í∞ïÌôî ÌÜ±ÎãàÏôÄ Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnEnhancedSaw = !this.enhancedSaws.some(s => Math.abs(s.x - x) < 3 && Math.abs(s.y - y) < 3);

      if (notOnSnake && notOnFood && notOnDeadZone && notOnSaw && notOnEnhancedSaw) {
        return { x, y };
      }
    }
    return { x: 20, y: 13 }; // Í∏∞Î≥∏ ÏúÑÏπò
  }

  spawnEnhancedSaw(delayMovement = false) {
    if (this.gameOver || this.enhancedSaws.length >= this.maxEnhancedSaws) return;

    const pos = this.getEnhancedSawSpawnPosition();
    const pixelX = pos.x * this.gridSize + this.gridSize / 2;
    const pixelY = pos.y * this.gridSize + this.gridSize / 2 + 60;

    // Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
    const container = this.add.container(pixelX, pixelY);
    container.setDepth(200);
    container.setScale(0);

    // Îπ®Í∞Ñ Í∏ÄÎ°úÏö∞ Ïò§Îùº (Í∞ïÌôî ÌÜ±Îãà ÌäπÏßï)
    const glowAura = this.add.graphics();
    const glowSize = this.gridSize * this.enhancedSawScale * 1.5;
    glowAura.fillStyle(0xff0000, 0.3);
    glowAura.fillCircle(0, 0, glowSize);
    container.add(glowAura);

    // ÏúÑÌóò Ïò§Îùº
    const dangerAura = this.add.graphics();
    dangerAura.fillStyle(0xff4400, 0.2);
    dangerAura.fillCircle(0, 0, this.gridSize * this.enhancedSawScale);
    container.add(dangerAura);

    // Í≤ΩÍ≥† ÎßÅ
    const warningRing = this.add.graphics();
    warningRing.lineStyle(3, 0xff0000, 0.8);
    warningRing.strokeCircle(0, 0, this.gridSize * this.enhancedSawScale * 0.9);
    container.add(warningRing);

    // ÌÜ±Îãà Î∏îÎ†àÏù¥Îìú (Í∞ïÌôî Î≤ÑÏ†Ñ - Îçî ÌÅ¨Í≥† ÎÇ†Ïπ¥Î°úÏõÄ)
    const blade = this.add.graphics();
    const bladeRadius = this.gridSize * 0.45 * this.enhancedSawScale;
    const teethCount = 16; // Îçî ÎßéÏùÄ ÌÜ±Îãà

    // Î∏îÎ†àÏù¥Îìú Í∑∏Î¶¨Í∏∞ (Îπ®Í∞ÑÏÉâ Ìè¨Ïù∏Ìä∏ Ï∂îÍ∞Ä)
    blade.fillStyle(0xcc3333, 1); // Îπ®Í∞Ñ Îπõ ÎèÑÎäî Í∏àÏÜç
    blade.beginPath();
    for (let i = 0; i < teethCount; i++) {
      const angle = (i / teethCount) * Math.PI * 2;
      const nextAngle = ((i + 0.5) / teethCount) * Math.PI * 2;
      const outerR = bladeRadius * 1.2;
      const innerR = bladeRadius * 0.7;

      if (i === 0) {
        blade.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      } else {
        blade.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      }
      blade.lineTo(Math.cos(nextAngle) * innerR, Math.sin(nextAngle) * innerR);
    }
    blade.closePath();
    blade.fill();

    // ÎÇ¥Î∂Ä ÏΩîÏñ¥ (Í≤ÄÏùÄÏÉâ)
    blade.fillStyle(0x220000, 1);
    blade.fillCircle(0, 0, bladeRadius * 0.35);

    // ÎπõÎÇòÎäî Ï§ëÏã¨
    blade.fillStyle(0xff6600, 1);
    blade.fillCircle(0, 0, bladeRadius * 0.15);

    container.add(blade);

    // Í∞ïÌôî ÌÜ±Îãà Í∞ùÏ≤¥ ÏÉùÏÑ±
    const enhancedSaw = {
      x: pos.x,
      y: pos.y,
      container,
      blade,
      warningRing,
      glowAura,
      dangerAura,
      moveDelay: this.enhancedSawDelay,
      canKill: false,
      nextPosition: null,
      lastDirection: null,
      nextStepSize: 2, // Í∞ïÌôî ÌÜ±ÎãàÎäî 2Ïπ∏ Ï†êÌîÑ Í∞ÄÎä•
      spinTween: null,
      pulseTween: null,
      breathTween: null,
      glowTween: null,
      trailTimer: null,
      moveTimer: null,
      isEnhanced: true
    };

    this.enhancedSaws.push(enhancedSaw);
    this.animateEnhancedSawSpawn(enhancedSaw, delayMovement);
  }

  animateEnhancedSawSpawn(saw, delayMovement = false) {
    const { width, height } = this.cameras.main;

    // Ïä§Ìè∞ ÌîåÎûòÏãú Ìö®Í≥º (Îπ®Í∞ÑÏÉâ)
    const flash = this.add.graphics();
    flash.setDepth(199);
    const flashX = saw.x * this.gridSize + this.gridSize / 2;
    const flashY = saw.y * this.gridSize + this.gridSize / 2 + 60;

    flash.fillStyle(0xff0000, 0.8);
    flash.fillCircle(flashX, flashY, this.gridSize * 2);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 400,
      onComplete: () => flash.destroy()
    });

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(200, 0.01);

    // Ïª®ÌÖåÏù¥ÎÑà Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: saw.container,
      scaleX: this.enhancedSawScale,
      scaleY: this.enhancedSawScale,
      duration: 500,
      ease: 'Back.easeOut'
    });

    // Í≤ΩÍ≥† ÎßÅ ÌéÑÏä§
    this.tweens.add({
      targets: saw.warningRing,
      scaleX: { from: 1.5, to: 1 },
      scaleY: { from: 1.5, to: 1 },
      alpha: { from: 1, to: 0.6 },
      duration: 500,
      ease: 'Power2'
    });

    // ÌöåÏ†Ñ ÏãúÏûë (Îçî Îπ†Î•¥Í≤å)
    saw.spinTween = this.tweens.add({
      targets: saw.blade,
      rotation: Math.PI * 2,
      duration: 200, // Í∏∞Î≥∏ ÌÜ±ÎãàÎ≥¥Îã§ Îπ†Î¶Ñ
      repeat: -1,
      ease: 'Linear'
    });

    // Í∏ÄÎ°úÏö∞ ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    saw.glowTween = this.tweens.add({
      targets: saw.glowAura,
      alpha: { from: 0.3, to: 0.6 },
      scaleX: { from: 1, to: 1.2 },
      scaleY: { from: 1, to: 1.2 },
      duration: 400,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // 1Ï¥à ÌõÑ ÌôúÏÑ±Ìôî
    this.time.delayedCall(1000, () => {
      if (saw && saw.container && saw.container.active) {
        saw.canKill = true;

        // delayMovementÍ∞Ä falseÏùº ÎïåÎßå Î∞îÎ°ú Ïù¥Îèô ÏãúÏûë
        if (!delayMovement) {
          this.startEnhancedSawMovement(saw);
        }

        // ÌôúÏÑ±Ìôî ÌîåÎûòÏãú
        const activateFlash = this.add.graphics();
        activateFlash.setDepth(201);
        activateFlash.fillStyle(0xff4400, 0.6);
        activateFlash.fillCircle(
          saw.x * this.gridSize + this.gridSize / 2,
          saw.y * this.gridSize + this.gridSize / 2 + 60,
          this.gridSize * 1.5
        );
        this.tweens.add({
          targets: activateFlash,
          alpha: 0,
          scaleX: 2,
          scaleY: 2,
          duration: 300,
          onComplete: () => activateFlash.destroy()
        });
      }
    });
  }

  startEnhancedSawMovement(saw) {
    if (!saw || !saw.container || !saw.container.active) return;

    saw.moveTimer = this.time.addEvent({
      delay: saw.moveDelay,
      loop: true,
      callback: () => this.moveEnhancedSaw(saw)
    });
  }

  moveEnhancedSaw(saw) {
    if (!saw || !saw.canKill || this.gameOver || !saw.container || !saw.container.active) return;

    // Îã§Ïùå ÏúÑÏπò Í≤∞Ï†ï (2Ïπ∏ Ï†êÌîÑ 50% ÌôïÎ•†)
    const stepSize = Math.random() < 0.5 ? 2 : 1;
    const target = this.chooseEnhancedSawTarget(saw, stepSize);

    if (!target) return;

    const oldX = saw.x;
    const oldY = saw.y;

    // Î∂àÍΩÉ Ìä∏Î†àÏùº ÏÉùÏÑ±
    this.createEnhancedSawTrail(oldX, oldY, target.x, target.y);

    // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    saw.x = target.x;
    saw.y = target.y;
    saw.lastDirection = target.direction;

    // Ïù¥Îèô Ïï†ÎãàÎ©îÏù¥ÏÖò (Îçî Îπ†Î¶Ñ)
    const newPixelX = saw.x * this.gridSize + this.gridSize / 2;
    const newPixelY = saw.y * this.gridSize + this.gridSize / 2 + 60;

    this.tweens.add({
      targets: saw.container,
      x: newPixelX,
      y: newPixelY,
      duration: saw.moveDelay * 0.4,
      ease: 'Power2',
      onComplete: () => {
        // Ï∂©Îèå Ï≤¥ÌÅ¨ (Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ï§ëÏóêÎäî Î¨¥Ïãú)
        if (!this.isStageClearingAnimation && saw.canKill && this.checkEnhancedSawCollision(saw)) {
          this.endGame();
        }
      }
    });
  }

  chooseEnhancedSawTarget(saw, stepSize) {
    const directions = [
      { dx: 0, dy: -1, name: 'up' },
      { dx: 0, dy: 1, name: 'down' },
      { dx: -1, dy: 0, name: 'left' },
      { dx: 1, dy: 0, name: 'right' }
    ];

    // Î±Ä Î®∏Î¶¨ Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô ÌôïÎ•† Ï¶ùÍ∞Ä (60%)
    const head = this.snake[0];
    let preferredDir = null;
    if (Math.random() < 0.6) {
      const dx = head.x - saw.x;
      const dy = head.y - saw.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        preferredDir = dx > 0 ? 'right' : 'left';
      } else {
        preferredDir = dy > 0 ? 'down' : 'up';
      }
    }

    // Ïú†Ìö®Ìïú Î∞©Ìñ• ÌïÑÌÑ∞ÎßÅ
    const validDirs = directions.filter(dir => {
      const newX = saw.x + dir.dx * stepSize;
      const newY = saw.y + dir.dy * stepSize;

      // Îßµ Î≤îÏúÑ Ï≤¥ÌÅ¨
      if (newX < 0 || newX >= this.cols || newY < 0 || newY >= this.rows) return false;
      // Îç∞ÎìúÏ°¥ Ï≤¥ÌÅ¨
      if (this.deadZones.some(dz => dz.x === newX && dz.y === newY)) return false;
      // Îã§Î•∏ ÌÜ±Îãà Ï≤¥ÌÅ¨
      if (this.saws.some(s => s.x === newX && s.y === newY)) return false;
      if (this.enhancedSaws.some(s => s !== saw && s.x === newX && s.y === newY)) return false;

      return true;
    });

    if (validDirs.length === 0) return null;

    // ÏÑ†Ìò∏ Î∞©Ìñ• Ïö∞ÏÑ†
    if (preferredDir) {
      const preferred = validDirs.find(d => d.name === preferredDir);
      if (preferred) {
        return {
          x: saw.x + preferred.dx * stepSize,
          y: saw.y + preferred.dy * stepSize,
          direction: preferred.name
        };
      }
    }

    // ÎûúÎç§ ÏÑ†ÌÉù
    const chosen = Phaser.Math.RND.pick(validDirs);
    return {
      x: saw.x + chosen.dx * stepSize,
      y: saw.y + chosen.dy * stepSize,
      direction: chosen.name
    };
  }

  createEnhancedSawTrail(fromX, fromY, toX, toY) {
    // Î∂àÍΩÉ Ìä∏Î†àÏùº Ìö®Í≥º
    const startPixelX = fromX * this.gridSize + this.gridSize / 2;
    const startPixelY = fromY * this.gridSize + this.gridSize / 2 + 60;
    const endPixelX = toX * this.gridSize + this.gridSize / 2;
    const endPixelY = toY * this.gridSize + this.gridSize / 2 + 60;

    // Ìä∏Î†àÏùº ÎùºÏù∏
    const trail = this.add.graphics();
    trail.setDepth(150);
    trail.lineStyle(4, 0xff4400, 0.8);
    trail.beginPath();
    trail.moveTo(startPixelX, startPixelY);
    trail.lineTo(endPixelX, endPixelY);
    trail.stroke();

    // Ïä§ÌååÌÅ¨ ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 5; i++) {
      const t = i / 4;
      const sparkX = startPixelX + (endPixelX - startPixelX) * t;
      const sparkY = startPixelY + (endPixelY - startPixelY) * t;

      const spark = this.add.graphics();
      spark.setDepth(151);
      spark.fillStyle(Phaser.Math.RND.pick([0xff6600, 0xff0000, 0xffaa00]), 1);
      spark.fillCircle(sparkX, sparkY, 3);

      this.tweens.add({
        targets: spark,
        alpha: 0,
        y: sparkY + Phaser.Math.Between(-10, 10),
        x: sparkX + Phaser.Math.Between(-10, 10),
        scaleX: 0,
        scaleY: 0,
        duration: 300,
        onComplete: () => spark.destroy()
      });
    }

    // Ìä∏Î†àÏùº ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.tweens.add({
      targets: trail,
      alpha: 0,
      duration: 200,
      onComplete: () => trail.destroy()
    });
  }

  checkEnhancedSawCollision(saw) {
    const head = this.snake[0];
    return head.x === saw.x && head.y === saw.y;
  }

  startEnhancedSawHellStage() {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // Í∏∞Ï°¥ ÌÜ±ÎãàÎì§ÎèÑ ÏùºÏãúÏ†ïÏßÄ
    this.pauseAllSaws();

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2 - 50, 'ENHANCED SAWS INCOMING!', {
      fontSize: '36px',
      fill: '#ff4400',
      fontStyle: 'bold',
      stroke: '#660000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(500, 0.02);

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scaleX: { from: 0.5, to: 1.2 },
      scaleY: { from: 0.5, to: 1.2 },
      duration: 400,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: warningText,
          scaleX: 1,
          scaleY: 1,
          duration: 200,
          onComplete: () => {
            // Í∞ïÌôî ÌÜ±Îãà 3Í∞ú ÏàúÏ∞® ÏÉùÏÑ± (Ïù¥ÎèôÏùÄ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ ÏãúÏûë)
            let sawIndex = 0;
            const spawnInterval = this.time.addEvent({
              delay: 600,
              repeat: 2,
              callback: () => {
                this.spawnEnhancedSaw(true); // delayMovement = true
                sawIndex++;

                // ÎßàÏßÄÎßâ ÌÜ±Îãà ÏÉùÏÑ± ÌõÑ
                if (sawIndex >= 3) {
                  this.time.delayedCall(1000, () => {
                    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏ ÌéòÏù¥ÎìúÏïÑÏõÉ
                    this.tweens.add({
                      targets: warningText,
                      alpha: 0,
                      duration: 300,
                      onComplete: () => {
                        warningText.destroy();
                        // Stage 14 Ï†ÑÏö© Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ (ÌÜ±Îãà ÏãúÏûë Ìè¨Ìï®)
                        this.startEnhancedSawCountdown();
                      }
                    });
                  });
                }
              }
            });
          }
        });
      }
    });
  }

  // Stage 14 Ï†ÑÏö© Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ (ÌÜ±Îãà Ïù¥Îèô ÏãúÏûë Ìè¨Ìï®)
  startEnhancedSawCountdown() {
    const { width, height } = this.cameras.main;

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏
    const countdownText = this.add.text(width / 2, height / 2, '3', {
      fontSize: '64px',
      fill: '#ff4400',
      fontStyle: 'bold',
      stroke: '#660000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(5000);

    let countdown = 3;
    const countdownTimer = this.time.addEvent({
      delay: 600,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          countdownText.setText(countdown.toString());
          // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌéÑÏä§ Ìö®Í≥º
          this.tweens.add({
            targets: countdownText,
            scaleX: { from: 1.3, to: 1 },
            scaleY: { from: 1.3, to: 1 },
            duration: 200,
            ease: 'Power2'
          });
        } else {
          countdownText.setText('GO!');
          countdownText.setFill('#00ff00');
          countdownTimer.remove();

          // GO! ÌéÑÏä§ Ìö®Í≥º
          this.tweens.add({
            targets: countdownText,
            scaleX: { from: 1.5, to: 1 },
            scaleY: { from: 1.5, to: 1 },
            duration: 300,
            ease: 'Back.easeOut'
          });

          // GO! ÌëúÏãú ÌõÑ Í≤åÏûÑ Ïû¨Í∞ú + ÌÜ±Îãà ÏãúÏûë
          this.time.delayedCall(400, () => {
            countdownText.destroy();

            // Î™®Îì† ÌÜ±Îãà Ïû¨Í∞ú (Í∏∞Ï°¥ ÌÜ±Îãà)
            this.resumeAllSaws();

            // Í∞ïÌôî ÌÜ±Îãà Ïù¥Îèô ÏãúÏûë
            this.startAllEnhancedSawMovement();

            // Í≤åÏûÑ Ïû¨Í∞ú
            this.moveTimer.paused = false;
          });
        }
      },
      loop: true
    });
  }

  // =====================
  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ ÏãúÏä§ÌÖú (ÎπÑÌôúÏÑ±) - Í∏∞Î≥∏ Ìï®ÏàòÎì§
  // =====================

  isGearTitanStage() {
    // Stage 12: Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§
    return this.currentStage === 12;
  }

  cleanupGearTitan() {
    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.gearTitanContainer) {
      this.gearTitanContainer.destroy(true);
      this.gearTitanContainer = null;
    }

    if (this.gearTitanAttackTimer) {
      this.gearTitanAttackTimer.remove();
      this.gearTitanAttackTimer = null;
    }

    if (this.gearTitanAnimTimer) {
      this.gearTitanAnimTimer.remove();
      this.gearTitanAnimTimer = null;
    }

    // Í∏∞Ïñ¥Îì§ Ï†ïÎ¶¨
    this.gearTitanGears.forEach(gear => {
      if (gear && gear.destroy) gear.destroy();
    });
    this.gearTitanGears = [];

    // Î†àÏù¥Ï†ÄÎì§ Ï†ïÎ¶¨
    this.gearTitanLasers.forEach(laser => {
      if (laser && laser.destroy) laser.destroy();
    });
    this.gearTitanLasers = [];

    // ÏΩîÏñ¥ Ï†ïÎ¶¨
    if (this.gearTitanCore) {
      if (this.gearTitanCore.destroy) this.gearTitanCore.destroy();
      this.gearTitanCore = null;
    }

    // Ï∞®ÏßÄ UI Ï†ïÎ¶¨
    this.cleanupChargeUI();

    // ÏÉÅÌÉú Î¶¨ÏÖã
    this.gearTitanMode = false;
    this.gearTitanPhase = 'none';
    this.gearTitanPosition = null;
    this.gearTitanHitCount = 0;
    this.gearTitanVulnerable = false;
    this.canChargeDash = false;
    this.isCharging = false;
    this.chargeReady = false;
    this.isDashing = false;
    this.dashingHideSnake = false;

    // Steam Overheat ÏÉÅÌÉú Î¶¨ÏÖã
    this.isOverheated = false;
    this.overheatEndTime = 0;
    this.steamDashPower = 'weak';
    this.steamPerfectPulsing = false;

    // HIT ÌÖçÏä§Ìä∏ Ï†ïÎ¶¨
    if (this.gearTitanHitText && this.gearTitanHitText.active) {
      this.gearTitanHitText.destroy();
      this.gearTitanHitText = null;
    }

    // SPACE ÌÇ§ Î†àÌçºÎü∞Ïä§ Ï†ïÎ¶¨
    if (this.chargeSpaceKey) {
      this.input.keyboard.removeKey(this.chargeSpaceKey);
      this.chargeSpaceKey = null;
    }
  }

  cleanupChargeUI() {
    // Steam ÌéÑÏä§ Ïù¥ÌéôÌä∏ Ï†ïÎ¶¨
    if (this.steamPerfectPulsing) {
      this.steamPerfectPulsing = false;
      if (this.steamPerfectZoneGraphic) {
        this.tweens.killTweensOf(this.steamPerfectZoneGraphic);
      }
    }

    if (this.chargeUI) {
      this.chargeUI.destroy();
      this.chargeUI = null;
    }
    if (this.chargeGaugeUI) {
      this.chargeGaugeUI.destroy();
      this.chargeGaugeUI = null;
    }

    this.steamPerfectZoneGraphic = null;

    // Ï∞®ÏßÄ ÏóêÎÑàÏßÄ Ïù¥ÌéôÌä∏ÎèÑ Ï†ïÎ¶¨
    this.cleanupChargeEnergyEffect();
  }

  // =====================
  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ ÏãúÏä§ÌÖú - Î©îÏù∏ Ìï®ÏàòÎì§
  // =====================

  startGearTitan() {
    this.gearTitanMode = true;
    this.gearTitanPhase = 'intro';
    this.gearTitanHitCount = 0;
    this.gearTitanVulnerable = false;
    this.gearTitanStunEndTime = 0;

    // Ï∞®ÏßÄ ÎåÄÏãú Ï¥àÍ∏∞Ìôî
    this.canChargeDash = false; // Ïù∏Ìä∏Î°ú ÎèôÏïà ÎπÑÌôúÏÑ±Ìôî
    this.lastDashTime = 0;
    this.isCharging = false;
    this.chargeReady = false;
    this.isDashing = false;
    this.dashingHideSnake = false;

    // Î≥¥Ïä§ ÏúÑÏπò ÏÑ§Ï†ï (Îßµ Ï§ëÏïô)
    this.gearTitanPosition = {
      x: Math.floor(this.cols / 2),
      y: Math.floor(this.rows / 2)
    };

    // ÌÜ±ÎãàÎì§ÏùÄ Ïù¥ÎØ∏ ÎÇ†ÏïÑÍ∞îÏúºÎØÄÎ°ú Î∞îÎ°ú Î≥¥Ïä§ Îì±Ïû• Ïù∏Ìä∏Î°ú ÏãúÏûë
    this.showGearTitanAppearIntro();
  }

  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ ÏßÅÏ†ë Ï†ÑÌà¨ ÏãúÏûë (Í∞úÎ∞úÏûê Î™®ÎìúÏö© - Ïù∏Ìä∏Î°ú Ïä§ÌÇµ)
  startGearTitanDirectBattle() {
    this.gearTitanMode = true;
    this.gearTitanPhase = 'phase1';
    this.lastAttackPhase = 'phase3'; // phase1Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎèÑÎ°ù phase3ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
    this.gearTitanHitCount = 0;
    this.gearTitanVulnerable = false;
    this.gearTitanStunEndTime = 0;

    // Ï∞®ÏßÄ ÎåÄÏãú ÌôúÏÑ±Ìôî
    this.canChargeDash = true;
    this.lastDashTime = 0;
    this.isCharging = false;
    this.chargeReady = false;
    this.isDashing = false;
    this.dashingHideSnake = false;
    this.isInvincible = false;

    // Î≥¥Ïä§ ÏúÑÏπò ÏÑ§Ï†ï (Îßµ Ï§ëÏïô)
    this.gearTitanPosition = {
      x: Math.floor(this.cols / 2),
      y: Math.floor(this.rows / 2)
    };

    // 12ÌÉÑ Î≥¥Ïä§ BGM Ïû¨ÏÉù
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.bgMusic.stop();
    }
    if (this.boss12Music) {
      this.boss12Music.play();
    }

    // Î≥¥Ïä§ Ïä§ÌîÑÎùºÏù¥Ìä∏ ÏÉùÏÑ±
    this.drawGearTitan();

    // Ï∞®ÏßÄ UI ÌëúÏãú
    this.showChargeUI();

    // Í≤åÏûÑ ÌÉÄÏù¥Î®∏ ÏãúÏûë
    if (this.moveTimer) {
      this.moveTimer.paused = false;
    }

    // Ïû†Ïãú ÌõÑ Ï≤´ Í≥µÍ≤© ÏãúÏûë
    this.time.delayedCall(1500, () => {
      this.gearTitanPhase1Attack();
    });
  }

  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Îì±Ïû• Ïù∏Ìä∏Î°ú (ÌÜ±Îãà ÎÇ†ÏïÑÍ∞Ñ ÌõÑ)
  showGearTitanAppearIntro() {
    const { width, height } = this.cameras.main;
    const centerX = this.gearTitanPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.gearTitanPosition.y * this.gridSize + this.gridSize / 2 + 60;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ (Ïù¥ÎØ∏ ÎêòÏñ¥ÏûàÏùÑ Ïàò ÏûàÏùå)
    this.moveTimer.paused = true;

    // Î±Ä ÎåÄÏÇ¨ (ÎßêÌíçÏÑ†) - ÏúÑÌä∏ÏûàÍ≤å
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÎßêÌíçÏÑ† Ïª®ÌÖåÏù¥ÎÑà
    const bubbleContainer = this.add.container(headX, headY - 55).setDepth(5001);

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubble = this.add.graphics();
    bubble.fillStyle(0xffffff, 0.95);
    bubble.lineStyle(3, 0x333333, 1);
    bubble.fillRoundedRect(-120, -25, 240, 50, 12);
    bubble.strokeRoundedRect(-120, -25, 240, 50, 12);

    // ÎßêÌíçÏÑ† Íº¨Î¶¨
    bubble.fillStyle(0xffffff, 0.95);
    bubble.fillTriangle(0, 25, -10, 15, 10, 15);
    bubble.lineStyle(3, 0x333333, 1);
    bubble.lineBetween(-10, 17, 0, 28);
    bubble.lineBetween(10, 17, 0, 28);
    bubbleContainer.add(bubble);

    // ÎåÄÏÇ¨ ÌÖçÏä§Ìä∏
    const snakeDialogue = "Good riddance! Now where's the big boss?";
    const dialogueText = this.add.text(0, 0, '', {
      fontSize: '12px',
      fill: '#222222',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    bubbleContainer.add(dialogueText);

    // ÎßêÌíçÏÑ† Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    bubbleContainer.setScale(0);
    this.tweens.add({
      targets: bubbleContainer,
      scale: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    this.time.delayedCall(300, () => {
      const typeTimer = this.time.addEvent({
        delay: 35,
        callback: () => {
          dialogueText.setText(snakeDialogue.substring(0, charIndex + 1));
          charIndex++;
          if (charIndex >= snakeDialogue.length) {
            typeTimer.destroy();

            // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ Î≥¥Ïä§ Îì±Ïû•
            this.time.delayedCall(1000, () => {
              // ÎßêÌíçÏÑ† ÏÇ¨ÎùºÏßê
              this.tweens.add({
                targets: bubbleContainer,
                scale: 0,
                alpha: 0,
                duration: 200,
                onComplete: () => bubbleContainer.destroy()
              });

              // Î≥¥Ïä§ Îì±Ïû• ÏãúÌÄÄÏä§
              this.showGearTitanBossAppear(centerX, centerY);
            });
          }
        },
        loop: true
      });
    });
  }

  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ Îì±Ïû• ÏãúÌÄÄÏä§
  showGearTitanBossAppear(centerX, centerY) {
    const { width, height } = this.cameras.main;

    // ÌôîÎ©¥ Ïñ¥Îë°Í≤å
    const overlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0);
    overlay.setDepth(4999);
    this.tweens.add({
      targets: overlay,
      fillAlpha: 0.7,
      duration: 400
    });

    // 12ÌÉÑ Î≥¥Ïä§ BGMÏúºÎ°ú Î≥ÄÍ≤Ω (WARNING! Îì±Ïû• ÏãúÏ†ê)
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.bgMusic.stop();
    }
    if (this.boss12Music) {
      this.boss12Music.play();
    }

    // WARNING ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2 - 100, 'WARNING!', {
      fontSize: '72px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#660000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(1200, 0.04);

    // WARNING Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: warningText,
      alpha: 1,
      duration: 150,
      yoyo: true,
      repeat: 4,
      onComplete: () => {
        warningText.destroy();

        // Ï§ëÏïôÏóêÏÑú ÏóêÎÑàÏßÄ ÏàòÎ†¥ Ìö®Í≥º
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const dist = 150;
          const particle = this.add.graphics().setDepth(5001);
          particle.fillStyle(0xff6600, 0.8);
          particle.fillCircle(0, 0, 8);
          particle.x = centerX + Math.cos(angle) * dist;
          particle.y = centerY + Math.sin(angle) * dist;

          this.tweens.add({
            targets: particle,
            x: centerX,
            y: centerY,
            alpha: 0,
            scaleX: 0.2,
            scaleY: 0.2,
            duration: 500,
            ease: 'Quad.easeIn',
            onComplete: () => particle.destroy()
          });
        }

        // ÎåÄÌè≠Î∞ú Ìö®Í≥º
        this.time.delayedCall(500, () => {
          this.cameras.main.flash(300, 255, 150, 0);

          // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
          for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2;
            const dist = Phaser.Math.Between(40, 100);
            const particle = this.add.graphics().setDepth(5002);
            particle.fillStyle(Phaser.Math.RND.pick([0xff4400, 0xffaa00, 0xff0000]), 1);
            particle.fillCircle(0, 0, Phaser.Math.Between(3, 8));
            particle.x = centerX;
            particle.y = centerY;

            this.tweens.add({
              targets: particle,
              x: centerX + Math.cos(angle) * dist,
              y: centerY + Math.sin(angle) * dist,
              alpha: 0,
              duration: 600,
              ease: 'Power2',
              onComplete: () => particle.destroy()
            });
          }

          // Î≥¥Ïä§ Îì±Ïû•
          this.drawGearTitan();

          // Ïò§Î≤ÑÎ†àÏù¥ ÏÑúÏÑúÌûà ÏÇ¨ÎùºÏßê
          this.tweens.add({
            targets: overlay,
            fillAlpha: 0,
            duration: 800,
            delay: 400,
            onComplete: () => overlay.destroy()
          });

          // Î≥¥Ïä§ Î¨¥ÏÑúÏö¥ ÎåÄÏÇ¨
          this.time.delayedCall(800, () => {
            this.showGearTitanDialogue("I AM GEAR TITAN... FORGED FROM STEEL!", () => {
              this.showGearTitanDialogue("YOUR SAWS WERE MERE TOYS... NOW FACE ME!", () => {
                // Ï∞®ÏßÄ ÎåÄÏãú ÌäúÌÜ†Î¶¨Ïñº ÌõÑ Ï†ÑÌà¨ ÏãúÏûë
                this.showChargeDashTutorial(() => {
                  this.canChargeDash = true;
                  this.gearTitanPhase = 'phase1';
                  this.lastAttackPhase = 'phase3'; // phase1Î∂ÄÌÑ∞ ÏãúÏûë
                  this.moveTimer.paused = false;
                  this.showChargeUI();
                  this.advanceGearTitanPhase();
                });
              });
            });
          });
        });
      }
    });
  }

  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ ÌÜ±Îãà Ìï©Ï≤¥ Ïù∏Ìä∏Î°ú (Ïù¥Ï†Ñ Î≤ÑÏ†Ñ - ÏÇ¨Ïö© ÏïàÌï®)
  showGearTitanMergeIntro() {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // Î±Ä ÎåÄÏÇ¨ (ÎßêÌíçÏÑ†) - ÏúÑÌä∏ÏûàÍ≤å
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÎßêÌíçÏÑ† Ïª®ÌÖåÏù¥ÎÑà
    const bubbleContainer = this.add.container(headX, headY - 55).setDepth(5001);

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubble = this.add.graphics();
    bubble.fillStyle(0xffffff, 0.95);
    bubble.lineStyle(3, 0x333333, 1);
    bubble.fillRoundedRect(-110, -25, 220, 50, 12);
    bubble.strokeRoundedRect(-110, -25, 220, 50, 12);

    // ÎßêÌíçÏÑ† Íº¨Î¶¨
    bubble.fillStyle(0xffffff, 0.95);
    bubble.fillTriangle(0, 25, -10, 15, 10, 15);
    bubble.lineStyle(3, 0x333333, 1);
    bubble.lineBetween(-10, 17, 0, 28);
    bubble.lineBetween(10, 17, 0, 28);
    bubbleContainer.add(bubble);

    // ÎåÄÏÇ¨ ÌÖçÏä§Ìä∏
    const snakeDialogue = "Whoa, saws! You guys need some therapy?";
    const dialogueText = this.add.text(0, 0, '', {
      fontSize: '13px',
      fill: '#222222',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    bubbleContainer.add(dialogueText);

    // ÎßêÌíçÏÑ† Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    bubbleContainer.setScale(0);
    this.tweens.add({
      targets: bubbleContainer,
      scale: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    this.time.delayedCall(300, () => {
      const typeTimer = this.time.addEvent({
        delay: 35,
        callback: () => {
          dialogueText.setText(snakeDialogue.substring(0, charIndex + 1));
          charIndex++;
          if (charIndex >= snakeDialogue.length) {
            typeTimer.destroy();

            // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ ÌÜ±ÎãàÎì§ Î∞òÏùë
            this.time.delayedCall(1000, () => {
              // ÎßêÌíçÏÑ† ÏÇ¨ÎùºÏßê
              this.tweens.add({
                targets: bubbleContainer,
                scale: 0,
                alpha: 0,
                duration: 200,
                onComplete: () => bubbleContainer.destroy()
              });

              // ÌÜ±ÎãàÎì§Ïù¥ Îñ®Î¶¨Í∏∞ ÏãúÏûë
              this.shakeSawsBeforeMerge();
            });
          }
        },
        loop: true
      });
    });
  }

  // ÌÜ±ÎãàÎì§ Îñ®Î¶º ÌõÑ Ìï©Ï≤¥
  shakeSawsBeforeMerge() {
    const { width, height } = this.cameras.main;
    const centerX = this.gearTitanPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.gearTitanPosition.y * this.gridSize + this.gridSize / 2 + 60;

    // Î™®Îì† ÌÜ±Îãà Ïª®ÌÖåÏù¥ÎÑà ÏàòÏßë
    const allSawContainers = [];
    this.saws.forEach(saw => {
      if (saw && saw.container && saw.container.active) {
        allSawContainers.push(saw.container);
      }
    });
    this.enhancedSaws.forEach(saw => {
      if (saw && saw.container && saw.container.active) {
        allSawContainers.push(saw.container);
      }
    });

    // ÌÜ±ÎãàÎì§ Îñ®Î¶º Ïï†ÎãàÎ©îÏù¥ÏÖò
    allSawContainers.forEach(container => {
      this.tweens.add({
        targets: container,
        x: container.x + Phaser.Math.Between(-3, 3),
        y: container.y + Phaser.Math.Between(-3, 3),
        duration: 50,
        yoyo: true,
        repeat: 15,
        ease: 'Sine.easeInOut'
      });
    });

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(800, 0.015);

    // Îñ®Î¶º ÌõÑ Ìï©Ï≤¥ ÏãúÏûë
    this.time.delayedCall(900, () => {
      this.animateSawMerge(allSawContainers, centerX, centerY);
    });
  }

  // ÌÜ±Îãà Ìï©Ï≤¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
  animateSawMerge(sawContainers, centerX, centerY) {
    const { width, height } = this.cameras.main;

    // Í∞Å ÌÜ±ÎãàÍ∞Ä Ï§ëÏïôÏúºÎ°ú Îπ®Î†§Îì§Ïñ¥Í∞ê
    let completed = 0;
    const total = sawContainers.length;

    sawContainers.forEach((container, index) => {
      // ÌöåÏ†Ñ Í∞ÄÏÜç
      this.tweens.add({
        targets: container,
        rotation: container.rotation + Math.PI * 8,
        duration: 800,
        ease: 'Quad.easeIn'
      });

      // Ï§ëÏïôÏúºÎ°ú Ïù¥Îèô
      this.tweens.add({
        targets: container,
        x: centerX,
        y: centerY,
        scaleX: 0.3,
        scaleY: 0.3,
        duration: 800,
        delay: index * 50,
        ease: 'Quad.easeIn',
        onComplete: () => {
          // Ìï©Ï≤¥ Ïãú Ïä§ÌååÌÅ¨ Ìö®Í≥º
          const spark = this.add.graphics();
          spark.setDepth(300);
          spark.fillStyle(0xff6600, 1);
          spark.fillCircle(centerX, centerY, 15);
          this.tweens.add({
            targets: spark,
            alpha: 0,
            scaleX: 2,
            scaleY: 2,
            duration: 150,
            onComplete: () => spark.destroy()
          });

          container.destroy();
          completed++;

          // Î™®Îì† ÌÜ±Îãà Ìï©Ï≤¥ ÏôÑÎ£å
          if (completed >= total) {
            this.saws = [];
            this.enhancedSaws = [];
            this.showGearTitanFormation(centerX, centerY);
          }
        }
      });
    });
  }

  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ ÌòïÏÑ± Ïï†ÎãàÎ©îÏù¥ÏÖò
  showGearTitanFormation(centerX, centerY) {
    const { width, height } = this.cameras.main;

    // ÎåÄÌè≠Î∞ú Ìö®Í≥º
    this.cameras.main.shake(500, 0.04);
    this.cameras.main.flash(200, 255, 100, 0);

    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * Math.PI * 2;
      const dist = Phaser.Math.Between(30, 80);
      const particle = this.add.graphics();
      particle.setDepth(301);
      particle.fillStyle(0xff4400, 1);
      particle.fillCircle(0, 0, Phaser.Math.Between(4, 10));
      particle.x = centerX;
      particle.y = centerY;

      this.tweens.add({
        targets: particle,
        x: centerX + Math.cos(angle) * dist,
        y: centerY + Math.sin(angle) * dist,
        alpha: 0,
        duration: 600,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // Î≥¥Ïä§ Îì±Ïû•
    this.time.delayedCall(400, () => {
      this.drawGearTitan();

      // Î≥¥Ïä§ Îì±Ïû• ÌõÑ Î¨¥ÏÑúÏö¥ ÎåÄÏÇ¨ (ÏûêÎßâ Ïä§ÌÉÄÏùº)
      this.time.delayedCall(600, () => {
        this.showGearTitanDialogue("I AM GEAR TITAN... FORGED FROM YOUR FEAR!", () => {
          // Îëê Î≤àÏß∏ ÎåÄÏÇ¨
          this.showGearTitanDialogue("YOUR LITTLE SNAKE WILL BE CRUSHED!", () => {
            // Î±Ä Î∞òÏùë (ÎßêÌíçÏÑ†)
            this.showGearTitanSnakeBubble("Crushed? More like... slithered away!", () => {
              // Ï∞®ÏßÄ ÎåÄÏãú ÌäúÌÜ†Î¶¨Ïñº ÌõÑ Ï†ÑÌà¨ ÏãúÏûë
              this.showChargeDashTutorial(() => {
                this.canChargeDash = true;
                this.gearTitanPhase = 'phase1';
                this.lastAttackPhase = 'phase3'; // phase1Î∂ÄÌÑ∞ ÏãúÏûë
                this.moveTimer.paused = false;
                this.showChargeUI();
                this.advanceGearTitanPhase();
              });
            });
          });
        });
      });
    });
  }

  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î¨¥ÏÑúÏö¥ ÏûêÎßâ ÎåÄÏÇ¨
  showGearTitanDialogue(text, callback) {
    const { width, height } = this.cameras.main;

    // ÌôîÎ©¥ ÌïòÎã® ÏûêÎßâ Ïä§ÌÉÄÏùº
    const subtitleBg = this.add.rectangle(width / 2, height - 60, width, 80, 0x000000, 0.8);
    subtitleBg.setDepth(5100);

    const dialogue = this.add.text(width / 2, height - 60, '', {
      fontSize: '22px',
      fill: '#ff3300',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4,
      shadow: { offsetX: 2, offsetY: 2, color: '#ff0000', blur: 10, fill: true }
    }).setOrigin(0.5).setDepth(5101);

    // Ïπ¥Î©îÎùº ÏïΩÍ∞Ñ ÌùîÎì§Î¶º (ÏúÑÌòëÏ†Å)
    this.cameras.main.shake(200, 0.01);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 30,
      callback: () => {
        dialogue.setText(text.substring(0, charIndex + 1));
        charIndex++;
        if (charIndex >= text.length) {
          typeTimer.destroy();
          this.time.delayedCall(1200, () => {
            this.tweens.add({
              targets: [subtitleBg, dialogue],
              alpha: 0,
              duration: 300,
              onComplete: () => {
                subtitleBg.destroy();
                dialogue.destroy();
                if (callback) callback();
              }
            });
          });
        }
      },
      loop: true
    });
  }

  // Î±Ä ÎßêÌíçÏÑ† ÎåÄÏÇ¨ (Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑÏö© - ÏúÑÌä∏ÏûàÎäî)
  showGearTitanSnakeBubble(text, callback) {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÎßêÌíçÏÑ† Ïª®ÌÖåÏù¥ÎÑà
    const bubbleContainer = this.add.container(headX, headY - 55).setDepth(5001);

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubble = this.add.graphics();
    bubble.fillStyle(0xffffff, 0.95);
    bubble.lineStyle(3, 0x333333, 1);
    bubble.fillRoundedRect(-130, -25, 260, 50, 12);
    bubble.strokeRoundedRect(-130, -25, 260, 50, 12);

    // ÎßêÌíçÏÑ† Íº¨Î¶¨
    bubble.fillStyle(0xffffff, 0.95);
    bubble.fillTriangle(0, 25, -10, 15, 10, 15);
    bubble.lineStyle(3, 0x333333, 1);
    bubble.lineBetween(-10, 17, 0, 28);
    bubble.lineBetween(10, 17, 0, 28);
    bubbleContainer.add(bubble);

    // ÎåÄÏÇ¨ ÌÖçÏä§Ìä∏
    const dialogueText = this.add.text(0, 0, '', {
      fontSize: '13px',
      fill: '#222222',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    bubbleContainer.add(dialogueText);

    // ÎßêÌíçÏÑ† Îì±Ïû•
    bubbleContainer.setScale(0);
    this.tweens.add({
      targets: bubbleContainer,
      scale: 1,
      duration: 200,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    this.time.delayedCall(200, () => {
      const typeTimer = this.time.addEvent({
        delay: 35,
        callback: () => {
          dialogueText.setText(text.substring(0, charIndex + 1));
          charIndex++;
          if (charIndex >= text.length) {
            typeTimer.destroy();
            this.time.delayedCall(1000, () => {
              this.tweens.add({
                targets: bubbleContainer,
                scale: 0,
                alpha: 0,
                duration: 200,
                onComplete: () => {
                  bubbleContainer.destroy();
                  if (callback) callback();
                }
              });
            });
          }
        },
        loop: true
      });
    });
  }

  showGearTitanIntro() {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // ÌôîÎ©¥ Ïñ¥Îë°Í≤å
    const overlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.7);
    overlay.setDepth(4999);

    // WARNING ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2 - 100, 'WARNING!', {
      fontSize: '72px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#660000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(1000, 0.03);

    // WARNING Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: warningText,
      alpha: 1,
      duration: 200,
      yoyo: true,
      repeat: 3,
      onComplete: () => {
        warningText.destroy();

        // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Îì±Ïû•
        this.drawGearTitan();

        // Î≥¥Ïä§ Ïù¥Î¶Ñ ÌëúÏãú
        const bossNameText = this.add.text(width / 2, height / 2 - 150, 'GEAR TITAN', {
          fontSize: '64px',
          fill: '#ffcc00',
          fontStyle: 'bold',
          stroke: '#664400',
          strokeThickness: 6
        }).setOrigin(0.5).setDepth(5001).setAlpha(0);

        this.tweens.add({
          targets: bossNameText,
          alpha: 1,
          scaleX: { from: 2, to: 1 },
          scaleY: { from: 2, to: 1 },
          duration: 500,
          ease: 'Back.easeOut',
          onComplete: () => {
            // ÌäúÌÜ†Î¶¨Ïñº ÌëúÏãú
            this.time.delayedCall(1000, () => {
              this.showChargeDashTutorial(() => {
                // ÌäúÌÜ†Î¶¨Ïñº ÌõÑ Í≤åÏûÑ ÏãúÏûë
                this.tweens.add({
                  targets: [overlay, bossNameText],
                  alpha: 0,
                  duration: 500,
                  onComplete: () => {
                    overlay.destroy();
                    bossNameText.destroy();
                    // Ï∞®ÏßÄ UI ÌëúÏãú
                    this.showChargeUI();
                    // Ï≤´ Î≤àÏß∏ Í≥µÍ≤© Ìå®ÌÑ¥ ÏãúÏûë
                    this.gearTitanPhase = 'phase1';
                    this.lastAttackPhase = 'phase1'; // ÌòÑÏû¨ Í≥µÍ≤© Ìå®ÌÑ¥ Ï†ÄÏû•
                    this.moveTimer.paused = false;
                    this.time.delayedCall(2000, () => {
                      this.gearTitanPhase1Attack();
                    });
                  }
                });
              });
            });
          }
        });
      }
    });
  }

  drawGearTitan() {
    const { width, height } = this.cameras.main;
    const centerX = this.gearTitanPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.gearTitanPosition.y * this.gridSize + this.gridSize / 2 + 60;

    // Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
    this.gearTitanContainer = this.add.container(centerX, centerY);
    this.gearTitanContainer.setDepth(300);
    this.gearTitanContainer.setScale(0);

    // Ïô∏Î∂Ä Í∏∞Ïñ¥Îì§ (4Í∞ú)
    const gearRadius = this.gridSize * 2;
    const gearPositions = [
      { angle: 0, offset: gearRadius * 1.5 },
      { angle: Math.PI / 2, offset: gearRadius * 1.5 },
      { angle: Math.PI, offset: gearRadius * 1.5 },
      { angle: Math.PI * 3 / 2, offset: gearRadius * 1.5 }
    ];

    gearPositions.forEach((pos, idx) => {
      const gear = this.createGear(gearRadius * 0.8, 12, 0x888888);
      gear.x = Math.cos(pos.angle) * pos.offset;
      gear.y = Math.sin(pos.angle) * pos.offset;
      this.gearTitanContainer.add(gear);
      this.gearTitanGears.push(gear);

      // Í∏∞Ïñ¥ ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: gear,
        rotation: (idx % 2 === 0 ? 1 : -1) * Math.PI * 2,
        duration: 3000,
        repeat: -1,
        ease: 'Linear'
      });
    });

    // Ï§ëÏïô ÏΩîÏñ¥ (ÏïΩÏ†ê)
    this.gearTitanCore = this.add.graphics();
    this.gearTitanCore.fillStyle(0x440000, 1);
    this.gearTitanCore.fillCircle(0, 0, gearRadius * 0.8);
    this.gearTitanCore.fillStyle(0xff0000, 1);
    this.gearTitanCore.fillCircle(0, 0, gearRadius * 0.5);
    // Îàà (ÏΩîÏñ¥ Ï§ëÏïô)
    this.gearTitanCore.fillStyle(0x000000, 1);
    this.gearTitanCore.fillCircle(0, 0, gearRadius * 0.2);
    this.gearTitanCore.fillStyle(0xffff00, 1);
    this.gearTitanCore.fillCircle(0, -gearRadius * 0.05, gearRadius * 0.1);
    this.gearTitanContainer.add(this.gearTitanCore);

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: this.gearTitanContainer,
      scaleX: 1,
      scaleY: 1,
      duration: 1000,
      ease: 'Back.easeOut'
    });

    // Ï†ÑÏ≤¥ Ïª®ÌÖåÏù¥ÎÑà ÌöåÏ†Ñ (ÎäêÎ¶¨Í≤å)
    this.gearTitanAnimTimer = this.time.addEvent({
      delay: 50,
      loop: true,
      callback: () => {
        if (this.gearTitanContainer && this.gearTitanContainer.active) {
          this.gearTitanContainer.rotation += 0.005;
        }
      }
    });
  }

  createGear(radius, teethCount, color) {
    const gear = this.add.graphics();
    const outerRadius = radius;
    const innerRadius = radius * 0.7;
    const toothDepth = radius * 0.15;

    // Í∏∞Ïñ¥ Î™∏Ï≤¥
    gear.fillStyle(color, 1);
    gear.beginPath();
    for (let i = 0; i < teethCount; i++) {
      const angle = (i / teethCount) * Math.PI * 2;
      const nextAngle = ((i + 0.5) / teethCount) * Math.PI * 2;
      const toothAngle = ((i + 0.25) / teethCount) * Math.PI * 2;
      const toothAngle2 = ((i + 0.75) / teethCount) * Math.PI * 2;

      if (i === 0) {
        gear.moveTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
      }

      // ÌÜ±Îãà Ïô∏Í≥Ω
      gear.lineTo(Math.cos(toothAngle) * (outerRadius + toothDepth), Math.sin(toothAngle) * (outerRadius + toothDepth));
      gear.lineTo(Math.cos(nextAngle) * outerRadius, Math.sin(nextAngle) * outerRadius);
      gear.lineTo(Math.cos(toothAngle2) * innerRadius, Math.sin(toothAngle2) * innerRadius);
      gear.lineTo(Math.cos((i + 1) / teethCount * Math.PI * 2) * outerRadius, Math.sin((i + 1) / teethCount * Math.PI * 2) * outerRadius);
    }
    gear.closePath();
    gear.fill();

    // Ï§ëÏïô Íµ¨Î©ç
    gear.fillStyle(0x333333, 1);
    gear.fillCircle(0, 0, radius * 0.25);

    return gear;
  }

  // =====================
  // Ï∞®ÏßÄ ÎåÄÏãú ÏãúÏä§ÌÖú
  // =====================

  showChargeDashTutorial(callback) {
    const { width, height } = this.cameras.main;

    // ÌäúÌÜ†Î¶¨Ïñº Ïª®ÌÖåÏù¥ÎÑà
    const tutorialContainer = this.add.container(width / 2, height / 2 + 30).setDepth(5002);

    // Î∞∞Í≤Ω
    const tutorialBg = this.add.rectangle(0, 0, 450, 200, 0x000000, 0.9);
    tutorialBg.setStrokeStyle(3, 0xff8800);
    tutorialContainer.add(tutorialBg);

    // ÌÉÄÏù¥ÌãÄ
    const titleText = this.add.text(0, -70, 'üî• STEAM OVERHEAT SYSTEM üî•', {
      fontSize: '22px',
      fill: '#ff8800',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    tutorialContainer.add(titleText);

    // ÏÑ§Î™Ö
    const tutorialText = this.add.text(0, -20,
      'HOLD SPACE to charge the Steam Gauge\n' +
      'Release in the GREEN ZONE for a PERFECT DASH!\n' +
      '‚ö†Ô∏è Don\'t overheat or you\'ll be STUNNED!', {
      fontSize: '16px',
      fill: '#ffffff',
      fontStyle: 'bold',
      align: 'center',
      lineSpacing: 8
    }).setOrigin(0.5);
    tutorialContainer.add(tutorialText);

    // Ïª¨Îü¨ Í∞ÄÏù¥Îìú
    const guideY = 50;
    const colorGuide = this.add.text(-180, guideY, 'üü° Weak', {
      fontSize: '12px', fill: '#ffcc00'
    });
    tutorialContainer.add(colorGuide);

    const perfectGuide = this.add.text(-60, guideY, 'üü¢ PERFECT!', {
      fontSize: '12px', fill: '#00ff00', fontStyle: 'bold'
    });
    tutorialContainer.add(perfectGuide);

    const strongGuide = this.add.text(50, guideY, 'üü† Strong', {
      fontSize: '12px', fill: '#ff8800'
    });
    tutorialContainer.add(strongGuide);

    const dangerGuide = this.add.text(130, guideY, 'üî¥ DANGER!', {
      fontSize: '12px', fill: '#ff0000'
    });
    tutorialContainer.add(dangerGuide);

    // Ïä§ÌÇµ ÌÖçÏä§Ìä∏
    const skipText = this.add.text(0, 85, 'Press ENTER to continue', {
      fontSize: '14px',
      fill: '#888888'
    }).setOrigin(0.5);
    tutorialContainer.add(skipText);

    // ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: skipText,
      alpha: { from: 1, to: 0.3 },
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    // ÏóîÌÑ∞ ÌÇ§ ÎåÄÍ∏∞
    const enterHandler = this.input.keyboard.once('keydown-ENTER', () => {
      tutorialContainer.destroy();
      if (callback) callback();
    });

    // ÏûêÎèô Ïä§ÌÇµ (6Ï¥à ÌõÑ)
    this.time.delayedCall(6000, () => {
      if (tutorialContainer.active) {
        tutorialContainer.destroy();
        if (callback) callback();
      }
    });
  }

  showChargeUI() {
    const { width, height } = this.cameras.main;

    // SPACE ÌÇ§ Î†àÌçºÎü∞Ïä§ ÏÉùÏÑ± (Ìïú Î≤àÎßå)
    if (!this.chargeSpaceKey) {
      this.chargeSpaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

      // ÎÑ§Ïù¥Ìã∞Î∏å ÌÇ§ ÏÉÅÌÉú Ï∂îÏ†Å (Phaser ÎåÄÏã†)
      this.nativeSpaceDown = false;

      // Phaser keyup
      this.chargeSpaceKey.on('up', () => {
        if (this.isCharging && this.canChargeDash && !this.isDashing) {
          this.releaseCharge();
        }
      });

      // ÎÑ§Ïù¥Ìã∞Î∏å keydown
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          this.nativeSpaceDown = true;
        }
      });

      // ÎÑ§Ïù¥Ìã∞Î∏å keyup (Î∞±ÏóÖ)
      window.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
          this.nativeSpaceDown = false;
          if (this.isCharging && this.canChargeDash && !this.isDashing && this.gearTitanMode) {
            this.releaseCharge();
          }
        }
      });
    }

    // Steam Overheat Í≤åÏù¥ÏßÄ UI
    this.chargeUI = this.add.container(width / 2, height - 60);
    this.chargeUI.setDepth(1000);

    const gaugeWidth = 200;
    const gaugeHeight = 24;

    // Í≤åÏù¥ÏßÄ Î∞∞Í≤Ω (Í≤ÄÏ†ï)
    const gaugeBg = this.add.rectangle(0, 0, gaugeWidth, gaugeHeight, 0x222222, 0.95);
    gaugeBg.setStrokeStyle(3, 0x444444);
    this.chargeUI.add(gaugeBg);

    // ÎÇúÏù¥ÎèÑÏóê Îî∞Î•∏ Ï°¥ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
    const difficulty = this.getSteamDashDifficulty();

    // Ï°¥ ÏòÅÏó≠ ÌëúÏãú (Î∞∞Í≤ΩÏóê ÏÉâÏÉÅ Íµ¨Í∞Ñ)
    // ÏïΩÌïú Íµ¨Í∞Ñ (Îπ®Í∞ï)
    const weakZone = this.add.rectangle(
      -gaugeWidth/2 + gaugeWidth * this.steamPerfectZoneStart / 2,
      0,
      gaugeWidth * this.steamPerfectZoneStart,
      gaugeHeight - 4,
      0x993333, 0.6
    );
    this.chargeUI.add(weakZone);

    // ÌçºÌéôÌä∏ Ï°¥ (Ï¥àÎ°ù) - Ïó¨Í∏∞ÏÑú ÎÜìÏúºÎ©¥ ÏÑ±Í≥µ!
    const perfectZoneWidth = gaugeWidth * (this.steamPerfectZoneEnd - this.steamPerfectZoneStart);
    const perfectZone = this.add.rectangle(
      -gaugeWidth/2 + gaugeWidth * this.steamPerfectZoneStart + perfectZoneWidth / 2,
      0,
      perfectZoneWidth,
      gaugeHeight - 4,
      0x00aa00, 0.8
    );
    this.chargeUI.add(perfectZone);
    this.steamPerfectZoneGraphic = perfectZone;

    // Í∞ïÌïú Íµ¨Í∞Ñ (Ï£ºÌô©)
    const strongZoneWidth = gaugeWidth * (this.steamDangerZoneStart - this.steamPerfectZoneEnd);
    const strongZone = this.add.rectangle(
      -gaugeWidth/2 + gaugeWidth * this.steamPerfectZoneEnd + strongZoneWidth / 2,
      0,
      strongZoneWidth,
      gaugeHeight - 4,
      0xcc6600, 0.6
    );
    this.chargeUI.add(strongZone);

    // ÏúÑÌóò Íµ¨Í∞Ñ (Îπ®Í∞ï + ÎπóÍ∏à)
    const dangerZoneWidth = gaugeWidth * (this.steamOverheatThreshold - this.steamDangerZoneStart);
    const dangerZone = this.add.rectangle(
      -gaugeWidth/2 + gaugeWidth * this.steamDangerZoneStart + dangerZoneWidth / 2,
      0,
      dangerZoneWidth,
      gaugeHeight - 4,
      0xcc0000, 0.7
    );
    this.chargeUI.add(dangerZone);

    // Ïò§Î≤ÑÌûàÌä∏ Íµ¨Í∞Ñ (Í≤ÄÎπ®)
    const overheatZoneWidth = gaugeWidth * (1 - this.steamOverheatThreshold);
    const overheatZone = this.add.rectangle(
      -gaugeWidth/2 + gaugeWidth * this.steamOverheatThreshold + overheatZoneWidth / 2,
      0,
      overheatZoneWidth,
      gaugeHeight - 4,
      0x660000, 0.9
    );
    this.chargeUI.add(overheatZone);

    // Í≤åÏù¥ÏßÄ Ï±ÑÏö∞Í∏∞ Î∞î (Ïã§Ï†ú ÏßÑÌñâ)
    this.chargeGaugeUI = this.add.rectangle(-gaugeWidth/2 + 2, 0, 0, gaugeHeight - 8, 0xffffff, 0.9);
    this.chargeGaugeUI.setOrigin(0, 0.5);
    this.chargeUI.add(this.chargeGaugeUI);

    // Í≤åÏù¥ÏßÄ ÌîÑÎ†àÏûÑ (ÏúÑÏóê Ïò¨Î¶º)
    const gaugeFrame = this.add.rectangle(0, 0, gaugeWidth, gaugeHeight);
    gaugeFrame.setStrokeStyle(3, 0x888888);
    gaugeFrame.setFillStyle(0x000000, 0);
    this.chargeUI.add(gaugeFrame);

    // ÎùºÎ≤®
    const label = this.add.text(0, -25, 'üî• STEAM GAUGE üî•', {
      fontSize: '14px',
      fill: '#ff8800',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5);
    this.chargeUI.add(label);

    // PERFECT ÎùºÎ≤® (ÌçºÌéôÌä∏ Ï°¥ ÏúÑ)
    const perfectLabel = this.add.text(
      -gaugeWidth/2 + gaugeWidth * (this.steamPerfectZoneStart + this.steamPerfectZoneEnd) / 2,
      -42,
      '‚¨á PERFECT ‚¨á',
      {
        fontSize: '10px',
        fill: '#00ff00',
        fontStyle: 'bold'
      }
    ).setOrigin(0.5);
    this.chargeUI.add(perfectLabel);

    // ÌûåÌä∏ ÌÖçÏä§Ìä∏
    const hintText = this.add.text(0, 22, 'HOLD SPACE - Release in GREEN!', {
      fontSize: '11px',
      fill: '#aaaaaa'
    }).setOrigin(0.5);
    this.chargeUI.add(hintText);

    // Ïø®Îã§Ïö¥/ÏÉÅÌÉú ÌÖçÏä§Ìä∏
    this.chargeCooldownText = this.add.text(0, 38, '', {
      fontSize: '12px',
      fill: '#ffcc00',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    this.chargeUI.add(this.chargeCooldownText);

    // Ï†ÄÏû•
    this.steamGaugeWidth = gaugeWidth;
  }

  updateChargeUI(progress) {
    if (!this.chargeGaugeUI || !this.chargeGaugeUI.active) return;

    const maxWidth = this.steamGaugeWidth - 4;
    this.chargeGaugeUI.width = maxWidth * progress;

    // Íµ¨Í∞ÑÏóê Îî∞Î•∏ ÏÉâÏÉÅ Î≥ÄÍ≤Ω
    if (progress >= this.steamOverheatThreshold) {
      // Ïò§Î≤ÑÌûàÌä∏ ÏûÑÎ∞ï - Îπ®Í∞ÑÏÉâ ÍπúÎπ°ÏûÑ
      this.chargeGaugeUI.fillColor = (Date.now() % 200 < 100) ? 0xff0000 : 0xff4444;
    } else if (progress >= this.steamDangerZoneStart) {
      // ÏúÑÌóò Íµ¨Í∞Ñ - Îπ®Í∞ÑÏÉâ
      this.chargeGaugeUI.fillColor = 0xff3300;
    } else if (progress >= this.steamPerfectZoneEnd) {
      // Í∞ïÌïú Íµ¨Í∞Ñ - Ï£ºÌô©ÏÉâ
      this.chargeGaugeUI.fillColor = 0xff8800;
    } else if (progress >= this.steamPerfectZoneStart) {
      // ÌçºÌéôÌä∏ Ï°¥ - Ï¥àÎ°ùÏÉâ + Í∏ÄÎ°úÏö∞
      this.chargeGaugeUI.fillColor = 0x00ff00;
      // ÌçºÌéôÌä∏ Ï°¥ÏóêÏÑúÎäî ÌéÑÏä§ Ìö®Í≥º
      if (this.steamPerfectZoneGraphic && !this.steamPerfectPulsing) {
        this.steamPerfectPulsing = true;
        this.tweens.add({
          targets: this.steamPerfectZoneGraphic,
          scaleY: 1.2,
          duration: 150,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });
      }
    } else {
      // ÏïΩÌïú Íµ¨Í∞Ñ - ÎÖ∏ÎûÄÏÉâ
      this.chargeGaugeUI.fillColor = 0xffcc00;
      // ÌéÑÏä§ Ï§ëÏßÄ
      if (this.steamPerfectPulsing) {
        this.steamPerfectPulsing = false;
        this.tweens.killTweensOf(this.steamPerfectZoneGraphic);
        if (this.steamPerfectZoneGraphic) this.steamPerfectZoneGraphic.setScale(1);
      }
    }
  }

  // ÎÇúÏù¥ÎèÑÏóê Îî∞Î•∏ Ï°¥ ÌÅ¨Í∏∞ Ï°∞Ï†ï (HIT ÏàòÍ∞Ä Ïò¨ÎùºÍ∞àÏàòÎ°ù Ïñ¥Î†§ÏõåÏßê)
  getSteamDashDifficulty() {
    const hitCount = this.gearTitanHitCount || 0;

    // Í∏∞Î≥∏Í∞í
    let perfectStart = 0.35;
    let perfectEnd = 0.55;
    let dangerStart = 0.75;
    let overheatThreshold = 0.95;
    let gaugeDuration = 2500;

    // ÌûàÌä∏ ÏàòÏóê Îî∞Îùº Ï†êÏ†ê Ïñ¥Î†§ÏõåÏßê
    if (hitCount >= 1) {
      perfectStart = 0.38;
      perfectEnd = 0.52;
      dangerStart = 0.72;
      gaugeDuration = 2200;
    }
    if (hitCount >= 2) {
      perfectStart = 0.40;
      perfectEnd = 0.50;
      dangerStart = 0.68;
      gaugeDuration = 2000;
    }
    if (hitCount >= 3) {
      perfectStart = 0.42;
      perfectEnd = 0.48;
      dangerStart = 0.65;
      overheatThreshold = 0.90;
      gaugeDuration = 1800;
    }
    if (hitCount >= 4) {
      perfectStart = 0.43;
      perfectEnd = 0.47;
      dangerStart = 0.62;
      overheatThreshold = 0.88;
      gaugeDuration = 1600;
    }
    if (hitCount >= 5) {
      perfectStart = 0.44;
      perfectEnd = 0.46;
      dangerStart = 0.60;
      overheatThreshold = 0.85;
      gaugeDuration = 1400;
    }

    // Í∞í ÏóÖÎç∞Ïù¥Ìä∏
    this.steamPerfectZoneStart = perfectStart;
    this.steamPerfectZoneEnd = perfectEnd;
    this.steamDangerZoneStart = dangerStart;
    this.steamOverheatThreshold = overheatThreshold;
    this.steamGaugeDuration = gaugeDuration;

    return { perfectStart, perfectEnd, dangerStart, overheatThreshold, gaugeDuration, hitCount };
  }

  handleChargeInput() {
    if (!this.canChargeDash || !this.gearTitanMode || this.gameOver) return;
    if (!this.chargeUI || !this.chargeUI.active) return;
    if (!this.chargeSpaceKey) return;

    const spaceKey = this.chargeSpaceKey;
    const now = Date.now();

    // Ïò§Î≤ÑÌûàÌä∏ ÏÉÅÌÉú Ï≤¥ÌÅ¨ (Í∏∞Ï†à Ï§ë)
    if (this.isOverheated) {
      if (now < this.overheatEndTime) {
        const remaining = Math.ceil((this.overheatEndTime - now) / 1000 * 10) / 10;
        if (this.chargeCooldownText && this.chargeCooldownText.active) {
          this.chargeCooldownText.setText(`üî• OVERHEATED! ${remaining.toFixed(1)}s`);
          this.chargeCooldownText.setColor('#ff0000');
        }
        return;
      } else {
        // Ïò§Î≤ÑÌûàÌä∏ Ï¢ÖÎ£å
        this.isOverheated = false;
        this.overheatEndTime = 0;
        if (this.chargeCooldownText && this.chargeCooldownText.active) {
          this.chargeCooldownText.setText('');
          this.chargeCooldownText.setColor('#ffcc00');
        }
        // Î±Ä ÏÉâÏÉÅ Î≥µÏõê
        this.draw();
      }
    }

    // Ïø®Îã§Ïö¥ Ï≤¥ÌÅ¨
    if (now - this.lastDashTime < this.dashCooldown) {
      const remaining = Math.ceil((this.dashCooldown - (now - this.lastDashTime)) / 1000);
      if (this.chargeCooldownText && this.chargeCooldownText.active) {
        this.chargeCooldownText.setText(`COOLING... ${remaining}s`);
        this.chargeCooldownText.setColor('#00ccff');
      }
      return;
    } else {
      if (this.chargeCooldownText && this.chargeCooldownText.active && !this.isCharging) {
        this.chargeCooldownText.setText('READY!');
        this.chargeCooldownText.setColor('#00ff00');
      }
    }

    // ÎÑ§Ïù¥Ìã∞Î∏å ÌÇ§ ÏÉÅÌÉú ÏÇ¨Ïö©
    const currentSpaceDown = this.nativeSpaceDown || false;
    const wasSpaceDown = this.prevSpaceDown || false;

    // ÌÇ§ ÎàÑÎ¶Ñ Í∞êÏßÄ (false -> true)
    const spacePressed = !wasSpaceDown && currentSpaceDown;
    // ÌÇ§ ÎñºÍ∏∞ Í∞êÏßÄ (true -> false)
    const spaceReleased = wasSpaceDown && !currentSpaceDown;

    // Ïù¥Ï†Ñ ÏÉÅÌÉú Ï†ÄÏû• (ÎåÄÏãú Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå)
    if (!this.isDashing) {
      this.prevSpaceDown = currentSpaceDown;
    }

    // Ï∞®ÏßÄ ÏãúÏûë
    if (spacePressed && !this.isDashing && !this.isOverheated && !this.isCharging) {
      this.startCharging();
    }

    // Ï∞®ÏßÄ Ïú†ÏßÄ
    if (currentSpaceDown && this.isCharging && !this.isDashing) {
      this.updateCharge();
    }

    // Ï∞®ÏßÄ Ìï¥Ï†ú (ÎåÄÏãú Ïã§Ìñâ)
    if (spaceReleased && this.isCharging) {
      this.releaseCharge();
    }
  }

  startCharging() {
    this.isCharging = true;
    this.chargeStartTime = Date.now();
    this.chargeReady = false;
    this.steamDashPower = 'none';

    // Í≥†Î¨¥Ï§Ñ ÏïïÏ∂ï Ìö®Í≥º Ï¥àÍ∏∞Ìôî
    this.chargeCompressionFactor = 1.0;
    this.chargeCompressionGraphics = this.add.graphics().setDepth(101);

    // ÎÇúÏù¥ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ (Îß§ Ï∞®ÏßÄÎßàÎã§ Í∞±Ïã†)
    this.getSteamDashDifficulty();

    // Ï∞®ÏßÄ ÏãúÏûë Ìö®Í≥º
    if (this.chargeUI) {
      this.tweens.add({
        targets: this.chargeUI,
        scaleX: 1.05,
        scaleY: 1.05,
        duration: 100,
        yoyo: true
      });
    }

    // ÏÉÅÌÉú ÌÖçÏä§Ìä∏
    if (this.chargeCooldownText && this.chargeCooldownText.active) {
      this.chargeCooldownText.setText('CHARGING...');
      this.chargeCooldownText.setColor('#ffff00');
    }

    // ÏóêÎÑàÏßÄ Î™®ÏúºÎäî Ïù¥ÌéôÌä∏ ÏãúÏûë
    this.startSteamChargeEffect();
  }

  // Steam Ï∞®ÏßÄ Ïù¥ÌéôÌä∏ (Í∏∞Ï°¥Î≥¥Îã§ Îçî Î∂àÍ∞ôÏùÄ ÎäêÎÇå)
  startSteamChargeEffect() {
    // Í∏∞Ï°¥ Ïù¥ÌéôÌä∏ Ï†ïÎ¶¨
    this.cleanupChargeEnergyEffect();

    // Ïä§ÌåÄ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    this.chargeEffectParticles = [];
    const particleCount = 16;

    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const particle = {
        graphics: this.add.graphics().setDepth(98),
        angle: angle,
        radius: 50 + Phaser.Math.Between(0, 25),
        speed: 0.04 + Math.random() * 0.03,
        size: Phaser.Math.Between(3, 7),
        color: Phaser.Math.RND.pick([0xff6600, 0xff8800, 0xffaa00, 0xff4400, 0xffcc00]),
        alpha: 0.85,
        trail: []
      };
      this.chargeEffectParticles.push(particle);
    }

    // Ïò§Îùº Í∑∏ÎûòÌîΩ ÏÉùÏÑ±
    this.chargeAuraGraphics = this.add.graphics().setDepth(97);

    // 60fps ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    this.chargeEffectTimer = this.time.addEvent({
      delay: 16,
      loop: true,
      callback: () => this.updateSteamChargeEffect()
    });
  }

  // Steam Ï∞®ÏßÄ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
  updateSteamChargeEffect() {
    if (!this.isCharging || this.chargeEffectParticles.length === 0) {
      this.cleanupChargeEnergyEffect();
      return;
    }

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    const elapsed = Date.now() - this.chargeStartTime;
    const progress = Math.min(elapsed / this.steamGaugeDuration, 1);

    // ====== Í≥†Î¨¥Ï§Ñ ÏïïÏ∂ï Ìö®Í≥º (Î±ÄÏù¥ ÍµµÍ≥† ÏßßÏïÑÏßê) ======
    if (this.chargeCompressionGraphics && this.chargeCompressionGraphics.active) {
      this.chargeCompressionGraphics.clear();

      // ÏïïÏ∂ï Ï†ïÎèÑ Í≥ÑÏÇ∞ (progressÏóê Îî∞Îùº Ï†êÏ†ê ÏïïÏ∂ïÎê®)
      // ÌçºÌéôÌä∏ Ï°¥ÏóêÏÑú ÏµúÎåÄ ÏïïÏ∂ï
      let compressionAmount;
      if (progress < this.steamPerfectZoneStart) {
        compressionAmount = progress / this.steamPerfectZoneStart * 0.4; // 0 ~ 0.4
      } else if (progress < this.steamPerfectZoneEnd) {
        compressionAmount = 0.4 + ((progress - this.steamPerfectZoneStart) / (this.steamPerfectZoneEnd - this.steamPerfectZoneStart)) * 0.1; // 0.4 ~ 0.5 (ÏµúÎåÄ)
      } else {
        compressionAmount = 0.5 - ((progress - this.steamPerfectZoneEnd) / (1 - this.steamPerfectZoneEnd)) * 0.1; // Ï°∞Í∏à Ï§ÑÏñ¥Îì¶
      }

      this.chargeCompressionFactor = compressionAmount;

      // Î±Ä Î∞©Ìñ•
      const dir = this.direction;
      const isHorizontal = (dir === 'LEFT' || dir === 'RIGHT');

      // ÏïïÏ∂ïÎêú Î±Ä Í∑∏Î¶¨Í∏∞ (ÏõêÎûò Î±Ä ÏúÑÏóê ÎçÆÏñ¥ÏîåÏõÄ)
      const segmentCount = Math.min(this.snake.length, 6);
      const baseSize = this.gridSize - 2;

      // ÏïïÏ∂ï Ïãú ÎëêÍªò Ï¶ùÍ∞Ä, Í∏∏Ïù¥ Í∞êÏÜå
      const thicknessMultiplier = 1 + compressionAmount * 1.2; // ÏµúÎåÄ 1.6Î∞∞ ÎëêÍ∫ºÏõåÏßê
      const lengthMultiplier = 1 - compressionAmount * 0.6; // ÏµúÎåÄ 0.7Î∞∞Î°ú ÏßßÏïÑÏßê

      // Îñ®Î¶º Ìö®Í≥º (ÏóêÎÑàÏßÄ Ï∂ïÏ†Å ÎäêÎÇå)
      const shakeAmount = compressionAmount * 2;
      const shakeX = (Math.random() - 0.5) * shakeAmount;
      const shakeY = (Math.random() - 0.5) * shakeAmount;

      // Î±Ä ÏÑ∏Í∑∏Î®ºÌä∏Îì§ÏùÑ ÏïïÏ∂ïÎêú ÌòïÌÉúÎ°ú Í∑∏Î¶¨Í∏∞
      for (let i = segmentCount - 1; i >= 0; i--) {
        const seg = this.snake[i];
        if (!seg) continue;

        const segX = seg.x * this.gridSize + this.gridSize / 2 + shakeX;
        const segY = seg.y * this.gridSize + this.gridSize / 2 + 60 + shakeY;

        // ÏÉâÏÉÅ (Î®∏Î¶¨Îäî Î∞ùÏùÄ Ï¥àÎ°ù)
        const segColor = i === 0 ? 0x00ff00 : 0x00aa00;
        const segAlpha = 1;

        // ÏïïÏ∂ïÎêú ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
        let width, height;
        if (isHorizontal) {
          // Í∞ÄÎ°ú Î∞©Ìñ•: Í∞ÄÎ°úÎ°ú ÏßßÏïÑÏßÄÍ≥† ÏÑ∏Î°úÎ°ú ÍµµÏñ¥Ïßê
          width = baseSize * lengthMultiplier;
          height = baseSize * thicknessMultiplier;
        } else {
          // ÏÑ∏Î°ú Î∞©Ìñ•: ÏÑ∏Î°úÎ°ú ÏßßÏïÑÏßÄÍ≥† Í∞ÄÎ°úÎ°ú ÍµµÏñ¥Ïßê
          width = baseSize * thicknessMultiplier;
          height = baseSize * lengthMultiplier;
        }

        // Í∏ÄÎ°úÏö∞ Ìö®Í≥º (ÏóêÎÑàÏßÄ Ï∂ïÏ†Å)
        const glowColor = progress >= this.steamPerfectZoneStart && progress < this.steamPerfectZoneEnd
          ? 0x00ff00 : 0xff8800;
        const glowSize = baseSize * (1 + compressionAmount * 0.5);
        this.chargeCompressionGraphics.fillStyle(glowColor, 0.3 * compressionAmount);
        this.chargeCompressionGraphics.fillCircle(segX, segY, glowSize);

        // Î©îÏù∏ ÏÑ∏Í∑∏Î®ºÌä∏
        this.chargeCompressionGraphics.fillStyle(segColor, segAlpha);
        this.chargeCompressionGraphics.fillEllipse(segX, segY, width, height);

        // Î®∏Î¶¨Îäî Ï∂îÍ∞Ä Í∞ïÏ°∞
        if (i === 0) {
          this.chargeCompressionGraphics.lineStyle(2, 0xffffff, 0.8);
          this.chargeCompressionGraphics.strokeEllipse(segX, segY, width + 2, height + 2);
        }
      }
    }

    // Ïò§Îùº Í∑∏Î¶¨Í∏∞ (Íµ¨Í∞ÑÏóê Îî∞Îùº ÏÉâÏÉÅ Î≥ÄÍ≤Ω)
    if (this.chargeAuraGraphics && this.chargeAuraGraphics.active) {
      this.chargeAuraGraphics.clear();

      let auraColor = 0xff8800; // Í∏∞Î≥∏ Ï£ºÌô©
      let glowIntensity = 0.2 + progress * 0.4;

      if (progress >= this.steamOverheatThreshold) {
        // Ïò§Î≤ÑÌûàÌä∏ ÏûÑÎ∞ï - Í∞ïÎ†¨Ìïú Îπ®Í∞ï + ÍπúÎπ°ÏûÑ
        auraColor = (Date.now() % 150 < 75) ? 0xff0000 : 0xff4400;
        glowIntensity = 0.6;
      } else if (progress >= this.steamDangerZoneStart) {
        // ÏúÑÌóò - Îπ®Í∞ÑÏÉâ
        auraColor = 0xff3300;
        glowIntensity = 0.45;
      } else if (progress >= this.steamPerfectZoneStart && progress < this.steamPerfectZoneEnd) {
        // ÌçºÌéôÌä∏ Ï°¥ - Î∞ùÏùÄ Ï¥àÎ°ù
        auraColor = 0x00ff00;
        glowIntensity = 0.5;
      }

      const auraSize = this.gridSize * (1 + progress * 0.6);
      this.chargeAuraGraphics.fillStyle(auraColor, glowIntensity);
      this.chargeAuraGraphics.fillCircle(headX, headY, auraSize);

      // ÎÇ¥Î∂Ä ÏΩîÏñ¥
      this.chargeAuraGraphics.fillStyle(0xffffff, glowIntensity * 0.4);
      this.chargeAuraGraphics.fillCircle(headX, headY, auraSize * 0.5);

      // ÌçºÌéôÌä∏ Ï°¥ÏóêÏÑúÎäî Ï∂îÍ∞Ä ÎßÅ
      if (progress >= this.steamPerfectZoneStart && progress < this.steamPerfectZoneEnd) {
        const pulseSize = auraSize * 1.3 + Math.sin(Date.now() * 0.015) * 5;
        this.chargeAuraGraphics.lineStyle(3, 0x00ff00, 0.7);
        this.chargeAuraGraphics.strokeCircle(headX, headY, pulseSize);
      }

      // ÏúÑÌóò Íµ¨Í∞ÑÏóêÏÑúÎäî Í≤ΩÍ≥† ÌéÑÏä§
      if (progress >= this.steamDangerZoneStart) {
        const warningPulse = auraSize * 1.5 + Math.sin(Date.now() * 0.02) * 8;
        this.chargeAuraGraphics.lineStyle(2, 0xff0000, 0.5);
        this.chargeAuraGraphics.strokeCircle(headX, headY, warningPulse);
      }
    }

    // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
    this.chargeEffectParticles.forEach((particle, index) => {
      if (!particle.graphics || !particle.graphics.active) return;

      particle.graphics.clear();

      // Î∞òÍ≤ΩÏù¥ Ï†êÏ†ê Ï§ÑÏñ¥Îì¶
      const targetRadius = 55 * (1 - progress * 0.85);
      particle.radius = Phaser.Math.Linear(particle.radius, targetRadius, 0.06);

      // ÌöåÏ†Ñ ÏÜçÎèÑ Ï¶ùÍ∞Ä
      particle.angle += particle.speed * (1 + progress * 3);

      // ÌååÌã∞ÌÅ¥ ÏúÑÏπò
      const px = headX + Math.cos(particle.angle) * particle.radius;
      const py = headY + Math.sin(particle.angle) * particle.radius;

      // ÏúÑÌóò Íµ¨Í∞ÑÏóêÏÑúÎäî ÌååÌã∞ÌÅ¥ ÏÉâÏÉÅ Î≥ÄÍ≤Ω
      let particleColor = particle.color;
      if (progress >= this.steamDangerZoneStart) {
        particleColor = Phaser.Math.RND.pick([0xff0000, 0xff2200, 0xff4400]);
      } else if (progress >= this.steamPerfectZoneStart && progress < this.steamPerfectZoneEnd) {
        particleColor = Phaser.Math.RND.pick([0x00ff00, 0x00ff88, 0x88ff00]);
      }

      // Ìä∏Î†àÏùº Í∏∞Î°ù
      particle.trail.push({ x: px, y: py, color: particleColor });
      if (particle.trail.length > 10) {
        particle.trail.shift();
      }

      // Ìä∏Î†àÏùº Í∑∏Î¶¨Í∏∞
      particle.trail.forEach((point, i) => {
        const trailAlpha = (i / particle.trail.length) * particle.alpha * 0.5;
        const trailSize = particle.size * (i / particle.trail.length);
        particle.graphics.fillStyle(point.color, trailAlpha);
        particle.graphics.fillCircle(point.x, point.y, trailSize);
      });

      // Î©îÏù∏ ÌååÌã∞ÌÅ¥
      particle.graphics.fillStyle(particleColor, particle.alpha);
      particle.graphics.fillCircle(px, py, particle.size);
    });
  }

  // Ï∞®ÏßÄ ÏóêÎÑàÏßÄ Ïù¥ÌéôÌä∏ ÏãúÏûë
  startChargeEnergyEffect() {
    // Í∏∞Ï°¥ Ïù¥ÌéôÌä∏ Ï†ïÎ¶¨
    this.cleanupChargeEnergyEffect();

    // ÏóêÎÑàÏßÄ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    this.chargeEffectParticles = [];
    const particleCount = 12;

    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const particle = {
        graphics: this.add.graphics().setDepth(98),
        angle: angle,
        radius: 60 + Phaser.Math.Between(0, 20),
        speed: 0.03 + Math.random() * 0.02,
        size: Phaser.Math.Between(3, 6),
        color: Phaser.Math.RND.pick([0x00ffff, 0x00ff88, 0xffff00, 0xff8800]),
        alpha: 0.8,
        trail: []
      };
      this.chargeEffectParticles.push(particle);
    }

    // Ïò§Îùº Í∑∏ÎûòÌîΩ ÏÉùÏÑ±
    this.chargeAuraGraphics = this.add.graphics().setDepth(97);

    // 60fps ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    this.chargeEffectTimer = this.time.addEvent({
      delay: 16,
      loop: true,
      callback: () => this.updateChargeEnergyEffect()
    });
  }

  // Ï∞®ÏßÄ ÏóêÎÑàÏßÄ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
  updateChargeEnergyEffect() {
    if (!this.isCharging || this.chargeEffectParticles.length === 0) {
      this.cleanupChargeEnergyEffect();
      return;
    }

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    const elapsed = Date.now() - this.chargeStartTime;
    const progress = Math.min(elapsed / this.chargeDuration, 1);

    // Ïò§Îùº Í∑∏Î¶¨Í∏∞
    if (this.chargeAuraGraphics && this.chargeAuraGraphics.active) {
      this.chargeAuraGraphics.clear();

      // Î∞∞Í≤Ω Ïò§Îùº (Ï†êÏ†ê Î∞ùÏïÑÏßê)
      const auraAlpha = 0.1 + progress * 0.3;
      const auraSize = this.gridSize * (1 + progress * 0.5);
      this.chargeAuraGraphics.fillStyle(0x00ffff, auraAlpha);
      this.chargeAuraGraphics.fillCircle(headX, headY, auraSize);

      // ÎÇ¥Î∂Ä Í∏ÄÎ°úÏö∞
      this.chargeAuraGraphics.fillStyle(0xffffff, auraAlpha * 0.5);
      this.chargeAuraGraphics.fillCircle(headX, headY, auraSize * 0.6);

      // Ï∞®ÏßÄ ÏôÑÎ£å Ïãú ÌéÑÏä§
      if (progress >= 1) {
        const pulseSize = auraSize + Math.sin(Date.now() * 0.01) * 5;
        this.chargeAuraGraphics.lineStyle(3, 0xffff00, 0.8);
        this.chargeAuraGraphics.strokeCircle(headX, headY, pulseSize);
      }
    }

    // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
    this.chargeEffectParticles.forEach((particle, index) => {
      if (!particle.graphics || !particle.graphics.active) return;

      particle.graphics.clear();

      // Î∞òÍ≤ΩÏù¥ Ï†êÏ†ê Ï§ÑÏñ¥Îì¶ (ÏóêÎÑàÏßÄÍ∞Ä Î™®ÏûÑ)
      const targetRadius = 60 * (1 - progress * 0.9);
      particle.radius = Phaser.Math.Linear(particle.radius, targetRadius, 0.05);

      // ÌöåÏ†Ñ
      particle.angle += particle.speed * (1 + progress * 2);

      // ÌååÌã∞ÌÅ¥ ÏúÑÏπò Í≥ÑÏÇ∞
      const px = headX + Math.cos(particle.angle) * particle.radius;
      const py = headY + Math.sin(particle.angle) * particle.radius;

      // Ìä∏Î†àÏùº Í∏∞Î°ù
      particle.trail.push({ x: px, y: py });
      if (particle.trail.length > 8) {
        particle.trail.shift();
      }

      // Ìä∏Î†àÏùº Í∑∏Î¶¨Í∏∞
      particle.trail.forEach((point, i) => {
        const trailAlpha = (i / particle.trail.length) * particle.alpha * 0.5;
        const trailSize = particle.size * (i / particle.trail.length);
        particle.graphics.fillStyle(particle.color, trailAlpha);
        particle.graphics.fillCircle(point.x, point.y, trailSize);
      });

      // Î©îÏù∏ ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞
      particle.graphics.fillStyle(particle.color, particle.alpha);
      particle.graphics.fillCircle(px, py, particle.size);

      // Í∏ÄÎ°úÏö∞
      particle.graphics.fillStyle(0xffffff, particle.alpha * 0.5);
      particle.graphics.fillCircle(px, py, particle.size * 0.5);

      // Ï∞®ÏßÄ ÏôÑÎ£å Ïãú Ï†ÑÍ∏∞ Ïä§ÌååÌÅ¨ Ìö®Í≥º
      if (progress >= 1 && Math.random() < 0.1) {
        const sparkAngle = Math.random() * Math.PI * 2;
        const sparkDist = Phaser.Math.Between(5, 15);
        particle.graphics.lineStyle(1, 0xffff00, 0.8);
        particle.graphics.lineBetween(
          px, py,
          px + Math.cos(sparkAngle) * sparkDist,
          py + Math.sin(sparkAngle) * sparkDist
        );
      }
    });
  }

  // Ï∞®ÏßÄ ÏóêÎÑàÏßÄ Ïù¥ÌéôÌä∏ Ï†ïÎ¶¨
  cleanupChargeEnergyEffect() {
    if (this.chargeEffectTimer) {
      this.chargeEffectTimer.remove();
      this.chargeEffectTimer = null;
    }

    this.chargeEffectParticles.forEach(particle => {
      if (particle.graphics && particle.graphics.active) {
        particle.graphics.destroy();
      }
    });
    this.chargeEffectParticles = [];

    if (this.chargeAuraGraphics && this.chargeAuraGraphics.active) {
      this.chargeAuraGraphics.destroy();
      this.chargeAuraGraphics = null;
    }

    // ÏïïÏ∂ï Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨
    if (this.chargeCompressionGraphics && this.chargeCompressionGraphics.active) {
      this.chargeCompressionGraphics.destroy();
      this.chargeCompressionGraphics = null;
    }
    this.chargeCompressionFactor = 0;
  }

  updateCharge() {
    if (!this.isCharging) return;

    const elapsed = Date.now() - this.chargeStartTime;
    const progress = Math.min(elapsed / this.steamGaugeDuration, 1);
    this.updateChargeUI(progress);

    // ÌòÑÏû¨ Íµ¨Í∞Ñ Í≤∞Ï†ï
    if (progress >= this.steamPerfectZoneStart && progress < this.steamPerfectZoneEnd) {
      this.steamDashPower = 'perfect';
      this.chargeReady = true;
    } else if (progress >= this.steamPerfectZoneEnd && progress < this.steamDangerZoneStart) {
      this.steamDashPower = 'strong';
      this.chargeReady = true;
    } else if (progress >= this.steamDangerZoneStart && progress < this.steamOverheatThreshold) {
      this.steamDashPower = 'weak'; // ÏúÑÌóò Íµ¨Í∞ÑÏóêÏÑúÎäî ÏïΩÌïú ÎåÄÏãú
      this.chargeReady = true;
    } else if (progress < this.steamPerfectZoneStart) {
      this.steamDashPower = 'weak';
      this.chargeReady = true;
    }

    // Ïò§Î≤ÑÌûàÌä∏ Ï≤¥ÌÅ¨ (Í≤åÏù¥ÏßÄÍ∞Ä ÎÅùÍπåÏßÄ Ï∞ºÏùÑ Îïå)
    if (progress >= 1) {
      this.triggerOverheat();
    }
  }

  showChargeReadyEffect() {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // Ïπ¥Î©îÎùº ÌéÑÏä§ Ìö®Í≥º
    this.cameras.main.flash(100, 255, 255, 0, true);

    // READY ÌÖçÏä§Ìä∏ (Î±Ä Î®∏Î¶¨ ÏúÑ)
    const readyText = this.add.text(headX, headY - 40, 'READY!', {
      fontSize: '18px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(1001);

    this.tweens.add({
      targets: readyText,
      y: headY - 60,
      alpha: { from: 1, to: 0 },
      scaleX: 1.5,
      scaleY: 1.5,
      duration: 800,
      ease: 'Power2',
      onComplete: () => readyText.destroy()
    });

    // Ìè≠Î∞ú ÎßÅ Ìö®Í≥º
    const ring = this.add.graphics().setDepth(99);
    ring.lineStyle(4, 0xffff00, 1);
    ring.strokeCircle(headX, headY, 10);

    this.tweens.add({
      targets: ring,
      scaleX: 4,
      scaleY: 4,
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => ring.destroy()
    });

    // ÏóêÎÑàÏßÄ Î∞©Ï∂ú ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const spark = this.add.graphics().setDepth(99);
      spark.fillStyle(0xffff00, 1);
      spark.fillCircle(0, 0, 4);
      spark.x = headX;
      spark.y = headY;

      this.tweens.add({
        targets: spark,
        x: headX + Math.cos(angle) * 40,
        y: headY + Math.sin(angle) * 40,
        alpha: 0,
        scaleX: 0.5,
        scaleY: 0.5,
        duration: 300,
        ease: 'Power2',
        onComplete: () => spark.destroy()
      });
    }
  }

  releaseCharge() {
    // Ïò§Î≤ÑÌûàÌä∏ ÏÉÅÌÉúÎ©¥ Ï∞®ÏßÄ Ìï¥Ï†úÎßå
    if (this.isOverheated) {
      this.isCharging = false;
      this.chargeReady = false;
      this.steamDashPower = 'none';
      this.updateChargeUI(0);
      this.cleanupChargeEnergyEffect();
      return;
    }

    const elapsed = Date.now() - this.chargeStartTime;
    const progress = Math.min(elapsed / this.steamGaugeDuration, 1);

    // Íµ¨Í∞ÑÎ≥Ñ Ï≤òÎ¶¨
    if (progress >= this.steamPerfectZoneStart && progress < this.steamPerfectZoneEnd) {
      // ÌçºÌéôÌä∏ Ï°¥ÏóêÏÑú ÎÜìÏùå! - Í∞ïÎ†•Ìïú Steam Dash!
      this.steamDashPower = 'perfect';
      this.showPerfectReleaseEffect();
      this.performSteamDash('perfect');
    } else if (progress >= this.steamPerfectZoneEnd && progress < this.steamDangerZoneStart) {
      // Í∞ïÌïú Íµ¨Í∞Ñ - Í¥úÏ∞ÆÏùÄ ÎåÄÏãú
      this.steamDashPower = 'strong';
      this.showStrongReleaseEffect();
      this.performSteamDash('strong');
    } else if (progress >= this.steamDangerZoneStart) {
      // ÏúÑÌóò Íµ¨Í∞Ñ - ÏïΩÌïú ÎåÄÏãú (Ïò§Î≤ÑÌûàÌä∏ ÏßÅÏ†ÑÏóê ÎÜìÏùÄ Í≤É)
      this.steamDashPower = 'weak';
      this.showWeakReleaseEffect();
      this.performSteamDash('weak');
    } else if (progress >= 0.1) {
      // ÎÑàÎ¨¥ ÏùºÏ∞ç ÎÜìÏùå - ÏïÑÏ£º ÏïΩÌïú ÎåÄÏãú
      this.steamDashPower = 'weak';
      this.showWeakReleaseEffect();
      this.performSteamDash('weak');
    } else {
      // Í±∞Ïùò Ïïà ÎàåÎ†ÄÏùå - ÎåÄÏãú Ïã§Ìå®
      this.showDashFailedEffect();
    }

    this.isCharging = false;
    this.chargeReady = false;
    this.updateChargeUI(0);

    // ÌéÑÏä§ Ïù¥ÌéôÌä∏ Ï†ïÎ¶¨
    if (this.steamPerfectPulsing) {
      this.steamPerfectPulsing = false;
      this.tweens.killTweensOf(this.steamPerfectZoneGraphic);
      if (this.steamPerfectZoneGraphic) this.steamPerfectZoneGraphic.setScale(1);
    }

    // ÏóêÎÑàÏßÄ Ïù¥ÌéôÌä∏ Ï†ïÎ¶¨
    this.cleanupChargeEnergyEffect();
  }

  // Ïò§Î≤ÑÌûàÌä∏ Î∞úÎèô!
  triggerOverheat() {
    if (this.isOverheated) return; // Ïù¥ÎØ∏ Ïò§Î≤ÑÌûàÌä∏ ÏÉÅÌÉú

    this.isOverheated = true;
    this.overheatEndTime = Date.now() + this.overheatStunDuration;
    this.isCharging = false;
    this.chargeReady = false;
    this.steamDashPower = 'none';

    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÌôîÎ©¥ Îπ®Í∞Ñ ÌîåÎûòÏãú
    this.cameras.main.flash(300, 255, 0, 0, true);
    this.cameras.main.shake(500, 0.03);

    // OVERHEAT! ÌÖçÏä§Ìä∏
    const overheatText = this.add.text(headX, headY - 50, 'üî• OVERHEAT! üî•', {
      fontSize: '24px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#660000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5010);

    this.tweens.add({
      targets: overheatText,
      y: headY - 80,
      alpha: { from: 1, to: 0 },
      scaleX: 1.5,
      scaleY: 1.5,
      duration: 1000,
      ease: 'Power2',
      onComplete: () => overheatText.destroy()
    });

    // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      const spark = this.add.graphics().setDepth(99);
      spark.fillStyle(Phaser.Math.RND.pick([0xff0000, 0xff4400, 0xff8800]), 1);
      spark.fillCircle(0, 0, Phaser.Math.Between(4, 8));
      spark.x = headX;
      spark.y = headY;

      this.tweens.add({
        targets: spark,
        x: headX + Math.cos(angle) * Phaser.Math.Between(40, 80),
        y: headY + Math.sin(angle) * Phaser.Math.Between(40, 80),
        alpha: 0,
        duration: 500,
        ease: 'Power2',
        onComplete: () => spark.destroy()
      });
    }

    // Î±Ä ÏÜçÎèÑ ÏùºÏãúÏ†Å Ï†ÄÌïò (ÎäêÎ†§Ïßê)
    if (this.moveTimer) {
      const originalDelay = this.moveTimer.delay;
      this.moveTimer.delay = originalDelay * 1.5; // 50% ÎäêÎ†§Ïßê

      // Ïò§Î≤ÑÌûàÌä∏ Ï¢ÖÎ£å ÌõÑ Î≥µÍµ¨
      this.time.delayedCall(this.overheatStunDuration, () => {
        if (this.moveTimer) {
          this.moveTimer.delay = originalDelay;
        }
      });
    }

    // UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updateChargeUI(0);
    this.cleanupChargeEnergyEffect();
  }

  // ÌçºÌéôÌä∏ Î¶¥Î¶¨Ï¶à Ïù¥ÌéôÌä∏
  showPerfectReleaseEffect() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // Ï¥àÎ°ùÏÉâ Ìè≠Î∞ú ÎßÅ
    for (let i = 0; i < 3; i++) {
      const ring = this.add.graphics().setDepth(100);
      ring.lineStyle(4 - i, 0x00ff00, 1);
      ring.strokeCircle(headX, headY, 10);

      this.tweens.add({
        targets: ring,
        scaleX: 5 + i * 2,
        scaleY: 5 + i * 2,
        alpha: 0,
        duration: 400,
        delay: i * 80,
        onComplete: () => ring.destroy()
      });
    }

    // PERFECT! ÌÖçÏä§Ìä∏
    const perfectText = this.add.text(headX, headY - 50, '‚ö° PERFECT! ‚ö°', {
      fontSize: '22px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#004400',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5010);

    this.tweens.add({
      targets: perfectText,
      y: headY - 80,
      alpha: { from: 1, to: 0 },
      scaleX: 1.3,
      scaleY: 1.3,
      duration: 800,
      ease: 'Power2',
      onComplete: () => perfectText.destroy()
    });

    // Ïπ¥Î©îÎùº Ìö®Í≥º
    this.cameras.main.flash(100, 0, 255, 0, true);
  }

  // Í∞ïÌïú Î¶¥Î¶¨Ï¶à Ïù¥ÌéôÌä∏
  showStrongReleaseEffect() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // Ï£ºÌô©ÏÉâ ÎßÅ
    const ring = this.add.graphics().setDepth(100);
    ring.lineStyle(3, 0xff8800, 1);
    ring.strokeCircle(headX, headY, 10);

    this.tweens.add({
      targets: ring,
      scaleX: 4,
      scaleY: 4,
      alpha: 0,
      duration: 300,
      onComplete: () => ring.destroy()
    });

    // GOOD! ÌÖçÏä§Ìä∏
    const goodText = this.add.text(headX, headY - 40, 'GOOD!', {
      fontSize: '18px',
      fill: '#ff8800',
      fontStyle: 'bold',
      stroke: '#442200',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(5010);

    this.tweens.add({
      targets: goodText,
      y: headY - 60,
      alpha: 0,
      duration: 600,
      onComplete: () => goodText.destroy()
    });
  }

  // ÏïΩÌïú Î¶¥Î¶¨Ï¶à Ïù¥ÌéôÌä∏
  showWeakReleaseEffect() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÏûëÏùÄ ÌöåÏÉâ ÎßÅ
    const ring = this.add.graphics().setDepth(100);
    ring.lineStyle(2, 0x888888, 0.7);
    ring.strokeCircle(headX, headY, 8);

    this.tweens.add({
      targets: ring,
      scaleX: 2,
      scaleY: 2,
      alpha: 0,
      duration: 200,
      onComplete: () => ring.destroy()
    });

    // WEAK ÌÖçÏä§Ìä∏
    const weakText = this.add.text(headX, headY - 35, 'WEAK...', {
      fontSize: '14px',
      fill: '#888888',
      fontStyle: 'italic'
    }).setOrigin(0.5).setDepth(5010);

    this.tweens.add({
      targets: weakText,
      y: headY - 50,
      alpha: 0,
      duration: 400,
      onComplete: () => weakText.destroy()
    });
  }

  // ÎåÄÏãú Ïã§Ìå® Ïù¥ÌéôÌä∏
  showDashFailedEffect() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    const failText = this.add.text(headX, headY - 30, 'TOO SHORT!', {
      fontSize: '12px',
      fill: '#ff4444'
    }).setOrigin(0.5).setDepth(5010);

    this.tweens.add({
      targets: failText,
      alpha: 0,
      y: headY - 45,
      duration: 400,
      onComplete: () => failText.destroy()
    });
  }

  // Steam Dash Ïã§Ìñâ (ÌååÏõå Î†àÎ≤®Ïóê Îî∞Îùº Îã§Î•∏ Ìö®Í≥º)
  performSteamDash(power) {
    if (this.isDashing) return;

    this.isDashing = true;
    this.isInvincible = true;
    this.lastDashTime = Date.now();

    const head = this.snake[0];
    const dir = this.direction;
    const startPos = { x: head.x, y: head.y };

    // ÌååÏõåÏóê Îî∞Î•∏ ÎåÄÏãú Í±∞Î¶¨ Î∞è ÏÜçÎèÑ
    let dashDist, canHitBoss, dashDuration;
    switch (power) {
      case 'perfect':
        dashDist = 8;
        canHitBoss = true;
        dashDuration = 100; // Îπ†Î¶Ñ!
        break;
      case 'strong':
        dashDist = 6;
        canHitBoss = true;
        dashDuration = 130;
        break;
      case 'weak':
      default:
        dashDist = 3;
        canHitBoss = false;
        dashDuration = 160;
        break;
    }

    // Î∞©Ìñ• Î≤°ÌÑ∞
    const dirVectors = {
      'UP': { dx: 0, dy: -1 },
      'DOWN': { dx: 0, dy: 1 },
      'LEFT': { dx: -1, dy: 0 },
      'RIGHT': { dx: 1, dy: 0 }
    };
    const vec = dirVectors[dir];
    const isHorizontal = (dir === 'LEFT' || dir === 'RIGHT');

    const oppositeDir = {
      'UP': 'DOWN',
      'DOWN': 'UP',
      'LEFT': 'RIGHT',
      'RIGHT': 'LEFT'
    };

    // ÎåÄÏãú Í≤ΩÎ°ú Í≥ÑÏÇ∞
    const maxSteps = this.gearTitanMode && this.gearTitanPosition
      ? Math.max(dashDist, Math.abs(head.x - this.gearTitanPosition.x) + Math.abs(head.y - this.gearTitanPosition.y))
      : dashDist;

    const pathPositions = [];
    let maxTravel = 0;
    for (let i = 1; i <= maxSteps; i++) {
      const testX = head.x + vec.dx * i;
      const testY = head.y + vec.dy * i;
      if (testX < 0 || testX >= this.cols || testY < 0 || testY >= this.rows) break;
      pathPositions.push({ x: testX, y: testY });
      maxTravel = i;
    }

    if (maxTravel <= 0) {
      this.isDashing = false;
      this.isInvincible = false;
      return;
    }

    const actualDashDist = Math.min(dashDist, maxTravel);

    // Î≥¥Ïä§ Ï∂©Îèå ÌåêÏ†ï
    const alignedWithCore = this.gearTitanMode && this.gearTitanPosition && (
      (vec.dx !== 0 && head.y === this.gearTitanPosition.y) ||
      (vec.dy !== 0 && head.x === this.gearTitanPosition.x)
    );
    let hitBoss = false;
    if (this.gearTitanMode && this.gearTitanPosition && canHitBoss) {
      const distToCore = Math.abs(head.x - this.gearTitanPosition.x) + Math.abs(head.y - this.gearTitanPosition.y);
      if (alignedWithCore && distToCore <= actualDashDist) hitBoss = true;
    }

    // Í≤åÏûÑ Ìã± Î©àÏ∂§
    if (this.moveTimer) this.moveTimer.paused = true;

    // Ï¢åÌëú Í≥ÑÏÇ∞
    const startPixelX = head.x * this.gridSize + this.gridSize / 2;
    const startPixelY = head.y * this.gridSize + this.gridSize / 2 + 60;
    const newHead = pathPositions[actualDashDist - 1];
    const endPixelX = newHead.x * this.gridSize + this.gridSize / 2;
    const endPixelY = newHead.y * this.gridSize + this.gridSize / 2 + 60;
    const returnDir = oppositeDir[dir];

    // ÌååÏõåÎ≥Ñ ÏÉâÏÉÅ
    let dashColor;
    switch (power) {
      case 'perfect': dashColor = 0x00ff00; break;
      case 'strong': dashColor = 0xff8800; break;
      default: dashColor = 0xaaaaaa;
    }

    // ÏõêÎûò Î±Ä Ïà®Í∏∞Í∏∞
    this.dashingHideSnake = true;
    this.draw();

    // ====== Í≥†Î¨¥Ï§Ñ ÌäïÍπÄ ÎåÄÏãú Ïï†ÎãàÎ©îÏù¥ÏÖò ======
    const dashGraphics = this.add.graphics().setDepth(200);
    const trailGraphics = this.add.graphics().setDepth(199);

    // Î±Ä ÏÑ∏Í∑∏Î®ºÌä∏ Ïàò (ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú ÌëúÌòÑÌï† Í∞úÏàò)
    const segmentCount = Math.min(this.snake.length, 8);
    const segSize = this.gridSize - 2;

    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÉÅÌÉú
    const anim = {
      progress: 0,
      stretch: 0  // ÎäòÏñ¥ÎÇ® Ï†ïÎèÑ
    };

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    const shakeIntensity = power === 'perfect' ? 0.025 : (power === 'strong' ? 0.018 : 0.01);
    this.cameras.main.shake(80, shakeIntensity);

    // Í≥†Î¨¥Ï§Ñ ÌäïÍπÄ Í∑∏Î¶¨Í∏∞ Ìï®Ïàò
    const drawRubberBandSnake = () => {
      dashGraphics.clear();
      trailGraphics.clear();

      const t = anim.progress;

      // ÌòÑÏû¨ Î®∏Î¶¨ ÏúÑÏπò (ÏãúÏûë ‚Üí ÎÅùÏúºÎ°ú Ïù¥Îèô)
      const currentX = startPixelX + (endPixelX - startPixelX) * t;
      const currentY = startPixelY + (endPixelY - startPixelY) * t;

      // ÎäòÏñ¥ÎÇ® Ìö®Í≥º: Ï¥àÎ∞òÏóê ÎäòÏñ¥ÎÇ¨Îã§Í∞Ä ÎèÑÏ∞© Ïãú Î≥µÍµ¨
      // 0~0.3: Îπ†Î•¥Í≤å ÎäòÏñ¥ÎÇ®, 0.3~1.0: Ï†êÏ†ê Î≥µÍµ¨
      let stretchFactor;
      if (t < 0.3) {
        stretchFactor = 1 + (t / 0.3) * 2.5; // ÏµúÎåÄ 3.5Î∞∞ÍπåÏßÄ ÎäòÏñ¥ÎÇ®
      } else {
        stretchFactor = 3.5 - ((t - 0.3) / 0.7) * 2.5; // Îã§Ïãú 1Î∞∞Î°ú Î≥µÍµ¨
      }

      // ÎëêÍªò Ìö®Í≥º: ÎäòÏñ¥ÎÇ†ÏàòÎ°ù Í∞ÄÎäòÏñ¥Ïßê
      const thicknessFactor = 1 / Math.sqrt(stretchFactor);

      // Ìä∏Î†àÏùº Ìö®Í≥º (ÏûîÏÉÅ)
      const trailCount = 6;
      for (let i = 0; i < trailCount; i++) {
        const trailT = Math.max(0, t - (i * 0.08));
        const trailX = startPixelX + (endPixelX - startPixelX) * trailT;
        const trailY = startPixelY + (endPixelY - startPixelY) * trailT;
        const trailAlpha = (1 - i / trailCount) * 0.3;
        const trailSize = segSize * thicknessFactor * (1 - i * 0.1);

        trailGraphics.fillStyle(dashColor, trailAlpha);
        if (isHorizontal) {
          trailGraphics.fillEllipse(trailX, trailY, trailSize * 1.5, trailSize * 0.7);
        } else {
          trailGraphics.fillEllipse(trailX, trailY, trailSize * 0.7, trailSize * 1.5);
        }
      }

      // Î±Ä Î™∏ÌÜµ Í∑∏Î¶¨Í∏∞ (ÎäòÏñ¥ÎÇú ÌòïÌÉú)
      for (let i = segmentCount - 1; i >= 0; i--) {
        // Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏ ÏúÑÏπò Í≥ÑÏÇ∞ (Îí§Ï™ΩÏùÄ ÏãúÏûëÏ†êÏóê Í∞ÄÍπùÍ≤å, ÏïûÏ™ΩÏùÄ ÌòÑÏû¨ ÏúÑÏπòÏóê Í∞ÄÍπùÍ≤å)
        const segT = i / segmentCount;
        const lagFactor = Math.pow(segT, 0.5); // Îí§Ï™Ω ÏÑ∏Í∑∏Î®ºÌä∏Îäî Îçî Îä¶Í≤å Îî∞ÎùºÏò¥

        const segProgress = Math.max(0, t - lagFactor * 0.3);
        const segX = startPixelX + (endPixelX - startPixelX) * segProgress;
        const segY = startPixelY + (endPixelY - startPixelY) * segProgress;

        // ÏÑ∏Í∑∏Î®ºÌä∏ ÌÅ¨Í∏∞ (ÏïûÏ™ΩÏù¥ Îçî ÌÅ¨Í≥†, ÎäòÏñ¥ÎÇ†ÏàòÎ°ù Í∞ÄÎäòÏñ¥Ïßê)
        const sizeMultiplier = 1 - (i * 0.08);
        const segWidth = segSize * thicknessFactor * sizeMultiplier;
        const segHeight = segSize * thicknessFactor * sizeMultiplier;

        // ÏÉâÏÉÅ (Î®∏Î¶¨Îäî Î∞ùÏùÄ Ï¥àÎ°ù, Îí§Î°ú Í∞àÏàòÎ°ù Ïñ¥ÎëêÏõåÏßê)
        const brightness = 1 - (i * 0.1);
        const segColor = i === 0 ? 0x00ff00 : Phaser.Display.Color.ValueToColor(0x00aa00).darken(i * 8).color;

        dashGraphics.fillStyle(segColor, 1);

        // Î∞©Ìñ•Ïóê Îî∞Îùº ÎäòÏñ¥ÎÇú ÌÉÄÏõêÌòïÏúºÎ°ú Í∑∏Î¶¨Í∏∞
        if (isHorizontal) {
          // Í∞ÄÎ°ú Î∞©Ìñ•: Í∞ÄÎ°úÎ°ú Í∏∏Í≤å ÎäòÏñ¥ÎÇ®
          const stretchedWidth = segWidth * (1 + (stretchFactor - 1) * 0.5);
          const stretchedHeight = segHeight * thicknessFactor;
          dashGraphics.fillEllipse(segX, segY, stretchedWidth, stretchedHeight);
        } else {
          // ÏÑ∏Î°ú Î∞©Ìñ•: ÏÑ∏Î°úÎ°ú Í∏∏Í≤å ÎäòÏñ¥ÎÇ®
          const stretchedWidth = segWidth * thicknessFactor;
          const stretchedHeight = segHeight * (1 + (stretchFactor - 1) * 0.5);
          dashGraphics.fillEllipse(segX, segY, stretchedWidth, stretchedHeight);
        }
      }

      // Î®∏Î¶¨ Í∞ïÏ°∞ (ÌôîÏÇ¥Ìëú + Í∏ÄÎ°úÏö∞)
      const headGlowSize = segSize * 1.5;
      dashGraphics.fillStyle(dashColor, 0.4);
      dashGraphics.fillCircle(currentX, currentY, headGlowSize);

      // Î®∏Î¶¨ ÌôîÏÇ¥Ìëú
      dashGraphics.fillStyle(0x00ff00, 1);
      const arrowSize = segSize * 0.6;
      dashGraphics.beginPath();
      switch (dir) {
        case 'RIGHT':
          dashGraphics.moveTo(currentX + arrowSize, currentY);
          dashGraphics.lineTo(currentX - arrowSize * 0.5, currentY - arrowSize * 0.8);
          dashGraphics.lineTo(currentX - arrowSize * 0.5, currentY + arrowSize * 0.8);
          break;
        case 'LEFT':
          dashGraphics.moveTo(currentX - arrowSize, currentY);
          dashGraphics.lineTo(currentX + arrowSize * 0.5, currentY - arrowSize * 0.8);
          dashGraphics.lineTo(currentX + arrowSize * 0.5, currentY + arrowSize * 0.8);
          break;
        case 'UP':
          dashGraphics.moveTo(currentX, currentY - arrowSize);
          dashGraphics.lineTo(currentX - arrowSize * 0.8, currentY + arrowSize * 0.5);
          dashGraphics.lineTo(currentX + arrowSize * 0.8, currentY + arrowSize * 0.5);
          break;
        case 'DOWN':
          dashGraphics.moveTo(currentX, currentY + arrowSize);
          dashGraphics.lineTo(currentX - arrowSize * 0.8, currentY - arrowSize * 0.5);
          dashGraphics.lineTo(currentX + arrowSize * 0.8, currentY - arrowSize * 0.5);
          break;
      }
      dashGraphics.closePath();
      dashGraphics.fill();

      // Ìù∞ÏÉâ ÌÖåÎëêÎ¶¨
      dashGraphics.lineStyle(2, 0xffffff, 0.9);
      dashGraphics.stroke();

      // Ïä§ÌîºÎìú ÎùºÏù∏ (ÏßÑÌñâ Ï§ë)
      if (t > 0.1 && t < 0.9) {
        const lineCount = 4;
        for (let i = 0; i < lineCount; i++) {
          const offset = (i - lineCount / 2) * 8;
          const lineLength = 30 * stretchFactor;

          dashGraphics.lineStyle(2, dashColor, 0.6 - i * 0.1);
          dashGraphics.beginPath();

          if (isHorizontal) {
            const lineX = currentX - vec.dx * lineLength;
            dashGraphics.moveTo(lineX, currentY + offset);
            dashGraphics.lineTo(currentX - vec.dx * 10, currentY + offset);
          } else {
            const lineY = currentY - vec.dy * lineLength;
            dashGraphics.moveTo(currentX + offset, lineY);
            dashGraphics.lineTo(currentX + offset, currentY - vec.dy * 10);
          }
          dashGraphics.stroke();
        }
      }
    };

    // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    const animTimer = this.time.addEvent({
      delay: 16, // ~60fps
      loop: true,
      callback: () => {
        anim.progress += 16 / dashDuration;
        if (anim.progress >= 1) {
          anim.progress = 1;
          animTimer.destroy();
        }
        drawRubberBandSnake();
      }
    });

    // ÎåÄÏãú ÏôÑÎ£å Ï≤òÎ¶¨
    this.time.delayedCall(dashDuration + 20, () => {
      // Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨
      dashGraphics.destroy();
      trailGraphics.destroy();

      // Î±Ä Ï†ÑÏ≤¥ Ïù¥Îèô (ÎåÄÏãú Í±∞Î¶¨ÎßåÌÅº)
      const dx = newHead.x - head.x;
      const dy = newHead.y - head.y;
      for (let i = 0; i < this.snake.length; i++) {
        this.snake[i].x += dx;
        this.snake[i].y += dy;
      }
      this.dashingHideSnake = false;
      this.draw();

      // ÎèÑÏ∞© ÏûÑÌå©Ìä∏ Ïù¥ÌéôÌä∏
      const impactGraphics = this.add.graphics().setDepth(198);

      // ÏûÑÌå©Ìä∏ ÎßÅ Ïó¨Îü¨ Í∞ú
      for (let i = 0; i < 3; i++) {
        this.time.delayedCall(i * 30, () => {
          const ring = this.add.graphics().setDepth(198 - i);
          ring.lineStyle(3 - i, dashColor, 1);
          ring.strokeCircle(endPixelX, endPixelY, 8);

          this.tweens.add({
            targets: ring,
            scaleX: 2.5 + i * 0.5,
            scaleY: 2.5 + i * 0.5,
            alpha: 0,
            duration: 150,
            ease: 'Quad.easeOut',
            onComplete: () => ring.destroy()
          });
        });
      }

      // Ïä§ÌååÌÅ¨ ÌååÌã∞ÌÅ¥
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const spark = this.add.graphics().setDepth(197);
        spark.fillStyle(dashColor, 1);
        spark.fillCircle(0, 0, 3);
        spark.x = endPixelX;
        spark.y = endPixelY;

        this.tweens.add({
          targets: spark,
          x: endPixelX + Math.cos(angle) * 25,
          y: endPixelY + Math.sin(angle) * 25,
          alpha: 0,
          scaleX: 0.3,
          scaleY: 0.3,
          duration: 120,
          ease: 'Quad.easeOut',
          onComplete: () => spark.destroy()
        });
      }

      // Î≥¥Ïä§ Ï∂©Îèå ÌåêÏ†ï
      if (hitBoss && this.gearTitanMode) {
        this.time.delayedCall(30, () => {
          this.performBossImpact(newHead, startPos, returnDir);
        });
      } else {
        this.time.delayedCall(50, () => {
          this.isDashing = false;
          this.isInvincible = false;
          if (this.moveTimer) this.moveTimer.paused = false;
          this.draw();
        });
      }
    });
  }

  // Steam Dash ÏûîÏÉÅ
  createSteamDashGhost(gridX, gridY, delay, color) {
    this.time.delayedCall(delay, () => {
      const x = gridX * this.gridSize + this.gridSize / 2;
      const y = gridY * this.gridSize + this.gridSize / 2 + 60;

      const ghost = this.add.graphics().setDepth(98);
      ghost.fillStyle(color, 0.6);
      ghost.fillRect(
        x - this.gridSize / 2 + 1,
        y - this.gridSize / 2 + 1,
        this.gridSize - 2,
        this.gridSize - 2
      );

      this.tweens.add({
        targets: ghost,
        alpha: 0,
        scaleX: 0.5,
        scaleY: 0.5,
        duration: 200,
        onComplete: () => ghost.destroy()
      });
    });
  }

  // Steam Ïä§ÌîºÎìú ÎùºÏù∏
  showSteamSpeedLines(startX, startY, endX, endY, dir, color) {
    const lineCount = 10;
    for (let i = 0; i < lineCount; i++) {
      const line = this.add.graphics().setDepth(99);
      const offset = (i - lineCount / 2) * 5;

      let lineStartX = startX;
      let lineStartY = startY;
      let lineEndX = endX;
      let lineEndY = endY;

      if (dir === 'LEFT' || dir === 'RIGHT') {
        lineStartY += offset;
        lineEndY += offset;
      } else {
        lineStartX += offset;
        lineEndX += offset;
      }

      line.lineStyle(2, color, 0.7);
      line.beginPath();
      line.moveTo(lineStartX, lineStartY);
      line.lineTo(lineEndX, lineEndY);
      line.stroke();

      this.tweens.add({
        targets: line,
        alpha: 0,
        duration: 150,
        delay: i * 8,
        onComplete: () => line.destroy()
      });
    }
  }

  performChargeDash() {
    if (this.isDashing) return;

    this.isDashing = true;
    this.isInvincible = true;
    this.lastDashTime = Date.now();

    const head = this.snake[0];
    const dir = this.direction;
    const startPos = { x: head.x, y: head.y }; // ÏõêÎûò ÏúÑÏπò Ï†ÄÏû•

    // Î∞©Ìñ•Ïóê Îî∞Î•∏ Ïù¥Îèô Î≤°ÌÑ∞
    const dirVectors = {
      'UP': { dx: 0, dy: -1 },
      'DOWN': { dx: 0, dy: 1 },
      'LEFT': { dx: -1, dy: 0 },
      'RIGHT': { dx: 1, dy: 0 }
    };

    const vec = dirVectors[dir];

    // Î∞òÎåÄ Î∞©Ìñ• Îß§Ìïë
    const oppositeDir = {
      'UP': 'DOWN',
      'DOWN': 'UP',
      'LEFT': 'RIGHT',
      'RIGHT': 'LEFT'
    };

    // Î≥¥Ïä§ ÏΩîÏñ¥ÍπåÏßÄ Ï∂©Î∂ÑÌûà ÎªóÏñ¥ÎÇòÍ∞ÄÎèÑÎ°ù ÏµúÎåÄ Ïä§ÌÖù Í≤∞Ï†ï
    const maxSteps = this.gearTitanMode && this.gearTitanPosition
      ? Math.max(this.dashDistance, Math.abs(head.x - this.gearTitanPosition.x) + Math.abs(head.y - this.gearTitanPosition.y))
      : this.dashDistance;

    // ÎåÄÏãú Í≤ΩÎ°ú Í≥ÑÏÇ∞
    const pathPositions = [];
    let maxTravel = 0;
    for (let i = 1; i <= maxSteps; i++) {
      const testX = head.x + vec.dx * i;
      const testY = head.y + vec.dy * i;

      if (testX < 0 || testX >= this.cols || testY < 0 || testY >= this.rows) {
        break;
      }

      pathPositions.push({ x: testX, y: testY });
      maxTravel = i;
    }

    if (maxTravel <= 0) {
      this.isDashing = false;
      this.isInvincible = false;
      return;
    }

    // ÏΩîÏñ¥ Ï†ïÎ†¨ Ïó¨Î∂ÄÏôÄ Ï∂©Îèå Ïó¨Î∂Ä
    const alignedWithCore = this.gearTitanMode && this.gearTitanPosition && (
      (vec.dx !== 0 && head.y === this.gearTitanPosition.y) ||
      (vec.dy !== 0 && head.x === this.gearTitanPosition.x)
    );

    let dashDist = maxTravel;
    let hitBoss = false;

    if (this.gearTitanMode && this.gearTitanPosition) {
      const distToCore = Math.abs(head.x - this.gearTitanPosition.x) + Math.abs(head.y - this.gearTitanPosition.y);
      if (alignedWithCore && distToCore > 0) {
        dashDist = Math.min(pathPositions.length, distToCore);
      }
      const impactPreview = pathPositions[Math.min(dashDist, pathPositions.length) - 1];
      const distAtEnd = Math.abs(impactPreview.x - this.gearTitanPosition.x) + Math.abs(impactPreview.y - this.gearTitanPosition.y);
      if (distAtEnd <= 1) {
        hitBoss = true;
      }
    }

    // Ïù¥Îèô Ï§ë Í≤åÏûÑ Ìã± Ïû†Ïãú Î©àÏ∂§
    this.moveTimer.paused = true;

    // === Ïó≠ÎèôÏ†ÅÏù∏ ÎåÄÏãú ÎèåÏßÑ Ïï†ÎãàÎ©îÏù¥ÏÖò ===
    const startPixelX = head.x * this.gridSize + this.gridSize / 2;
    const startPixelY = head.y * this.gridSize + this.gridSize / 2 + 60;
    const newHead = pathPositions[dashDist - 1];
    const endPixelX = newHead.x * this.gridSize + this.gridSize / 2;
    const endPixelY = newHead.y * this.gridSize + this.gridSize / 2 + 60;
    const returnDir = oppositeDir[dir];

    // ÎåÄÏãú Ï†Ñ Ï§ÄÎπÑ Ìö®Í≥º (Ïû†Ïãú ÏõÖÌÅ¨Î¶º)
    this.showDashChargeEffect(startPixelX, startPixelY);

    // Ïó≠ÎèôÏ†ÅÏù∏ ÎåÄÏãú ÎèåÏßÑ (Îπ†Î•∏ Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú Ïù¥Îèô)
    this.time.delayedCall(50, () => {
      // Î™®ÏÖò Î∏îÎü¨ ÏûîÏÉÅ Ìö®Í≥º (Îçî Ï¥òÏ¥òÌïòÍ≤å)
      pathPositions.slice(0, dashDist).forEach((pos, idx) => {
        this.createDashGhost(pos.x, pos.y, idx * 8); // Îçî Îπ†Î•∏ Í∞ÑÍ≤©
      });

      // Ïä§ÌîºÎìú ÎùºÏù∏ Ìö®Í≥º
      this.showSpeedLines(startPixelX, startPixelY, endPixelX, endPixelY, dir);

      // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨ (ÎèåÏßÑ ÎäêÎÇå)
      this.cameras.main.shake(80, 0.015);

      // Î±Ä Î®∏Î¶¨Î•º Ïã§Ï†úÎ°ú Ïù¥Îèô
      this.snake.unshift(newHead);
      this.snake.pop();
      this.draw();

      // Î≥¥Ïä§ Ï∂©Îèå ÌåêÏ†ï
      if (hitBoss && this.gearTitanMode) {
        // === Î≥¥Ïä§Ïóê Í∞ïÎ†•ÌïòÍ≤å Ï∂©Îèå! ===
        this.time.delayedCall(30, () => {
          this.performBossImpact(newHead, startPos, returnDir);
        });
      } else {
        // Î≥¥Ïä§Ïóê ÎãøÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Îπ†Î•¥Í≤å Î≥µÍ∑Ä
        this.time.delayedCall(100, () => {
          this.isDashing = false;
          this.isInvincible = false;
          this.moveTimer.paused = false;
          this.draw();
        });
      }
    });
  }

  // === Î≥¥Ïä§ Ï∂©Îèå Ï≤òÎ¶¨ (Ïó≠ÎèôÏ†Å ÏûÑÌå©Ìä∏) ===
  performBossImpact(impactPos, startPos, returnDir) {
    const bossPx = this.gearTitanPosition.x * this.gridSize + this.gridSize / 2;
    const bossPy = this.gearTitanPosition.y * this.gridSize + this.gridSize / 2 + 60;

    // 1. ÏûÑÌå©Ìä∏ ÏàúÍ∞Ñ ÌôîÎ©¥ Ï†ïÏßÄ Ìö®Í≥º (ÌûàÌä∏Ïä§ÌÜ±)
    this.time.timeScale = 0.1;
    this.cameras.main.flash(100, 255, 255, 255, false);

    // 2. Í∞ïÎ†•Ìïú ÏûÑÌå©Ìä∏ Ïù¥ÌéôÌä∏
    this.showPowerfulImpactEffect(bossPx, bossPy);

    // 3. Î≥¥Ïä§ ÌîºÍ≤© Î∞òÏùë (ÏïÑÌååÌïòÎäî Ìö®Í≥º + Ïä§ÌÑ¥)
    this.applyBossHitReaction(bossPx, bossPy);

    // 4. ÌûàÌä∏Ïä§ÌÜ± ÌõÑ Î±Ä ÌäïÍ≤®ÎÇòÍ∞ê
    this.time.delayedCall(150, () => {
      this.time.timeScale = 1;

      // Î±ÄÏù¥ ÌäïÍ≤®Ï†∏ ÎÇòÏò§Îäî Ïó≠ÎèôÏ†Å Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.bounceSnakeBack(impactPos, startPos, returnDir, () => {
        // ÌäïÍ≤®Ï†∏ ÎÇòÏò® ÌõÑ Î∞îÎ°ú Î∞òÎåÄÎ∞©Ìñ•ÏúºÎ°ú ÏßÑÌñâ ÏãúÏûë
        this.isDashing = false;

        if (this.gearTitanVulnerable) {
          // Î≥¥Ïä§Í∞Ä vulnerable ÏÉÅÌÉúÎ©¥ HIT Ï≤òÎ¶¨
          this.handleGearTitanHit({
            skipSnakePush: true,
            bounceOverride: null, // Ïù¥ÎØ∏ ÌäïÍ≤®ÎÇòÏôîÏúºÎØÄÎ°ú Ïä§ÌÇµ
            forceDirection: returnDir,
            resumeDelay: 100 // Î∞îÎ°ú ÏßÑÌñâ
          });
        } else {
          // Ïä§ÌÑ¥ ÏÉÅÌÉúÏù∏ Î≥¥Ïä§, Î±ÄÏùÄ Î∞îÎ°ú ÏßÑÌñâ
          this.direction = returnDir;
          this.inputQueue = [];
          this.isInvincible = false;
          this.moveTimer.paused = false;
          this.draw();
        }
      });
    });
  }

  // === ÎåÄÏãú Ï∞®ÏßÄ Ïù¥ÌéôÌä∏ (ÎèåÏßÑ Ï†Ñ ÏõÖÌÅ¨Î¶º) ===
  showDashChargeEffect(x, y) {
    // Ï∞®ÏßÄ ÌååÌã∞ÌÅ¥Ïù¥ Î±Ä Ï£ºÏúÑÎ°ú Î™®ÏûÑ
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const particle = this.add.graphics().setDepth(100);
      particle.fillStyle(0x00ffff, 0.8);
      particle.fillCircle(x + Math.cos(angle) * 30, y + Math.sin(angle) * 30, 4);

      this.tweens.add({
        targets: particle,
        x: x - particle.x,
        y: y - particle.y,
        alpha: 0,
        duration: 50,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }
  }

  // === Ïä§ÌîºÎìú ÎùºÏù∏ Ìö®Í≥º ===
  showSpeedLines(startX, startY, endX, endY, dir) {
    const lineCount = 12;
    for (let i = 0; i < lineCount; i++) {
      const line = this.add.graphics().setDepth(99);
      const offset = (i - lineCount / 2) * 4;

      let lineStartX = startX;
      let lineStartY = startY;
      let lineEndX = endX;
      let lineEndY = endY;

      if (dir === 'LEFT' || dir === 'RIGHT') {
        lineStartY += offset;
        lineEndY += offset;
      } else {
        lineStartX += offset;
        lineEndX += offset;
      }

      line.lineStyle(2, Phaser.Math.RND.pick([0x00ffff, 0xffffff, 0x00ff88]), 0.8);
      line.beginPath();
      line.moveTo(lineStartX, lineStartY);
      line.lineTo(lineEndX, lineEndY);
      line.stroke();

      this.tweens.add({
        targets: line,
        alpha: 0,
        duration: 150,
        delay: i * 10,
        onComplete: () => line.destroy()
      });
    }
  }

  // === Í∞ïÎ†•Ìïú ÏûÑÌå©Ìä∏ Ïù¥ÌéôÌä∏ ===
  showPowerfulImpactEffect(x, y) {
    // ÎåÄÌòï Ï∂©Í≤©Ìåå ÎßÅ
    for (let i = 0; i < 4; i++) {
      const ring = this.add.graphics().setDepth(5001);
      ring.lineStyle(6 - i, Phaser.Math.RND.pick([0xffff00, 0xff8800, 0xffffff]), 1);
      ring.strokeCircle(x, y, 15);

      this.tweens.add({
        targets: ring,
        scaleX: 6 + i * 2,
        scaleY: 6 + i * 2,
        alpha: 0,
        duration: 300 + i * 50,
        ease: 'Power2',
        onComplete: () => ring.destroy()
      });
    }

    // Ïä§ÌååÌÅ¨ Ìè≠Î∞ú (Îçî ÎßéÏù¥)
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * Math.PI * 2 + Math.random() * 0.3;
      const spark = this.add.graphics().setDepth(5002);
      spark.fillStyle(Phaser.Math.RND.pick([0xffff00, 0xff8800, 0xffffff, 0x00ffff]), 1);
      spark.fillCircle(0, 0, Phaser.Math.Between(4, 10));
      spark.x = x;
      spark.y = y;

      this.tweens.add({
        targets: spark,
        x: x + Math.cos(angle) * Phaser.Math.Between(80, 150),
        y: y + Math.sin(angle) * Phaser.Math.Between(80, 150),
        alpha: 0,
        scaleX: 0.3,
        scaleY: 0.3,
        duration: 400,
        ease: 'Power2',
        onComplete: () => spark.destroy()
      });
    }

    // "CRASH!" ÌÖçÏä§Ìä∏
    const crashText = this.add.text(x, y - 50, 'CRASH!', {
      fontSize: '40px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff6600',
      strokeThickness: 5
    }).setOrigin(0.5).setDepth(5010).setScale(0);

    this.tweens.add({
      targets: crashText,
      scaleX: 1.3,
      scaleY: 1.3,
      duration: 100,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: crashText,
          y: y - 100,
          alpha: 0,
          scaleX: 0.8,
          scaleY: 0.8,
          duration: 400,
          onComplete: () => crashText.destroy()
        });
      }
    });

    // Í∞ïÎ†•Ìïú Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(300, 0.04);
  }

  // === Î≥¥Ïä§ ÌîºÍ≤© Î∞òÏùë (ÏïÑÌååÌï® + Ïä§ÌÑ¥) ===
  applyBossHitReaction(bossPx, bossPy) {
    if (!this.gearTitanContainer) return;

    // Î≥¥Ïä§ Ïä§ÌÑ¥ ÏãúÍ∞Ñ ÏÑ§Ï†ï
    this.gearTitanStunEndTime = this.time.now + 1200;

    // 1. Îπ®Í∞Ñ/Ìù∞ÏÉâ ÍπúÎπ°ÏûÑ (ÏïÑÌååÌïòÎäî Ìö®Í≥º)
    let flashCount = 0;
    const flashColors = [0xff0000, 0xffffff, 0xff0000, 0xffffff, 0xff0000];
    this.time.addEvent({
      delay: 60,
      repeat: flashColors.length - 1,
      callback: () => {
        if (this.gearTitanContainer) {
          this.gearTitanContainer.iterate(child => {
            if (child.setTint) child.setTint(flashColors[flashCount]);
          });
        }
        flashCount++;
      }
    });

    // ÍπúÎπ°ÏûÑ ÌõÑ ÏÉâÏÉÅ Î≥µÏõê
    this.time.delayedCall(400, () => {
      if (this.gearTitanContainer) {
        this.gearTitanContainer.iterate(child => {
          if (child.clearTint) child.clearTint();
        });
      }
    });

    // 2. Î≥¥Ïä§Í∞Ä ÌÅ¨Í≤å ÌùîÎì§Î¶º (ÏïÑÌååÌïòÎäî ÎäêÎÇå)
    this.tweens.add({
      targets: this.gearTitanContainer,
      x: { from: this.gearTitanContainer.x - 15, to: this.gearTitanContainer.x + 15 },
      duration: 50,
      yoyo: true,
      repeat: 6,
      ease: 'Sine.easeInOut',
      onComplete: () => {
        if (this.gearTitanContainer) {
          this.gearTitanContainer.x = bossPx;
        }
      }
    });

    // 3. Î≥¥Ïä§ ÏÇ¥Ïßù Îí§Î°ú Î∞ÄÎ¶º Ìö®Í≥º
    this.tweens.add({
      targets: this.gearTitanContainer,
      scaleX: 0.85,
      scaleY: 1.1,
      duration: 100,
      yoyo: true,
      ease: 'Power2'
    });

    // 4. Ïä§ÌÑ¥ Î≥Ñ Ïù¥ÌéôÌä∏ (Î®∏Î¶¨ ÏúÑÏóê Î≥ÑÏù¥ ÎèåÏïÑÍ∞ê)
    this.showBossStunStars(bossPx, bossPy - 60);
  }

  // === Î≥¥Ïä§ Ïä§ÌÑ¥ Î≥Ñ Ïù¥ÌéôÌä∏ ===
  showBossStunStars(x, y) {
    const starCount = 4;
    const stars = [];

    for (let i = 0; i < starCount; i++) {
      const star = this.add.text(x, y, '‚òÖ', {
        fontSize: '20px',
        fill: '#ffff00'
      }).setOrigin(0.5).setDepth(5005);
      stars.push(star);
    }

    // Î≥ÑÎì§Ïù¥ ÏõêÌòïÏúºÎ°ú ÎèåÏïÑÍ∞ê
    let angle = 0;
    const radius = 25;
    const starTimer = this.time.addEvent({
      delay: 16,
      loop: true,
      callback: () => {
        angle += 0.1;
        stars.forEach((star, idx) => {
          const starAngle = angle + (idx / starCount) * Math.PI * 2;
          star.x = x + Math.cos(starAngle) * radius;
          star.y = y + Math.sin(starAngle) * radius * 0.5;
        });
      }
    });

    // 1Ï¥à ÌõÑ Î≥Ñ Ï†úÍ±∞
    this.time.delayedCall(1000, () => {
      starTimer.remove();
      stars.forEach(star => {
        this.tweens.add({
          targets: star,
          alpha: 0,
          scaleX: 2,
          scaleY: 2,
          duration: 200,
          onComplete: () => star.destroy()
        });
      });
    });
  }

  // === Î±Ä ÌäïÍ≤®ÎÇòÍ∞ÄÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ===
  bounceSnakeBack(impactPos, startPos, returnDir, onComplete) {
    const impactPx = impactPos.x * this.gridSize + this.gridSize / 2;
    const impactPy = impactPos.y * this.gridSize + this.gridSize / 2 + 60;
    const startPx = startPos.x * this.gridSize + this.gridSize / 2;
    const startPy = startPos.y * this.gridSize + this.gridSize / 2 + 60;

    // Î±Ä Î®∏Î¶¨Î•º ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú ÌäïÍ≤®ÎÇòÍ∞ÄÍ≤å
    const bounceSnake = this.add.graphics().setDepth(5000);
    bounceSnake.fillStyle(0x00ff00, 1);
    bounceSnake.fillRect(-this.gridSize / 2, -this.gridSize / 2, this.gridSize - 2, this.gridSize - 2);
    bounceSnake.x = impactPx;
    bounceSnake.y = impactPy;

    // ÌäïÍ≤®ÎÇòÍ∞ÄÎäî ÏûîÏÉÅ Ìö®Í≥º
    const ghostCount = 6;
    for (let i = 0; i < ghostCount; i++) {
      const t = i / ghostCount;
      const ghostX = Phaser.Math.Linear(impactPx, startPx, t);
      const ghostY = Phaser.Math.Linear(impactPy, startPy, t);

      this.time.delayedCall(i * 25, () => {
        const ghost = this.add.graphics().setDepth(99);
        ghost.fillStyle(0x00ffff, 0.6 - t * 0.4);
        ghost.fillRect(
          ghostX - this.gridSize / 2,
          ghostY - this.gridSize / 2,
          this.gridSize - 2,
          this.gridSize - 2
        );

        this.tweens.add({
          targets: ghost,
          alpha: 0,
          duration: 200,
          onComplete: () => ghost.destroy()
        });
      });
    }

    // Î±Ä Î®∏Î¶¨Í∞Ä Îπ†Î•¥Í≤å ÌäïÍ≤®ÎÇòÍ∞ê
    this.tweens.add({
      targets: bounceSnake,
      x: startPx,
      y: startPy,
      duration: 150,
      ease: 'Back.easeOut',
      onComplete: () => {
        bounceSnake.destroy();

        // Ï∞©ÏßÄ Ìö®Í≥º
        const landEffect = this.add.graphics().setDepth(98);
        landEffect.lineStyle(4, 0x00ff00, 1);
        landEffect.strokeCircle(startPx, startPy, 8);

        // Ï∞©ÏßÄ Î®ºÏßÄ ÌååÌã∞ÌÅ¥
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const dust = this.add.graphics().setDepth(97);
          dust.fillStyle(0xcccccc, 0.7);
          dust.fillCircle(0, 0, 3);
          dust.x = startPx;
          dust.y = startPy;

          this.tweens.add({
            targets: dust,
            x: startPx + Math.cos(angle) * 25,
            y: startPy + Math.sin(angle) * 15,
            alpha: 0,
            duration: 300,
            ease: 'Power2',
            onComplete: () => dust.destroy()
          });
        }

        this.tweens.add({
          targets: landEffect,
          scaleX: 3,
          scaleY: 3,
          alpha: 0,
          duration: 250,
          onComplete: () => landEffect.destroy()
        });

        // Ïã§Ï†ú Î±Ä ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        this.snake[0] = { x: startPos.x, y: startPos.y };
        this.direction = returnDir;
        this.inputQueue = [];
        this.draw();

        // ÏΩúÎ∞± Ìò∏Ï∂ú
        if (onComplete) onComplete();
      }
    });
  }

  // ÎåÄÏãú ÌõÑ Ï†úÏûêÎ¶¨ Î≥µÍ∑Ä + Î∞òÎåÄ Î∞©Ìñ• Ï†ÑÌôò
  returnSnakeAfterDash(startPos, impactPos, newDirection) {
    const hitX = impactPos.x * this.gridSize + this.gridSize / 2;
    const hitY = impactPos.y * this.gridSize + this.gridSize / 2 + 60;

    // Ï∂©Îèå Ìö®Í≥º - Îπ®Í∞Ñ ÌîåÎûòÏãú
    this.cameras.main.flash(150, 255, 100, 100);
    this.cameras.main.shake(200, 0.02);

    // "BLOCKED!" ÌÖçÏä§Ìä∏
    const blockedText = this.add.text(hitX, hitY - 40, 'BLOCKED!', {
      fontSize: '24px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: blockedText,
      y: hitY - 80,
      alpha: 0,
      duration: 450,
      ease: 'Power2',
      onComplete: () => blockedText.destroy()
    });

    // Î≥µÍ∑Ä ÏûîÏÉÅ (Ï∂©Îèå ‚Üí ÏãúÏûëÏ†ê)
    const steps = Math.max(1, Math.abs(startPos.x - impactPos.x) + Math.abs(startPos.y - impactPos.y));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const gx = Math.round(Phaser.Math.Linear(impactPos.x, startPos.x, t));
      const gy = Math.round(Phaser.Math.Linear(impactPos.y, startPos.y, t));
      this.createDashGhost(gx, gy, i * 22);
    }

    this.time.delayedCall(120, () => {
      this.snake[0] = { x: startPos.x, y: startPos.y };
      this.direction = newDirection;
      this.inputQueue = [];

      const landX = startPos.x * this.gridSize + this.gridSize / 2;
      const landY = startPos.y * this.gridSize + this.gridSize / 2 + 60;
      const landEffect = this.add.graphics().setDepth(98);
      landEffect.lineStyle(3, 0x00ffff, 1);
      landEffect.strokeCircle(landX, landY, 5);

      this.tweens.add({
        targets: landEffect,
        scaleX: 3,
        scaleY: 3,
        alpha: 0,
        duration: 250,
        onComplete: () => landEffect.destroy()
      });

      this.draw();
    });

    this.time.delayedCall(260, () => {
      this.isInvincible = false;
      this.moveTimer.paused = false;
      this.draw();
    });
  }

  // Î≥¥Ïä§ ÏΩîÏñ¥ Ï∂©Îèå ÎπÑÏ£ºÏñº
  playGearTitanImpactEffect(impactPx, impactPy) {
    // ÏûÑÌå©Ìä∏ ÎßÅ
    for (let i = 0; i < 2; i++) {
      const ring = this.add.graphics().setDepth(5001);
      ring.lineStyle(4 - i, 0xffff00, 1);
      ring.strokeCircle(impactPx, impactPy, 12 + i * 6);
      this.tweens.add({
        targets: ring,
        scaleX: 4 + i,
        scaleY: 4 + i,
        alpha: 0,
        duration: 250 + i * 80,
        ease: 'Power2',
        onComplete: () => ring.destroy()
      });
    }

    // Ïä§ÌååÌÅ¨
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2;
      const spark = this.add.graphics().setDepth(5002);
      spark.fillStyle(Phaser.Math.RND.pick([0xffff00, 0xff8800, 0xffffff]), 1);
      spark.fillCircle(impactPx, impactPy, Phaser.Math.Between(3, 6));
      this.tweens.add({
        targets: spark,
        x: impactPx + Math.cos(angle) * Phaser.Math.Between(40, 70),
        y: impactPy + Math.sin(angle) * Phaser.Math.Between(40, 70),
        alpha: 0,
        duration: 300,
        ease: 'Power2',
        onComplete: () => spark.destroy()
      });
    }

    // Î≥¥Ïä§ ÌùîÎì§Î¶º/ÍπúÎπ°ÏûÑ
    if (this.gearTitanContainer) {
      this.tweens.add({
        targets: this.gearTitanContainer,
        angle: { from: -0.08, to: 0.08 },
        yoyo: true,
        repeat: 5,
        duration: 40
      });

      this.gearTitanContainer.iterate(child => {
        if (child.setTint) child.setTint(0xffcc00);
      });

      this.time.delayedCall(200, () => {
        this.gearTitanContainer.iterate(child => {
          if (child.clearTint) child.clearTint();
        });
      });
    }
  }

  showDashEffect(startX, startY, distance, direction) {
    const { width, height } = this.cameras.main;

    // ÎåÄÏãú ÎùºÏù∏ Ìö®Í≥º
    const startPixelX = startX * this.gridSize + this.gridSize / 2;
    const startPixelY = startY * this.gridSize + this.gridSize / 2 + 60;

    const dirVectors = {
      'UP': { dx: 0, dy: -1 },
      'DOWN': { dx: 0, dy: 1 },
      'LEFT': { dx: -1, dy: 0 },
      'RIGHT': { dx: 1, dy: 0 }
    };

    const vec = dirVectors[direction];
    const endPixelX = startPixelX + vec.dx * distance * this.gridSize;
    const endPixelY = startPixelY + vec.dy * distance * this.gridSize;

    // Î™®ÏÖò Î∏îÎü¨ ÎùºÏù∏
    const dashLine = this.add.graphics();
    dashLine.setDepth(98);
    dashLine.lineStyle(8, 0x00ffff, 0.8);
    dashLine.beginPath();
    dashLine.moveTo(startPixelX, startPixelY);
    dashLine.lineTo(endPixelX, endPixelY);
    dashLine.stroke();

    // Ïä§ÌååÌÅ¨ ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 10; i++) {
      const t = i / 9;
      const sparkX = startPixelX + (endPixelX - startPixelX) * t;
      const sparkY = startPixelY + (endPixelY - startPixelY) * t;

      const spark = this.add.graphics();
      spark.setDepth(99);
      spark.fillStyle(0x00ffff, 1);
      spark.fillCircle(sparkX + Phaser.Math.Between(-5, 5), sparkY + Phaser.Math.Between(-5, 5), 3);

      this.tweens.add({
        targets: spark,
        alpha: 0,
        scaleX: 0,
        scaleY: 0,
        duration: 300,
        delay: i * 20,
        onComplete: () => spark.destroy()
      });
    }

    // ÎåÄÏãú ÎùºÏù∏ ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.tweens.add({
      targets: dashLine,
      alpha: 0,
      duration: 200,
      onComplete: () => dashLine.destroy()
    });

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(100, 0.01);
  }

  createDashGhost(x, y, delay) {
    const pixelX = x * this.gridSize + this.gridSize / 2;
    const pixelY = y * this.gridSize + this.gridSize / 2 + 60;

    this.time.delayedCall(delay, () => {
      const ghost = this.add.graphics();
      ghost.setDepth(97);
      ghost.fillStyle(0x00ffff, 0.5);
      ghost.fillRect(
        pixelX - this.gridSize / 2,
        pixelY - this.gridSize / 2,
        this.gridSize - 2,
        this.gridSize - 2
      );

      this.tweens.add({
        targets: ghost,
        alpha: 0,
        duration: 200,
        onComplete: () => ghost.destroy()
      });
    });
  }

  checkGearTitanHit(snakeHead) {
    if (!this.gearTitanPosition) return false;

    const dist = Math.abs(snakeHead.x - this.gearTitanPosition.x) + Math.abs(snakeHead.y - this.gearTitanPosition.y);
    return dist <= 2; // Î≥¥Ïä§ Í∑ºÏ≤ò 2Ïπ∏ Ïù¥ÎÇ¥
  }

  // =====================
  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Í≥µÍ≤© Ìå®ÌÑ¥
  // =====================

  gearTitanPhase1Attack() {
    if (!this.gearTitanMode || this.gameOver) return;

    const { width, height } = this.cameras.main;
    const bossPos = this.gearTitanPosition || { x: Math.floor(this.cols / 2), y: Math.floor(this.rows / 2) };

    // Í≤ΩÍ≥† ÌëúÏãú
    const warningText = this.add.text(width / 2, 100, 'SAW BARRAGE!', {
      fontSize: '32px',
      fill: '#ff4400',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: warningText,
      alpha: { from: 1, to: 0 },
      duration: 1000,
      onComplete: () => warningText.destroy()
    });

    // 4Î∞©Ìñ•ÏóêÏÑú ÌÜ±Îãà Î∞úÏÇ¨
    const cornerSpawns = [
      { x: 0, y: 0 },
      { x: this.cols - 1, y: 0 },
      { x: 0, y: this.rows - 1 },
      { x: this.cols - 1, y: this.rows - 1 }
    ];

    cornerSpawns.forEach((pos, idx) => {
      this.time.delayedCall(idx * 200, () => {
        this.fireGearTitanSaw(pos.x, pos.y);
      });
    });

    // Ï∂îÍ∞Ä ÏóêÏßÄ Ïä§Ìè∞ (Ï§ëÏïôÏóêÏÑú Îπ†Î•¥Í≤å)
    const edgeSpawns = [
      { x: Math.floor(this.cols / 2), y: 0 },
      { x: Math.floor(this.cols / 2), y: this.rows - 1 },
      { x: 0, y: Math.floor(this.rows / 2) },
      { x: this.cols - 1, y: Math.floor(this.rows / 2) }
    ];

    edgeSpawns.forEach((pos, idx) => {
      this.time.delayedCall(600 + idx * 160, () => {
        this.fireGearTitanSaw(pos.x, pos.y);
      });
    });

    // ÌîåÎ†àÏù¥Ïñ¥Î•º Í≤®ÎÉ•Ìïú Ï∂îÍ∞Ä ÏÉ∑
    this.time.delayedCall(1200, () => {
      const snakeHead = this.snake[0];
      const fromLeft = snakeHead.x > bossPos.x;
      const fromTop = snakeHead.y > bossPos.y;
      const startX = fromLeft ? 0 : this.cols - 1;
      const startY = fromTop ? 0 : this.rows - 1;
      this.fireGearTitanSaw(startX, startY);
    });

    // Í≥µÍ≤© ÏôÑÎ£å ÌõÑ Ï∑®ÏïΩ ÏÉÅÌÉú
    this.time.delayedCall(4200, () => {
      this.makeGearTitanVulnerable();
    });
  }

  fireGearTitanSaw(startX, startY) {
    const pixelX = startX * this.gridSize + this.gridSize / 2;
    const pixelY = startY * this.gridSize + this.gridSize / 2 + 60;

    // ÎØ∏Îãà ÌÜ±Îãà ÏÉùÏÑ±
    const sawContainer = this.add.container(pixelX, pixelY);
    sawContainer.setDepth(250);

    const sawGraphic = this.add.graphics();
    const sawRadius = this.gridSize * 0.4;

    sawGraphic.fillStyle(0xff6600, 1);
    sawGraphic.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const nextAngle = ((i + 0.5) / 8) * Math.PI * 2;
      const outerR = sawRadius * 1.2;
      const innerR = sawRadius * 0.6;

      if (i === 0) {
        sawGraphic.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      } else {
        sawGraphic.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      }
      sawGraphic.lineTo(Math.cos(nextAngle) * innerR, Math.sin(nextAngle) * innerR);
    }
    sawGraphic.closePath();
    sawGraphic.fill();

    sawContainer.add(sawGraphic);

    // ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: sawGraphic,
      rotation: Math.PI * 2,
      duration: 200,
      repeat: -1,
      ease: 'Linear'
    });

    // Î±Ä Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô
    const head = this.snake[0];
    const targetX = head.x * this.gridSize + this.gridSize / 2;
    const targetY = head.y * this.gridSize + this.gridSize / 2 + 60;

    this.tweens.add({
      targets: sawContainer,
      x: targetX,
      y: targetY,
      duration: 1100,
      ease: 'Quad.easeIn',
      onUpdate: () => {
        // Ï∂©Îèå Ï≤¥ÌÅ¨ (Î¨¥Ï†ÅÏù¥ ÏïÑÎãê ÎïåÎßå)
        if (!this.isInvincible && !this.isDashing) {
          const sawGridX = Math.floor((sawContainer.x - this.gridSize / 2) / this.gridSize);
          const sawGridY = Math.floor((sawContainer.y - this.gridSize / 2 - 60) / this.gridSize);
          const snakeHead = this.snake[0];

          if (sawGridX === snakeHead.x && sawGridY === snakeHead.y) {
            this.endGame();
          }
        }
      },
      onComplete: () => {
        sawContainer.destroy();
      }
    });
  }

  gearTitanPhase2Attack() {
    if (!this.gearTitanMode || this.gameOver) return;

    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥† ÌëúÏãú
    const warningText = this.add.text(width / 2, 100, 'GEAR LASER!', {
      fontSize: '32px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: warningText,
      alpha: { from: 1, to: 0 },
      duration: 1000,
      onComplete: () => warningText.destroy()
    });

    // ÎûúÎç§ÏúºÎ°ú Í∞ÄÎ°ú ÎòêÎäî ÏÑ∏Î°ú Î†àÏù¥Ï†Ä 2Ïó∞ÌÉÄ (ÍµêÏ∞®)
    const firstHorizontal = Math.random() < 0.5;
    const firstPos = firstHorizontal
      ? Phaser.Math.Between(3, this.rows - 4)
      : Phaser.Math.Between(3, this.cols - 4);

    const snakeHead = this.snake[0];
    const secondHorizontal = !firstHorizontal;
    const secondPos = secondHorizontal
      ? Phaser.Math.Clamp(snakeHead.y + Phaser.Math.Between(-1, 1), 2, this.rows - 3)
      : Phaser.Math.Clamp(snakeHead.x + Phaser.Math.Between(-1, 1), 2, this.cols - 3);

    // Ï≤´ Î≤àÏß∏ Î†àÏù¥Ï†Ä
    this.showLaserWarning(firstHorizontal, firstPos, () => {
      this.fireLaser(firstHorizontal, firstPos, () => {
        // Îëê Î≤àÏß∏ (ÍµêÏ∞®) Î†àÏù¥Ï†Ä
        this.time.delayedCall(300, () => {
          this.showLaserWarning(secondHorizontal, secondPos, () => {
            this.fireLaser(secondHorizontal, secondPos, () => {
              this.time.delayedCall(500, () => {
                this.makeGearTitanVulnerable();
              });
            });
          });
        });
      });
    });
  }

  showLaserWarning(isHorizontal, pos, callback) {
    const { width, height } = this.cameras.main;

    const warningLine = this.add.graphics();
    warningLine.setDepth(200);

    if (isHorizontal) {
      const y = pos * this.gridSize + this.gridSize / 2 + 60;
      warningLine.lineStyle(this.gridSize, 0xff0000, 0.3);
      warningLine.beginPath();
      warningLine.moveTo(0, y);
      warningLine.lineTo(width, y);
      warningLine.stroke();
    } else {
      const x = pos * this.gridSize + this.gridSize / 2;
      warningLine.lineStyle(this.gridSize, 0xff0000, 0.3);
      warningLine.beginPath();
      warningLine.moveTo(x, 60);
      warningLine.lineTo(x, height);
      warningLine.stroke();
    }

    // Í≤ΩÍ≥†ÏÑ† ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: warningLine,
      alpha: { from: 0.3, to: 0.8 },
      duration: 200,
      yoyo: true,
      repeat: 2,
      onComplete: () => {
        warningLine.destroy();
        if (callback) callback();
      }
    });
  }

  fireLaser(isHorizontal, pos, onComplete) {
    const { width, height } = this.cameras.main;

    const laser = this.add.graphics();
    laser.setDepth(250);

    // Î†àÏù¥Ï†Ä Ìö®Í≥º
    if (isHorizontal) {
      const y = pos * this.gridSize + this.gridSize / 2 + 60;
      laser.fillStyle(0xff4400, 0.9);
      laser.fillRect(0, y - this.gridSize / 2, width, this.gridSize);
      laser.fillStyle(0xffff00, 1);
      laser.fillRect(0, y - 3, width, 6);
    } else {
      const x = pos * this.gridSize + this.gridSize / 2;
      laser.fillStyle(0xff4400, 0.9);
      laser.fillRect(x - this.gridSize / 2, 60, this.gridSize, height - 60);
      laser.fillStyle(0xffff00, 1);
      laser.fillRect(x - 3, 60, 6, height - 60);
    }

    // Ï∂©Îèå Ï≤¥ÌÅ¨
    if (!this.isInvincible && !this.isDashing) {
      const head = this.snake[0];
      const hit = isHorizontal ? (head.y === pos) : (head.x === pos);
      if (hit) {
        this.endGame();
      }
    }

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(200, 0.02);

    // Î†àÏù¥Ï†Ä ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.tweens.add({
      targets: laser,
      alpha: 0,
      duration: 300,
      onComplete: () => {
        laser.destroy();
        // Îã§Ïùå Í≥µÍ≤© Ï§ÄÎπÑ
        if (onComplete) {
          onComplete();
        } else {
          this.time.delayedCall(800, () => {
            this.makeGearTitanVulnerable();
          });
        }
      }
    });
  }

  gearTitanPhase3Attack() {
    if (!this.gearTitanMode || this.gameOver) return;

    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥† ÌëúÏãú
    const warningText = this.add.text(width / 2, 100, 'GRIND CHARGE!', {
      fontSize: '32px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: warningText,
      alpha: { from: 1, to: 0 },
      duration: 1000,
      onComplete: () => warningText.destroy()
    });

    // Î≥¥Ïä§Í∞Ä Î±Ä Î∞©Ìñ•ÏúºÎ°ú ÎèåÏßÑ
    const head = this.snake[0];
    const bossX = this.gearTitanPosition.x;
    const bossY = this.gearTitanPosition.y;

    // ÎèåÏßÑ Î∞©Ìñ• Í≤∞Ï†ï
    let targetX, targetY;
    if (Math.abs(head.x - bossX) > Math.abs(head.y - bossY)) {
      // Í∞ÄÎ°ú Î∞©Ìñ• ÎèåÏßÑ
      targetX = head.x > bossX ? this.cols - 1 : 0;
      targetY = bossY;
    } else {
      // ÏÑ∏Î°ú Î∞©Ìñ• ÎèåÏßÑ
      targetX = bossX;
      targetY = head.y > bossY ? this.rows - 1 : 0;
    }

    const startPixelX = bossX * this.gridSize + this.gridSize / 2;
    const startPixelY = bossY * this.gridSize + this.gridSize / 2 + 60;
    const endPixelX = targetX * this.gridSize + this.gridSize / 2;
    const endPixelY = targetY * this.gridSize + this.gridSize / 2 + 60;

    // Í≤ΩÍ≥†ÏÑ† ÌëúÏãú
    const chargeLine = this.add.graphics();
    chargeLine.setDepth(199);
    chargeLine.lineStyle(this.gridSize * 2, 0xff0000, 0.3);
    chargeLine.beginPath();
    chargeLine.moveTo(startPixelX, startPixelY);
    chargeLine.lineTo(endPixelX, endPixelY);
    chargeLine.stroke();

    // Í≤ΩÍ≥†ÏÑ† ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: chargeLine,
      alpha: { from: 0.3, to: 0.6 },
      duration: 200,
      yoyo: true,
      repeat: 2,
      onComplete: () => {
        chargeLine.destroy();

        // ÎèåÏßÑ Ïã§Ìñâ
        if (this.gearTitanContainer) {
          this.tweens.add({
            targets: this.gearTitanContainer,
            x: endPixelX,
            y: endPixelY,
            duration: 380,
            ease: 'Power2',
            onUpdate: () => {
              // Ï∂©Îèå Ï≤¥ÌÅ¨
              if (!this.isInvincible && !this.isDashing && this.gearTitanContainer) {
                const bossGridX = Math.floor((this.gearTitanContainer.x - this.gridSize / 2) / this.gridSize);
                const bossGridY = Math.floor((this.gearTitanContainer.y - this.gridSize / 2 - 60) / this.gridSize);
                const snakeHead = this.snake[0];

                if (Math.abs(bossGridX - snakeHead.x) <= 1 && Math.abs(bossGridY - snakeHead.y) <= 1) {
                  this.endGame();
                }
              }
            },
            onComplete: () => {
              // Î≥¥Ïä§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
              this.gearTitanPosition = { x: targetX, y: targetY };

              // ÎèåÏßÑ ÏßÅÌõÑ Ï∂îÍ∞Ä ÏïïÎ∞ï (Î≥¥Ïä§ ÏúÑÏπòÏóêÏÑú ÏÇ¨Ï∂ú)
              this.time.delayedCall(150, () => {
                this.fireGearTitanSaw(this.gearTitanPosition.x, this.gearTitanPosition.y);
              });

              // Î≤ΩÏóê Î∂ÄÎî™ÌòÄÏÑú Ïä§ÌÑ¥ (Ï∑®ÏïΩ ÏÉÅÌÉú)
              this.cameras.main.shake(300, 0.03);
              this.makeGearTitanVulnerable();
            }
          });
        }
      }
    });
  }

  makeGearTitanVulnerable() {
    if (!this.gearTitanMode) return;

    this.gearTitanVulnerable = true;
    this.gearTitanPhase = 'vulnerable';

    const { width, height } = this.cameras.main;

    // HIT ÌÖçÏä§Ìä∏
    this.gearTitanHitText = this.add.text(width / 2, 100, 'HIT', {
      fontSize: '48px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: this.gearTitanHitText,
      alpha: { from: 1, to: 0.5 },
      scaleX: { from: 1, to: 1.2 },
      scaleY: { from: 1, to: 1.2 },
      duration: 300,
      yoyo: true,
      repeat: -1
    });

    // ÏΩîÏñ¥ ÏÉâÏÉÅ Î≥ÄÍ≤Ω (Ï¥àÎ°ùÏÉâ)
    if (this.gearTitanCore) {
      this.gearTitanCore.clear();
      this.gearTitanCore.fillStyle(0x004400, 1);
      this.gearTitanCore.fillCircle(0, 0, this.gridSize * 2 * 0.8);
      this.gearTitanCore.fillStyle(0x00ff00, 1);
      this.gearTitanCore.fillCircle(0, 0, this.gridSize * 2 * 0.5);
      this.gearTitanCore.fillStyle(0x000000, 1);
      this.gearTitanCore.fillCircle(0, 0, this.gridSize * 2 * 0.2);
      this.gearTitanCore.fillStyle(0xffffff, 1);
      this.gearTitanCore.fillCircle(0, -this.gridSize * 2 * 0.05, this.gridSize * 2 * 0.1);
    }

    // ÏßßÏùÄ Ï∑®ÏïΩ Ï∞Ω (Îçî Ïñ¥Î†§Ïö¥ ÎÇúÏù¥ÎèÑ)
    this.time.delayedCall(1800, () => {
      if (this.gearTitanHitText && this.gearTitanHitText.active) {
        this.gearTitanHitText.destroy();
        this.gearTitanHitText = null;
      }

      if (this.gearTitanMode && !this.gameOver) {
        this.gearTitanVulnerable = false;

        // ÏΩîÏñ¥ ÏÉâÏÉÅ Î≥µÏõê (Îπ®Í∞ÑÏÉâ)
        if (this.gearTitanCore) {
          this.gearTitanCore.clear();
          this.gearTitanCore.fillStyle(0x440000, 1);
          this.gearTitanCore.fillCircle(0, 0, this.gridSize * 2 * 0.8);
          this.gearTitanCore.fillStyle(0xff0000, 1);
          this.gearTitanCore.fillCircle(0, 0, this.gridSize * 2 * 0.5);
          this.gearTitanCore.fillStyle(0x000000, 1);
          this.gearTitanCore.fillCircle(0, 0, this.gridSize * 2 * 0.2);
          this.gearTitanCore.fillStyle(0xffff00, 1);
          this.gearTitanCore.fillCircle(0, -this.gridSize * 2 * 0.05, this.gridSize * 2 * 0.1);
        }

        // Îã§Ïùå Í≥µÍ≤© Ìå®ÌÑ¥
        this.advanceGearTitanPhase();
      }
    });
  }

  advanceGearTitanPhase() {
    if (this.gearTitanStunEndTime && this.time.now < this.gearTitanStunEndTime) {
      const remaining = this.gearTitanStunEndTime - this.time.now;
      this.time.delayedCall(remaining, () => {
        this.gearTitanStunEndTime = 0;
        this.advanceGearTitanPhase();
      });
      return;
    }

    const hitCount = this.gearTitanHitCount;
    const hitsNeeded = this.gearTitanHitsToKill || 4;
    const enrageThreshold = Math.max(2, hitsNeeded - 2);

    // Í¥ëÌè≠Ìôî Ï≤¥ÌÅ¨ (HP 25% Ïù¥Ìïò)
    if (hitCount >= enrageThreshold && this.gearTitanPhase !== 'enrage') {
      this.gearTitanEnrageMode();
      return;
    }

    // Ìå®ÌÑ¥ ÏàúÌôò (vulnerableÏóêÏÑúÎèÑ ÎßàÏßÄÎßâ Í≥µÍ≤© Ìå®ÌÑ¥ Í∏∞Ïñµ)
    const patterns = ['phase1', 'phase2', 'phase3'];

    // ÌòÑÏû¨ ÌéòÏù¥Ï¶àÍ∞Ä vulnerableÏù¥Î©¥ ÎßàÏßÄÎßâ Í≥µÍ≤© ÌéòÏù¥Ï¶à Í∏∞Ï§ÄÏúºÎ°ú Îã§Ïùå Ìå®ÌÑ¥ ÏÑ†ÌÉù
    let currentIdx;
    if (this.gearTitanPhase === 'vulnerable' || this.gearTitanPhase === 'none') {
      currentIdx = patterns.indexOf(this.lastAttackPhase || 'phase3'); // ÎßàÏßÄÎßâ Í≥µÍ≤© Í∏∞Ï§Ä
    } else {
      currentIdx = patterns.indexOf(this.gearTitanPhase);
    }

    const nextIdx = (currentIdx + 1) % patterns.length;
    this.gearTitanPhase = patterns[nextIdx];
    this.lastAttackPhase = this.gearTitanPhase; // ÎßàÏßÄÎßâ Í≥µÍ≤© Ìå®ÌÑ¥ Ï†ÄÏû•

    this.time.delayedCall(700, () => {
      switch (this.gearTitanPhase) {
        case 'phase1':
          this.gearTitanPhase1Attack();
          break;
        case 'phase2':
          this.gearTitanPhase2Attack();
          break;
        case 'phase3':
          this.gearTitanPhase3Attack();
          break;
      }
    });
  }

  gearTitanEnrageMode() {
    if (!this.gearTitanMode) return;

    this.gearTitanPhase = 'enrage';

    const { width, height } = this.cameras.main;

    // ENRAGE ÌÖçÏä§Ìä∏
    const enrageText = this.add.text(width / 2, height / 2, 'ENRAGE!', {
      fontSize: '72px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#660000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(1000, 0.04);

    // Î≥¥Ïä§ Îπ®Í∞ÑÏÉâ Ìã¥Ìä∏
    if (this.gearTitanContainer) {
      this.gearTitanGears.forEach(gear => {
        gear.clear();
        gear.fillStyle(0xff4400, 1);
        // Í∏∞Ïñ¥ Îã§Ïãú Í∑∏Î¶¨Í∏∞ (Îπ®Í∞ÑÏÉâ)
        const radius = this.gridSize * 2 * 0.8;
        gear.beginPath();
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const nextAngle = ((i + 0.5) / 12) * Math.PI * 2;
          const outerR = radius;
          const innerR = radius * 0.7;

          if (i === 0) {
            gear.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
          }
          gear.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
          gear.lineTo(Math.cos(nextAngle) * innerR, Math.sin(nextAngle) * innerR);
        }
        gear.closePath();
        gear.fill();
      });
    }

    this.tweens.add({
      targets: enrageText,
      alpha: 1,
      scaleX: { from: 2, to: 1 },
      scaleY: { from: 2, to: 1 },
      duration: 500,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.time.delayedCall(1000, () => {
          enrageText.destroy();

          // Í¥ëÌè≠Ìôî Í≥µÍ≤© (Î™®Îì† Ìå®ÌÑ¥ ÎèôÏãú)
          this.gearTitanPhase1Attack();
          this.time.delayedCall(500, () => this.gearTitanPhase2Attack());
          this.time.delayedCall(900, () => this.gearTitanPhase3Attack());
        });
      }
    });
  }

  // =====================
  // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ HIT/ÏäπÎ¶¨ Ï≤òÎ¶¨
  // =====================

  handleGearTitanHit(options = {}) {
    if (!this.gearTitanVulnerable) return;

    this.gearTitanHitCount++;
    this.gearTitanVulnerable = false;
    this.gearTitanStunEndTime = 0; // Ïä§ÌÑ¥ ÌÉÄÏù¥Î®∏ Ï¥àÍ∏∞Ìôî
    const hitsNeeded = this.gearTitanHitsToKill || 4;
    const { skipSnakePush = false, bounceOverride = null, forceDirection = null, resumeDelay = 800 } = options;

    // HIT ÌÖçÏä§Ìä∏ Ï†úÍ±∞
    if (this.gearTitanHitText && this.gearTitanHitText.active) {
      this.gearTitanHitText.destroy();
      this.gearTitanHitText = null;
    }

    // ÌûàÌä∏ ÌõÑ ÏùºÏãúÏ†Å Î¨¥Ï†Å (Î≥¥Ïä§ Ï∂©Îèå Î¨¥Ïãú)
    this.isInvincible = true;
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;
    const bossX = this.gearTitanPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.gearTitanPosition.y * this.gridSize + this.gridSize / 2 + 60;

    // === ÌÜµÏæåÌïú ÌûàÌä∏ Ïï†ÎãàÎ©îÏù¥ÏÖò ===

    // 1. Ïä¨Î°úÏö∞ Î™®ÏÖò Ìö®Í≥º (Ïû†Íπê)
    this.cameras.main.flash(200, 0, 255, 100, false);

    // 2. ÏûÑÌå©Ìä∏ ÎßÅ Ìö®Í≥º
    for (let i = 0; i < 3; i++) {
      const ring = this.add.graphics().setDepth(5002);
      ring.lineStyle(4 - i, 0x00ffff, 1);
      ring.strokeCircle(bossX, bossY, 10);

      this.tweens.add({
        targets: ring,
        scaleX: 4 + i * 2,
        scaleY: 4 + i * 2,
        alpha: 0,
        duration: 400,
        delay: i * 100,
        onComplete: () => ring.destroy()
      });
    }

    // 3. Ïä§ÌååÌÅ¨ Ìè≠Î∞ú
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      const spark = this.add.graphics().setDepth(5003);
      spark.fillStyle(Phaser.Math.RND.pick([0x00ffff, 0x00ff00, 0xffff00]), 1);
      spark.fillCircle(0, 0, Phaser.Math.Between(4, 8));
      spark.x = bossX;
      spark.y = bossY;

      this.tweens.add({
        targets: spark,
        x: bossX + Math.cos(angle) * Phaser.Math.Between(60, 120),
        y: bossY + Math.sin(angle) * Phaser.Math.Between(60, 120),
        alpha: 0,
        duration: 500,
        ease: 'Power2',
        onComplete: () => spark.destroy()
      });
    }

    // 4. HIT ÌÖçÏä§Ìä∏ (Îçî Ïó≠ÎèôÏ†ÅÏúºÎ°ú)
    const hitText = this.add.text(width / 2, height / 2, `CRITICAL HIT!`, {
      fontSize: '56px',
      fill: '#00ffff',
      fontStyle: 'bold',
      stroke: '#004466',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5010).setAlpha(0).setScale(3);

    this.tweens.add({
      targets: hitText,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 200,
      ease: 'Back.easeOut',
      onComplete: () => {
        // HIT Ïπ¥Ïö¥Ìä∏ ÌëúÏãú
        const countText = this.add.text(width / 2, height / 2 + 50, `${this.gearTitanHitCount}/${hitsNeeded}`, {
          fontSize: '36px',
          fill: '#ffcc00',
          fontStyle: 'bold'
        }).setOrigin(0.5).setDepth(5010);

        this.tweens.add({
          targets: [hitText, countText],
          alpha: 0,
          y: '-=30',
          duration: 800,
          delay: 500,
          onComplete: () => {
            hitText.destroy();
            countText.destroy();
          }
        });
      }
    });

    // 5. Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨ (Í∞ïÎ†•ÌïòÍ≤å)
    this.cameras.main.shake(400, 0.05);

    // 6. Î≥¥Ïä§ ÌîºÍ≤© Ìö®Í≥º (Îπ®Í∞Ñ ÌîåÎûòÏãú + Î∞ÄÎ†§ÎÇ®)
    if (this.gearTitanContainer) {
      // Îπ®Í∞ÑÏÉâÏúºÎ°ú ÍπúÎπ°
      this.gearTitanContainer.iterate(child => {
        if (child.setTint) child.setTint(0xff0000);
      });

      this.tweens.add({
        targets: this.gearTitanContainer,
        alpha: { from: 1, to: 0.2 },
        duration: 80,
        yoyo: true,
        repeat: 5,
        onComplete: () => {
          this.gearTitanContainer.iterate(child => {
            if (child.clearTint) child.clearTint();
          });
        }
      });
    }

    // 7. Î±ÄÏùÑ Î≥¥Ïä§Î°úÎ∂ÄÌÑ∞ Î∞ÄÏñ¥ÎÇ¥Í∏∞ (ÎåÄÏãú Ï†ÑÏö©Ïùº Îïê Ïä§ÌÇµ)
    if (!skipSnakePush) {
      const pushDir = {
        x: head.x - this.gearTitanPosition.x,
        y: head.y - this.gearTitanPosition.y
      };
      const pushDist = Math.sqrt(pushDir.x * pushDir.x + pushDir.y * pushDir.y);
      if (pushDist > 0) {
        pushDir.x /= pushDist;
        pushDir.y /= pushDist;
      } else {
        pushDir.x = 1;
        pushDir.y = 0;
      }

      // Î±ÄÏùÑ 4Ïπ∏ Î∞ÄÏñ¥ÎÉÑ
      const newX = Math.max(0, Math.min(this.cols - 1, Math.round(head.x + pushDir.x * 4)));
      const newY = Math.max(0, Math.min(this.rows - 1, Math.round(head.y + pushDir.y * 4)));
      this.snake[0] = { x: newX, y: newY };

      // 8. Î∞©Ìñ•ÏùÑ ÎèåÏßÑ Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú Î≥ÄÍ≤Ω
      const oppositeDirections = {
        'RIGHT': 'LEFT',
        'LEFT': 'RIGHT',
        'UP': 'DOWN',
        'DOWN': 'UP'
      };
      this.direction = oppositeDirections[this.direction] || this.direction;
      this.inputQueue = []; // ÏûÖÎ†• ÌÅê Ï¥àÍ∏∞Ìôî
    } else {
      // ÎåÄÏãú Ï†ÑÏö©: Ï†úÏûêÎ¶¨ Î≥µÍ∑Ä + Î∞òÎåÄ Î∞©Ìñ• Ï†ÑÌôò
      if (bounceOverride) {
        this.snake[0] = { x: bounceOverride.x, y: bounceOverride.y };
      }
      if (forceDirection) {
        this.direction = forceDirection;
      }
      this.inputQueue = [];

      // Î≥µÍ∑Ä ÏûîÏÉÅ
      if (bounceOverride) {
        const steps = Math.max(1, Math.abs(head.x - bounceOverride.x) + Math.abs(head.y - bounceOverride.y));
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const gx = Math.round(Phaser.Math.Linear(head.x, bounceOverride.x, t));
          const gy = Math.round(Phaser.Math.Linear(head.y, bounceOverride.y, t));
          this.createDashGhost(gx, gy, i * 18);
        }

        const landX = bounceOverride.x * this.gridSize + this.gridSize / 2;
        const landY = bounceOverride.y * this.gridSize + this.gridSize / 2 + 60;
        const landEffect = this.add.graphics().setDepth(98);
        landEffect.lineStyle(3, 0x00ffff, 1);
        landEffect.strokeCircle(landX, landY, 5);
        this.tweens.add({
          targets: landEffect,
          scaleX: 3,
          scaleY: 3,
          alpha: 0,
          duration: 250,
          onComplete: () => landEffect.destroy()
        });
      }
      this.draw();
    }

    // 9. Î¨¥Ï†Å Ìï¥Ï†ú Î∞è Í≤åÏûÑ Ïû¨Í∞ú
    this.time.delayedCall(resumeDelay, () => {
      this.isInvincible = false;

      // 4 HIT Ïãú ÏäπÎ¶¨
      if (this.gearTitanHitCount >= hitsNeeded) {
        this.showGearTitanVictory();
      } else {
        // Steam Gauge UI Ïû¨ÏÉùÏÑ± (ÎÇúÏù¥ÎèÑ Ï¶ùÍ∞Ä Î∞òÏòÅ)
        this.refreshSteamGaugeUI();

        // Í≤åÏûÑ Ïû¨Í∞ú
        this.moveTimer.paused = false;
        // Îã§Ïùå Í≥µÍ≤© Ìå®ÌÑ¥
        this.time.delayedCall(500, () => {
          this.advanceGearTitanPhase();
        });
      }
    });
  }

  // Steam Gauge UI Ïû¨ÏÉùÏÑ± (ÎÇúÏù¥ÎèÑ Ï¶ùÍ∞Ä Ïãú)
  refreshSteamGaugeUI() {
    // Í∏∞Ï°¥ UI Ï†ïÎ¶¨
    this.cleanupChargeUI();

    // ÏÉà ÎÇúÏù¥ÎèÑÎ°ú UI Ïû¨ÏÉùÏÑ±
    this.showChargeUI();

    // ÎÇúÏù¥ÎèÑ Ï¶ùÍ∞Ä ÏïåÎ¶º
    const { width, height } = this.cameras.main;
    const difficultyText = this.add.text(width / 2, height - 110, '‚ö†Ô∏è DIFFICULTY UP! ‚ö†Ô∏è', {
      fontSize: '16px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(1001);

    this.tweens.add({
      targets: difficultyText,
      y: height - 130,
      alpha: { from: 1, to: 0 },
      duration: 1500,
      ease: 'Power2',
      onComplete: () => difficultyText.destroy()
    });
  }

  showGearTitanVictory() {
    this.gearTitanPhase = 'victory';

    const { width, height } = this.cameras.main;

    // Î≥¥Ïä§ Ìè≠Î∞ú Ìö®Í≥º
    if (this.gearTitanContainer) {
      // Í∏∞Ïñ¥Îì§Ïù¥ Î∂ÑÌï¥ÎêòÏñ¥ ÎÇ†ÏïÑÍ∞ê
      this.gearTitanGears.forEach((gear, idx) => {
        const angle = (idx / 4) * Math.PI * 2;
        this.tweens.add({
          targets: gear,
          x: gear.x + Math.cos(angle) * 200,
          y: gear.y + Math.sin(angle) * 200,
          alpha: 0,
          rotation: Math.PI * 4,
          duration: 1000,
          ease: 'Power2'
        });
      });

      // ÏΩîÏñ¥ Ìè≠Î∞ú
      this.time.delayedCall(500, () => {
        const explosionX = this.gearTitanContainer.x;
        const explosionY = this.gearTitanContainer.y;

        // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
        for (let i = 0; i < 20; i++) {
          const particle = this.add.graphics();
          particle.setDepth(400);
          particle.fillStyle(Phaser.Math.RND.pick([0xff0000, 0xff6600, 0xffff00]), 1);
          particle.fillCircle(explosionX, explosionY, Phaser.Math.Between(5, 15));

          const angle = (i / 20) * Math.PI * 2;
          const dist = Phaser.Math.Between(50, 150);

          this.tweens.add({
            targets: particle,
            x: explosionX + Math.cos(angle) * dist,
            y: explosionY + Math.sin(angle) * dist,
            alpha: 0,
            duration: 800,
            onComplete: () => particle.destroy()
          });
        }

        // ÌôîÎ©¥ ÌîåÎûòÏãú
        const flash = this.add.rectangle(width / 2, height / 2, width, height, 0xffffff, 1);
        flash.setDepth(5000);
        this.tweens.add({
          targets: flash,
          alpha: 0,
          duration: 500,
          onComplete: () => flash.destroy()
        });

        // Ïª®ÌÖåÏù¥ÎÑà Ï†úÍ±∞
        this.gearTitanContainer.destroy();
        this.gearTitanContainer = null;
      });
    }

    // BOSS CLEAR ÌÖçÏä§Ìä∏
    this.time.delayedCall(1500, () => {
      const clearText = this.add.text(width / 2, height / 2 - 50, 'BOSS CLEAR!', {
        fontSize: '72px',
        fill: '#00ff00',
        fontStyle: 'bold',
        stroke: '#004400',
        strokeThickness: 8
      }).setOrigin(0.5).setDepth(5001).setAlpha(0);

      this.tweens.add({
        targets: clearText,
        alpha: 1,
        scaleX: { from: 2, to: 1 },
        scaleY: { from: 2, to: 1 },
        duration: 500,
        ease: 'Back.easeOut'
      });

      // +1000 BONUS
      this.time.delayedCall(500, () => {
        const bonusText = this.add.text(width / 2, height / 2 + 50, '+1000 BONUS!', {
          fontSize: '48px',
          fill: '#ffcc00',
          fontStyle: 'bold'
        }).setOrigin(0.5).setDepth(5001).setAlpha(0);

        this.tweens.add({
          targets: bonusText,
          alpha: 1,
          y: height / 2 + 30,
          duration: 500,
          onComplete: () => {
            // Ï†êÏàò Ï∂îÍ∞Ä
            this.score += 1000;
            this.scoreText.setText(this.score.toString());

            // Ï†ïÎ¶¨ Î∞è Îã§Ïùå Îã®Í≥Ñ
            this.time.delayedCall(2000, () => {
              clearText.destroy();
              bonusText.destroy();

              // ÏΩ§Î≥¥ Î≥µÏõê
              this.combo = this.savedCombo;
              this.comboShieldCount = this.savedComboShieldCount;
              if (this.combo > 0) {
                this.comboText.setText(`x${this.combo}`);
              }

              // Î≥¥Ïä§ Î™®Îìú Ï¢ÖÎ£å
              this.gearTitanMode = false;
              this.gearTitanPhase = 'none';
              this.bossMode = false;
              this.isBossStage = false;
              this.canChargeDash = false;
              this.cleanupChargeUI();

              // 12ÌÉÑ Î≥¥Ïä§ BGM Ï†ïÏßÄ ÌõÑ Í∏∞Î≥∏ BGMÏúºÎ°ú ÏõêÎ≥µ
              if (this.boss12Music && this.boss12Music.isPlaying) {
                this.boss12Music.stop();
              }
              if (this.bgMusic && !this.bgMusic.isPlaying) {
                this.bgMusic.play();
              }

              // ÏÉÅÏ†ê Ïò§Ìîà (Î±Ä Ï†êÌîÑ Ïï†ÎãàÎ©îÏù¥ÏÖò Ìè¨Ìï®)
              this.stageClear();
            });
          }
        });
      });
    });
  }

  startDeadZoneSequence() {
    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // ÎûúÎç§ ÏúÑÏπò ÏÑ†ÌÉù (Î±Ä/Î®πÏù¥ÏôÄ Í≤πÏπòÏßÄ ÏïäÎäî Í≥≥)
    let deadZonePos;
    let validPosition = false;

    while (!validPosition) {
      deadZonePos = {
        x: Phaser.Math.Between(0, this.cols - 1),
        y: Phaser.Math.Between(0, this.rows - 1)
      };

      // Î±ÄÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnSnake = !this.snake.some(segment =>
        segment.x === deadZonePos.x && segment.y === deadZonePos.y
      );

      // Î®πÏù¥ÏôÄ Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
      const notOnFood = !(deadZonePos.x === this.food.x && deadZonePos.y === this.food.y);

      // Î±ÄÏùò ÏßÑÌñâÎ∞©Ìñ• Î∞îÎ°ú ÏïûÏóê ÏÉùÍ∏∞ÏßÄ ÏïäÍ≤å Ï≤¥ÌÅ¨
      const snakeHead = this.snake[0];
      let nextX = snakeHead.x;
      let nextY = snakeHead.y;
      switch (this.direction) {
        case 'LEFT': nextX -= 1; break;
        case 'RIGHT': nextX += 1; break;
        case 'UP': nextY -= 1; break;
        case 'DOWN': nextY += 1; break;
      }
      const notInFrontOfSnake = !(deadZonePos.x === nextX && deadZonePos.y === nextY);

      validPosition = notOnSnake && notOnFood && notInFrontOfSnake;
    }

    // ÍπúÎπ°Ïù¥Îäî ÏÇ¨Í∞ÅÌòï ÏÉùÏÑ±
    const rect = this.add.rectangle(
      deadZonePos.x * this.gridSize + this.gridSize / 2,
      deadZonePos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
      this.gridSize - 2,
      this.gridSize - 2,
      0x000000,
      1
    );
    rect.setDepth(50);

    // ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò (10Î≤à, 1.5Ï¥à)
    let blinkCount = 0;
    const blinkTimer = this.time.addEvent({
      delay: 150,
      callback: () => {
        rect.setVisible(!rect.visible);
        blinkCount++;

        if (blinkCount >= 10) {
          blinkTimer.remove();
          rect.setVisible(true);
          rect.setFillStyle(0x000000, 1);

          // Í≤ΩÍ≥† Î©îÏãúÏßÄ ÌëúÏãú
          this.showDeadZoneWarning(rect, deadZonePos);
        }
      },
      loop: true
    });
  }

  showDeadZoneWarning(rect, deadZonePos) {
    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2, '', {
      fontSize: '32px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2000);

    const message = 'THIS WILL KILL YOU!';
    let charIndex = 0;

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    const typingTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        if (charIndex < message.length) {
          warningText.setText(message.substring(0, charIndex + 1));
          charIndex++;
        } else {
          typingTimer.remove();
          // ÌÉÄÏù¥Ìïë ÏôÑÎ£å ÌõÑ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
          this.time.delayedCall(500, () => {
            warningText.destroy();
            this.startCountdownAndResume(rect, deadZonePos);
          });
        }
      },
      loop: true
    });
  }

  startCountdownAndResume(rect, deadZonePos) {
    const { width, height } = this.cameras.main;

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏
    const countdownText = this.add.text(width / 2, height / 2, '3', {
      fontSize: '64px',
      fill: '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2000);

    let countdown = 3;
    const countdownTimer = this.time.addEvent({
      delay: 600,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          countdownText.setText(countdown.toString());
        } else {
          countdownText.setText('GO!');
          countdownTimer.remove();

          // GO! ÌëúÏãú ÌõÑ Í≤åÏûÑ Ïû¨Í∞ú
          this.time.delayedCall(400, () => {
            countdownText.destroy();

            // Îç∞ÎìúÏ°¥ Ï†ÄÏû•
            this.deadZones.push({
              x: deadZonePos.x,
              y: deadZonePos.y,
              rect: rect
            });

            // Í≤åÏûÑ Ïû¨Í∞ú
            this.moveTimer.paused = false;
          });
        }
      },
      loop: true
    });
  }

  addDeadZonesForStage4() {
    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // 3Í∞úÏùò Îç∞ÎìúÏ°¥ ÏúÑÏπò Ï∞æÍ∏∞
    const deadZonePositions = [];
    for (let i = 0; i < 3; i++) {
      let deadZonePos;
      let validPosition = false;

      while (!validPosition) {
        deadZonePos = {
          x: Phaser.Math.Between(0, this.cols - 1),
          y: Phaser.Math.Between(0, this.rows - 1)
        };

        // Î±ÄÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
        const notOnSnake = !this.snake.some(segment =>
          segment.x === deadZonePos.x && segment.y === deadZonePos.y
        );

        // Î®πÏù¥ÏôÄ Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ
        const notOnFood = !(deadZonePos.x === this.food.x && deadZonePos.y === this.food.y);

        // Î±ÄÏùò ÏßÑÌñâÎ∞©Ìñ• Î∞îÎ°ú ÏïûÏóê ÏÉùÍ∏∞ÏßÄ ÏïäÍ≤å Ï≤¥ÌÅ¨
        const snakeHead = this.snake[0];
        let nextX = snakeHead.x;
        let nextY = snakeHead.y;
        switch (this.direction) {
          case 'LEFT': nextX -= 1; break;
          case 'RIGHT': nextX += 1; break;
          case 'UP': nextY -= 1; break;
          case 'DOWN': nextY += 1; break;
        }
        const notInFrontOfSnake = !(deadZonePos.x === nextX && deadZonePos.y === nextY);

        // Í∏∞Ï°¥ Îç∞ÎìúÏ°¥Í≥º Ï∂©Î∂ÑÌûà Îñ®Ïñ¥Ï†∏ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨ (Îß®Ìï¥Ìäº Í±∞Î¶¨ 5Ïπ∏ Ïù¥ÏÉÅ)
        const farFromOtherDeadZones = [...this.deadZones, ...deadZonePositions].every(dz => {
          const distance = Math.abs(dz.x - deadZonePos.x) + Math.abs(dz.y - deadZonePos.y);
          return distance >= 5;
        });

        validPosition = notOnSnake && notOnFood && notInFrontOfSnake && farFromOtherDeadZones;
      }

      deadZonePositions.push(deadZonePos);
    }

    // 2Í∞úÏùò ÍπúÎπ°Ïù¥Îäî ÏÇ¨Í∞ÅÌòï ÏÉùÏÑ±
    const blinkRects = deadZonePositions.map(pos => {
      const rect = this.add.rectangle(
        pos.x * this.gridSize + this.gridSize / 2,
        pos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
        this.gridSize - 2,
        this.gridSize - 2,
        0x000000,
        1
      );
      rect.setDepth(50);
      return { rect, pos };
    });

    // 2Í∞ú ÎèôÏãú ÍπúÎπ°ÏûÑ (10Î≤à, 1.5Ï¥à)
    let blinkCount = 0;
    const blinkTimer = this.time.addEvent({
      delay: 150,
      callback: () => {
        blinkRects.forEach(({ rect }) => {
          rect.setVisible(!rect.visible);
        });
        blinkCount++;

        if (blinkCount >= 10) {
          blinkTimer.remove();
          blinkRects.forEach(({ rect }) => {
            rect.setVisible(true);
            rect.setFillStyle(0x000000, 1);
          });

          // Í≤ΩÍ≥† Î©îÏãúÏßÄ ÌëúÏãú
          this.showStage4Warning(() => {
            // Îç∞ÎìúÏ°¥ Ï†ÄÏû•
            blinkRects.forEach(({ rect, pos }) => {
              this.deadZones.push({
                x: pos.x,
                y: pos.y,
                rect: rect
              });
            });

            // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ Í≤åÏûÑ Ïû¨Í∞ú
            this.startCountdownAndResumeStage4();
          });
        }
      },
      loop: true
    });
  }

  showStage4Warning(onComplete) {
    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2, '', {
      fontSize: '32px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2000);

    const message = 'THIS TOO SHALL KILL YOU!';
    let charIndex = 0;

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    const typingTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        if (charIndex < message.length) {
          warningText.setText(message.substring(0, charIndex + 1));
          charIndex++;
        } else {
          typingTimer.remove();
          // ÌÉÄÏù¥Ìïë ÏôÑÎ£å ÌõÑ ÏΩúÎ∞± Ïã§Ìñâ
          this.time.delayedCall(500, () => {
            warningText.destroy();
            onComplete();
          });
        }
      },
      loop: true
    });
  }

  startCountdownAndResumeStage4() {
    const { width, height } = this.cameras.main;

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏
    const countdownText = this.add.text(width / 2, height / 2, '3', {
      fontSize: '64px',
      fill: '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2000);

    let countdown = 3;
    const countdownTimer = this.time.addEvent({
      delay: 600,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          countdownText.setText(countdown.toString());
        } else {
          countdownText.setText('GO!');
          countdownTimer.remove();

          // GO! ÌëúÏãú ÌõÑ Í≤åÏûÑ Ïû¨Í∞ú
          this.time.delayedCall(400, () => {
            countdownText.destroy();
            // Í≤åÏûÑ Ïû¨Í∞ú
            this.moveTimer.paused = false;
          });
        }
      },
      loop: true
    });
  }

  // Î™®Îì† Îç∞ÎìúÏ°¥ÏùÑ ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖòÍ≥º Ìï®Íªò Ï†úÍ±∞ (ÌÉÑÎßâÎ≥¥Ïä§ ÏãúÏûë Ïãú)
  destroyAllDeadZonesWithAnimation() {
    if (!this.deadZones || this.deadZones.length === 0) return;

    const { width, height } = this.cameras.main;

    // Í∞Å Îç∞ÎìúÏ°¥Ïóê ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
    this.deadZones.forEach((dz, index) => {
      if (!dz.rect) return;

      const dzX = dz.x * this.gridSize + this.gridSize / 2;
      const dzY = this.gameAreaY + dz.y * this.gridSize + this.gridSize / 2;

      // ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥Î•º ÎëêÍ≥† ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÌååÍ¥¥
      this.time.delayedCall(index * 80, () => {
        // 1. Îπ®Í∞Ñ ÌîåÎûòÏãú
        this.tweens.add({
          targets: dz.rect,
          fillColor: { from: 0x000000, to: 0xff0000 },
          duration: 100,
          yoyo: true,
          repeat: 2
        });

        // 2. ÌååÍ¥¥ ÌååÌã∞ÌÅ¥ (Îπ®Í∞ÑÏÉâ + Í≤ÄÏùÄÏÉâ Ï°∞Í∞ÅÎì§)
        this.time.delayedCall(300, () => {
          // ÌååÌé∏ ÌååÌã∞ÌÅ¥
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const speed = 60 + Math.random() * 40;
            const particle = this.add.rectangle(
              dzX, dzY,
              6 + Math.random() * 4,
              6 + Math.random() * 4,
              i % 2 === 0 ? 0xff0000 : 0x000000
            ).setDepth(2000);

            this.tweens.add({
              targets: particle,
              x: dzX + Math.cos(angle) * speed,
              y: dzY + Math.sin(angle) * speed,
              alpha: 0,
              rotation: Math.random() * Math.PI * 2,
              scale: 0,
              duration: 400,
              ease: 'Power2',
              onComplete: () => particle.destroy()
            });
          }

          // Ï∂©Í≤©Ìåå ÎßÅ
          const shockwave = this.add.circle(dzX, dzY, 5, 0xff0000, 0.8)
            .setDepth(1999).setStrokeStyle(2, 0xffff00);
          this.tweens.add({
            targets: shockwave,
            radius: 30,
            alpha: 0,
            duration: 300,
            ease: 'Power2',
            onComplete: () => shockwave.destroy()
          });

          // Îç∞ÎìúÏ°¥ rect Ï†úÍ±∞
          if (dz.rect) {
            this.tweens.add({
              targets: dz.rect,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 200,
              onComplete: () => {
                dz.rect.destroy();
                dz.rect = null;
              }
            });
          }
        });
      });
    });

    // Î™®Îì† Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÌõÑ Î∞∞Ïó¥ ÎπÑÏö∞Í∏∞
    const totalDelay = this.deadZones.length * 80 + 600;
    this.time.delayedCall(totalDelay, () => {
      this.deadZones = [];
    });
  }

  draw() {
    // Runner Î™®ÎìúÏóêÏÑúÎäî Î±Ä Í∑∏Î¶¨Í∏∞ Ïä§ÌÇµ (Ìù∞ Î±ÄÏùÄ Î≥ÑÎèÑ Î†åÎçîÎßÅ)
    if (this.runnerMode) {
      return;
    }

    // Quantum Split Î™®ÎìúÏóêÏÑúÎäî RenderTexture Í∏∞Î∞ò Î†åÎçîÎßÅ
    if (this.quantumSplitMode) {
      this.drawQuantumViewports();
      return;
    }

    // Multiverse Collapse Phase 3: ÏúµÌï© Î±ÄÏùÄ Î≥ÑÎèÑ Î†åÎçîÎßÅ
    if (this.multiverseCollapseMode && this.multiverseCollapsePhase === 'becomeone') {
      // drawFusionSnakeÍ∞Ä ÎèÖÎ¶Ω ÌÉÄÏù¥Î®∏ÏóêÏÑú Ìò∏Ï∂úÎê®
      return;
    }

    // Ïù¥Ï†Ñ ÌîÑÎ†àÏûÑ ÏßÄÏö∞Í∏∞
    if (this.graphics) {
      this.graphics.clear();
      // Í∑∏ÎûòÌîΩÏù¥ Ïà®Í≤®Ï†∏ ÏûàÏúºÎ©¥ Îã§Ïãú Î≥¥Ïù¥Í≤å (hideSnakeGraphics ÌõÑ Î≥µÍµ¨)
      // Îã®, Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ï§ëÏù¥Î©¥ Ïà®Í∏¥ ÏÉÅÌÉú Ïú†ÏßÄ
      if (!this.graphics.visible && !this.isStageClearingAnimation && !this.runnerMode) {
        this.graphics.setVisible(true);
      }
    } else {
      this.graphics = this.add.graphics();
    }

    // Î¨¥Ï†Å ÍπúÎπ°ÏûÑ Ï§ëÏù¥Î©¥ ÏùºÎ∂Ä ÌîÑÎ†àÏûÑÏóêÏÑú Î±Ä Í∑∏Î¶¨Í∏∞ Ïä§ÌÇµ
    // ÎåÄÏãú Ï§ëÏóêÎèÑ Î±Ä Ïà®Í∏∞Í∏∞ (ÎåÄÏãú Ïï†ÎãàÎ©îÏù¥ÏÖò ÌëúÏãú)
    const skipSnakeDraw = (this.invincibilityBlinkActive && this.invincibilityBlinkCount % 2 === 1) || this.dashingHideSnake;

    // Î±Ä Í∑∏Î¶¨Í∏∞ (Î¨¥Ï†Å ÍπúÎπ°ÏûÑ Ï§ëÏóêÎäî Ïä§ÌÇµ)
    if (!skipSnakeDraw) {
      this.snake.forEach((segment, index) => {
        // Meta Universe Ïä§Ìè∞ Ïï†ÎãàÎ©îÏù¥ÏÖò: ÏïåÌåå Ï≤¥ÌÅ¨
        const segmentAlpha = this.snakeSegmentAlphas ? this.snakeSegmentAlphas[index] : 1;
        if (segmentAlpha <= 0) return; // ÏïåÌååÍ∞Ä 0Ïù¥Î©¥ Í∑∏Î¶¨ÏßÄ ÏïäÏùå

        // Í∏ÄÎ°úÏö∞ Ìö®Í≥º (Í∞ïÌïú Ìö®Í≥ºÏùº Îïå)
        if (this.snakeGlow) {
          this.graphics.fillStyle(0xff0000, 0.3 * segmentAlpha);
          this.graphics.fillCircle(
            segment.x * this.gridSize + this.gridSize / 2,
            segment.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
            this.gridSize
          );
        }

        if (index === 0) {
          // Î®∏Î¶¨ ÏÉâÏÉÅ
          if (this.snakePoisoned) {
            // Î≥¥Ïä§Ï†Ñ ÎèÖ ÏÉÅÌÉú - Î≥¥ÎùºÏÉâ
            this.graphics.fillStyle(0x9900ff, segmentAlpha);
          } else if (this.comboShieldCount > 0 && !this.comboDisabled) {
            // ÏΩ§Î≥¥ Ïã§ÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÎÖ∏ÎûÄÏÉâ - ÏàòÌä∏ Í∏∞Îä• (Meta UniverseÏóêÏÑúÎäî ÎπÑÌôúÏÑ±Ìôî)
            this.graphics.fillStyle(0xffff00, segmentAlpha);
          } else if (this.snakeHeadTint) {
            this.graphics.fillStyle(this.snakeHeadTint, segmentAlpha);
          } else if (this.snakeBodyTint) {
            this.graphics.fillStyle(this.snakeBodyTint, segmentAlpha);
          } else {
            this.graphics.fillStyle(0x00ff00, segmentAlpha);
          }
        } else {
          // Î™∏ÌÜµ ÏÉâÏÉÅ
          if (this.snakePoisoned) {
            // Î≥¥Ïä§Ï†Ñ ÎèÖ ÏÉÅÌÉú - Î≥¥ÎùºÏÉâ
            this.graphics.fillStyle(0x7700cc, segmentAlpha);
          } else if (this.snakeBodyTint) {
            this.graphics.fillStyle(this.snakeBodyTint, segmentAlpha);
          } else {
            this.graphics.fillStyle(0x00aa00, segmentAlpha);
          }
        }

        this.graphics.fillRect(
          segment.x * this.gridSize + 1,
          segment.y * this.gridSize + 1 + this.gameAreaY,
          this.gridSize - 2,
          this.gridSize - 2
        );
      });
    }

    // Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑÎäî Î≥ÑÎèÑ ÌÉÄÏù¥Î®∏ÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏ (60fps Î∂ÄÎìúÎü¨Ïö¥ Ïï†ÎãàÎ©îÏù¥ÏÖò)

    // Î®πÏù¥ Í∑∏Î¶¨Í∏∞ (Î≥¥Ïä§ ÏöîÏÜåÍ∞Ä ÏûàÍ±∞ÎÇò NEXUS Î™®ÎìúÎ©¥ Í±¥ÎÑàÎõ∞Í∏∞)
    if (!this.bossElement && !this.fogBossMode && !this.nexusMode && this.food) {
      const isFinalFood = this.foodCount === 19; // Îã§Ïùå Î®πÏù¥Í∞Ä 20Î≤àÏß∏ (ÎßàÏßÄÎßâ)
      this.graphics.fillStyle(isFinalFood ? 0x00ff00 : 0xff0000);
      this.graphics.fillCircle(
        this.food.x * this.gridSize + this.gridSize / 2,
        this.food.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
        this.gridSize / 2 - 2
      );
    }

    this.updateFogOfWar();
    this.updateStage8BlackoutSnakeOverlay();
  }

  shouldUseFog() {
    // World 2 (Stage 7-9)ÏóêÏÑúÎßå ÏïàÍ∞ú ÌôúÏÑ±Ìôî
    return this.fogTestForceEnable || shouldHaveFog(this.currentStage);
  }

  isFogOfWarActive() {
    if (this.gameOver) return false;
    return this.shouldUseFog() && this.fogEnabled;
  }

  ensureFogAssets() {
    if (!this.fogRenderTexture) {
      const { width, height } = this.cameras.main;
      this.fogRenderTexture = this.add.renderTexture(0, 0, width, height);
      this.fogRenderTexture.setOrigin(0, 0);
      this.fogRenderTexture.setDepth(1200); // Í≤åÏûÑ Ïò§Î∏åÏ†ùÌä∏ ÏúÑ, UI ÏïÑÎûò
      this.fogRenderTexture.setScrollFactor(0);
    }

    if (!this.fogLightSprite) {
      const lightRadius = this.gridSize * this.fogVisibleTiles;
      const textureSize = Math.ceil(lightRadius * 2);
      const textureKey = `${this.fogLightTextureKey}_v2`;

      if (!this.textures.exists(textureKey)) {
        const g = this.make.graphics({ x: 0, y: 0, add: false });
        const steps = 12;
        for (let i = 0; i < steps; i++) {
          const t = i / (steps - 1);
          const alpha = Math.pow(t, 1.8); // Ï§ëÏã¨Î∂ÄÎäî Î∞ùÍ≤å, Î∞îÍπ•ÏùÄ Í∏âÍ≤©Ìûà Ïñ¥Îë°Í≤å
          const radius = lightRadius * (1 - 0.85 * t);
          g.fillStyle(0xffffff, alpha);
          g.fillCircle(lightRadius, lightRadius, radius);
        }
        // ÏôÑÏ†ÑÌïú Î∞ùÍ∏∞Ïùò ÏûëÏùÄ ÏΩîÏñ¥Î°ú ÌÜ†Ïπò ÎäêÎÇå Í∞ïÌôî
        g.fillStyle(0xffffff, 1);
        g.fillCircle(lightRadius, lightRadius, lightRadius * 0.14);
        g.generateTexture(textureKey, textureSize, textureSize);
        g.destroy();
      }

      this.fogLightSprite = this.add.image(0, 0, textureKey);
      this.fogLightSprite.setOrigin(0.5);
      this.fogLightSprite.setVisible(false); // renderTexture.eraseÏóêÏÑúÎßå ÏÇ¨Ïö©
    }
  }

  resetFogOfWar() {
    this.fogFlashEndTime = 0;
    this.fogLastRenderKey = null;
    if (this.fogRenderTexture) {
      this.fogRenderTexture.clear();
      this.fogRenderTexture.setVisible(false);
    }
  }

  triggerFogFlash() {
    if (!this.isFogOfWarActive()) return;
    if (!this.fogTorchEnabled) return;
    this.fogFlashEndTime = this.time.now + this.fogFlashDuration;

    // Ïù¥ÎèôÏù¥ Î©àÏ∂∞ÏûàÎäî ÏÉÅÌô©(Ïù∏Ìä∏Î°ú/Ïó∞Ï∂ú)ÏóêÏÑúÎèÑ ÌîåÎûòÏãú Ï¢ÖÎ£å ÌõÑ Îã§Ïãú Ïñ¥ÎëêÏõåÏßÄÎèÑÎ°ù Î≥¥Ï†ï
    if (this.fogFlashUpdateTimer) {
      if (this.fogFlashUpdateTimer.destroy) this.fogFlashUpdateTimer.destroy();
      else if (this.fogFlashUpdateTimer.remove) this.fogFlashUpdateTimer.remove();
      this.fogFlashUpdateTimer = null;
    }

    this.fogFlashUpdateTimer = this.time.delayedCall(this.fogFlashDuration + 30, () => {
      this.fogFlashUpdateTimer = null;
      if (!this.isFogOfWarActive()) return;
      if (!this.fogTorchEnabled) return;
      this.fogLastRenderKey = null;
      this.updateFogOfWar();
    });
  }

  startFogIntroIfNeeded() {
    if (this.fogIntroPlaying) {
      return;
    }

    if (this.fogIntroShown || !this.shouldUseFog()) {
      this.fogEnabled = this.shouldUseFog();
      this.fogTorchEnabled = this.fogEnabled;
      if (this.fogEnabled) {
        this.draw(); // Î±ÄÏù¥ ÏïàÎ≥¥Ïù¥Îäî Î≤ÑÍ∑∏ ÏàòÏ†ï - fog ÌôúÏÑ±Ìôî ÌõÑ Îã§Ïãú Í∑∏Î¶¨Í∏∞
      }
      return;
    }

    // Ïù∏Ìä∏Î°ú Ï§ëÏóêÎäî ÌôîÎ©¥Ïù¥ ÏôÑÏ†Ñ Ïñ¥Îë°Í≤å Ïú†ÏßÄÎêòÎèÑÎ°ù, ÏïàÍ∞ú(Í≤ÄÏ†ï) Î†àÏù¥Ïñ¥Î•º Î®ºÏ†Ä ÍπîÏïÑÎëîÎã§
    this.fogEnabled = true;
    this.fogTorchEnabled = false;
    this.fogIntroPlaying = true;
    if (this.moveTimer) {
      this.moveTimer.paused = true;
    }
    this.resetFogOfWar();
    this.ensureFogAssets();
    this.updateFogOfWar();

    this.destroyAllSaws();

    const { width, height } = this.cameras.main;
    const flickerOverlayDepth = 6000;
    const introDialogueDepth = 6200;
    const flickerOverlay = this.add.rectangle(
      0,
      0,
      width,
      height,
      0x000000,
      0
    ).setOrigin(0, 0).setDepth(flickerOverlayDepth).setScrollFactor(0).setVisible(true);

    const flickerSteps = [
      { alpha: 1.0, duration: 140 },
      { alpha: 0.55, duration: 140 },
      { alpha: 1.0, duration: 140 },
      { alpha: 0.45, duration: 140 },
      { alpha: 1.0, duration: 160 }
    ];

    const applyOverlayAlpha = (a) => {
      flickerOverlay.setVisible(true);
      flickerOverlay.setFillStyle(0x000000, a);
      flickerOverlay.setAlpha(a);
    };

    const showExclaim = () => {
      const head = this.snake[0];
      if (!head) return;
      const headX = head.x * this.gridSize + this.gridSize / 2;
      const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY - this.gridSize * 1.2;
      const mark = this.add.text(headX, headY, '!', {
        fontSize: '26px',
        fontStyle: 'bold',
        fill: '#ffcc00',
        stroke: '#000000',
        strokeThickness: 3
      }).setOrigin(0.5).setDepth(introDialogueDepth);
      mark.setScale(0);
      this.tweens.add({
        targets: mark,
        scale: 1.2,
        alpha: 1,
        duration: 150,
        ease: 'Back.easeOut',
        yoyo: true,
        hold: 80,
        onComplete: () => mark.destroy()
      });
    };

    const playSpark = (power = 1) => {
      const head = this.snake[0];
      if (!head) return;
      const headX = head.x * this.gridSize + this.gridSize / 2;
      const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
      const jitter = this.gridSize * 0.15;
      const spark = this.add.circle(
        headX + Phaser.Math.FloatBetween(-jitter, jitter),
        headY - this.gridSize * 0.4 + Phaser.Math.FloatBetween(-jitter, jitter),
        this.gridSize * 0.18 * (1 + power * 0.6),
        0xffcc55,
        1
      ).setDepth(introDialogueDepth + 1);
      spark.setStrokeStyle(2, 0xff8800, 0.9);
      this.tweens.add({
        targets: spark,
        scale: 1.4 + power * 0.4,
        alpha: 0,
        duration: 160 + power * 80,
        ease: 'Cubic.easeOut',
        onComplete: () => spark.destroy()
      });
    };

    const playFlicker = (idx = 0) => {
      if (idx >= flickerSteps.length) {
        // ÏôÑÏ†Ñ Ïñ¥Îë† Ïú†ÏßÄ
        applyOverlayAlpha(1);
        // Ìò∏Í∏∞Ïã¨ ÎåÄÏÇ¨ (Î≥¥Ïä§ ÎßêÌíçÏÑ†Ïù¥ ÏïÑÎãå Î±Ä ÎßêÌíçÏÑ† Ïä§ÌÉÄÏùº)
        const head = this.snake[0];
        const headX = head.x * this.gridSize + this.gridSize / 2;
        const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
        this.showSnakeStyleDialogue('What the...?', () => {
          // ÌöÉÎ∂à Ï†êÌôî ÏãúÎèÑ 2Ìöå ÌõÑ ÏÑ±Í≥µ
          const tryIgnite = attempt => {
            if (attempt < 2) {
              playSpark(0.4);
              this.tweens.add({
                targets: flickerOverlay,
                alpha: 0.7,
                duration: 130,
                yoyo: true,
                ease: 'Sine.easeInOut'
              });
              this.time.delayedCall(260, () => tryIgnite(attempt + 1));
            } else {
              // ÎßàÏßÄÎßâ Ï†êÌôî ÏÑ±Í≥µ
              playSpark(1.2);
              this.fogTorchEnabled = true;
              this.triggerFogFlash();
              this.fogLastRenderKey = null;
              this.updateFogOfWar();
              this.tweens.add({
                targets: flickerOverlay,
                alpha: 0,
                duration: 240,
                ease: 'Sine.easeOut',
                onComplete: () => flickerOverlay.destroy()
              });
              // Ïû†Ïãú Î©àÏπ´ ÌõÑ ÏãúÏûë ÎåÄÏÇ¨
              this.time.delayedCall(420, () => {
                this.showSnakeStyleDialogue("Okay... let's give this a shot!", () => {
                  this.fogIntroPlaying = false;
                  this.fogIntroShown = true;
                  if (this.moveTimer) {
                    this.moveTimer.paused = false;
                  }
                  this.draw(); // Î±ÄÏù¥ ÏïàÎ≥¥Ïù¥Îäî Î≤ÑÍ∑∏ ÏàòÏ†ï - fog ÌôúÏÑ±Ìôî ÌõÑ Îã§Ïãú Í∑∏Î¶¨Í∏∞
                }, { x: headX, y: headY - this.gridSize * 1.8, depth: introDialogueDepth, fontSize: '14px' });
              }, null, this);
            }
          };
          tryIgnite(0);
        }, { x: headX, y: headY - this.gridSize * 1.8, depth: introDialogueDepth, fontSize: '14px' });
        return;
      }

      if (idx === 0) {
        applyOverlayAlpha(1);
        showExclaim();
      }

      const step = flickerSteps[idx];
      applyOverlayAlpha(step.alpha);
      this.time.delayedCall(step.duration, () => playFlicker(idx + 1));
    };

    // Î∞îÎ°ú ÍπúÎπ°ÏûÑ ÏãúÏûë
    playFlicker(0);
  }

  updateFogOfWar() {
    if (!this.isFogOfWarActive()) {
      if (this.fogRenderTexture) {
        this.fogRenderTexture.setVisible(false);
      }
      return;
    }

    if (!this.snake || this.snake.length === 0) return;

    this.ensureFogAssets();

    const head = this.snake[0];
    const headPixelX = head.x * this.gridSize + this.gridSize / 2;
    const headPixelY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    const { width, height } = this.cameras.main;
    const fogHeight = Math.max(0, height - this.gameAreaY - this.bottomUIHeight);

    const torchEnabled = !!this.fogTorchEnabled;
    let alpha = this.fogBaseAlpha;
    let scale = 1;

    if (torchEnabled && this.fogFlashEndTime > this.time.now) {
      const remaining = this.fogFlashEndTime - this.time.now;
      const t = 1 - remaining / this.fogFlashDuration;
      const eased = Phaser.Math.Easing.Quadratic.InOut(Phaser.Math.Clamp(t, 0, 1));
      alpha = Phaser.Math.Linear(this.fogFlashAlpha, this.fogBaseAlpha, eased);
      scale = Phaser.Math.Linear(1.25, 1, eased);
    }

    if (!torchEnabled) {
      alpha = 1;
      scale = 1;
    }

    const renderKey = `${head.x},${head.y},${torchEnabled ? 1 : 0},${alpha.toFixed(3)},${scale.toFixed(2)}`;
    if (this.fogLastRenderKey === renderKey) {
      this.fogRenderTexture.setVisible(true);
      return;
    }
    this.fogLastRenderKey = renderKey;

    this.fogRenderTexture.clear();
    this.fogRenderTexture.fill(0x000000, alpha, 0, this.gameAreaY, width, fogHeight);

    if (torchEnabled) {
      this.fogLightSprite.setScale(scale);
      this.fogRenderTexture.erase(this.fogLightSprite, headPixelX, headPixelY);
    }
    this.fogRenderTexture.setVisible(true);
  }

  // ===== Stage 8: Torch Blackout =====
  startStage8BlackoutCycleIfNeeded() {
    if (this.currentStage !== 8) return;
    if (!this.shouldUseFog()) return;
    if (this.foodCount < 10) return;
    if (this.stage8BlackoutCycleStarted) return;

    this.stage8BlackoutCycleStarted = true;
    this.scheduleNextStage8Blackout();
  }

  stopStage8BlackoutCycle() {
    this.stage8BlackoutCycleStarted = false;
    this.stage8BlackoutActive = false;

    if (this.stage8BlackoutTimer) {
      if (this.stage8BlackoutTimer.destroy) this.stage8BlackoutTimer.destroy();
      else if (this.stage8BlackoutTimer.remove) this.stage8BlackoutTimer.remove();
      this.stage8BlackoutTimer = null;
    }

    if (this.stage8BlackoutEndTimer) {
      if (this.stage8BlackoutEndTimer.destroy) this.stage8BlackoutEndTimer.destroy();
      else if (this.stage8BlackoutEndTimer.remove) this.stage8BlackoutEndTimer.remove();
      this.stage8BlackoutEndTimer = null;
    }

    if (this.stage8BlackoutSnakeGraphics) {
      this.stage8BlackoutSnakeGraphics.clear();
      this.stage8BlackoutSnakeGraphics.setVisible(false);
    }

    // Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ/Ïû¨ÏãúÏûëÏùÑ ÏúÑÌï¥ Í∏∞Î≥∏ Î≥µÍµ¨
    this.fogTorchEnabled = true;
    this.fogLastRenderKey = null;
  }

  scheduleNextStage8Blackout() {
    if (!this.stage8BlackoutCycleStarted) return;
    if (this.currentStage !== 8) return;
    if (this.gameOver) return;
    if (this.stage8BlackoutActive) return;

    const delay = Phaser.Math.Between(4000, 7000);
    this.stage8BlackoutTimer = this.time.delayedCall(delay, () => {
      this.beginStage8Blackout();
    });
  }

  beginStage8Blackout() {
    if (!this.stage8BlackoutCycleStarted) return;
    if (this.currentStage !== 8) return;
    if (this.gameOver) return;
    if (this.stage8BlackoutActive) return;
    if (!this.shouldUseFog()) return;

    this.stage8BlackoutActive = true;
    this.fogTorchEnabled = false;
    this.fogFlashEndTime = 0;
    this.fogLastRenderKey = null;
    this.updateFogOfWar();
    this.updateStage8BlackoutSnakeOverlay();

    const duration = Phaser.Math.Between(2200, 3400);
    this.stage8BlackoutEndTimer = this.time.delayedCall(duration, () => {
      this.endStage8Blackout();
    });
  }

  endStage8Blackout() {
    if (!this.stage8BlackoutActive) return;
    if (this.currentStage !== 8) return;
    if (this.gameOver) return;

    this.stage8BlackoutActive = false;
    this.fogTorchEnabled = true;
    this.fogLastRenderKey = null;
    this.playStage8TorchReigniteEffect();
    this.updateFogOfWar();
    this.updateStage8BlackoutSnakeOverlay();

    this.scheduleNextStage8Blackout();
  }

  playStage8TorchReigniteEffect() {
    const head = this.snake && this.snake[0];
    if (!head) return;

    // Ïä§ÌååÌÅ¨ + ÏÇ¥Ïßù Î≤àÏ©çÏûÑ (Í≤åÏûÑÏùÄ Î©àÏ∂îÏßÄ ÏïäÏùå)
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    for (let i = 0; i < 6; i++) {
      const jitter = this.gridSize * 0.25;
      const spark = this.add.circle(
        headX + Phaser.Math.FloatBetween(-jitter, jitter),
        headY + Phaser.Math.FloatBetween(-jitter, jitter),
        this.gridSize * 0.12,
        0xffcc55,
        1
      ).setDepth(1305);
      spark.setStrokeStyle(2, 0xff8800, 0.9);

      this.tweens.add({
        targets: spark,
        scale: 1.6,
        alpha: 0,
        duration: 180 + i * 20,
        ease: 'Cubic.easeOut',
        onComplete: () => spark.destroy()
      });
    }

    this.triggerFogFlash();
  }

  updateStage8BlackoutSnakeOverlay() {
    const shouldShow = this.stage8BlackoutActive && this.currentStage === 8 && this.shouldUseFog();

    if (!shouldShow) {
      if (this.stage8BlackoutSnakeGraphics) {
        this.stage8BlackoutSnakeGraphics.clear();
        this.stage8BlackoutSnakeGraphics.setVisible(false);
      }
      return;
    }

    if (!this.stage8BlackoutSnakeGraphics) {
      this.stage8BlackoutSnakeGraphics = this.add.graphics();
      this.stage8BlackoutSnakeGraphics.setDepth(1301); // ÏïàÍ∞ú(1200) ÏúÑ, UI(2000) ÏïÑÎûò
    }

    this.stage8BlackoutSnakeGraphics.setVisible(true);
    this.stage8BlackoutSnakeGraphics.clear();

    if (!this.snake || this.snake.length === 0) return;

    this.snake.forEach((segment, index) => {
      const color = index === 0 ? 0x666666 : 0x444444;
      this.stage8BlackoutSnakeGraphics.fillStyle(color, 0.95);
      this.stage8BlackoutSnakeGraphics.fillRect(
        segment.x * this.gridSize + 1,
        segment.y * this.gridSize + 1 + this.gameAreaY,
        this.gridSize - 2,
        this.gridSize - 2
      );
    });
  }

  // ===== Stage 7-8: Ïñ¥Îë† Ï∞¢Ïñ¥Ïßê Ïó∞Ï∂ú =====
  startDarkCreepCycleIfNeeded() {
    if (this.darkCreepCycleStarted) return;
    if (this.currentStage !== 7 && this.currentStage !== 8) return;
    if (!this.shouldUseFog()) return;
    if (this.foodCount < 10) return;

    this.darkCreepCycleStarted = true;
    this.spawnDarkCreepEffect();

    this.darkCreepTimer = this.time.addEvent({
      delay: this.darkCreepInterval,
      callback: () => {
        this.spawnDarkCreepEffect();
      },
      loop: true
    });
  }

  stopDarkCreepCycle() {
    this.darkCreepCycleStarted = false;

    if (this.darkCreepTimer) {
      this.darkCreepTimer.destroy();
      this.darkCreepTimer = null;
    }

    if (this.darkCreepEffects && this.darkCreepEffects.length > 0) {
      this.darkCreepEffects.forEach(effect => {
        if (!effect) return;
        if (effect.overlay) {
          this.tweens.killTweensOf(effect.overlay);
          effect.overlay.clearMask(true);
          effect.overlay.destroy();
        }
        if (effect.maskGraphics) {
          effect.maskGraphics.destroy();
        }
      });
      this.darkCreepEffects = [];
    }
  }

  spawnDarkCreepEffect() {
    if (!this.darkCreepCycleStarted) return;
    if (!this.isFogOfWarActive()) return;
    if (this.gameOver) return;
    if (this.shopOpen || this.loanUIOpen || this.isStageClearingAnimation) return;
    if (!this.snake || this.snake.length === 0) return;

    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    const safeRadius = this.gridSize * (this.fogVisibleTiles + 0.8);
    const left = 10;
    const right = width - 10;
    const top = this.gameAreaY + 10;
    const bottom = height - this.bottomUIHeight - 10;

    const overlay = this.add.graphics().setDepth(1250);
    overlay.setAlpha(0);

    const shapeCount = Phaser.Math.Between(5, 7);
    for (let i = 0; i < shapeCount; i++) {
      const baseRadius = Phaser.Math.Between(this.gridSize * 1.2, this.gridSize * 2.6);
      let cx = Phaser.Math.Between(left, right);
      let cy = Phaser.Math.Between(top, bottom);
      let attempts = 0;

      while (Phaser.Math.Distance.Between(cx, cy, headX, headY) < safeRadius + baseRadius && attempts < 12) {
        cx = Phaser.Math.Between(left, right);
        cy = Phaser.Math.Between(top, bottom);
        attempts++;
      }

      overlay.fillStyle(0x120008, 0.55);
      overlay.beginPath();
      const sides = Phaser.Math.Between(6, 10);
      for (let s = 0; s < sides; s++) {
        const angle = (s / sides) * Math.PI * 2;
        const radius = baseRadius * (0.5 + Math.random() * 0.6);
        const px = cx + Math.cos(angle) * radius;
        const py = cy + Math.sin(angle) * radius;
        if (s === 0) {
          overlay.moveTo(px, py);
        } else {
          overlay.lineTo(px, py);
        }
      }
      overlay.closePath();
      overlay.fillPath();

      overlay.lineStyle(2, 0x1f000f, 0.8);
      overlay.beginPath();
      overlay.moveTo(
        cx + Phaser.Math.Between(-baseRadius, baseRadius),
        cy + Phaser.Math.Between(-baseRadius, baseRadius)
      );
      overlay.lineTo(
        cx + Phaser.Math.Between(-baseRadius * 1.2, baseRadius * 1.2),
        cy + Phaser.Math.Between(-baseRadius * 1.2, baseRadius * 1.2)
      );
      overlay.strokePath();
    }

    const maskGraphics = this.make.graphics({ x: 0, y: 0, add: false });
    maskGraphics.fillStyle(0xffffff, 1);
    maskGraphics.fillCircle(headX, headY, safeRadius);
    const mask = maskGraphics.createGeometryMask();
    mask.invertAlpha = true;
    overlay.setMask(mask);

    const effect = { overlay, maskGraphics };
    this.darkCreepEffects.push(effect);

    this.tweens.add({
      targets: overlay,
      alpha: 0.9,
      duration: 250,
      yoyo: true,
      hold: 400,
      onComplete: () => {
        if (overlay && overlay.active) {
          overlay.clearMask(true);
          overlay.destroy();
        }
        if (maskGraphics) {
          maskGraphics.destroy();
        }
        this.darkCreepEffects = this.darkCreepEffects.filter(entry => entry !== effect);
      }
    });
  }

  // ===== Stage 8: Í∑ÄÏã† Î™π Ïä§Ìè∞ =====
  startStage8GhostSpawnIfNeeded() {
    if (this.stage8GhostSpawnActive) return;
    if (this.currentStage !== 8) return;
    if (!this.shouldUseFog()) return;
    if (this.foodCount < 10) return;

    this.stage8GhostSpawnActive = true;
    this.scheduleStage8GhostSpawn();
  }

  stopStage8GhostSpawning() {
    this.stage8GhostSpawnActive = false;

    if (this.stage8GhostSpawnTimer) {
      this.stage8GhostSpawnTimer.destroy();
      this.stage8GhostSpawnTimer = null;
    }

    if (this.stage8Ghosts && this.stage8Ghosts.length > 0) {
      this.stage8Ghosts.forEach(ghost => this.removeStage8Ghost(ghost, true));
      this.stage8Ghosts = [];
    }
  }

  scheduleStage8GhostSpawn() {
    if (!this.stage8GhostSpawnActive) return;
    if (this.gameOver) return;

    const delay = Phaser.Math.Between(2500, 4200);
    this.stage8GhostSpawnTimer = this.time.delayedCall(delay, () => {
      if (!this.stage8GhostSpawnActive) return;
      this.spawnStage8Ghost();
      this.scheduleStage8GhostSpawn();
    });
  }

  spawnStage8Ghost() {
    if (!this.stage8GhostSpawnActive) return;
    if (this.gameOver) return;
    if (this.shopOpen || this.loanUIOpen || this.isStageClearingAnimation) return;
    if (this.stage8Ghosts.length >= this.stage8GhostMax) return;

    const spawnPos = this.findStage8GhostSpawnPosition();
    if (!spawnPos) return;

    const ghostTypes = ['wailer', 'mask', 'wisp'];
    const ghostType = Phaser.Math.RND.pick(ghostTypes);
    const ghost = this.createStage8Ghost(ghostType, spawnPos.x, spawnPos.y);
    if (ghost) {
      this.stage8Ghosts.push(ghost);
    }
  }

  findStage8GhostSpawnPosition() {
    if (!this.snake || this.snake.length === 0) return null;

    const head = this.snake[0];
    const minDistance = this.fogVisibleTiles + 1.2;
    let attempts = 0;

    while (attempts < 40) {
      const tileX = Phaser.Math.Between(0, this.cols - 2);
      const tileY = Phaser.Math.Between(0, this.rows - 2);
      attempts++;

      if (this.isStage8GhostOverlap(tileX, tileY)) continue;
      if (this.isStage8GhostTileBlocked(tileX, tileY)) continue;

      const ghostCenterX = tileX + 1;
      const ghostCenterY = tileY + 1;
      const dist = Phaser.Math.Distance.Between(ghostCenterX, ghostCenterY, head.x, head.y);
      if (dist < minDistance) continue;

      return { x: tileX, y: tileY };
    }

    return null;
  }

  isStage8GhostOverlap(tileX, tileY) {
    return this.stage8Ghosts.some(ghost => {
      return tileX <= ghost.tileX + 1 &&
        tileX + 1 >= ghost.tileX &&
        tileY <= ghost.tileY + 1 &&
        tileY + 1 >= ghost.tileY;
    });
  }

  isStage8GhostTileBlocked(tileX, tileY) {
    for (let dx = 0; dx < 2; dx++) {
      for (let dy = 0; dy < 2; dy++) {
        const x = tileX + dx;
        const y = tileY + dy;
        if (this.isPositionOccupied(x, y)) return true;
        if (this.food && this.food.x === x && this.food.y === y) return true;
      }
    }
    return false;
  }

  createStage8Ghost(type, tileX, tileY) {
    const pixelX = tileX * this.gridSize + this.gridSize;
    const pixelY = tileY * this.gridSize + this.gridSize + this.gameAreaY;
    const size = this.gridSize * 2;
    const container = this.add.container(pixelX, pixelY).setDepth(1150).setAlpha(0);

    if (type === 'wailer') {
      const body = this.add.ellipse(0, -4, size * 0.75, size * 0.95, 0xdde8ff, 0.35);
      const tail = this.add.triangle(0, size * 0.35, -size * 0.3, 0, size * 0.3, 0, 0, size * 0.55, 0xbcc8dd, 0.35);
      const eye1 = this.add.circle(-size * 0.15, -size * 0.2, size * 0.08, 0x000000, 0.7);
      const eye2 = this.add.circle(size * 0.15, -size * 0.2, size * 0.08, 0x000000, 0.7);
      const mouth = this.add.ellipse(0, size * 0.05, size * 0.16, size * 0.25, 0x220011, 0.8);
      container.add([body, tail, eye1, eye2, mouth]);
    } else if (type === 'mask') {
      const mask = this.add.ellipse(0, -4, size * 0.7, size * 0.9, 0xf1e1cf, 0.5);
      const eyeLeft = this.add.ellipse(-size * 0.18, -size * 0.15, size * 0.18, size * 0.22, 0x1a000f, 0.9);
      const eyeRight = this.add.ellipse(size * 0.18, -size * 0.15, size * 0.18, size * 0.22, 0x1a000f, 0.9);
      const crack = this.add.line(0, 0, -size * 0.1, -size * 0.4, size * 0.25, size * 0.35, 0x5a2b2b, 0.8);
      crack.setLineWidth(2);
      container.add([mask, eyeLeft, eyeRight, crack]);
    } else {
      const core = this.add.circle(0, -size * 0.1, size * 0.28, 0x88ddff, 0.35);
      const glow = this.add.circle(0, -size * 0.1, size * 0.45, 0x224466, 0.2);
      const tail = this.add.ellipse(0, size * 0.35, size * 0.4, size * 0.6, 0x112233, 0.35);
      const eye = this.add.circle(0, -size * 0.15, size * 0.08, 0x000000, 0.75);
      container.add([glow, tail, core, eye]);
    }

    this.tweens.add({
      targets: container,
      alpha: 0.9,
      duration: 200,
      ease: 'Sine.easeOut'
    });

    const floatTween = this.tweens.add({
      targets: container,
      y: pixelY + this.gridSize * 0.2,
      duration: 600,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    const ghost = {
      tileX,
      tileY,
      container,
      floatTween,
      expireTimer: null,
      type
    };

    ghost.expireTimer = this.time.delayedCall(this.stage8GhostLifetime, () => {
      this.removeStage8Ghost(ghost);
    });

    return ghost;
  }

  removeStage8Ghost(ghost, silent = false) {
    if (!ghost) return;

    if (ghost.expireTimer) {
      ghost.expireTimer.destroy();
      ghost.expireTimer = null;
    }

    if (ghost.floatTween) {
      ghost.floatTween.stop();
      ghost.floatTween = null;
    }

    if (ghost.container) {
      if (silent) {
        ghost.container.destroy();
      } else {
        this.tweens.add({
          targets: ghost.container,
          alpha: 0,
          scale: 0.6,
          duration: 150,
          onComplete: () => {
            if (ghost.container) ghost.container.destroy();
          }
        });
      }
      ghost.container = null;
    }

    this.stage8Ghosts = this.stage8Ghosts.filter(entry => entry !== ghost);
  }

  checkStage8GhostCollision(head) {
    if (this.currentStage !== 8) return;
    if (!this.stage8Ghosts || this.stage8Ghosts.length === 0) return;
    if (!head) return;

    for (const ghost of [...this.stage8Ghosts]) {
      if (head.x >= ghost.tileX && head.x <= ghost.tileX + 1 &&
          head.y >= ghost.tileY && head.y <= ghost.tileY + 1) {
        this.applyStage8GhostPenalty(1);
        this.removeStage8Ghost(ghost);
        break;
      }
    }
  }

  applyStage8GhostPenalty(amount = 1) {
    if (this.foodCount <= 0) return;

    this.foodCount = Math.max(0, this.foodCount - amount);
    if (this.foodCountText) {
      this.foodCountText.setText(this.foodCount.toString());
      this.tweens.add({
        targets: this.foodCountText,
        scaleX: { from: 1, to: 1.8 },
        scaleY: { from: 1, to: 1.8 },
        duration: 120,
        yoyo: true,
        repeat: 2,
        ease: 'Back.easeOut'
      });
      this.tweens.add({
        targets: this.foodCountText,
        tint: 0xff3333,
        duration: 100,
        yoyo: true,
        repeat: 3,
        onComplete: () => {
          if (this.foodCountText) this.foodCountText.clearTint();
        }
      });
    }

    if (this.foodCountText) {
      const penaltyText = this.add.text(
        this.foodCountText.x + 18,
        this.foodCountText.y + 4,
        `-${amount}`,
        {
          fontSize: '18px',
          fill: '#ff3333',
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 3
        }
      ).setOrigin(0, 0.5).setDepth(2501);

      this.tweens.add({
        targets: penaltyText,
        y: penaltyText.y - 20,
        alpha: 0,
        duration: 600,
        ease: 'Cubic.easeOut',
        onComplete: () => penaltyText.destroy()
      });
    }

    const head = this.snake && this.snake[0];
    if (head) {
      const headX = head.x * this.gridSize + this.gridSize / 2;
      const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
      const burst = this.add.circle(headX, headY, this.gridSize * 0.9, 0x550011, 0.6).setDepth(1500);
      this.tweens.add({
        targets: burst,
        alpha: 0,
        scale: 1.6,
        duration: 200,
        onComplete: () => burst.destroy()
      });
    }
  }

  // ===== ESC Pause =====
  pauseFromEsc() {
    if (this.isEscPaused) return;
    this.isEscPaused = true;

    const { width, height } = this.cameras.main;

    const overlay = this.add.rectangle(0, 0, width, height, 0x000000, 0.65)
      .setOrigin(0, 0)
      .setDepth(9000)
      .setScrollFactor(0);

    const title = this.add.text(width / 2, height / 2 - 40, 'PAUSED', {
      fontSize: '56px',
      fill: '#ffffff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(9001).setScrollFactor(0);

    const hint = this.add.text(width / 2, height / 2 + 20, 'Press ESC to resume', {
      fontSize: '16px',
      fill: '#cccccc'
    }).setOrigin(0.5).setDepth(9001).setScrollFactor(0);

    this.escPauseElements = [overlay, title, hint];

    if (this.pauseHintText && this.pauseHintText.active) {
      this.pauseHintText.setVisible(false);
    }

    // ÌÉÄÏù¥Î®∏/Ìä∏Ïúà ÏùºÏãúÏ†ïÏßÄ
    this.tweens.pauseAll();
    this.time.paused = true;
  }

  resumeFromEscPause() {
    if (!this.isEscPaused) return;

    // Î®ºÏ†Ä ÌÉÄÏù¥Î®∏/Ìä∏Ïúà Ïû¨Í∞ú
    this.time.paused = false;
    this.tweens.resumeAll();

    this.isEscPaused = false;

    if (this.escPauseElements && this.escPauseElements.length > 0) {
      for (const el of this.escPauseElements) {
        if (el && el.active) el.destroy();
      }
    }
    this.escPauseElements = [];

    if (this.pauseHintText && this.pauseHintText.active) {
      this.pauseHintText.setVisible(true);
    }

    // Ï¶âÏãú ÌôîÎ©¥ Í∞±Ïã† (ÏïàÍ∞ú/Ïò§Î≤ÑÎ†àÏù¥ Ìè¨Ìï®)
    this.draw();
  }

  endGame() {
    if (this.gameOver) return; // Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ

    // Stage 8 Î∏îÎûôÏïÑÏõÉ Ï§ëÏù¥Î©¥ UI Î∞©Ìï¥ Î∞©ÏßÄÏö© Ï†ïÎ¶¨
    this.stopStage8BlackoutCycle();
    this.stopDarkCreepCycle();
    this.stopStage8GhostSpawning();

    // Î∂ÄÌôú Í∞ÄÎä• Ïó¨Î∂Ä Î®ºÏ†Ä Ï≤¥ÌÅ¨
    if (this.canRevive()) {
      this.gameOver = true; // ÏûÑÏãúÎ°ú ÏÑ§Ï†ï (Î∂ÄÌôú Ïãú falseÎ°ú ÎêòÎèåÎ¶º)
      this.moveTimer.paused = true; // ÏùºÏãúÏ†ïÏßÄ
      this.showReviveSequence();
      return;
    }

    // Î∂ÄÌôú Î∂àÍ∞Ä - Î∂ÄÌôú Ïã§Ìå® Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Í≤åÏûÑÏò§Î≤Ñ
    this.gameOver = true;
    this.moveTimer.paused = true;
    this.showReviveFailedSequence();
  }

  // Î∂ÄÌôú Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
  canRevive() {
    if (this.isReviving) return false; // Ïù¥ÎØ∏ Î∂ÄÌôú Ï≤òÎ¶¨ Ï§ë
    const totalAssets = this.money + this.score;
    return totalAssets >= this.reviveCost;
  }

  // Í∏∞Ï°¥ Í≤åÏûÑÏò§Î≤Ñ Ï≤òÎ¶¨ (Î∂ÄÌôú Ïã§Ìå® ÌõÑ ÎòêÎäî ÏßÅÏ†ë Ìò∏Ï∂ú)
  showGameOverScreen() {
    this.moveTimer.remove();

    this.resetFogOfWar();

    this.destroyAllSaws();

    // ÏïÑÏù¥ÌÖú ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.itemSpawnTimer) {
      this.itemSpawnTimer.remove();
    }

    // Î™®Îì† ÏïÑÏù¥ÌÖú Ï†úÍ±∞
    this.items.forEach(item => {
      if (item.graphics) item.graphics.destroy();
      if (item.text) item.text.destroy();
    });
    this.items = [];

    // Î≥¥Ïä§ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.bossElement) {
      this.bossElement.destroy();
      this.bossElement = null;
    }
    // Î≥¥Ïä§ HIT ÌÖçÏä§Ìä∏ Ï†ïÎ¶¨
    if (this.bossHitText) {
      this.tweens.killTweensOf(this.bossHitText);
      this.bossHitText.destroy();
      this.bossHitText = null;
    }
    this.bossMode = false;
    this.isBossStage = false;
    this.snakePoisoned = false;

    // Î∞∞Í≤ΩÏùåÏïÖ Ï†ïÏßÄ
    if (this.bgMusic) {
      this.bgMusic.stop();
    }

    const { width, height } = this.cameras.main;

    // Î∞òÌà¨Î™Ö Ïò§Î≤ÑÎ†àÏù¥
    this.add.rectangle(0, 0, width, height, 0x000000, 0.7).setOrigin(0);

    // Í≤åÏûÑ Ïò§Î≤Ñ ÌÖçÏä§Ìä∏
    this.add.text(width / 2, height / 2 - 80, 'GAME OVER', {
      fontSize: '64px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5);

    this.add.text(width / 2, height / 2, `Final Score: ${this.score}`, {
      fontSize: '32px',
      fill: '#fff'
    }).setOrigin(0.5);

    this.add.text(width / 2, height / 2 + 50, `Final Stage: ${this.currentStage}`, {
      fontSize: '32px',
      fill: '#00aaff'
    }).setOrigin(0.5);

    this.add.text(width / 2, height / 2 + 100, `Max Combo: x${this.maxCombo}`, {
      fontSize: '32px',
      fill: '#ffaa00'
    }).setOrigin(0.5);

    this.add.text(width / 2, height / 2 + 160, 'Press SPACE to Title', {
      fontSize: '24px',
      fill: '#aaa'
    }).setOrigin(0.5);

    // Ïä§ÌéòÏù¥Ïä§Î∞îÎ°ú ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô
    this.input.keyboard.once('keydown-SPACE', () => {
      this.stopAllBGM();
      this.scene.start('TitleScene');
    });

    // ÌÅ¥Î¶≠ÏúºÎ°úÎèÑ ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ÏúºÎ°ú Ïù¥Îèô
    this.input.once('pointerdown', () => {
      this.stopAllBGM();
      this.scene.start('TitleScene');
    });
  }

  // Î™®Îì† BGM Ï†ïÏßÄ (ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ Ïù¥Îèô Ïãú ÏÇ¨Ïö©)
  stopAllBGM() {
    if (this.bgMusic && this.bgMusic.isPlaying) this.bgMusic.stop();
    if (this.boss3Music && this.boss3Music.isPlaying) this.boss3Music.stop();
    if (this.boss6Music && this.boss6Music.isPlaying) this.boss6Music.stop();
    if (this.boss9Music && this.boss9Music.isPlaying) this.boss9Music.stop();
    if (this.boss12Music && this.boss12Music.isPlaying) this.boss12Music.stop();
    if (this.boss15Music && this.boss15Music.isPlaying) this.boss15Music.stop();
    if (this.boss18Music && this.boss18Music.isPlaying) this.boss18Music.stop();
  }

  // ========== Î∂ÄÌôú ÏãúÏä§ÌÖú ==========

  // Î∂ÄÌôú ÏÑ±Í≥µ Ïï†ÎãàÎ©îÏù¥ÏÖò
  showReviveSequence() {
    this.isReviving = true;
    // Fog of War Î†àÏù¥Ïñ¥Í∞Ä Î∂ÄÌôú UIÎ•º Í∞ÄÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù Ï¶âÏãú Ïà®ÍπÄ (Stage 7-9)
    this.resetFogOfWar();
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;
    const totalAssets = this.money + this.score;

    // Phase 1: Ïä¨Î°úÏö∞Î™®ÏÖò + Ïñ¥Îë°Í≤å
    this.time.timeScale = 0.3;

    const overlay = this.add.rectangle(0, 0, width, height, 0x000000, 0)
      .setOrigin(0)
      .setDepth(1000);
    this.reviveElements.push(overlay);

    this.tweens.add({
      targets: overlay,
      alpha: 0.6,
      duration: 100,
      onComplete: () => {
        // Phase 2: ÏΩîÏù∏ Ï∞®Í∞ê Ïï†ÎãàÎ©îÏù¥ÏÖò (Îπ†Î•¥Í≤å)
        this.showReviveCoinAnimation(centerX, centerY, totalAssets);
      }
    });
  }

  // ÏΩîÏù∏ Ï∞®Í∞ê Ïï†ÎãàÎ©îÏù¥ÏÖò (Îπ†Î•∏ Î≤ÑÏ†Ñ)
  showReviveCoinAnimation(centerX, centerY, totalAssets) {
    const remaining = totalAssets - this.reviveCost;

    // ÏΩîÏù∏ ÏïÑÏù¥ÏΩò (ÏõêÌòï)
    const coinBg = this.add.circle(centerX, centerY - 40, 40, 0xffd700)
      .setDepth(1001);
    const coinSymbol = this.add.text(centerX, centerY - 40, '$', {
      fontSize: '36px',
      fill: '#8B4513',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1002);
    this.reviveElements.push(coinBg, coinSymbol);

    // ÌòÑÏû¨ ÏûêÏÇ∞ ‚Üí ÎÇ®ÏùÄ ÏûêÏÇ∞ ÌëúÏãú
    const assetText = this.add.text(centerX, centerY + 20, `$${totalAssets}`, {
      fontSize: '48px',
      fill: '#00ff88',
      fontStyle: 'bold',
      stroke: '#004422',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(1001);
    this.reviveElements.push(assetText);

    // -$500 ÌëúÏãú
    const minusText = this.add.text(centerX + 80, centerY + 20, '-$500', {
      fontSize: '28px',
      fill: '#ff4444',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1002).setAlpha(0);
    this.reviveElements.push(minusText);

    this.tweens.add({
      targets: minusText,
      alpha: 1,
      x: centerX + 100,
      duration: 150
    });

    // Îπ†Î•∏ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
    let currentValue = totalAssets;
    const countInterval = this.time.addEvent({
      delay: 20,
      repeat: 10,
      callback: () => {
        currentValue -= (totalAssets - remaining) / 10;
        assetText.setText(`$${Math.round(currentValue)}`);
        if (currentValue <= remaining + 1) {
          assetText.setText(`$${remaining}`);
          assetText.setFill('#ffff00');
        }
      }
    });
    this.reviveElements.push({ destroy: () => countInterval.remove() });

    // ÏΩîÏù∏ ÌååÌã∞ÌÅ¥ (Ï†ÅÍ≤å)
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const coin = this.add.circle(centerX, centerY - 40, 6, 0xffd700).setDepth(1004);
      this.reviveElements.push(coin);
      this.tweens.add({
        targets: coin,
        x: centerX + Math.cos(angle) * 80,
        y: centerY - 40 + Math.sin(angle) * 60,
        alpha: 0,
        duration: 250
      });
    }

    // REVIVE! ÌÖçÏä§Ìä∏ Îπ†Î•¥Í≤å
    this.time.delayedCall(300, () => {
      this.showReviveText(centerX, centerY, remaining);
    });
  }

  // REVIVE! ÌÖçÏä§Ìä∏ ÌëúÏãú (Îπ†Î•∏ Î≤ÑÏ†Ñ)
  showReviveText(centerX, centerY, remaining) {
    const reviveText = this.add.text(centerX, centerY - 20, 'REVIVE!', {
      fontSize: '64px',
      fill: '#00ff88',
      fontStyle: 'bold',
      stroke: '#003311',
      strokeThickness: 5
    }).setOrigin(0.5).setDepth(1005).setScale(0.5).setAlpha(0);
    this.reviveElements.push(reviveText);
    reviveText.setShadow(0, 0, '#00ff88', 15, true, true);

    this.tweens.add({
      targets: reviveText,
      scale: 1,
      alpha: 1,
      duration: 150,
      ease: 'Back.easeOut'
    });

    // Ïä§ÌååÌÅ¨ (Ï†ÅÍ≤å)
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const spark = this.add.star(centerX, centerY - 20, 5, 3, 6, 0x00ff88)
        .setDepth(1004).setAlpha(0.8);
      this.reviveElements.push(spark);
      this.tweens.add({
        targets: spark,
        x: centerX + Math.cos(angle) * 60,
        y: centerY - 20 + Math.sin(angle) * 60,
        alpha: 0,
        duration: 200
      });
    }

    // Îπ†Î•∏ Î¶¨Ïä§Ìè∞
    this.time.delayedCall(250, () => {
      this.performRevive(remaining);
    });
  }

  // Ïã§Ï†ú Î∂ÄÌôú Ï≤òÎ¶¨
  performRevive(remaining) {
    const { width, height } = this.cameras.main;

    // ÌôîÎ©¥ ÌîåÎûòÏãú (Ìù∞ÏÉâ)
    const flash = this.add.rectangle(0, 0, width, height, 0xffffff, 1)
      .setOrigin(0)
      .setDepth(1010);
    this.reviveElements.push(flash);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 150,
      onComplete: () => {
        this.cleanupReviveElements();
        this.time.timeScale = 1;
        this.money = remaining;
        this.restartCurrentStage();
      }
    });
  }

  // Î∂ÄÌôú Ïã§Ìå® Ïï†ÎãàÎ©îÏù¥ÏÖò (Îπ†Î•∏ Î≤ÑÏ†Ñ)
  showReviveFailedSequence() {
    this.isReviving = true;
    // Fog of War Î†àÏù¥Ïñ¥Í∞Ä Í≤åÏûÑÏò§Î≤Ñ/Î∂ÄÌôú UIÎ•º Í∞ÄÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù Ï¶âÏãú Ïà®ÍπÄ (Stage 7-9)
    this.resetFogOfWar();
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;
    const totalAssets = this.money + this.score;

    // Ïä¨Î°úÏö∞Î™®ÏÖò ÏóÜÏù¥ Îπ†Î•¥Í≤å
    const overlay = this.add.rectangle(0, 0, width, height, 0x000000, 0.7)
      .setOrigin(0)
      .setDepth(1000);
    this.reviveElements.push(overlay);

    // ÌòÑÏû¨ ÏûêÏÇ∞ ÌëúÏãú (Îπ®Í∞ÑÏÉâ)
    const assetText = this.add.text(centerX, centerY + 10, `$${totalAssets}`, {
      fontSize: '42px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#440000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(1001);
    this.reviveElements.push(assetText);

    // NEED $500 ÌëúÏãú
    const needText = this.add.text(centerX, centerY + 60, 'NEED $500', {
      fontSize: '24px',
      fill: '#ff6666',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1001);
    this.reviveElements.push(needText);

    // NOT ENOUGH! ÌÖçÏä§Ìä∏
    const notEnoughText = this.add.text(centerX, centerY - 50, 'NOT ENOUGH!', {
      fontSize: '48px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#220000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(1005).setScale(0.5);
    this.reviveElements.push(notEnoughText);

    this.tweens.add({
      targets: notEnoughText,
      scale: 1,
      duration: 150,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÏßßÏùÄ ÌùîÎì§Î¶º
        this.tweens.add({
          targets: notEnoughText,
          x: { from: centerX - 5, to: centerX + 5 },
          duration: 30,
          yoyo: true,
          repeat: 3
        });
      }
    });

    // X ÎßàÌÅ¨
    const xMark = this.add.text(centerX, centerY - 110, '‚úï', {
      fontSize: '48px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1005).setAlpha(0);
    this.reviveElements.push(xMark);

    this.tweens.add({
      targets: xMark,
      alpha: 1,
      duration: 100
    });

    // Îπ®Í∞Ñ ÌîåÎûòÏãú
    const redGlow = this.add.rectangle(0, 0, width, height, 0xff0000, 0.15)
      .setOrigin(0)
      .setDepth(999);
    this.reviveElements.push(redGlow);

    this.tweens.add({
      targets: redGlow,
      alpha: 0,
      duration: 200
    });

    // Îπ†Î•¥Í≤å Í≤åÏûÑÏò§Î≤ÑÎ°ú Ï†ÑÌôò
    this.time.delayedCall(500, () => {
      this.transitionToGameOver();
    });
  }

  // Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ÏúºÎ°ú Ï†ÑÌôò
  transitionToGameOver() {
    const { width, height } = this.cameras.main;

    const fadeOverlay = this.add.rectangle(0, 0, width, height, 0x000000, 0)
      .setOrigin(0)
      .setDepth(1100);
    this.reviveElements.push(fadeOverlay);

    this.tweens.add({
      targets: fadeOverlay,
      alpha: 1,
      duration: 150,
      onComplete: () => {
        this.cleanupReviveElements();
        this.time.timeScale = 1;
        this.showGameOverScreen();
      }
    });
  }

    // Ïä§ÌÖåÏù¥ÏßÄ Ïû¨ÏãúÏûë (Î∂ÄÌôú Ïãú)
  restartCurrentStage() {
    // Stage 8 Î∏îÎûôÏïÑÏõÉ Ï†ïÎ¶¨ (Î∂ÄÌôú Ïãú)
    this.stopStage8BlackoutCycle();

    // World 4 (Stage 13-15): ÏûêÍ∏∞Ïû• Î¶¨ÏÖã (Î∂ÄÌôú Ïãú Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú ÏãúÏûë)
    if (shouldHaveGasZone(this.currentStage)) {
      this.stopGasZone();
      this.time.delayedCall(1000, () => {
        this.startGasZone();
      });
    }

    // ÌÉÑÎßâÎ≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ: Í∏∞Ï°¥ Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.isBulletBossStage()) {
      this.cleanupBulletBoss();
    }

    // ÎèÖÍ∞úÍµ¨Î¶¨ Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ: Í∏∞Ï°¥ Î≥¥Ïä§/ÎèÖ ÏÉÅÌÉú Ï†ïÎ¶¨
    if (this.isPoisonFrogBossStage && this.isPoisonFrogBossStage()) {
      if (this.bossElement) {
        this.bossElement.destroy();
        this.bossElement = null;
      }
      if (this.bossHitText) {
        this.tweens.killTweensOf(this.bossHitText);
        this.bossHitText.destroy();
        this.bossHitText = null;
      }
      this.bossHitCount = 0;
      this.bossInputBlocked = false;
      this.bossIntroMoveCount = undefined;
      this.poisonGrowthActive = false;
      this.poisonGrowthData = null;
      this.snakePoisoned = false;
    }

    // Í≤åÏûÑ ÏÉÅÌÉú Î¶¨ÏÖã (Ïä§ÌÖåÏù¥ÏßÄÎäî Ïú†ÏßÄ)
    this.gameOver = false;
    this.isReviving = false;
    this.score = 0;
    this.foodCount = 0;

    // Î±Ä Ï¥àÍ∏∞Ìôî (3Ïπ∏)
    this.snake = [
      { x: 5, y: 13 },
      { x: 4, y: 13 },
      { x: 3, y: 13 }
    ];
    this.direction = 'RIGHT';
    this.inputQueue = [];

    // ÏΩ§Î≥¥ Î¶¨ÏÖã (ÏΩ§Î≥¥ Ïã§ÎìúÎäî Ïú†ÏßÄ)
    this.combo = 0;
    this.directionChangesCount = 0;

    // ÌÖîÎ†àÌè¨Ìä∏ ÏÉÅÌÉú Î¶¨ÏÖã
    this.foodTeleportEnabled = false;
    this.currentFoodTeleportCount = 0;
    this.nextTeleportStep = 0;

    // Î®πÏù¥/Î≥¥Ïä§ Ïò§Î∏åÏ†ùÌä∏ Î¶¨ÏÖã
    if (this.isBulletBossStage()) {
      // ÌÉÑÎßâÎ≥¥Ïä§: Î®πÏù¥ ÏóÜÏùå
      this.food = { x: -100, y: -100 };
    } else if (this.isGearTitanStage()) {
      // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ: Î®πÏù¥ ÏóÜÏùå (Î≥¥Ïä§Í∞Ä Î®πÏù¥ Ïó≠Ìï†)
      this.food = { x: -100, y: -100 };
    } else if (this.isPoisonFrogBossStage && this.isPoisonFrogBossStage()) {
      // ÎèÖÍ∞úÍµ¨Î¶¨: Ïù∏Ìä∏Î°ú Ïä§ÌÇµ ‚Üí Ìï®Ï†ï(ÎèÖ)Î∂ÄÌÑ∞ ÏãúÏûë
      this.isBossStage = true;
      this.bossMode = true;
      this.bossPhase = 'trap';
      const spawnPos = this.getPoisonFrogSpawnPosition ? this.getPoisonFrogSpawnPosition() : { x: this.cols - 9, y: 15 };
      this.drawBoss(spawnPos.x, spawnPos.y);
    } else {
      // ÏùºÎ∞ò Ïä§ÌÖåÏù¥ÏßÄ
      this.food = this.generateFood();
    }

    // UI ÏóÖÎç∞Ïù¥Ìä∏
    this.scoreText.setText('0');
    this.foodCountText.setText('0');
    this.updateMoneyDisplay();

    // Í∑∏ÎûòÌîΩ Îã§Ïãú Í∑∏Î¶¨Í∏∞
    this.draw();

    // Î™®Îì† Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë ÏÜçÎèÑ 90ms Í≥†Ï†ï
    const startSpeed = 90;
    if (this.moveTimer) {
      this.moveTimer.delay = startSpeed;
      this.moveTimer.paused = false;
    }
    this.speedText.setText(startSpeed + 'ms');

    // Î±Ä Î∞òÏßùÏûÑ Ìö®Í≥º (Î∂ÄÌôú ÌëúÏãú)
    this.showReviveSpawnEffect();

    // ÌÉÑÎßâÎ≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ: Î≥¥Ïä§ Ïû¨ÏãúÏûë
    if (this.isBulletBossStage()) {
      this.time.delayedCall(800, () => {
        this.startBulletBoss();
      });
    }

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Ïä§ÌÖåÏù¥ÏßÄ: Î≥¥Ïä§ ÏãúÏûë
    if (this.isGearTitanStage()) {
      this.time.delayedCall(800, () => {
        this.startGearTitan();
      });
    }
  }

  // Î∂ÄÌôú ÌõÑ Î±Ä Î∞òÏßùÏûÑ Ìö®Í≥º
  showReviveSpawnEffect() {
    let blinkCount = 0;
    const blinkInterval = this.time.addEvent({
      delay: 100,
      repeat: 7,
      callback: () => {
        blinkCount++;
        if (this.graphics) {
          this.graphics.setAlpha(blinkCount % 2 === 0 ? 1 : 0.3);
        }
      },
      callbackScope: this
    });

    // ÎßàÏßÄÎßâÏóê ÏôÑÏ†ÑÌûà Î≥¥Ïù¥Í≤å
    this.time.delayedCall(800, () => {
      if (this.graphics) {
        this.graphics.setAlpha(1);
      }
    });
  }

  // Î∂ÄÌôú UI ÏöîÏÜå Ï†ïÎ¶¨
  cleanupReviveElements() {
    this.reviveElements.forEach(el => {
      if (el && el.destroy) {
        el.destroy();
      }
    });
    this.reviveElements = [];
    this.isReviving = false;
  }

  // Îèà ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏ (ÏÉÅÏ†ê Î∞ñÏóêÏÑúÎèÑ ÏÇ¨Ïö©)
  updateMoneyDisplay() {
    // ÏÉÅÏ†ê ÌÖçÏä§Ìä∏ Í∞ùÏ≤¥Í∞Ä Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ (ÌååÍ¥¥Îêú Í∞ùÏ≤¥ Ï†ëÍ∑º Î∞©ÏßÄ)
    if (this.shopMoneyText && this.shopMoneyText.active) {
      try {
        this.shopMoneyText.setText(`$${this.money}`);
      } catch (e) {
        // ÌÖçÏä§Ìä∏ Í∞ùÏ≤¥Í∞Ä ÌååÍ¥¥Îêú Í≤ΩÏö∞ Î¨¥Ïãú
      }
    }
  }

  stageClear() {
    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (ÌÜ±Îãà Ï∂©Îèå Î¨¥ÏãúÏö©)
    this.isStageClearingAnimation = true;

    // Î™®Îì† ÌÜ±Îãà Ï†ïÏßÄ (ÏùºÏãúÏ†ïÏßÄÎßå, ÌÉÄÏù¥Î®∏ Ïú†ÏßÄ)
    this.pauseAllSaws();

    // Stage 8 Î∏îÎûôÏïÑÏõÉ Î™®Îìú Ï†ïÎ¶¨ (ÌöåÏÉâ Î±Ä ÏûîÏÉÅ Î∞©ÏßÄ)
    this.stopStage8BlackoutCycle();

    // Î±Ä Í∑∏ÎûòÌîΩ Ïà®Í∏∞Í∏∞ (Ï†êÌîÑ Ïï†ÎãàÎ©îÏù¥ÏÖòÏóêÏÑú Î≥ÑÎèÑ Î†âÌÉ±Í∏ÄÎ°ú ÌëúÏãú)
    this.hideSnakeGraphics();

    // Meta Universe ÏõúÌôÄ Ïä§Ìè∞ Ï§ëÏù¥Î©¥ Ï†ïÎ¶¨
    if (this.wormholeSpawnData) {
      if (this.wormholeSpawnData.wormholeAnimEvent) {
        this.wormholeSpawnData.wormholeAnimEvent.destroy();
      }
      if (this.wormholeSpawnData.exitWormhole) {
        this.wormholeSpawnData.exitWormhole.destroy();
      }
      this.wormholeSpawnData = null;
    }

    // Meta Universe ÏõúÌôÄÎì§Í≥º ÌÉÄÏù¥ÌãÄ Ïà®Í∏∞Í∏∞
    if (this.metaUniverseMode) {
      this.destroyWormholes();
      if (this.universeTitle) {
        this.universeTitle.setVisible(false);
      }
    }

    const { width, height } = this.cameras.main;

    // Î®πÏù¥ Ï¶âÏãú Ïà®ÍπÄ
    this.graphics.clear();

    // ÎßêÌíçÏÑ† Ï†úÍ±∞
    if (this.foodBubble) {
      // Ï¶âÏãú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å + alpha 0ÏúºÎ°ú ÏÑ§Ï†ï
      if (this.foodBubble.image) {
        this.foodBubble.image.setVisible(false);
        this.foodBubble.image.setAlpha(0);
      }
      if (this.foodBubble.text) {
        this.foodBubble.text.setVisible(false);
        this.foodBubble.text.setAlpha(0);
      }

      // TweenManagerÏóêÏÑú ÏôÑÏ†ÑÌûà Ï†úÍ±∞
      if (this.foodBubble.image && this.foodBubble.text) {
        this.tweens.killTweensOf([this.foodBubble.image, this.foodBubble.text]);
      }

      // Í∞ùÏ≤¥ Ï†úÍ±∞
      if (this.foodBubble.image) {
        this.foodBubble.image.destroy();
      }
      if (this.foodBubble.text) {
        this.foodBubble.text.destroy();
      }
    }
    this.foodBubble = null;

    // Î±Ä Ï†êÌîÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.playSnakeJumpAnimation(() => {
      // Ï†êÌîÑ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÌõÑ STAGE CLEAR ÌëúÏãú
      this.showStageClearText();
    });
  }

  playSnakeJumpAnimation(onComplete) {
    const { width, height } = this.cameras.main;

    // ÏßÑÌñâ Î∞©Ìñ•Ïóê Îî∞Î•∏ Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞
    let targetX = 0;
    let targetY = 0;

    switch (this.direction) {
      case 'RIGHT':
        targetX = width + 300;
        break;
      case 'LEFT':
        targetX = -300;
        break;
      case 'UP':
        targetY = -300;
        break;
      case 'DOWN':
        targetY = height + 300;
        break;
    }

    // Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏Î•º Rectangle Í∞ùÏ≤¥Î°ú ÏÉùÏÑ±
    const segmentRects = [];
    this.snake.forEach((segment, index) => {
      const color = index === 0 ? 0x00ff00 : 0x00aa00;
      const startX = segment.x * this.gridSize + this.gridSize / 2;
      const startY = segment.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      const rect = this.add.rectangle(
        startX,
        startY,
        this.gridSize - 2,
        this.gridSize - 2,
        color
      ).setDepth(4000);

      segmentRects.push(rect);

      // Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏Ïóê ÏàúÏ∞®Ï†Å Ï†êÌîÑ (2.5D Ìö®Í≥º)
      this.time.delayedCall(index * 80, () => {
        // Phase 1: Ï§ÄÎπÑ ÎèôÏûë (ÏûëÍ≤å)
        this.tweens.add({
          targets: rect,
          scaleX: 0.8,
          scaleY: 0.8,
          duration: 100,
          ease: 'Quad.easeIn',
          onComplete: () => {
            // Phase 2: ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÌäÄÏñ¥ÎÇòÏò¥! (ÌÅ¨Í≤å)
            this.tweens.add({
              targets: rect,
              scaleX: 4,
              scaleY: 4,
              duration: 300,
              ease: 'Back.easeOut',
              onComplete: () => {
                // Phase 3: ÏÇ¥Ïßù ÏûëÏïÑÏßÄÎ©∞ ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÏÇ¨ÎùºÏßê
                this.tweens.add({
                  targets: rect,
                  scaleX: 0.5,
                  scaleY: 0.5,
                  alpha: 0,
                  duration: 350,
                  ease: 'Power2.easeIn',
                  onComplete: () => {
                    rect.destroy();
                    // ÎßàÏßÄÎßâ ÏÑ∏Í∑∏Î®ºÌä∏ ÏôÑÎ£å Ïãú
                    if (index === this.snake.length - 1) {
                      if (onComplete) onComplete();
                    }
                  }
                });
              }
            });
          }
        });

        // ÏßÑÌñâ Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô (ZÏ∂ï Ï†êÌîÑÏôÄ ÎèôÏãú ÏßÑÌñâ)
        const finalX = this.direction === 'LEFT' || this.direction === 'RIGHT' ? targetX : startX;
        const finalY = this.direction === 'UP' || this.direction === 'DOWN' ? targetY : startY;

        this.tweens.add({
          targets: rect,
          x: finalX,
          y: finalY,
          duration: 800,
          ease: 'Power2.easeOut'
        });
      });
    });
  }

  showStageClearText() {
    const { width, height } = this.cameras.main;

    // STAGE CLEAR ÌÖçÏä§Ìä∏
    const clearText = this.add.text(width / 2, height / 2 - 100, 'STAGE CLEAR!', {
      fontSize: '72px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff6600',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // STAGE CLEAR Ïï†ÎãàÎ©îÏù¥ÏÖò (Ï§åÏù∏ + ÌéòÏù¥ÎìúÏù∏)
    this.tweens.add({
      targets: clearText,
      scaleX: { from: 0, to: 1.2 },
      scaleY: { from: 0, to: 1.2 },
      alpha: { from: 0, to: 1 },
      duration: 500,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÏÉÅÏ†ê Ï°∞Í±¥Ïù¥Î©¥ Î∞îÎ°ú ÏÉÅÏ†ê Ïó¥Í∏∞ (Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ÏùÄ ÏôÑÎ£å ÌõÑ)
        // Stage 3 ÌÅ¥Î¶¨Ïñ¥ ÌõÑ ÏÉÅÏ†ê Ïò§Ìîà
        if (this.currentStage >= 3) {
          this.time.delayedCall(500, () => {
            clearText.destroy();
            this.openShop();
          });
        } else {
          // ÏÉÅÏ†ê ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ÎåÄÎ°ú Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
          this.startStageClearCountdown(clearText);
        }
      }
    });
  }

  startStageClearCountdown(clearText) {
    const { width, height } = this.cameras.main;

    // ÏÉÅÏ†êÏù¥ ÏóÜÏùÑ ÎïåÎèÑ Ïä§ÏΩîÏñ¥Î•º ÎèàÏúºÎ°ú Ï†ÑÌôò
    if (this.score > 0) {
      this.money += this.score;

      // Í∞ÑÎã®Ìïú Ïä§ÏΩîÏñ¥ Ï†ÑÌôò ÌëúÏãú
      const scoreText = this.add.text(width / 2, height / 2 + 30, `+$${this.score}`, {
        fontSize: '24px',
        fill: '#00ff00',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(5001);

      this.tweens.add({
        targets: scoreText,
        y: height / 2,
        alpha: 0,
        duration: 800,
        onComplete: () => scoreText.destroy()
      });
    }

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏
    const countdownText = this.add.text(width / 2, height / 2 + 50, '', {
      fontSize: '96px',
      fill: '#00ffff',
      fontStyle: 'bold',
      stroke: '#0088ff',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(5001).setAlpha(0);

    // 3, 2, 1 Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
    let countdown = 3;
    countdownText.setText(countdown.toString());
    countdownText.setAlpha(1);

    this.time.addEvent({
      delay: 500,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          countdownText.setText(countdown.toString());
          this.tweens.add({
            targets: countdownText,
            scaleX: { from: 0.5, to: 1 },
            scaleY: { from: 0.5, to: 1 },
            duration: 200,
            ease: 'Back.easeOut'
          });
        } else {
          clearText.destroy();
          countdownText.destroy();
          this.showNextStage();
        }
      },
      repeat: 2
    });
  }

  getNextStageAfterClear() {
    return { stage: this.currentStage + 1 };
  }

  enterBossStage() {
    this.isBossStage = true;
    this.bossMode = true;
    this.savedCombo = this.combo;
    this.savedComboShieldCount = this.comboShieldCount;
    this.combo = 0;
    this.comboText.setText('');
  }

  showNextStage() {
    const { width, height } = this.cameras.main;

    const { stage: nextStage } = this.getNextStageAfterClear();

    this.currentStage = nextStage;

    // Boss stage checks (bullet/fog/gear titan handled separately)
    const isBulletBoss = this.isBulletBossStage();
    const isFogBoss = this.isFogBossStage();
    const isGearTitan = this.isGearTitanStage();
    const isMultiverse = isMultiverseCollapseStage(this.currentStage);
    const isPoisonFrogBoss = !isBulletBoss && !isFogBoss && !isGearTitan && !isMagnetarStage(this.currentStage) && !isMultiverse && (
      this.currentStage === this.testBossStage ||
      (this.currentStage > this.testBossStage && this.currentStage % this.bossStageInterval === 0)
    );

    const isAnyBossStage = isPoisonFrogBoss || isBulletBoss || isFogBoss || isGearTitan;

    if (isAnyBossStage) {
      this.enterBossStage();
    }

    if (isPoisonFrogBoss) {
      this.resetStage();
      this.bossPhase = 'intro';
      this.food = { x: -100, y: -100 };
      this.bossIntroMoveCount = 0;
    } else if (isGearTitan) {
      // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ: ÌÜ±Îãà ÎÇ†ÏïÑÍ∞ÄÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ resetStage
      this.moveTimer.paused = true;
      this.food = { x: -100, y: -100 };
      this.hideFoodGraphics({ skipRedraw: true });
      // resetStageÎäî ÌÜ±Îãà ÎÇ†ÏïÑÍ∞Ñ ÌõÑ Ìò∏Ï∂úÎê®
    } else if (isAnyBossStage) {
      this.resetStage();
      this.moveTimer.paused = true;
      this.food = { x: -100, y: -100 };
      this.hideFoodGraphics();
    }

    if (!isAnyBossStage && this.isBossStage) {
      this.isBossStage = false;
      this.bossMode = false;
      this.combo = this.savedCombo;
      this.comboShieldCount = this.savedComboShieldCount;
      if (this.combo > 0) {
        this.comboText.setText(`x${this.combo}`);
      }
      this.updateItemStatusUI();
    }

    if (!isAnyBossStage) {
      this.resetStage();
    }

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ ÏãúÏûë (ÌÜ±Îãà ÎÇ†ÏïÑÍ∞ÄÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Î®ºÏ†Ä)
    if (isGearTitan) {
      this.time.delayedCall(500, () => {
        this.animateSawsFlyOut(() => {
          this.resetStage();
          this.showSnakeGraphics(); // Î±Ä Îã§Ïãú Î≥¥Ïù¥Í∏∞
          this.startGearTitan();
        });
      });
    }

    if (this.hasSpeedBoost) {
      this.initSpeedBoostOrbitals();
    }

    const stageLabel = `STAGE ${this.currentStage}`;
    const stageColor = '#00ff00';
    const strokeColor = '#008800';

    const stageText = this.add.text(width / 2, height / 2 - 100, stageLabel, {
      fontSize: '96px',
      fill: stageColor,
      fontStyle: 'bold',
      stroke: strokeColor,
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    this.tweens.add({
      targets: stageText,
      alpha: { from: 0, to: 0.7 },
      scaleX: { from: 1.2, to: 1 },
      scaleY: { from: 1.2, to: 1 },
      duration: 300,
      ease: 'Power2',
      onComplete: () => {
        this.time.delayedCall(400, () => {
          this.tweens.add({
            targets: stageText,
            alpha: 0,
            duration: 300,
            onComplete: () => {
              stageText.destroy();

              if (this.currentStage === 5) {
                this.addDeadZonesForStage4();
              }
            }
          });
        });
      }
    });
  }

  resetStage() {
    // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌîåÎûòÍ∑∏ Î¶¨ÏÖã
    this.isStageClearingAnimation = false;

    if (this.gridGraphics) {
      this.gridGraphics.setVisible(true);
    }

    // Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ Ï†ïÎ¶¨ (ÏÉàÎ°ú ÏÉùÏÑ±ÌïòÍ∏∞ Ï†ÑÏóê)
    this.cleanupSpeedBoostOrbitals();
    this.resetFogOfWar();
    this.stopStage8BlackoutCycle();
    this.stopDarkCreepCycle();
    this.stopStage8GhostSpawning();

    // Meta Universe Ï†ïÎ¶¨
    if (this.metaUniverseMode) {
      this.cleanupMetaUniverse();
    }

    // ÏïàÍ∞ú Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.fogBossMode) {
      this.cleanupFogBoss();
    }

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.gearTitanMode) {
      this.cleanupGearTitan();
    }

    // ÌÜ±Îãà Î≥¥Ï°¥ Ï≤¥ÌÅ¨: World 3 (Stage 10-12) ÎÇ¥ÏóêÏÑú ÌÜ±Îãà Ïú†ÏßÄ
    if (!this.shouldPreserveSaws()) {
      this.destroyAllSaws();
      this.destroyAllEnhancedSaws();
    } else {
      // ÌÜ±Îãà Î≥¥Ï°¥ Ïãú ÏõÄÏßÅÏûÑ Ïû¨Í∞ú
      this.resumeAllSaws();
    }
    this.preserveSawsForNextStage = false; // ÌîåÎûòÍ∑∏ Î¶¨ÏÖã

    // Stage 11 ÏãúÏûë: Í∞ïÌôî ÌÜ±Îãà Îì±Ïû• Ïó∞Ï∂ú
    if (this.currentStage === 11 && this.saws.length > 0) {
      this.time.delayedCall(500, () => {
        this.startEnhancedSawHellStage();
      });
    }

    // ÎèÖÍ∞ÄÏä§ Ï†ïÎ¶¨
    this.stopGasZone();

    // Flux Maze ÏãúÏä§ÌÖú Ï†ïÎ¶¨
    this.stopPolaritySystem();
    this.cleanupMagneticTurrets();
    this.cleanupLaserTurrets();
    this.cleanupFloatingMines();

    // NEXUS Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.nexusMode) {
      this.cleanupNexus();
    }

    // Î±Ä Ï¥àÍ∏∞Ìôî
    this.snake = [
      { x: 10, y: 15 },
      { x: 9, y: 15 },
      { x: 8, y: 15 }
    ];

    // Î∞©Ìñ• Ï¥àÍ∏∞Ìôî
    this.direction = 'RIGHT';
    this.inputQueue = [];

    // Î≥¥Ïä§Ï†Ñ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.bossPhase = 'none';
    this.bossHitCount = 0;
    this.poisonGrowthActive = false;
    this.poisonGrowthData = null;
    this.snakePoisoned = false;
    if (this.bossElement) {
      this.bossElement.destroy();
      this.bossElement = null;
    }

    // Î®πÏù¥ Í∞úÏàò Î¶¨ÏÖã
    this.foodCount = 0;
    this.foodCountText.setText('0');

    // Ïä§ÏΩîÏñ¥ Î¶¨ÏÖã (Îß§ Ïä§ÌÖåÏù¥ÏßÄ 0ÏóêÏÑú ÏãúÏûë)
    this.score = 0;
    this.scoreText.setText('0');

    // ÏΩ§Î≥¥Îäî Ïú†ÏßÄ (Ïä§ÌÖåÏù¥ÏßÄ ÎÑòÏñ¥Í∞ÄÎèÑ Ïù¥Ïñ¥Ïßê)
    this.directionChangesCount = 0;

    // Î®πÏù¥ ÏÉùÏÑ± (Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑúÎäî ÏÉùÏÑ± ÏïàÌï®)
    if (!this.isBossStage && !this.gearTitanMode) {
      this.food = this.generateFood();
    } else {
      // Î≥¥Ïä§Ï†ÑÏóêÏÑúÎäî Î®πÏù¥Î•º ÌôîÎ©¥ Î∞ñÏúºÎ°ú
      this.food = { x: -100, y: -100 };
    }

    // Î™®Îì† Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë ÏÜçÎèÑ 90ms Í≥†Ï†ï
    const startSpeed = 90;
    this.moveTimer.delay = startSpeed;

    // ÏÜçÎèÑ UI ÏóÖÎç∞Ïù¥Ìä∏
    this.speedText.setText(startSpeed + 'ms');

    // Í≤åÏûÑ Ïû¨Í∞ú
    this.moveTimer.paused = false;

    // Î±Ä/Î®πÏù¥ Î®ºÏ†Ä Í∑∏Î¶¨Í∏∞ (ÏïàÍ∞ú ÌôúÏÑ±Ìôî Ï†ÑÏóê Î†åÎçîÎßÅ)
    this.draw();

    // Ïä§ÌÖåÏù¥ÏßÄ 7ÏóêÏÑú Ï≤òÏùå ÏßÑÏûÖ Ïãú ÏïàÍ∞ú Ïù∏Ìä∏Î°ú Ïã§Ìñâ
    this.startFogIntroIfNeeded();

    // World 4 (Stage 13-14): ÏõêÌòï ÎèÖÍ∞ÄÏä§ ÏûêÍ∏∞Ïû• ÏãúÏä§ÌÖú ÌôúÏÑ±Ìôî
    // Stage 15 (NEXUS Î≥¥Ïä§)Îäî Ïù∏Ìä∏Î°ú Ïó∞Ï∂ú ÌõÑ ÏãúÏûë
    if (shouldHaveGasZone(this.currentStage) && !isMagnetarStage(this.currentStage)) {
      this.time.delayedCall(1000, () => {
        this.startGasZone();
      });
    }

    // ÌÉÑÎßâ Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 6)
    if (this.isBulletBossStage()) {
      this.time.delayedCall(500, () => {
        this.startBulletBoss();
      });
    }

    // ÏïàÍ∞ú Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 9 - World 2 ÎÖπÌÑ¥ Î≥¥Ïä§)
    if (this.isFogBossStage()) {
      this.time.delayedCall(500, () => {
        this.startFogBoss();
      });
    }

    // Flux Maze Í∏∞Îä• ÌôúÏÑ±Ìôî (Stage 14) - Î†àÏù¥Ï†Ä ÌÑ∞Î†õ ÏãúÏä§ÌÖú
    if (shouldHaveLaserTurrets(this.currentStage)) {
      this.time.delayedCall(1000, () => {
        this.initLaserTurrets();
      });
    }

    if (shouldHaveFloatingMines(this.currentStage)) {
      this.time.delayedCall(2000, () => {
        this.startMineSpawner();
      });
    }

    // NEXUS Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 15)
    if (isMagnetarStage(this.currentStage)) {
      this.bossPhase = 'intro';
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.hideFoodGraphics();
      this.time.delayedCall(500, () => {
        this.startNexusBoss();
      });
    }

    // Meta Universe Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 16-18)
    if (isMetaUniverseStage(this.currentStage) && this.currentStage === 16) {
      // Stage 16ÏóêÏÑúÎßå Ïù∏Ìä∏Î°ú ÌëúÏãú
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.time.delayedCall(500, () => {
        this.showMetaUniverseIntro();
      });
    }

    // Quantum Split Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 17)
    if (isQuantumSplitStage(this.currentStage)) {
      this.food = { x: -100, y: -100 }; // Í∏∞Î≥∏ Î®πÏù¥ Ïà®ÍπÄ
      this.moveTimer.paused = true;
      this.time.delayedCall(500, () => {
        this.showQuantumSplitIntro();
      });
    }

    // Multiverse Collapse Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 18)
    if (isMultiverseCollapseStage(this.currentStage)) {
      this.food = { x: -100, y: -100 }; // Í∏∞Î≥∏ Î®πÏù¥ Ïà®ÍπÄ
      this.moveTimer.paused = true;
      this.time.delayedCall(500, () => {
        this.startMultiverseCollapseBoss();
      });
    }
  }

  // =====================
  // ÏÉÅÏ†ê ÏãúÏä§ÌÖú (Balatro Style)
  // =====================

  openShop() {
    // Ïù¥ÎØ∏ ÏÉÅÏ†êÏù¥ Ïó¥Î†§ÏûàÏúºÎ©¥ Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ
    if (this.shopOpen) return;

    // Ïù∏Í≤åÏûÑ Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ Ï†ïÎ¶¨ (ÏÉÅÏ†êÏóêÏÑúÎäî ÌîÑÎ¶¨Î∑∞Ïö©ÏúºÎ°ú Î≥ÑÎèÑ ÌëúÏãú)
    this.cleanupSpeedBoostOrbitals();

    this.shopOpen = true;
    if (this.pauseHintText && this.pauseHintText.active) {
      this.pauseHintText.setVisible(false);
    }
    this.isPurchaseConfirmOpen = false;
    this.purchaseConfirmSelection = 'yes';
    this.pendingPurchaseIndex = null;
    this.lastPurchaseConfirmKey = null;
    this.purchaseConfirmButtons = null;
    this.lastShopFocusKey = null;
    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ ÏÉÅÏ†ê ÏöîÏÜåÍ∞Ä ÎÇ®ÏïÑÏûàÏúºÎ©¥ Ï†ïÎ¶¨
    if (this.shopElements && this.shopElements.length > 0) {
      this.shopElements.forEach(el => {
        if (el && el.destroy) el.destroy();
      });
      this.shopElements = [];
    }
    if (this.shopCards && this.shopCards.length > 0) {
      this.shopCards.forEach(card => {
        if (card && card.destroy) card.destroy();
      });
      this.shopCards = [];
    }
    if (this.shopDebtElements && this.shopDebtElements.length > 0) {
      this.shopDebtElements.forEach(el => {
        if (el && el.destroy) el.destroy();
      });
      this.shopDebtElements = [];
    }

    // Îßµ ÏúÑÏùò Î±Ä Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨ (Î≥¥Ïä§Ï†Ñ ÌõÑ Î≥¥ÎùºÏÉâ Î±Ä Îì±)
    this.snakePoisoned = false;
    this.graphics.clear();

    // Îß§ ÏÉÅÏ†ê Ïò§Ìîà Ïãú ÏïÑÏù¥ÌÖú Î™©Î°ù ÏÉàÎ°ú Î°úÎìú
    this.shopItems = getShopItems();

    // ÎåÄÏ∂ú Ïù¥Ïûê Ï†ÅÏö©ÏùÄ animateScoreToMoneyÏóêÏÑú Ïä§ÏΩîÏñ¥ Ìï©ÏÇ∞ ÌõÑ Ï≤òÎ¶¨
    // (Ïä§ÏΩîÏñ¥ + Í∏∞Ï°¥Îèà ‚Üí ÏÉÅÌôò ‚Üí ÏµúÏ¢ÖÍ∏àÏï°)

    // Ï≤´ ÏÉÅÏ†ê Ïò§Ìîà Ïó¨Î∂Ä ÌôïÏù∏
    const isFirstShop = !this.hasOpenedShopBefore;
    if (isFirstShop) {
      this.hasOpenedShopBefore = true;
    }

    // Ïñ¥ÎëêÏö¥ Ïò§Î≤ÑÎ†àÏù¥ (ÌéòÏù¥ÎìúÏù∏)
    const overlay = this.add.rectangle(0, 0, width, height, 0x0a1628, 0)
      .setOrigin(0, 0)
      .setDepth(6000);
    this.shopElements.push(overlay);

    this.tweens.add({
      targets: overlay,
      fillAlpha: 0.85,
      duration: 600,
      ease: 'Power2'
    });

    // Ï≤´ ÏÉÅÏ†ê Ïò§Ìîà Ï∂ïÌïò Ïï†ÎãàÎ©îÏù¥ÏÖò
    if (isFirstShop) {
      // ÌôîÎ©¥ ÌîåÎûòÏãú Ìö®Í≥º
      const flash = this.add.rectangle(0, 0, width, height, 0xffffff, 0)
        .setOrigin(0, 0).setDepth(6150);
      this.tweens.add({
        targets: flash,
        fillAlpha: { from: 0, to: 0.8 },
        duration: 150,
        yoyo: true,
        onComplete: () => flash.destroy()
      });

      // Î©îÏù∏ Ï∂ïÌïò ÌÖçÏä§Ìä∏
      const unlockText = this.add.text(width / 2, height / 2 - 60, 'üéä SHOP UNLOCKED! üéä', {
        fontSize: '48px',
        fill: '#ffff00',
        fontStyle: 'bold',
        stroke: '#ff0000',
        strokeThickness: 6
      }).setOrigin(0.5).setDepth(6100).setAlpha(0).setScale(0);

      // ÏÑúÎ∏å ÌÖçÏä§Ìä∏
      const subText = this.add.text(width / 2, height / 2 + 10, '‚ú® You can now buy powerful items! ‚ú®', {
        fontSize: '22px',
        fill: '#00ffff',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
      }).setOrigin(0.5).setDepth(6100).setAlpha(0);

      // ÎåÄÌòï ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú Ìö®Í≥º
      const colors = [0xffff00, 0xff6600, 0x00ff00, 0xff00ff, 0x00ffff, 0xff0000];

      // Ï§ëÏïôÏóêÏÑú ÌçºÏßÄÎäî ÌååÌã∞ÌÅ¥
      for (let i = 0; i < 60; i++) {
        const angle = (i / 60) * Math.PI * 2;
        const distance = Phaser.Math.Between(100, 250);
        const particle = this.add.circle(
          width / 2,
          height / 2,
          Phaser.Math.Between(4, 12),
          colors[i % colors.length],
          1
        ).setDepth(6099).setAlpha(0);

        this.tweens.add({
          targets: particle,
          alpha: { from: 0, to: 1 },
          x: width / 2 + Math.cos(angle) * distance,
          y: height / 2 + Math.sin(angle) * distance,
          scaleX: { from: 1.5, to: 0 },
          scaleY: { from: 1.5, to: 0 },
          duration: Phaser.Math.Between(1000, 2000),
          delay: Phaser.Math.Between(0, 300),
          ease: 'Power2',
          onComplete: () => particle.destroy()
        });
      }

      // Î≥Ñ ÌååÌã∞ÌÅ¥ (ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî)
      for (let i = 0; i < 30; i++) {
        const star = this.add.text(
          Phaser.Math.Between(100, width - 100),
          height + 50,
          '‚≠ê',
          { fontSize: Phaser.Math.Between(16, 32) + 'px' }
        ).setOrigin(0.5).setDepth(6098).setAlpha(0);

        this.tweens.add({
          targets: star,
          alpha: { from: 0, to: 1 },
          y: Phaser.Math.Between(-50, height / 2),
          rotation: Phaser.Math.Between(-2, 2),
          duration: Phaser.Math.Between(1500, 2500),
          delay: Phaser.Math.Between(100, 800),
          ease: 'Power1',
          onComplete: () => star.destroy()
        });
      }

      // Î©îÏù∏ ÌÖçÏä§Ìä∏ Îì±Ïû• (Í∞ïÎ†¨Ìïú Î∞îÏö¥Ïä§)
      this.tweens.add({
        targets: unlockText,
        alpha: 1,
        scale: { from: 0, to: 1.5 },
        duration: 600,
        ease: 'Back.easeOut',
        onComplete: () => {
          // ÌéÑÏä§ Ìö®Í≥º
          this.tweens.add({
            targets: unlockText,
            scale: { from: 1.5, to: 1.3 },
            duration: 300,
            yoyo: true,
            repeat: 2,
            ease: 'Sine.easeInOut'
          });

          // Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Î≥ÄÌôî
          let colorIndex = 0;
          const rainbowColors = ['#ffff00', '#ff6600', '#ff00ff', '#00ffff', '#00ff00'];
          this.time.addEvent({
            delay: 150,
            repeat: 10,
            callback: () => {
              unlockText.setFill(rainbowColors[colorIndex % rainbowColors.length]);
              colorIndex++;
            }
          });
        }
      });

      // ÏÑúÎ∏å ÌÖçÏä§Ìä∏ Îì±Ïû•
      this.tweens.add({
        targets: subText,
        alpha: 1,
        y: height / 2 + 30,
        scale: { from: 0.5, to: 1 },
        duration: 500,
        delay: 400,
        ease: 'Back.easeOut'
      });

      // Ï∂ïÌïò ÌÖçÏä§Ìä∏ ÌéòÏù¥ÎìúÏïÑÏõÉ ÌõÑ ÏÉÅÏ†ê UI ÌëúÏãú
      this.time.delayedCall(2500, () => {
        this.tweens.add({
          targets: [unlockText, subText],
          alpha: 0,
          scale: 0.5,
          duration: 400,
          ease: 'Power2',
          onComplete: () => {
            unlockText.destroy();
            subText.destroy();
          }
        });
      });
    }

    // ===== Î†àÏù¥ÏïÑÏõÉ Í≥ÑÏÇ∞ =====
    const sidebarMargin = 10; // ÌôîÎ©¥ ÎÅùÏóêÏÑú Í∞ÑÍ≤©
    const sidebarWidth = 140;
    const sidebarEndX = sidebarMargin + sidebarWidth;
    const rightAreaCenterX = sidebarEndX + (width - sidebarEndX) / 2;

    // ===== ÎÑ§Ïò® SHOP ÌÉÄÏù¥ÌãÄ =====

    const titleBg = this.add.rectangle(rightAreaCenterX, 50, 200, 60, 0x8B0000, 1)
      .setDepth(6001)
      .setStrokeStyle(4, 0xff0000)
      .setAlpha(0);
    this.shopElements.push(titleBg);

    const title = this.add.text(rightAreaCenterX, 50, 'SHOP', {
      fontSize: '42px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff6600',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(6002).setAlpha(0);
    this.shopElements.push(title);

    // ÌÉÄÏù¥ÌãÄ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.time.delayedCall(200, () => {
      this.tweens.add({
        targets: [titleBg, title],
        alpha: 1,
        scaleX: { from: 0, to: 1 },
        scaleY: { from: 0, to: 1 },
        duration: 400,
        ease: 'Back.easeOut'
      });

      // ÎÑ§Ïò® ÍπúÎπ°ÏûÑ Ìö®Í≥º
      this.time.delayedCall(500, () => {
        this.tweens.add({
          targets: title,
          alpha: { from: 1, to: 0.7 },
          duration: 100,
          yoyo: true,
          repeat: 2,
          onComplete: () => {
            // ÏßÄÏÜçÏ†ÅÏù∏ ÎÑ§Ïò® ÌéÑÏä§
            this.shopNeonTween = this.tweens.add({
              targets: title,
              alpha: { from: 1, to: 0.8 },
              duration: 1500,
              yoyo: true,
              repeat: -1,
              ease: 'Sine.easeInOut'
            });
          }
        });
      });
    });

    // ===== ÏôºÏ™Ω ÏÇ¨Ïù¥ÎìúÎ∞î =====
    const sidebarX = -sidebarWidth;
    const sidebarFinalX = sidebarMargin + sidebarWidth / 2;

    const sidebar = this.add.rectangle(sidebarFinalX, height / 2, sidebarWidth, height - 80, 0x1a1a2e, 0.95)
      .setDepth(6001)
      .setStrokeStyle(2, 0x3d5a80)
      .setX(sidebarX);
    this.shopElements.push(sidebar);

    // ÏÇ¨Ïù¥ÎìúÎ∞î Ïä¨ÎùºÏù¥Îìú Ïù∏
    this.tweens.add({
      targets: sidebar,
      x: sidebarFinalX,
      duration: 500,
      ease: 'Back.easeOut',
      delay: 300
    });

    // ÏÇ¨Ïù¥ÎìúÎ∞î ÎÇ¥Ïö©
    const sidebarContent = [];
    const contentX = sidebarMargin + 10;
    const contentCenterX = sidebarMargin + sidebarWidth / 2;

    // Ïä§ÌÖåÏù¥ÏßÄ ÌëúÏãú
    const stageLabel = this.add.text(contentX, 100, 'STAGE', {
      fontSize: '12px',
      fill: '#888888',
      fontStyle: 'bold'
    }).setDepth(6002).setAlpha(0);
    sidebarContent.push(stageLabel);

    const stageValue = this.add.text(contentCenterX, 125, `${this.currentStage}`, {
      fontSize: '28px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(6002).setAlpha(0);
    sidebarContent.push(stageValue);

    // Îèà ÌëúÏãú
    const moneyLabel = this.add.text(contentX, 170, 'MONEY', {
      fontSize: '12px',
      fill: '#888888',
      fontStyle: 'bold'
    }).setDepth(6002).setAlpha(0);
    sidebarContent.push(moneyLabel);

    this.shopMoneyText = this.add.text(contentCenterX, 195, `$${this.money}`, {
      fontSize: '24px',
      fill: '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(6002).setAlpha(0);
    sidebarContent.push(this.shopMoneyText);

    this.shopElements.push(...sidebarContent);

    // Îπö Ï†ïÎ≥¥Îäî updateShopDebtInfoÏóêÏÑú Í¥ÄÎ¶¨ (Ï§ëÎ≥µ Î∞©ÏßÄ)
    this.shopDebtElements = [];

    // ÏÇ¨Ïù¥ÎìúÎ∞î ÎÇ¥Ïö© ÌéòÏù¥ÎìúÏù∏
    this.time.delayedCall(600, () => {
      sidebarContent.forEach((el, i) => {
        this.tweens.add({
          targets: el,
          alpha: 1,
          duration: 300,
          delay: i * 50,
          ease: 'Power2'
        });
      });
      // Îπö Ï†ïÎ≥¥ ÌëúÏãú - Ï†ïÏÇ∞ ÏôÑÎ£å ÌõÑÏóê ÌëúÏãúÎê® (animateScoreToMoneyÏóêÏÑú Ìò∏Ï∂ú)
      // Ïä§ÏΩîÏñ¥Í∞Ä ÏûàÏúºÎ©¥ Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî ÌëúÏãúÌïòÏßÄ ÏïäÏùå
      if (this.score === 0) {
        this.time.delayedCall(sidebarContent.length * 50 + 100, () => {
          this.updateShopDebtInfo();
        });
      }
    });

    // ===== ÏïÑÏù¥ÌÖú Ïπ¥ÎìúÎì§ =====
    this.shopCards = [];
    const cardWidth = 100;
    const cardHeight = 140;
    const cardSpacing = 120;
    const cardY = 200;
    // Ïö∞Ï∏° ÏòÅÏó≠ Ï§ëÏïô Í∏∞Ï§ÄÏúºÎ°ú Ïπ¥Îìú Î∞∞Ïπò
    const totalCardsWidth = (this.shopItems.length - 1) * cardSpacing;
    const cardStartX = rightAreaCenterX - totalCardsWidth / 2;

    // Ï¥ù Îèà Í≥ÑÏÇ∞ (ÌòÑÏû¨ money + ÌöçÎìùÌï† score)
    const totalMoney = this.money + this.score;

    this.shopItems.forEach((item, index) => {
      const cardX = cardStartX + index * cardSpacing;
      const canAfford = totalMoney >= item.price;

      // Ïπ¥Îìú Ïª®ÌÖåÏù¥ÎÑà
      const card = this.add.container(cardX, -200).setDepth(6001);

      // Íµ¨Îß§ Î∂àÍ∞Ä ÏïÑÏù¥ÌÖúÏùÄ Ï≤òÏùåÎ∂ÄÌÑ∞ Ïñ¥Îë°Í≤å
      if (!item.purchased && !canAfford) {
        card.setAlpha(0.5);
      }

      // Ïπ¥Îìú Î∞∞Í≤Ω
      const cardBg = this.add.rectangle(0, 0, cardWidth, cardHeight, 0x2a3f5f, 1)
        .setStrokeStyle(3, item.purchased ? 0x666666 : 0x4a9eff);

      // Ïπ¥Îìú ÎÇ¥Î∂Ä Ìå®ÌÑ¥
      const cardInner = this.add.rectangle(0, -20, cardWidth - 20, cardHeight - 60, 0x1a2a3f, 1);

      // ÏïÑÏù¥ÌÖú ÏïÑÏù¥ÏΩò (Ïù¥ÎØ∏ÏßÄ ÎòêÎäî Ïù¥Î™®ÏßÄ)
      let iconElement;
      if (item.icon && this.textures.exists(item.icon)) {
        // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÏúºÎ©¥ Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ïö©
        iconElement = this.add.image(0, -20, item.icon)
          .setDisplaySize(64, 64);
      } else {
        // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Ïù¥Î™®ÏßÄ
        const defaultIcons = ['‚ö°', '√ó2', '‚ù§', 'üß≤', 'üõ°'];
        iconElement = this.add.text(0, -25, defaultIcons[index] || '?', {
          fontSize: '32px'
        }).setOrigin(0.5);
      }

      // ÏïÑÏù¥ÌÖú Ïù¥Î¶Ñ
      const nameText = this.add.text(0, 30, item.name.split(' ')[0], {
        fontSize: '11px',
        fill: item.purchased ? '#666666' : '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5);

      // Í∞ÄÍ≤© ÌÉúÍ∑∏ (Íµ¨Îß§ Í∞ÄÎä• Ïó¨Î∂ÄÏóê Îî∞Îùº ÏÉâÏÉÅ)
      const priceTagColor = item.purchased ? 0x666666 : (canAfford ? 0x00aa00 : 0x661111);
      const priceTagStroke = item.purchased ? 0x444444 : (canAfford ? 0x00ff00 : 0xff4444);
      const priceTag = this.add.rectangle(0, -cardHeight / 2 - 15, 40, 20, priceTagColor, 1)
        .setStrokeStyle(2, priceTagStroke);

      const priceTextColor = item.purchased ? '#666666' : (canAfford ? '#00ff00' : '#ff4444');
      const priceText = this.add.text(0, -cardHeight / 2 - 15,
        item.purchased ? 'SOLD' : `$${item.price}`, {
        fontSize: '10px',
        fill: priceTextColor,
        fontStyle: 'bold'
      }).setOrigin(0.5);

      card.add([cardBg, cardInner, iconElement, nameText, priceTag, priceText]);
      this.shopElements.push(card);

      this.shopCards.push({
        container: card,
        bg: cardBg,
        name: nameText,
        price: priceText,
        priceTag: priceTag,
        index: index
      });

      // Ïπ¥Îìú Îñ®Ïñ¥ÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.time.delayedCall(400 + index * 150, () => {
        this.tweens.add({
          targets: card,
          y: cardY,
          duration: 600,
          ease: 'Bounce.easeOut'
        });

        // Ï∞©ÏßÄ Ïãú ÌååÌã∞ÌÅ¥
        this.time.delayedCall(600, () => {
          for (let i = 0; i < 3; i++) {
            const particle = this.add.circle(
              cardX + (Math.random() - 0.5) * 30,
              cardY + cardHeight / 2,
              2,
              0x4a9eff
            ).setDepth(6000).setAlpha(0.8);

            this.tweens.add({
              targets: particle,
              y: cardY + cardHeight / 2 + 20,
              alpha: 0,
              duration: 300,
              onComplete: () => particle.destroy()
            });
          }
        });
      });
    });

    // ===== Î±Ä ÌîÑÎ¶¨Î∑∞ ÏòÅÏó≠ =====
    const previewY = 430;
    const previewGridSize = 12;
    const previewCols = 22;
    const previewRows = 5;
    const previewWidth = previewCols * previewGridSize;
    const previewHeight = previewRows * previewGridSize;
    const previewX = rightAreaCenterX - previewWidth / 2;

    // ÎØ∏ÎãàÎßµ Î∞∞Í≤Ω
    const previewBg = this.add.rectangle(
      rightAreaCenterX, previewY,
      previewWidth, previewHeight,
      0x0d1117, 1
    ).setDepth(6001).setAlpha(0);
    this.shopElements.push(previewBg);

    // Í∑∏Î¶¨Îìú ÎùºÏù∏ Ï†ÄÏû•Ïö©
    const gridLines = [];

    // Í∑∏Î¶¨Îìú ÎùºÏù∏ (Îçî ÏÑ†Î™ÖÌïòÍ≤å)
    for (let i = 0; i <= previewCols; i++) {
      const x = previewX + i * previewGridSize;
      const line = this.add.rectangle(x, previewY, 1, previewHeight, 0x3a4a5a, 1)
        .setDepth(6001).setAlpha(0);
      gridLines.push(line);
      this.shopElements.push(line);
    }
    for (let i = 0; i <= previewRows; i++) {
      const y = previewY - previewHeight / 2 + i * previewGridSize;
      const line = this.add.rectangle(rightAreaCenterX, y, previewWidth, 1, 0x3a4a5a, 1)
        .setDepth(6001).setAlpha(0);
      gridLines.push(line);
      this.shopElements.push(line);
    }

    // ÌÖåÎëêÎ¶¨
    const previewBorder = this.add.rectangle(
      rightAreaCenterX, previewY,
      previewWidth, previewHeight
    ).setDepth(6002).setStrokeStyle(2, 0x4a6a8a).setFillStyle(0x000000, 0).setAlpha(0);
    this.shopElements.push(previewBorder);

    // Ï¥àÍ∏∞ Î±Ä (6Ïπ∏, Í∞ÄÎ°ú)
    this.shopSnakePreview = [];
    const snakeLength = 6;
    const snakeStartCol = Math.floor(previewCols / 2) + 2;
    const snakeRow = Math.floor(previewRows / 2);

    for (let i = 0; i < snakeLength; i++) {
      const col = snakeStartCol - i;
      const cellX = previewX + col * previewGridSize + previewGridSize / 2;
      const cellY = previewY - previewHeight / 2 + snakeRow * previewGridSize + previewGridSize / 2;

      const isHead = i === 0;
      // ÏΩ§Î≥¥ Ïã§ÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÎÖ∏ÎûÄÏÉâ, ÏóÜÏúºÎ©¥ ÎÖπÏÉâ
      const color = isHead ? (this.comboShieldCount > 0 ? 0xffff00 : 0x00ff00) : 0x00cc00;

      const segment = this.add.rectangle(
        cellX, cellY,
        previewGridSize - 2, previewGridSize - 2,
        color, 1
      ).setDepth(6002).setAlpha(0);

      this.shopSnakePreview.push(segment);
      this.shopElements.push(segment);
    }

    // ÌîÑÎ¶¨Î∑∞ Ï¢åÌëú Ï†ÄÏû• (ÏàòÌä∏ Ï†ÅÏö©Ïö©)
    this.shopPreviewInfo = {
      headX: previewX + snakeStartCol * previewGridSize + previewGridSize / 2,
      headY: previewY - previewHeight / 2 + snakeRow * previewGridSize + previewGridSize / 2,
      gridSize: previewGridSize
    };

    // ÌîÑÎ¶¨Î∑∞ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.time.delayedCall(1000, () => {
      // Î∞∞Í≤ΩÍ≥º Í∑∏Î¶¨Îìú
      this.tweens.add({
        targets: [previewBg, ...gridLines],
        alpha: 0.6,
        duration: 300,
        ease: 'Power2'
      });

      // ÌÖåÎëêÎ¶¨
      this.tweens.add({
        targets: previewBorder,
        alpha: 1,
        duration: 300,
        ease: 'Power2'
      });

      // Î±Ä ÏÑ∏Í∑∏Î®ºÌä∏ ÏàúÏ∞® Îì±Ïû•
      this.shopSnakePreview.forEach((segment, i) => {
        this.tweens.add({
          targets: segment,
          alpha: 1,
          duration: 200,
          delay: 100 + i * 50,
          ease: 'Back.easeOut'
        });
      });

      // Ïû•Ï∞©Îêú ÏàòÌä∏ Ï†ÅÏö© (Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ Îì±)
      this.time.delayedCall(400, () => {
        this.applyShopPreviewSuits();
      });
    });

    // ===== ÌïòÎã® Î≤ÑÌäºÎì§ =====
    // ÏÇ¨Ïù¥ÎìúÎ∞î ÌïòÎã®Í≥º Î≤ÑÌäº ÌïòÎã® Ï†ïÎ†¨ (ÏÇ¨Ïù¥ÎìúÎ∞î ÌïòÎã®: height - 40, Î≤ÑÌäº ÎÜíÏù¥: 45)
    const sidebarBottom = height - 40;
    const buttonHeight = 45;
    const buttonY = sidebarBottom - buttonHeight / 2;
    const buttonGap = 12;
    const nextBtnWidth = 110;
    const loanBtnWidth = 70;

    // 5Î≤àÏß∏ Ïπ¥Îìú Ïö∞Ï∏° = cardStartX + 4 * cardSpacing + cardWidth / 2
    const lastCardRightX = cardStartX + 4 * cardSpacing + cardWidth / 2;
    const loanBtnX = lastCardRightX - loanBtnWidth / 2;

    // Loan Î≤ÑÌäº ÌëúÏãú Ïó¨Î∂Ä Î®ºÏ†Ä ÌôïÏù∏
    const showLoanBtn = this.currentStage >= 8;

    // Loan Î≤ÑÌäºÏù¥ ÏóÜÏúºÎ©¥ Next Stage Ïö∞Ï∏°ÏùÑ Ïπ¥Îìú Ïö∞Ï∏°Ïóê ÎßûÏ∂§, ÏûàÏúºÎ©¥ Loan ÏôºÏ™ΩÏóê Î∞∞Ïπò
    const nextBtnX = showLoanBtn
      ? loanBtnX - loanBtnWidth / 2 - buttonGap - nextBtnWidth / 2
      : lastCardRightX - nextBtnWidth / 2;

    // Next Stage Î≤ÑÌäº (Î™®Îçò Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïä§ÌÉÄÏùº)
    const nextBtnGlow = this.add.rectangle(nextBtnX, buttonY, nextBtnWidth + 8, 53, 0x00ff88, 0.3)
      .setDepth(6000)
      .setAlpha(0);

    const nextBtnBg = this.add.rectangle(nextBtnX, buttonY, nextBtnWidth, 45, 0x1a472a, 1)
      .setDepth(6001)
      .setStrokeStyle(2, 0x00ff88)
      .setAlpha(0);

    const nextBtnHighlight = this.add.rectangle(nextBtnX, buttonY - 12, nextBtnWidth - 10, 8, 0x00ff88, 0.2)
      .setDepth(6001)
      .setAlpha(0);

    const nextBtnText = this.add.text(nextBtnX, buttonY, 'NEXT STAGE', {
      fontSize: '16px',
      fill: '#00ff88',
      fontStyle: 'bold',
      align: 'center'
    }).setOrigin(0.5).setDepth(6002).setAlpha(0);

    this.shopNextBtn = { bg: nextBtnBg, text: nextBtnText, glow: nextBtnGlow, highlight: nextBtnHighlight };
    this.shopElements.push(nextBtnGlow, nextBtnBg, nextBtnHighlight, nextBtnText);

    // Loan Î≤ÑÌäº (Stage 8 ÌÅ¥Î¶¨Ïñ¥ ÌõÑ Ïò§Ìîà)
    const isFirstLoan = this.currentStage === 8; // Ï≤òÏùå ÎåÄÏ∂ú Í∏∞Îä• Ìï¥Í∏à

    if (showLoanBtn) {
      const loanBtnGlow = this.add.rectangle(loanBtnX, buttonY, loanBtnWidth + 8, 53, 0xff6b6b, 0.3)
        .setDepth(6000)
        .setAlpha(0);

      const loanBtnBg = this.add.rectangle(loanBtnX, buttonY, loanBtnWidth, 45, 0x4a1a1a, 1)
        .setDepth(6001)
        .setStrokeStyle(2, 0xff6b6b)
        .setAlpha(0);

      const loanBtnHighlight = this.add.rectangle(loanBtnX, buttonY - 12, loanBtnWidth - 10, 8, 0xff6b6b, 0.2)
        .setDepth(6001)
        .setAlpha(0);

      const loanBtnText = this.add.text(loanBtnX, buttonY, 'LOAN', {
        fontSize: '16px',
        fill: '#ff6b6b',
        fontStyle: 'bold',
        align: 'center'
      }).setOrigin(0.5).setDepth(6002).setAlpha(0);

      this.shopLoanBtn = { bg: loanBtnBg, text: loanBtnText, glow: loanBtnGlow, highlight: loanBtnHighlight };
      this.shopElements.push(loanBtnGlow, loanBtnBg, loanBtnHighlight, loanBtnText);

      // Ï≤òÏùå ÎåÄÏ∂ú Í∏∞Îä• Ìï¥Í∏à Ïãú NEW Î±ÉÏßÄ Ï∂îÍ∞Ä
      if (isFirstLoan) {
        const newBadge = this.add.text(loanBtnX + 25, buttonY - 25, 'NEW!', {
          fontSize: '10px',
          fill: '#ffff00',
          fontStyle: 'bold',
          stroke: '#ff6600',
          strokeThickness: 2
        }).setOrigin(0.5).setDepth(6003).setAlpha(0);
        this.shopElements.push(newBadge);

        // NEW Î±ÉÏßÄ ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
        this.time.delayedCall(1400, () => {
          this.tweens.add({
            targets: newBadge,
            alpha: 1,
            scale: { from: 0, to: 1.2 },
            duration: 300,
            ease: 'Back.easeOut',
            onComplete: () => {
              this.tweens.add({
                targets: newBadge,
                scale: { from: 1.2, to: 1 },
                duration: 200,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
              });
            }
          });
        });
      }
    } else {
      this.shopLoanBtn = null;
    }

    // Î≤ÑÌäº Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò (Ïä¨ÎùºÏù¥Îìú ÏóÖ + ÌéòÏù¥Îìú)
    this.time.delayedCall(1200, () => {
      const allBtnElements = [
        nextBtnGlow, nextBtnBg, nextBtnHighlight, nextBtnText
      ];

      // Loan Î≤ÑÌäºÏù¥ ÏûàÏúºÎ©¥ Ï∂îÍ∞Ä
      if (this.shopLoanBtn) {
        allBtnElements.push(
          this.shopLoanBtn.glow, this.shopLoanBtn.bg,
          this.shopLoanBtn.highlight, this.shopLoanBtn.text
        );
      }

      allBtnElements.forEach((el, i) => {
        const originalY = el.y;
        el.y = originalY + 30;
        this.tweens.add({
          targets: el,
          y: originalY,
          alpha: (el === nextBtnGlow || (this.shopLoanBtn && el === this.shopLoanBtn.glow)) ? 0.3 : 1,
          duration: 400,
          delay: Math.floor(i / 4) * 150,
          ease: 'Back.easeOut'
        });
      });

      // Next Stage Î≤ÑÌäº Í∏ÄÎ°úÏö∞ ÌéÑÏä§
      this.tweens.add({
        targets: nextBtnGlow,
        alpha: 0.5,
        scaleX: 1.05,
        scaleY: 1.1,
        duration: 1000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    });

    // ÏÑ†ÌÉù Ïù∏Îç±Ïä§ Ï¥àÍ∏∞Ìôî (Ï≤´ Î≤àÏß∏ Íµ¨Îß§ Í∞ÄÎä•Ìïú ÏïÑÏù¥ÌÖú)
    this.selectedShopIndex = 0;
    for (let i = 0; i < this.shopItems.length; i++) {
      if (!this.shopItems[i].purchased) {
        this.selectedShopIndex = i;
        break;
      }
    }
    // Î™®Îì† ÏïÑÏù¥ÌÖúÏù¥ SOLDÎ©¥ Next Stage Î≤ÑÌäº ÏÑ†ÌÉù
    if (this.shopItems.every(item => item.purchased)) {
      this.selectedShopIndex = this.shopItems.length;
    }

    // Ïä§ÏΩîÏñ¥ ‚Üí Îèà Ï†ÑÌôò Ïï†ÎãàÎ©îÏù¥ÏÖò (Ï≤´ ÏÉÅÏ†êÏùÄ Ï∂ïÌïò ÌõÑ ÏãúÏûë)
    const settleDelay = isFirstShop ? 3000 : 800;
    this.time.delayedCall(settleDelay, () => {
      this.animateScoreToMoney();
    });

    // ÌÇ§Î≥¥Îìú ÌôúÏÑ±Ìôî (Ï≤´ ÏÉÅÏ†êÏùÄ Ï∂ïÌïò ÌõÑ ÌôúÏÑ±Ìôî)
    const keyboardDelay = isFirstShop ? 3700 : 1500;
    this.time.delayedCall(keyboardDelay, () => {
      this.updateShopSelection();
      this.shopKeyboardEnabled = true;
    });
  }

  animateScoreToMoney() {
    const { width, height } = this.cameras.main;
    const previousMoney = this.money;
    const scoreEarned = this.score;

    // Ï†ïÏÇ∞ Ï§ë ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (ÌÇ§Î≥¥Îìú ÏûÖÎ†• Ï∞®Îã®)
    this.isSettling = true;

    // 1. Ïä§ÏΩîÏñ¥Î•º Î®ºÏ†Ä Ìï©ÏÇ∞
    const afterScore = previousMoney + scoreEarned;
    this.money = afterScore;

    // 2. ÎåÄÏ∂úÏù¥ ÏûàÏúºÎ©¥ ÏûêÎèôÏÉÅÌôò Í≥ÑÏÇ∞ (5Ïä§ÌÖåÏù¥ÏßÄ ÏõêÎ¶¨Í∏àÍ∑†Îì±)
    const repayments = []; // Í∞Å ÏùÄÌñâÎ≥Ñ ÏÉÅÌôò Ï†ïÎ≥¥
    let hasMissedPayment = false;
    let bankruptBank = null;

    if (this.loans.length > 0) {
      this.loans.forEach(loan => {
        // ÎßàÏßÄÎßâ Ïä§ÌÖåÏù¥ÏßÄÎ©¥ ÎÇ®ÏùÄ Ï†ÑÏï°, ÏïÑÎãàÎ©¥ Í≥†Ï†ï ÏÉÅÌôòÏï°
        const payment = loan.stagesLeft === 1 ? loan.remaining : Math.min(loan.paymentPerStage, loan.remaining);

        if (this.money >= payment) {
          this.money -= payment;
          loan.remaining -= payment;
          loan.stagesLeft--;
          loan.missedPayments = 0;
          repayments.push({
            bankName: loan.bankName,
            amount: payment,
            remainingAfter: loan.remaining
          });
        } else {
          loan.missedPayments++;
          hasMissedPayment = true;
          repayments.push({
            bankName: loan.bankName,
            amount: 0,
            missed: true,
            remainingAfter: loan.remaining
          });
        }
      });

      bankruptBank = this.loans.find(l => l.missedPayments >= 2);
      this.loans = this.loans.filter(loan => loan.remaining > 0);
      this.loanTier = this.loans.length;
      this.totalDebt = this.loans.reduce((sum, loan) => sum + loan.remaining, 0);
    }

    const finalMoney = this.money;

    // ÌôîÎ©¥ Ï§ëÏïô Ï†ïÏÇ∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
    const centerX = width / 2;
    const centerY = height / 2;

    // Ìå®ÎÑê ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (ÏÉÅÌôò Í∞úÏàòÏóê Îî∞Îùº Ï°∞Ï†ï)
    const panelWidth = 300;
    const baseHeight = 140;
    const repaymentHeight = repayments.length > 0 ? repayments.length * 22 + 15 : 0;
    const panelHeight = baseHeight + repaymentHeight;

    // Ï†ïÏÇ∞ ÏòÅÏó≠ Î∞∞Í≤Ω Ìå®ÎÑê
    const panelBg = this.add.rectangle(centerX, centerY, panelWidth, panelHeight, 0x000000, 0.9)
      .setDepth(7100).setScale(0);
    const panelBorder = this.add.rectangle(centerX, centerY, panelWidth, panelHeight)
      .setStrokeStyle(3, 0xffff00).setDepth(7101).setScale(0);

    // Ìå®ÎÑê Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: [panelBg, panelBorder],
      scaleX: 1,
      scaleY: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    // Ï†ïÏÇ∞ ÏöîÏÜåÎì§ Ï†ÄÏû• (ÎÇòÏ§ëÏóê Ï†ïÎ¶¨Ïö©)
    const settlementElements = [panelBg, panelBorder];

    // Y ÏúÑÏπò Í≥ÑÏÇ∞
    const startY = centerY - panelHeight / 2 + 25;
    let currentY = startY;

    // Í∏∞Ï°¥Í∏àÏï° ÎùºÎ≤® + Í∏àÏï°
    const prevLabel = this.add.text(centerX - 100, currentY, 'Previous:', {
      fontSize: '13px',
      fill: '#aaaaaa'
    }).setOrigin(0, 0.5).setDepth(7102).setAlpha(0);
    settlementElements.push(prevLabel);

    const prevAmount = this.add.text(centerX + 100, currentY, `$${previousMoney}`, {
      fontSize: '13px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(1, 0.5).setDepth(7102).setAlpha(0);
    settlementElements.push(prevAmount);

    currentY += 24;

    // Ïä§ÏΩîÏñ¥ ÎùºÎ≤® + Í∏àÏï°
    const scoreLabel = this.add.text(centerX - 100, currentY, 'Score:', {
      fontSize: '13px',
      fill: '#aaaaaa'
    }).setOrigin(0, 0.5).setDepth(7102).setAlpha(0);
    settlementElements.push(scoreLabel);

    const scoreAmount = this.add.text(centerX + 100, currentY, `+$${scoreEarned}`, {
      fontSize: '13px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(1, 0.5).setDepth(7102).setAlpha(0);
    settlementElements.push(scoreAmount);

    currentY += 24;

    // Í∞Å ÏùÄÌñâÎ≥Ñ ÏÉÅÌôò ÎùºÎ≤® ÏÉùÏÑ±
    const repayLabels = [];
    repayments.forEach((repay, index) => {
      const bankLabel = this.add.text(centerX - 100, currentY + index * 22, `${repay.bankName}:`, {
        fontSize: '11px',
        fill: '#aaaaaa'
      }).setOrigin(0, 0.5).setDepth(7102).setAlpha(0);
      settlementElements.push(bankLabel);

      const amountText = repay.missed ? 'MISSED!' : `-$${repay.amount}`;
      const amountColor = repay.missed ? '#ff0000' : '#ff4444';
      const bankAmount = this.add.text(centerX + 100, currentY + index * 22, amountText, {
        fontSize: '11px',
        fill: amountColor,
        fontStyle: 'bold'
      }).setOrigin(1, 0.5).setDepth(7102).setAlpha(0);
      settlementElements.push(bankAmount);

      repayLabels.push({ label: bankLabel, amount: bankAmount, repay });
    });

    // Íµ¨Î∂ÑÏÑ†
    const dividerY = currentY + repayments.length * 22 + 8;
    const divider = this.add.rectangle(centerX, dividerY, 180, 2, 0xffffff, 0.3)
      .setDepth(7102).setAlpha(0);
    settlementElements.push(divider);

    // ÏµúÏ¢Ö Í∏àÏï° ÌëúÏãú
    const finalY = dividerY + 20;
    const finalLabel = this.add.text(centerX - 100, finalY, 'Total:', {
      fontSize: '14px',
      fill: '#ffff00'
    }).setOrigin(0, 0.5).setDepth(7102).setAlpha(0);
    settlementElements.push(finalLabel);

    const mainAmount = this.add.text(centerX + 100, finalY, `$${previousMoney}`, {
      fontSize: '18px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(1, 0.5).setDepth(7102).setAlpha(0);
    settlementElements.push(mainAmount);

    let currentDelay = 200;

    // 1Îã®Í≥Ñ: Í∏∞Ï°¥ Í∏àÏï° ÌëúÏãú
    this.tweens.add({
      targets: [prevLabel, prevAmount, finalLabel, mainAmount, divider],
      alpha: 1,
      duration: 200,
      delay: currentDelay,
      ease: 'Power2'
    });

    currentDelay += 350;

    // 2Îã®Í≥Ñ: Ïä§ÏΩîÏñ¥ Ï∂îÍ∞Ä
    if (scoreEarned > 0) {
      this.tweens.add({
        targets: [scoreLabel, scoreAmount],
        alpha: 1,
        duration: 200,
        delay: currentDelay,
        ease: 'Power2'
      });

      // Ïπ¥Ïö¥Ìä∏ÏóÖ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.time.delayedCall(currentDelay + 250, () => {
        const countDuration = 400;
        const startTime = this.time.now;

        const countUp = this.time.addEvent({
          delay: 16,
          callback: () => {
            const elapsed = this.time.now - startTime;
            const progress = Math.min(elapsed / countDuration, 1);
            const currentValue = Math.floor(previousMoney + scoreEarned * progress);
            mainAmount.setText(`$${currentValue}`);
            mainAmount.setFill('#00ff00');

            if (progress >= 1) {
              mainAmount.setText(`$${afterScore}`);
              mainAmount.setFill('#ffffff');
              countUp.destroy();
            }
          },
          loop: true
        });
      });

      currentDelay += 750;
    }

    // 3Îã®Í≥Ñ: Í∞Å ÏùÄÌñâÎ≥Ñ ÏÉÅÌôò Ï∞®Í∞ê (ÏàúÏ∞®Ï†ÅÏúºÎ°ú)
    let runningTotal = afterScore;
    repayLabels.forEach((item, index) => {
      const delay = currentDelay + index * 500;

      // ÎùºÎ≤® ÌëúÏãú
      this.tweens.add({
        targets: [item.label, item.amount],
        alpha: 1,
        duration: 200,
        delay: delay,
        ease: 'Power2'
      });

      // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ïï†ÎãàÎ©îÏù¥ÏÖò (missedÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå)
      if (!item.repay.missed && item.repay.amount > 0) {
        const startValue = runningTotal;
        const endValue = runningTotal - item.repay.amount;
        runningTotal = endValue;

        this.time.delayedCall(delay + 200, () => {
          const countDuration = 250;
          const startTime = this.time.now;

          const countDown = this.time.addEvent({
            delay: 16,
            callback: () => {
              const elapsed = this.time.now - startTime;
              const progress = Math.min(elapsed / countDuration, 1);
              const currentValue = Math.floor(startValue - item.repay.amount * progress);
              mainAmount.setText(`$${currentValue}`);
              mainAmount.setFill('#ff4444');

              if (progress >= 1) {
                mainAmount.setText(`$${endValue}`);
                mainAmount.setFill('#ffffff');
                countDown.destroy();
              }
            },
            loop: true
          });
        });
      }
    });

    currentDelay += repayments.length * 500 + 300;

    // 4Îã®Í≥Ñ: Î∞∞Í≤Ω ÌéòÏù¥ÎìúÏïÑÏõÉ + ÏµúÏ¢Ö Í∏àÏï° ÎÇ†ÏïÑÍ∞ê
    this.time.delayedCall(currentDelay + 200, () => {
      // Î∞∞Í≤ΩÍ≥º ÎùºÎ≤®Îì§ ÌéòÏù¥ÎìúÏïÑÏõÉ
      settlementElements.forEach(el => {
        if (el !== mainAmount) {
          this.tweens.add({
            targets: el,
            alpha: 0,
            duration: 300,
            ease: 'Power2',
            onComplete: () => el.destroy()
          });
        }
      });

      // ÏµúÏ¢Ö Í∏àÏï° Îπ†Î•¥Í≤å ÎÇ†ÏïÑÍ∞ê (ÏùÄÌñâ Ï†ïÏÇ∞ Ïä§ÌÉÄÏùº)
      this.time.delayedCall(100, () => {
        const targetX = this.shopMoneyText ? this.shopMoneyText.x : 80;
        const targetY = this.shopMoneyText ? this.shopMoneyText.y : 180;
        const startMoney = previousMoney;

        // Îπ†Î•¥Í≤å ÎÇ†ÏïÑÍ∞ÄÍ∏∞
        this.tweens.add({
          targets: mainAmount,
          x: targetX,
          y: targetY,
          scaleX: 0.5,
          scaleY: 0.5,
          alpha: 0,
          duration: 180,
          ease: 'Power2.easeIn',
          onComplete: () => {
            mainAmount.destroy();

            if (this.shopMoneyText && this.shopMoneyText.active) {
              // Ïπ¥Ïö¥Ìä∏ÏóÖ Ïï†ÎãàÎ©îÏù¥ÏÖò (ÏùÄÌñâ Ï†ïÏÇ∞ ÎäêÎÇå)
              const countDuration = 250;
              const startTime = this.time.now;

              const countUp = this.time.addEvent({
                delay: 16,
                callback: () => {
                  const elapsed = this.time.now - startTime;
                  const progress = Math.min(elapsed / countDuration, 1);
                  // easeOutÏúºÎ°ú ÎßàÏßÄÎßâÏóê Ï≤úÏ≤úÌûà
                  const eased = 1 - Math.pow(1 - progress, 3);
                  const currentValue = Math.floor(startMoney + (finalMoney - startMoney) * eased);
                  this.shopMoneyText.setText(`$${currentValue}`);

                  if (progress >= 1) {
                    this.shopMoneyText.setText(`$${finalMoney}`);
                    countUp.destroy();
                  }
                },
                loop: true
              });
            }

            // Îπö Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ + Ï†ïÏÇ∞ ÏôÑÎ£å
            this.time.delayedCall(300, () => {
              this.updateShopDebtInfo();
              this.isSettling = false; // Ï†ïÏÇ∞ ÏôÑÎ£å - ÌÇ§Î≥¥Îìú ÏûÖÎ†• ÌóàÏö©

              // Îπö ÏôÑÎÇ© Ï≤¥ÌÅ¨ (Ïù¥Ï†ÑÏóê ÎåÄÏ∂úÏù¥ ÏûàÏóàÍ≥† ÏßÄÍ∏àÏùÄ ÏóÜÎäî Í≤ΩÏö∞)
              if (repayments.length > 0 && this.loans.length === 0) {
                this.showDebtFreeAnimation();
              }
            });
          }
        });
      });
    });

    // ÌååÏÇ∞/Ïó∞Ï≤¥ Í≤ΩÍ≥† (Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÌõÑ)
    const warningDelay = currentDelay + 1800;
    if (bankruptBank) {
      this.time.delayedCall(warningDelay, () => {
        this.showBankruptcyGameOver(bankruptBank.bankName);
      });
    } else if (hasMissedPayment) {
      const missedLoans = this.loans.filter(l => l.missedPayments > 0)
        .map(l => ({ name: l.bankName, missed: l.missedPayments }));
      if (missedLoans.length > 0) {
        this.time.delayedCall(warningDelay, () => {
          this.showPaymentWarning(missedLoans);
        });
      }
    }
  }

  // Ìè¨Ïª§Ïä§Í∞Ä Ïù¥ÎèôÌï† Îïå ÏßßÏùÄ ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú Ïù∏ÌÑ∞ÎûôÏÖòÏùÑ ÌÜµÏùº
  spawnFocusPulse(x, y, color, depth = 6005, collection = 'shop') {
    if (x === undefined || y === undefined) return;

    const outer = this.add.circle(x, y, 44, color, 0.08).setDepth(depth).setAlpha(0);
    const inner = this.add.circle(x, y, 24, color, 0.15).setDepth(depth + 1).setAlpha(0);

    const targets = [outer, inner];
    targets.forEach(t => {
      this.tweens.add({
        targets: t,
        alpha: { from: 0.8, to: 0 },
        scale: { from: 0.9, to: 1.5 },
        duration: 260,
        ease: 'Sine.easeOut',
        onComplete: () => t.destroy()
      });
    });

    if (collection === 'confirm') {
      this.purchaseConfirmElements.push(...targets);
    } else {
      this.shopElements.push(...targets);
    }
  }

  updateShopSelection() {
    if (!this.shopCards) return;

    // Í∏∞Ï°¥ ÏÑ§Î™Ö ÌåùÏóÖ Ï†úÍ±∞
    if (this.itemDescPopup) {
      this.itemDescPopup.destroy();
      this.itemDescPopup = null;
    }

    // Ìè¨Ïª§Ïä§Í∞Ä Î∞îÎÄåÎ©¥ ÌÜµÏùºÎêú ÌéÑÏä§ Ïó∞Ï∂úÏùÑ Ï∂îÍ∞Ä
    let focusInfo = null;
    if (this.selectedShopIndex < this.shopItems.length) {
      const focusedItem = this.shopItems[this.selectedShopIndex];
      const focusedCard = this.shopCards[this.selectedShopIndex];
      if (focusedItem && focusedCard) {
        const canAfford = this.money >= focusedItem.price;
        focusInfo = {
          key: `card-${this.selectedShopIndex}`,
          x: focusedCard.container.x,
          y: focusedCard.container.y,
          color: focusedItem.purchased ? 0x666666 : (canAfford ? 0x00ff88 : 0xff4444)
        };
      }
    } else if (this.selectedShopIndex === this.shopItems.length && this.shopNextBtn) {
      focusInfo = {
        key: 'next',
        x: this.shopNextBtn.bg.x,
        y: this.shopNextBtn.bg.y,
        color: 0x00ff88
      };
    } else if (this.selectedShopIndex === this.shopItems.length + 1 && this.shopLoanBtn) {
      focusInfo = {
        key: 'loan',
        x: this.shopLoanBtn.bg.x,
        y: this.shopLoanBtn.bg.y,
        color: 0xff6b6b
      };
    }

    if (focusInfo && focusInfo.key !== this.lastShopFocusKey) {
      this.spawnFocusPulse(focusInfo.x, focusInfo.y, focusInfo.color, 6005, 'shop');
      this.lastShopFocusKey = focusInfo.key;
    }

    // ÏÑ†ÌÉùÎêú ÏïÑÏù¥ÌÖúÏù¥ Ïπ¥ÎìúÏù∏ Í≤ΩÏö∞ ÏÑ§Î™Ö ÌåùÏóÖ ÌëúÏãú
    if (this.selectedShopIndex < this.shopItems.length) {
      const selectedItem = this.shopItems[this.selectedShopIndex];
      const card = this.shopCards[this.selectedShopIndex];

      if (card && selectedItem.description) {
        const { width } = this.cameras.main;

        // Î±Ä ÌîÑÎ¶¨Î∑∞ÏôÄ ÎèôÏùºÌïú Ï§ëÏïô ÏúÑÏπò Í≥ÑÏÇ∞
        const sidebarWidth = 120;
        const sidebarEndX = sidebarWidth + 10;
        const rightAreaCenterX = sidebarEndX + (width - sidebarEndX) / 2;

        // ÏïÑÏù¥ÌÖúÍ≥º Î±Ä ÏÇ¨Ïù¥Ïóê Ìà¥ÌåÅ (ÏïÑÏù¥ÌÖú Ï™ΩÏúºÎ°ú Í∞ÄÍπùÍ≤å)
        const popupX = rightAreaCenterX;
        const popupY = 340;

        // Ïô∏Í≥ΩÏÑ† (ÎÑ§Ïò® Ìö®Í≥º)
        const popupBgOuter = this.add.rectangle(popupX, popupY - 30, 320, 50, 0x4a9eff, 1)
          .setDepth(6000);
        // ÎÇ¥Î∂Ä Î∞∞Í≤Ω
        const popupBgInner = this.add.rectangle(popupX, popupY - 30, 316, 46, 0x000000, 1)
          .setDepth(6001);

        // ÏïÑÏù¥ÌÖú Ïù¥Î¶Ñ
        const nameText = this.add.text(popupX, popupY - 40, selectedItem.name, {
          fontSize: '14px',
          fill: '#00ffff',
          fontStyle: 'bold',
          stroke: '#006666',
          strokeThickness: 2
        }).setOrigin(0.5).setDepth(6002);

        // ÏÑ§Î™Ö ÌÖçÏä§Ìä∏ - Ìù∞ÏÉâÏúºÎ°ú Î∞ùÍ≤å
        const popupText = this.add.text(popupX, popupY - 22, selectedItem.description, {
          fontSize: '12px',
          fill: '#ffffff',
          align: 'center',
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 2,
          wordWrap: { width: 300 }
        }).setOrigin(0.5).setDepth(6002);

        // Ïª®ÌÖåÏù¥ÎÑà ÎåÄÏã† Í∞úÎ≥Ñ ÏöîÏÜåÎ°ú Í¥ÄÎ¶¨ (Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä Î†åÎçîÎßÅ ÌíàÏßà Ï†ÄÌïò Ïú†Î∞ú)
        this.itemDescPopup = [popupBgOuter, popupBgInner, nameText, popupText];
        this.itemDescPopup.forEach(el => this.shopElements.push(el));
        // destroy Î©îÏÑúÎìú Ï∂îÍ∞Ä
        this.itemDescPopup.destroy = function() {
          this.forEach(el => el.destroy());
        };

        // Ïó≠ÎèôÏ†ÅÏù∏ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
        // Î∞∞Í≤Ω: ÏûëÍ≤å ÏãúÏûëÌï¥ÏÑú Ìå°! ÌÑ∞ÏßÄÎìØÏù¥
        [popupBgOuter, popupBgInner].forEach(el => {
          el.setAlpha(0).setScale(0.3);
        });

        this.tweens.add({
          targets: [popupBgOuter, popupBgInner],
          alpha: 1,
          scaleX: 1,
          scaleY: 1,
          duration: 200,
          ease: 'Back.easeOut'
        });

        // ÌÖçÏä§Ìä∏: ÏúÑÏóêÏÑú Îñ®Ïñ¥ÏßÄÎ©∞ Î∞îÏö¥Ïä§ + ÏïΩÍ∞Ñ ÏßÄÏó∞
        [nameText, popupText].forEach(el => {
          el.setAlpha(0);
          el.y -= 30;
        });

        this.tweens.add({
          targets: nameText,
          alpha: 1,
          y: '+=30',
          duration: 300,
          delay: 80,
          ease: 'Bounce.easeOut'
        });

        this.tweens.add({
          targets: popupText,
          alpha: 1,
          y: '+=30',
          duration: 300,
          delay: 120,
          ease: 'Bounce.easeOut'
        });
      }
    }

    this.shopCards.forEach((card, index) => {
      const isSelected = index === this.selectedShopIndex;
      const item = this.shopItems[index];
      const canAfford = this.money >= item.price;

      // Îî§ Ï≤òÎ¶¨ ÏóÖÎç∞Ïù¥Ìä∏ (Íµ¨Îß§ Í∞ÄÎä• Ïó¨Î∂ÄÏóê Îî∞Îùº)
      if (!item.purchased) {
        // Ïª®ÌÖåÏù¥ÎÑà ÏïåÌåå (Îî§ Ï≤òÎ¶¨)
        card.container.setAlpha(canAfford ? 1 : 0.5);

        // Í∞ÄÍ≤© ÌÉúÍ∑∏ ÏÉâÏÉÅ
        const priceTagColor = canAfford ? 0x00aa00 : 0x661111;
        const priceTagStroke = canAfford ? 0x00ff00 : 0xff4444;
        card.priceTag.setFillStyle(priceTagColor);
        card.priceTag.setStrokeStyle(2, priceTagStroke);

        // Í∞ÄÍ≤© ÌÖçÏä§Ìä∏ ÏÉâÏÉÅ
        card.price.setFill(canAfford ? '#00ff00' : '#ff4444');
      }

      if (isSelected && !item.purchased) {
        // ÏÑ†ÌÉùÎêú Ïπ¥Îìú - ÏúÑÎ°ú Ïò¨ÎùºÏò§Í≥† Î∞úÍ¥ë
        this.tweens.add({
          targets: card.container,
          y: 180,
          duration: 200,
          ease: 'Back.easeOut'
        });

        // ÌÖåÎëêÎ¶¨ Î∞úÍ¥ë (Íµ¨Îß§ Î∂àÍ∞Ä Ïãú Îπ®Í∞ÑÏÉâ)
        card.bg.setStrokeStyle(4, canAfford ? 0xffff00 : 0xff4444);

        // Îì§Ïç©ÏûÑ Ìö®Í≥º
        if (!card.floatTween) {
          card.floatTween = this.tweens.add({
            targets: card.container,
            y: '+=5',
            duration: 300,
            yoyo: true,
            repeat: -1,
            ease: 'Sine.easeInOut'
          });
        }
      } else {
        // ÏÑ†ÌÉù Ìï¥Ï†ú
        this.tweens.add({
          targets: card.container,
          y: 200,
          duration: 200,
          ease: 'Power2'
        });

        card.bg.setStrokeStyle(3, item.purchased ? 0x666666 : 0x4a9eff);

        if (card.floatTween) {
          card.floatTween.stop();
          card.floatTween = null;
        }
      }
    });

    // Next Stage Î≤ÑÌäº ÌïòÏù¥ÎùºÏù¥Ìä∏
    if (this.shopNextBtn) {
      const isNextSelected = this.selectedShopIndex === this.shopItems.length;

      if (isNextSelected) {
        this.shopNextBtn.bg.setStrokeStyle(3, 0xffffff);
        this.shopNextBtn.text.setFill('#ffffff');
        this.shopNextBtn.glow.setFillStyle(0xffffff, 0.5);

        // Ìè¨Ïª§Ïä§ Ïãú Ïä§ÏºÄÏùº ÏóÖ + Í∏ÄÎ°úÏö∞ Í∞ïÌôî
        if (!this.shopNextBtn.floatTween) {
          this.shopNextBtn.floatTween = this.tweens.add({
            targets: [this.shopNextBtn.bg, this.shopNextBtn.text, this.shopNextBtn.highlight],
            scaleX: 1.08,
            scaleY: 1.08,
            duration: 150,
            ease: 'Back.easeOut'
          });
          this.tweens.add({
            targets: this.shopNextBtn.glow,
            alpha: 0.7,
            scaleX: 1.15,
            scaleY: 1.2,
            duration: 150
          });
        }
      } else {
        this.shopNextBtn.bg.setStrokeStyle(2, 0x00ff88);
        this.shopNextBtn.text.setFill('#00ff88');
        this.shopNextBtn.glow.setFillStyle(0x00ff88, 0.3);

        // Ìè¨Ïª§Ïä§ Ìï¥Ï†ú Ïãú ÏõêÎûò ÌÅ¨Í∏∞Î°ú
        if (this.shopNextBtn.floatTween) {
          this.shopNextBtn.floatTween.stop();
          this.shopNextBtn.floatTween = null;
          this.tweens.add({
            targets: [this.shopNextBtn.bg, this.shopNextBtn.text, this.shopNextBtn.highlight],
            scaleX: 1,
            scaleY: 1,
            duration: 150
          });
          this.tweens.add({
            targets: this.shopNextBtn.glow,
            alpha: 0.3,
            scaleX: 1,
            scaleY: 1,
            duration: 150
          });
        }
      }
    }

    // Loan Î≤ÑÌäº ÌïòÏù¥ÎùºÏù¥Ìä∏
    if (this.shopLoanBtn) {
      const isLoanSelected = this.selectedShopIndex === this.shopItems.length + 1;

      if (isLoanSelected) {
        this.shopLoanBtn.bg.setStrokeStyle(3, 0xffffff);
        this.shopLoanBtn.text.setFill('#ffffff');
        this.shopLoanBtn.glow.setFillStyle(0xffffff, 0.5);

        // Ìè¨Ïª§Ïä§ Ïãú Ïä§ÏºÄÏùº ÏóÖ + Í∏ÄÎ°úÏö∞ Í∞ïÌôî
        if (!this.shopLoanBtn.floatTween) {
          this.shopLoanBtn.floatTween = this.tweens.add({
            targets: [this.shopLoanBtn.bg, this.shopLoanBtn.text, this.shopLoanBtn.highlight],
            scaleX: 1.08,
            scaleY: 1.08,
            duration: 150,
            ease: 'Back.easeOut'
          });
          this.tweens.add({
            targets: this.shopLoanBtn.glow,
            alpha: 0.7,
            scaleX: 1.15,
            scaleY: 1.2,
            duration: 150
          });
        }
      } else {
        this.shopLoanBtn.bg.setStrokeStyle(2, 0xff6b6b);
        this.shopLoanBtn.text.setFill('#ff6b6b');
        this.shopLoanBtn.glow.setFillStyle(0xff6b6b, 0.3);

        // Ìè¨Ïª§Ïä§ Ìï¥Ï†ú Ïãú ÏõêÎûò ÌÅ¨Í∏∞Î°ú
        if (this.shopLoanBtn.floatTween) {
          this.shopLoanBtn.floatTween.stop();
          this.shopLoanBtn.floatTween = null;
          this.tweens.add({
            targets: [this.shopLoanBtn.bg, this.shopLoanBtn.text, this.shopLoanBtn.highlight],
            scaleX: 1,
            scaleY: 1,
            duration: 150
          });
          this.tweens.add({
            targets: this.shopLoanBtn.glow,
            alpha: 0.3,
            scaleX: 1,
            scaleY: 1,
            duration: 150
          });
        }
      }
    }
  }

  handleShopInput(direction) {
    if (!this.shopOpen || !this.shopKeyboardEnabled || this.isSettling) return;

    // Íµ¨Îß§ ÌôïÏù∏Ï∞ΩÏù¥ Ïó¥Î†§ ÏûàÏúºÎ©¥ Í∑∏Ï™ΩÏúºÎ°ú ÏûÖÎ†•ÏùÑ Ï†ÑÎã¨
    if (this.isPurchaseConfirmOpen) {
      this.handlePurchaseConfirmInput(direction);
      return;
    }

    const itemCount = this.shopItems.length;

    // ÏïÑÏù¥ÌÖú ÎÇ¥ÏóêÏÑú Îã§Ïùå ÏÑ†ÌÉù Í∞ÄÎä•Ìïú Ïù∏Îç±Ïä§ Ï∞æÍ∏∞ (SOLD Í±¥ÎÑàÎõ∞Í∏∞, ÏïÑÏù¥ÌÖúÎßå ÏàúÌôò)
    const findNextItemAvailable = (start, delta) => {
      // Î≤ÑÌäºÏóêÏÑú Ï¢åÏö∞ ÎàÑÎ•¥Î©¥ Î¨¥Ïãú
      if (start >= itemCount) return start;

      let idx = start;
      for (let i = 0; i < itemCount; i++) {
        idx = (idx + delta + itemCount) % itemCount;
        if (!this.shopItems[idx].purchased) {
          return idx;
        }
      }
      return start; // Î™ª Ï∞æÏúºÎ©¥ ÌòÑÏû¨ Ïú†ÏßÄ
    };

    if (direction === 'LEFT') {
      if (this.selectedShopIndex < itemCount) {
        // ÏïÑÏù¥ÌÖú ÏòÅÏó≠ÏóêÏÑú Ï¢åÏö∞ ÏàúÌôò
        this.selectedShopIndex = findNextItemAvailable(this.selectedShopIndex, -1);
        this.updateShopSelection();
      } else {
        // Î≤ÑÌäº ÏòÅÏó≠ÏóêÏÑú Ï¢åÏö∞ Ïù¥Îèô (Next Stage <-> Loan)
        this.selectedShopIndex = this.selectedShopIndex === itemCount ? itemCount + 1 : itemCount;
        this.updateShopSelection();
      }
    } else if (direction === 'RIGHT') {
      if (this.selectedShopIndex < itemCount) {
        // ÏïÑÏù¥ÌÖú ÏòÅÏó≠ÏóêÏÑú Ï¢åÏö∞ ÏàúÌôò
        this.selectedShopIndex = findNextItemAvailable(this.selectedShopIndex, 1);
        this.updateShopSelection();
      } else {
        // Î≤ÑÌäº ÏòÅÏó≠ÏóêÏÑú Ï¢åÏö∞ Ïù¥Îèô (Next Stage <-> Loan)
        this.selectedShopIndex = this.selectedShopIndex === itemCount ? itemCount + 1 : itemCount;
        this.updateShopSelection();
      }
    } else if (direction === 'UP') {
      // Î≤ÑÌäºÏóêÏÑú ÏúÑÎ°ú ÎàÑÎ•¥Î©¥ ÏïÑÏù¥ÌÖú Ïπ¥ÎìúÎ°ú Ïù¥Îèô
      if (this.selectedShopIndex >= this.shopItems.length) {
        // Ï≤´ Î≤àÏß∏ Íµ¨Îß§ Í∞ÄÎä•Ìïú ÏïÑÏù¥ÌÖú Ï∞æÍ∏∞
        let foundIndex = -1;
        for (let i = 0; i < this.shopItems.length; i++) {
          if (!this.shopItems[i].purchased) {
            foundIndex = i;
            break;
          }
        }

        if (foundIndex !== -1) {
          this.selectedShopIndex = foundIndex;
          this.updateShopSelection();
        }
        // Î™®Îì† ÏïÑÏù¥ÌÖúÏù¥ SOLDÎ©¥ Î≤ÑÌäºÏóê Î®∏Î¨¥Î¶Ñ
      }
    } else if (direction === 'DOWN') {
      // ÏïÑÏù¥ÌÖú Ïπ¥ÎìúÏóêÏÑú ÏïÑÎûòÎ°ú ÎàÑÎ•¥Î©¥ Next Stage Î≤ÑÌäºÏúºÎ°ú Ïù¥Îèô
      if (this.selectedShopIndex < this.shopItems.length) {
        this.selectedShopIndex = this.shopItems.length;
        this.updateShopSelection();
      }
    } else if (direction === 'ENTER') {
      // Ïπ¥Îìú ÏÑ†ÌÉù Ï§ëÏù¥Î©¥ Íµ¨Îß§ ÏãúÎèÑ, Next Stage Î≤ÑÌäºÏù¥Î©¥ ÏÉÅÏ†ê Îã´Í∏∞, Loan Î≤ÑÌäºÏù¥Î©¥ ÎåÄÏ∂ú UI
      if (this.selectedShopIndex < this.shopItems.length) {
        this.attemptPurchase(this.selectedShopIndex);
      } else if (this.selectedShopIndex === this.shopItems.length) {
        this.closeShop();
      } else if (this.selectedShopIndex === this.shopItems.length + 1) {
        this.openLoanUI();
      }
    }
  }

  handleAlreadyPurchased(card) {
    if (!card || !card.container) return;
    this.tweens.add({
      targets: card.container,
      x: card.container.x + 10,
      duration: 50,
      yoyo: true,
      repeat: 3
    });
  }

  handleNotEnoughMoney(card) {
    if (!card || !card.container) return;

    this.shopMoneyText.setFill('#ff0000');
    this.tweens.add({
      targets: this.shopMoneyText,
      x: this.shopMoneyText.x + 5,
      duration: 50,
      yoyo: true,
      repeat: 5,
      onComplete: () => {
        this.shopMoneyText.setFill('#ffff00');
      }
    });

    // Ïπ¥Îìú ÌùîÎì§Î¶º
    this.tweens.add({
      targets: card.container,
      angle: { from: -5, to: 5 },
      duration: 50,
      yoyo: true,
      repeat: 2,
      onComplete: () => card.container.setAngle(0)
    });

    // "NOT ENOUGH" Î©îÏãúÏßÄ Ïï†ÎãàÎ©îÏù¥ÏÖò
    const cardX = card.container.x;
    const cardY = card.container.y;
    const notEnoughText = this.add.text(cardX, cardY, 'NOT ENOUGH', {
      fontSize: '14px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(6010).setAlpha(0);

    this.tweens.add({
      targets: notEnoughText,
      y: cardY - 50,
      alpha: 1,
      duration: 200,
      ease: 'Power2',
      onComplete: () => {
        this.tweens.add({
          targets: notEnoughText,
          y: cardY - 80,
          alpha: 0,
          duration: 300,
          delay: 200,
          ease: 'Power2',
          onComplete: () => notEnoughText.destroy()
        });
      }
    });
  }

  attemptPurchase(index) {
    if (this.isPurchaseConfirmOpen) return;
    const item = this.shopItems[index];
    const card = this.shopCards[index];
    if (!item || !card) return;

    if (item.purchased) {
      this.handleAlreadyPurchased(card);
      return;
    }

    if (this.money < item.price) {
      this.handleNotEnoughMoney(card);
      return;
    }

    this.showPurchaseConfirm(item, index);
  }

  showPurchaseConfirm(item, index) {
    if (this.isPurchaseConfirmOpen) return;
    this.isPurchaseConfirmOpen = true;
    this.pendingPurchaseIndex = index;
    this.purchaseConfirmSelection = 'yes';
    this.lastPurchaseConfirmKey = null;
    this.purchaseConfirmElements = [];

    const { width, height } = this.cameras.main;

    // Î∞òÌà¨Î™Ö Ïò§Î≤ÑÎ†àÏù¥
    const overlay = this.add.rectangle(0, 0, width, height, 0x000000, 0.7)
      .setOrigin(0, 0)
      .setDepth(7200)
      .setAlpha(0);
    this.purchaseConfirmElements.push(overlay);
    this.tweens.add({
      targets: overlay,
      alpha: 0.7,
      duration: 180
    });

    // Ìå®ÎÑê
    const panelBg = this.add.rectangle(width / 2, height / 2, 360, 200, 0x0d1117, 0.95)
      .setDepth(7202)
      .setScale(0.6)
      .setAlpha(0);
    const panelBorder = this.add.rectangle(width / 2, height / 2, 360, 200)
      .setDepth(7203)
      .setStrokeStyle(3, 0x4a9eff)
      .setScale(0.6)
      .setAlpha(0);
    this.purchaseConfirmElements.push(panelBg, panelBorder);

    this.tweens.add({
      targets: [panelBg, panelBorder],
      alpha: 1,
      scaleX: { from: 0.6, to: 1 },
      scaleY: { from: 0.6, to: 1 },
      duration: 220,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥ÌãÄ & ÎÇ¥Ïö©
    const title = this.add.text(width / 2, height / 2 - 62, 'CONFIRM PURCHASE', {
      fontSize: '18px',
      fill: '#00ffff',
      fontStyle: 'bold',
      stroke: '#006666',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(7204).setAlpha(0);

    const desc = this.add.text(width / 2, height / 2 - 30,
      `Buy ${item.name} for $${item.price}?`, {
      fontSize: '15px',
      fill: '#ffffff',
      fontStyle: 'bold',
      align: 'center',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(7204).setAlpha(0);

    const sub = this.add.text(width / 2, height / 2,
      'Press ENTER to confirm', {
        fontSize: '12px',
        fill: '#aaaaaa'
      }).setOrigin(0.5).setDepth(7204).setAlpha(0);

    this.purchaseConfirmElements.push(title, desc, sub);

    this.tweens.add({
      targets: [title, desc, sub],
      alpha: 1,
      y: '+=8',
      duration: 200,
      ease: 'Power2',
      delay: 60
    });

    // Î≤ÑÌäº
    const btnY = height / 2 + 50;
    const yesX = width / 2 - 70;
    const noX = width / 2 + 70;

    const yesGlow = this.add.rectangle(yesX, btnY, 110, 50, 0x00ff88, 0.18)
      .setDepth(7201).setAlpha(0);
    const yesBg = this.add.rectangle(yesX, btnY, 100, 44, 0x103522, 1)
      .setDepth(7202).setStrokeStyle(2, 0x00ff88).setAlpha(0);
    const yesHighlight = this.add.rectangle(yesX, btnY - 12, 80, 8, 0x00ff88, 0.2)
      .setDepth(7202).setAlpha(0);
    const yesText = this.add.text(yesX, btnY, 'YES', {
      fontSize: '16px',
      fill: '#00ff88',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7204).setAlpha(0);

    const noGlow = this.add.rectangle(noX, btnY, 110, 50, 0xff6b6b, 0.18)
      .setDepth(7201).setAlpha(0);
    const noBg = this.add.rectangle(noX, btnY, 100, 44, 0x401c1c, 1)
      .setDepth(7202).setStrokeStyle(2, 0xff6b6b).setAlpha(0);
    const noHighlight = this.add.rectangle(noX, btnY - 12, 80, 8, 0xff6b6b, 0.2)
      .setDepth(7202).setAlpha(0);
    const noText = this.add.text(noX, btnY, 'NO', {
      fontSize: '16px',
      fill: '#ff6b6b',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7204).setAlpha(0);

    this.purchaseConfirmButtons = {
      yes: { bg: yesBg, text: yesText, glow: yesGlow, highlight: yesHighlight },
      no: { bg: noBg, text: noText, glow: noGlow, highlight: noHighlight }
    };

    this.purchaseConfirmElements.push(
      yesGlow, yesBg, yesHighlight, yesText,
      noGlow, noBg, noHighlight, noText
    );

    // Î≤ÑÌäº Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    [yesGlow, yesBg, yesHighlight, yesText, noGlow, noBg, noHighlight, noText].forEach((el, i) => {
      const originalY = el.y;
      el.y = originalY + 25;
      this.tweens.add({
        targets: el,
        y: originalY,
        alpha: el === yesGlow || el === noGlow ? 0.3 : 1,
        duration: 240,
        delay: 70 + i * 20,
        ease: 'Back.easeOut'
      });
    });

    // Í∏∞Î≥∏ Ìè¨Ïª§Ïä§ Ïä§ÌÉÄÏùº Ï†ÅÏö©
    this.updatePurchaseConfirmSelection();
  }

  updatePurchaseConfirmSelection() {
    if (!this.purchaseConfirmButtons) return;

    const yesSelected = this.purchaseConfirmSelection === 'yes';
    const noSelected = this.purchaseConfirmSelection === 'no';

    const styleButton = (btn, selected, baseColor) => {
      if (!btn) return;
      btn.bg.setStrokeStyle(selected ? 3 : 2, selected ? 0xffffff : baseColor);
      btn.text.setFill(selected ? '#ffffff' : Phaser.Display.Color.IntegerToColor(baseColor).rgba);
      btn.glow.setFillStyle(selected ? 0xffffff : baseColor, selected ? 0.4 : 0.2);

      if (selected) {
        if (!btn.floatTween) {
          btn.floatTween = this.tweens.add({
            targets: [btn.bg, btn.text, btn.highlight],
            scaleX: 1.05,
            scaleY: 1.05,
            duration: 140,
            ease: 'Back.easeOut'
          });
        }
      } else if (btn.floatTween) {
        btn.floatTween.stop();
        btn.floatTween = null;
        this.tweens.add({
          targets: [btn.bg, btn.text, btn.highlight],
          scaleX: 1,
          scaleY: 1,
          duration: 120
        });
      }
    };

    styleButton(this.purchaseConfirmButtons.yes, yesSelected, 0x00ff88);
    styleButton(this.purchaseConfirmButtons.no, noSelected, 0xff6b6b);

    // Ìè¨Ïª§Ïä§ ÌéÑÏä§
    const focusKey = `confirm-${this.purchaseConfirmSelection}`;
    const focusTarget = yesSelected ? this.purchaseConfirmButtons.yes : this.purchaseConfirmButtons.no;
    const focusColor = yesSelected ? 0x00ff88 : 0xff6b6b;
    if (focusKey !== this.lastPurchaseConfirmKey && focusTarget) {
      this.spawnFocusPulse(focusTarget.bg.x, focusTarget.bg.y, focusColor, 7205, 'confirm');
      this.lastPurchaseConfirmKey = focusKey;
    }
  }

  handlePurchaseConfirmInput(direction) {
    if (!this.isPurchaseConfirmOpen) return;

    if (direction === 'LEFT' || direction === 'UP') {
      this.purchaseConfirmSelection = 'yes';
      this.updatePurchaseConfirmSelection();
    } else if (direction === 'RIGHT' || direction === 'DOWN') {
      this.purchaseConfirmSelection = 'no';
      this.updatePurchaseConfirmSelection();
    } else if (direction === 'ENTER') {
      if (this.purchaseConfirmSelection === 'yes') {
        this.confirmPurchase();
      } else {
        this.closePurchaseConfirmOverlay();
      }
    }
  }

  confirmPurchase() {
    const index = this.pendingPurchaseIndex;
    this.closePurchaseConfirmOverlay();
    if (index !== null && index !== undefined) {
      this.purchaseItem(index);
    }
  }

  closePurchaseConfirmOverlay(force = false) {
    if (!this.purchaseConfirmElements.length && !this.isPurchaseConfirmOpen) return;

    this.isPurchaseConfirmOpen = false;
    this.pendingPurchaseIndex = null;
    this.lastPurchaseConfirmKey = null;

    const elements = [...this.purchaseConfirmElements];
    this.purchaseConfirmElements = [];
    this.purchaseConfirmButtons = null;

    if (force) {
      elements.forEach(el => {
        if (el && el.destroy) el.destroy();
      });
      return;
    }

    elements.forEach(el => {
      if (!el || el.active === false) return;
      this.tweens.add({
        targets: el,
        alpha: 0,
        duration: 160,
        onComplete: () => {
          if (el && el.destroy) el.destroy();
        }
      });
    });
  }

  purchaseItem(index) {
    const item = this.shopItems[index];
    const card = this.shopCards[index];
    if (!item || !card) return;

    if (item.purchased) {
      this.handleAlreadyPurchased(card);
      return;
    }

    if (this.money < item.price) {
      this.handleNotEnoughMoney(card);
      return;
    }

    // Íµ¨Îß§ ÏÑ±Í≥µ!
    this.money -= item.price;
    item.purchased = true;
    this.shopMoneyText.setText(`$${this.money}`);

    // ÏïÑÏù¥ÌÖúÎ≥Ñ Ìö®Í≥º Ï†ÅÏö©
    if (item.id === 'combo_shield') {
      // Combo Shield - ÏΩ§Î≥¥ Ïã§Îìú Ï∂îÍ∞Ä
      this.comboShieldCount++;
      this.savedComboShieldCount++; // Î≥¥Ïä§ ÌÅ¥Î¶¨Ïñ¥ ÌõÑ Î≥µÏõê ÏãúÏóêÎèÑ Î∞òÏòÅÎêòÎèÑÎ°ù
      this.hasHadShield = true; // Ïã§ÎìúÎ•º Í∞ÄÏ°åÎçò Ï†ÅÏù¥ ÏûàÏùå
      this.updateItemStatusUI();

      // ÌôîÎ†§Ìïú Ïû•Ï∞© Ïï†ÎãàÎ©îÏù¥ÏÖò
      if (this.shopSnakePreview && this.shopSnakePreview.length > 0) {
        const head = this.shopSnakePreview[0];
        const headX = head.x;
        const headY = head.y;

        // 1. ÎÖ∏ÎûÄ ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const particle = this.add.circle(headX, headY, 3, 0xffff00)
            .setDepth(6010).setAlpha(1);
          this.tweens.add({
            targets: particle,
            x: headX + Math.cos(angle) * 40,
            y: headY + Math.sin(angle) * 40,
            alpha: 0,
            scale: 0,
            duration: 400,
            ease: 'Power2',
            onComplete: () => particle.destroy()
          });
        }

        // 2. Ï†ÑÏ≤¥ Î±Ä Ïõ®Ïù¥Î∏å Ìö®Í≥º + Î®∏Î¶¨ ÎÖ∏ÎûÄÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
        this.shopSnakePreview.forEach((segment, i) => {
          this.tweens.add({
            targets: segment,
            scaleX: 1.4,
            scaleY: 1.4,
            duration: 100,
            delay: i * 50,
            yoyo: true,
            ease: 'Back.easeOut'
          });

          this.time.delayedCall(i * 50, () => {
            segment.setFillStyle(0xffffff);
            this.time.delayedCall(100, () => {
              // Î®∏Î¶¨Îäî ÎÖ∏ÎûÄÏÉâ, Î™∏ÌÜµÏùÄ ÏõêÎûòÏÉâ
              segment.setFillStyle(i === 0 ? 0xffff00 : 0x00cc00);
            });
          });
        });

        // 3. Î®∏Î¶¨ Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        this.time.delayedCall(300, () => {
          const glow = this.add.circle(headX, headY, 15, 0xffff00, 0.5)
            .setDepth(6009);
          this.tweens.add({
            targets: glow,
            alpha: 0,
            scale: 2,
            duration: 500,
            onComplete: () => glow.destroy()
          });
        });
      }
    } else if (item.id === 'speed_boost' && this.shopSnakePreview && this.shopSnakePreview.length > 0) {
      // Speed Boost - Í∂§ÎèÑ Ï†ÑÏûê ÏàòÌä∏ Í∏∞Îä•
      this.hasSpeedBoost = true;

      const head = this.shopSnakePreview[0];
      const headX = head.x;
      const headY = head.y;

      // 1. ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌîåÎûòÏãú (Ï≤≠Î°ùÏÉâ ‚Üí ÌôîÏù¥Ìä∏)
      const { width, height } = this.cameras.main;
      const flash = this.add.rectangle(width / 2, height / 2, width, height, 0x00ffff, 0.6)
        .setDepth(6020);
      this.tweens.add({
        targets: flash,
        alpha: 0,
        duration: 200,
        onComplete: () => flash.destroy()
      });

      // 2. ÏóêÎÑàÏßÄ ÏßëÏ§ë Ìö®Í≥º - Î∞îÍπ•ÏóêÏÑú Î®∏Î¶¨Î°ú ÏàòÎ†¥
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const startDist = 80 + Math.random() * 40;
        const particle = this.add.circle(
          headX + Math.cos(angle) * startDist,
          headY + Math.sin(angle) * startDist,
          4, 0x00ffff
        ).setDepth(6015).setAlpha(0.8);

        this.tweens.add({
          targets: particle,
          x: headX,
          y: headY,
          scale: 0.3,
          alpha: 0,
          duration: 400 + Math.random() * 200,
          ease: 'Power2.easeIn',
          onComplete: () => particle.destroy()
        });
      }

      // 3. Ï§ëÏïô Ìè≠Î∞ú (ÏóêÎÑàÏßÄ ÏàòÎ†¥ ÏôÑÎ£å ÌõÑ)
      this.time.delayedCall(500, () => {
        // ÌÅ∞ Ï≤≠Î°ùÏÉâ Ìè≠Î∞ú
        const explosion = this.add.circle(headX, headY, 5, 0x00ffff, 1)
          .setDepth(6016);
        this.tweens.add({
          targets: explosion,
          scale: 8,
          alpha: 0,
          duration: 400,
          ease: 'Power2',
          onComplete: () => explosion.destroy()
        });

        // ÌôîÎ©¥ ÌùîÎì§Î¶º
        this.cameras.main.shake(200, 0.015);

        // Ïõ®Ïù¥Î∏å ÎßÅ 3Í∞ú
        for (let r = 0; r < 3; r++) {
          const ring = this.add.circle(headX, headY, 10, 0x000000, 0)
            .setStrokeStyle(3, 0x00ffff, 1)
            .setDepth(6015);
          this.tweens.add({
            targets: ring,
            scale: 4 + r,
            alpha: 0,
            duration: 500,
            delay: r * 100,
            ease: 'Power2',
            onComplete: () => ring.destroy()
          });
        }
      });

      // 4. Î±Ä Ï†ÑÏ≤¥ ÏàúÏ∞® Ï†ÑÍ∏∞ Ïõ®Ïù¥Î∏å
      this.shopSnakePreview.forEach((segment, i) => {
        this.time.delayedCall(600 + i * 60, () => {
          // Ïä§ÏºÄÏùº Ìéë!
          this.tweens.add({
            targets: segment,
            scaleX: 1.6,
            scaleY: 1.6,
            duration: 80,
            yoyo: true,
            ease: 'Back.easeOut'
          });

          // ÏÉâÏÉÅ ÌîåÎûòÏãú
          const originalColor = i === 0 ? (this.comboShieldCount > 0 ? 0xffff00 : 0x00ff00) : 0x00cc00;
          segment.setFillStyle(0xffffff);
          this.time.delayedCall(80, () => {
            segment.setFillStyle(0x00ffff);
            this.time.delayedCall(80, () => {
              segment.setFillStyle(originalColor);
            });
          });

          // Í∞úÎ≥Ñ ÌååÌã∞ÌÅ¥
          for (let p = 0; p < 4; p++) {
            const pAngle = (p / 4) * Math.PI * 2;
            const spark = this.add.circle(segment.x, segment.y, 2, 0x00ffff)
              .setDepth(6014);
            this.tweens.add({
              targets: spark,
              x: segment.x + Math.cos(pAngle) * 15,
              y: segment.y + Math.sin(pAngle) * 15,
              alpha: 0,
              duration: 200,
              onComplete: () => spark.destroy()
            });
          }
        });
      });

      // 5. Í∂§ÎèÑ ÌååÌã∞ÌÅ¥ Îì±Ïû• (ÏÉÅÏ†ê ÌîÑÎ¶¨Î∑∞Ïö©)
      this.time.delayedCall(900, () => {
        // Í∏∞Ï°¥ ÏÉÅÏ†ê Í∂§ÎèÑ ÌååÌã∞ÌÅ¥ Ï†úÍ±∞
        if (this.shopOrbitalParticles) {
          this.shopOrbitalParticles.forEach(p => {
            this.tweens.killTweensOf(p);
            p.destroy();
          });
        }
        this.shopOrbitalParticles = [];

        // 2Í∞úÏùò Í∂§ÎèÑ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
        for (let i = 0; i < 2; i++) {
          const orbital = this.add.circle(headX, headY, 3, 0x00ffff)
            .setDepth(6012).setAlpha(0);
          this.shopElements.push(orbital);
          this.shopOrbitalParticles.push(orbital);

          // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
          this.tweens.add({
            targets: orbital,
            alpha: 1,
            scale: { from: 0, to: 1 },
            duration: 200,
            ease: 'Back.easeOut'
          });
        }

        // Í∂§ÎèÑ ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
        let shopOrbitalAngle = 0;
        this.shopOrbitalTween = this.time.addEvent({
          delay: 16,
          callback: () => {
            if (!this.shopOpen || !this.shopOrbitalParticles) return;
            shopOrbitalAngle += 0.1;
            const orbitRadius = 12;

            this.shopOrbitalParticles.forEach((orbital, idx) => {
              if (orbital && orbital.active) {
                const angle = shopOrbitalAngle + (idx * Math.PI);
                orbital.setPosition(
                  headX + Math.cos(angle) * orbitRadius,
                  headY + Math.sin(angle) * orbitRadius
                );
              }
            });
          },
          loop: true
        });

        // Í∏ÄÎ°úÏö∞ ÎßÅ
        const glowRing = this.add.circle(headX, headY, 12, 0x000000, 0)
          .setStrokeStyle(1, 0x00ffff, 0.3)
          .setDepth(6011);
        this.shopElements.push(glowRing);
      });

      // 6. "BOOST EQUIPPED!" ÌÖçÏä§Ìä∏
      this.time.delayedCall(700, () => {
        const equipText = this.add.text(headX, headY - 40, 'BOOST!', {
          fontSize: '14px',
          fill: '#00ffff',
          fontStyle: 'bold',
          stroke: '#004444',
          strokeThickness: 3
        }).setOrigin(0.5).setDepth(6017).setAlpha(0).setScale(0.5);

        this.tweens.add({
          targets: equipText,
          alpha: 1,
          scale: 1.2,
          y: headY - 55,
          duration: 300,
          ease: 'Back.easeOut',
          onComplete: () => {
            this.tweens.add({
              targets: equipText,
              alpha: 0,
              y: headY - 70,
              duration: 400,
              delay: 400,
              onComplete: () => equipText.destroy()
            });
          }
        });
      });
    }

    // Ïπ¥ÎìúÍ∞Ä ÏúÑÎ°ú ÎÇ†ÏïÑÍ∞ÄÎ©∞ ÏÇ¨ÎùºÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
    if (card.floatTween) {
      card.floatTween.stop();
      card.floatTween = null;
    }

    // Íµ¨Îß§ ÏÑ±Í≥µ ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú
    const cardX = card.container.x;
    const cardY = card.container.y;
    for (let i = 0; i < 15; i++) {
      const angle = (i / 15) * Math.PI * 2;
      const particle = this.add.circle(
        cardX,
        cardY,
        4,
        [0x00ff00, 0xffff00, 0x00ffff][Math.floor(Math.random() * 3)]
      ).setDepth(6003);

      this.tweens.add({
        targets: particle,
        x: cardX + Math.cos(angle) * 80,
        y: cardY + Math.sin(angle) * 80,
        alpha: 0,
        scale: 0,
        duration: 500,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // Ïπ¥Îìú ÎÇ†ÏïÑÍ∞ÄÎ©∞ ÌöåÏ†Ñ
    this.tweens.add({
      targets: card.container,
      y: -200,
      angle: 360,
      scale: 0.5,
      alpha: 0,
      duration: 600,
      ease: 'Back.easeIn',
      onComplete: () => {
        // Íµ¨Îß§ ÏôÑÎ£å ÌëúÏãú (Îπà Ïä¨Î°Ø)
        const soldText = this.add.text(cardX, 200, 'SOLD', {
          fontSize: '16px',
          fill: '#666666',
          fontStyle: 'bold'
        }).setOrigin(0.5).setDepth(6001).setAlpha(0);

        this.tweens.add({
          targets: soldText,
          alpha: 0.5,
          duration: 300
        });

        this.shopElements.push(soldText);
      }
    });

    // Îèà Í∞êÏÜå Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: this.shopMoneyText,
      scaleX: 0.8,
      scaleY: 0.8,
      duration: 100,
      yoyo: true
    });

    // Îã§Ïùå Ïπ¥ÎìúÎ°ú ÏûêÎèô Ïù¥Îèô (Ïò§Î•∏Ï™ΩÏúºÎ°ú)
    this.time.delayedCall(300, () => {
      const currentIndex = index;
      const itemCount = this.shopItems.length;

      // ÌòÑÏû¨ Ïù∏Îç±Ïä§+1Î∂ÄÌÑ∞ Ïò§Î•∏Ï™ΩÏúºÎ°ú Í≤ÄÏÉâ
      for (let i = 1; i <= itemCount; i++) {
        const nextIndex = (currentIndex + i) % itemCount;
        if (!this.shopItems[nextIndex].purchased) {
          this.selectedShopIndex = nextIndex;
          this.updateShopSelection();
          return;
        }
      }
      // Î™®Îëê Íµ¨Îß§ÌñàÏúºÎ©¥ Next StageÎ°ú
      this.selectedShopIndex = this.shopItems.length;
      this.updateShopSelection();
    });
  }

  // Ïù∏Í≤åÏûÑ Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ Ï¥àÍ∏∞Ìôî
  initSpeedBoostOrbitals() {
    // Í∏∞Ï°¥ Í∂§ÎèÑ Ï†ïÎ¶¨
    this.cleanupSpeedBoostOrbitals();

    const orbitRadius = 14;
    this.speedBoostOrbitals = [];

    // Í∂§ÎèÑ ÎßÅ
    const orbitRing = this.add.circle(0, 0, orbitRadius)
      .setStrokeStyle(1, 0x00ffff, 0.2)
      .setDepth(1000)
      .setVisible(false);
    orbitRing.isRing = true;
    this.speedBoostOrbitals.push(orbitRing);

    // 2Í∞úÏùò Ï†ÑÏûê ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 2; i++) {
      // Ìä∏Î†àÏùº (Í∞Å Ï†ÑÏûêÎãπ 3Í∞ú)
      for (let t = 0; t < 3; t++) {
        const trail = this.add.circle(0, 0, 3 - t * 0.6, 0x00ffff, 0.2 - t * 0.05)
          .setDepth(1000)
          .setVisible(false);
        trail.trailIndex = t;
        trail.electronIndex = i;
        this.speedBoostOrbitals.push(trail);
      }

      // Í∏ÄÎ°úÏö∞
      const glow = this.add.circle(0, 0, 5.5, 0x00ffff, 0.35)
        .setDepth(1001)
        .setVisible(false);
      glow.isGlow = true;
      glow.electronIndex = i;
      this.speedBoostOrbitals.push(glow);

      // Ïô∏Í≥Ω
      const outer = this.add.circle(0, 0, 3, 0x00ffff, 0.9)
        .setDepth(1002)
        .setVisible(false);
      outer.isOuter = true;
      outer.electronIndex = i;
      this.speedBoostOrbitals.push(outer);

      // ÏΩîÏñ¥
      const core = this.add.circle(0, 0, 1.5, 0xffffff, 1)
        .setDepth(1003)
        .setVisible(false);
      core.isCore = true;
      core.electronIndex = i;
      this.speedBoostOrbitals.push(core);
    }

    // 60fps ÌÉÄÏù¥Î®∏Î°ú ÏóÖÎç∞Ïù¥Ìä∏
    this.speedBoostOrbitalTimer = this.time.addEvent({
      delay: 16,
      loop: true,
      callback: () => this.updateSpeedBoostOrbitals()
    });

    // Ï¶âÏãú ÌëúÏãú
    this.speedBoostOrbitals.forEach(p => p.setVisible(true));
  }

  // Ïù∏Í≤åÏûÑ Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
  updateSpeedBoostOrbitals() {
    if (!this.hasSpeedBoost || !this.speedBoostOrbitals || this.speedBoostOrbitals.length === 0) return;
    if (!this.snake || this.snake.length === 0) return;

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ïù∏Í≤åÏûÑÏùÄ ÌÅ¨Í∏∞Í∞Ä Ïª§ÏÑú ÎäêÎ¶¨Í≤å ÎèåÏïÑÏïº ÌîÑÎ¶¨Î∑∞ÏôÄ ÎπÑÏä∑ÌïòÍ≤å ÎäêÍª¥Ïßê
    const angle = this.time.now * 0.011;
    const orbitRadius = 14;
    const pulseSize = 1 + Math.sin(angle * 3) * 0.4;
    const ringAlpha = 0.12 + Math.sin(angle * 2) * 0.08;

    this.speedBoostOrbitals.forEach(p => {
      if (!p || !p.active) return;

      // Í∂§ÎèÑ ÎßÅ
      if (p.isRing) {
        p.setPosition(headX, headY);
        p.setStrokeStyle(1, 0x00ffff, ringAlpha);
        return;
      }

      const electronAngle = angle + (p.electronIndex * Math.PI);

      // Ìä∏Î†àÏùº
      if (p.trailIndex !== undefined) {
        const trailAngle = electronAngle - ((p.trailIndex + 1) * 0.18);
        p.setPosition(
          headX + Math.cos(trailAngle) * orbitRadius,
          headY + Math.sin(trailAngle) * orbitRadius
        );
        p.setRadius((3 - p.trailIndex * 0.6) * pulseSize);
      }
      // Í∏ÄÎ°úÏö∞
      else if (p.isGlow) {
        p.setPosition(
          headX + Math.cos(electronAngle) * orbitRadius,
          headY + Math.sin(electronAngle) * orbitRadius
        );
        p.setRadius(4.5 + pulseSize);
      }
      // Ïô∏Í≥Ω
      else if (p.isOuter) {
        p.setPosition(
          headX + Math.cos(electronAngle) * orbitRadius,
          headY + Math.sin(electronAngle) * orbitRadius
        );
        p.setRadius(3 * pulseSize);
      }
      // ÏΩîÏñ¥
      else if (p.isCore) {
        p.setPosition(
          headX + Math.cos(electronAngle) * orbitRadius,
          headY + Math.sin(electronAngle) * orbitRadius
        );
        p.setRadius(1.5 * pulseSize);
      }
    });
  }

  // Ïù∏Í≤åÏûÑ Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ Ï†ïÎ¶¨
  cleanupSpeedBoostOrbitals() {
    if (this.speedBoostOrbitalTimer) {
      this.speedBoostOrbitalTimer.destroy();
      this.speedBoostOrbitalTimer = null;
    }
    if (this.speedBoostOrbitals) {
      this.speedBoostOrbitals.forEach(p => {
        if (p && p.active) p.destroy();
      });
      this.speedBoostOrbitals = [];
    }
  }

  // ÏÉÅÏ†ê ÌîÑÎ¶¨Î∑∞Ïóê Ïû•Ï∞©Îêú ÏàòÌä∏Îì§ Ï†ÅÏö©
  applyShopPreviewSuits() {
    if (!this.shopPreviewInfo || !this.shopSnakePreview || this.shopSnakePreview.length === 0) return;

    const { headX, headY, gridSize } = this.shopPreviewInfo;
    const scale = gridSize / this.gridSize; // 12/20 = 0.6

    // Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑ ÌååÌã∞ÌÅ¥ Ï†ÅÏö©
    if (this.hasSpeedBoost) {
      const orbitRadius = 14 * scale; // 8.4
      this.shopOrbitalParticles = [];
      let angle = 0;

      // Í∂§ÎèÑ ÎßÅ
      const orbitRing = this.add.circle(headX, headY, orbitRadius)
        .setStrokeStyle(1, 0x00ffff, 0.2)
        .setDepth(6003)
        .setAlpha(0);
      this.shopOrbitalParticles.push(orbitRing);
      this.shopElements.push(orbitRing);

      // 2Í∞úÏùò Ï†ÑÏûê ÌååÌã∞ÌÅ¥
      for (let i = 0; i < 2; i++) {
        // Ìä∏Î†àÏùº ÌååÌã∞ÌÅ¥ (Í∞Å Ï†ÑÏûêÎãπ 3Í∞ú)
        for (let t = 0; t < 3; t++) {
          const trail = this.add.circle(headX, headY, (2.5 - t * 0.4) * scale, 0x00ffff, 0.15 - t * 0.04)
            .setDepth(6003)
            .setAlpha(0);
          trail.trailIndex = t;
          trail.electronIndex = i;
          this.shopOrbitalParticles.push(trail);
          this.shopElements.push(trail);
        }

        // Í∏ÄÎ°úÏö∞ (ÌÅ∞ Í≤É)
        const glow = this.add.circle(headX, headY, 4 * scale, 0x00ffff, 0.35)
          .setDepth(6003)
          .setAlpha(0);
        glow.isGlow = true;
        glow.electronIndex = i;
        this.shopOrbitalParticles.push(glow);
        this.shopElements.push(glow);

        // Ïô∏Í≥Ω (Ï≤≠Î°ùÏÉâ)
        const outer = this.add.circle(headX, headY, 2.5 * scale, 0x00ffff, 0.9)
          .setDepth(6004)
          .setAlpha(0);
        outer.isOuter = true;
        outer.electronIndex = i;
        this.shopOrbitalParticles.push(outer);
        this.shopElements.push(outer);

        // ÏΩîÏñ¥ (Ìù∞ÏÉâ)
        const core = this.add.circle(headX, headY, 1.2 * scale, 0xffffff, 1)
          .setDepth(6005)
          .setAlpha(0);
        core.isCore = true;
        core.electronIndex = i;
        this.shopOrbitalParticles.push(core);
        this.shopElements.push(core);
      }

      // ÌéòÏù¥ÎìúÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.shopOrbitalParticles.forEach(p => {
        this.tweens.add({
          targets: p,
          alpha: p.fillAlpha || p.strokeAlpha || 1,
          duration: 300,
          ease: 'Power2'
        });
      });

      // Í∂§ÎèÑ ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.shopOrbitalTween = this.time.addEvent({
        delay: 16,
        loop: true,
        callback: () => {
          if (!this.shopOrbitalParticles || this.shopOrbitalParticles.length === 0) return;

          angle += 0.25;
          const pulseSize = 1 + Math.sin(angle * 3) * 0.4;
          const ringAlpha = 0.12 + Math.sin(angle * 2) * 0.08;

          this.shopOrbitalParticles.forEach(p => {
            if (!p || !p.active) return;

            // Í∂§ÎèÑ ÎßÅ ÌéÑÏä§
            if (p === orbitRing) {
              p.setStrokeStyle(1, 0x00ffff, ringAlpha);
              return;
            }

            const electronAngle = angle + (p.electronIndex * Math.PI);

            // Ìä∏Î†àÏùº ÌååÌã∞ÌÅ¥
            if (p.trailIndex !== undefined) {
              const trailAngle = electronAngle - ((p.trailIndex + 1) * 0.18);
              p.x = headX + Math.cos(trailAngle) * orbitRadius;
              p.y = headY + Math.sin(trailAngle) * orbitRadius;
              p.setRadius((2.5 - p.trailIndex * 0.4) * scale * pulseSize);
            }
            // Í∏ÄÎ°úÏö∞
            else if (p.isGlow) {
              p.x = headX + Math.cos(electronAngle) * orbitRadius;
              p.y = headY + Math.sin(electronAngle) * orbitRadius;
              p.setRadius((4 + pulseSize) * scale);
            }
            // Ïô∏Í≥Ω
            else if (p.isOuter) {
              p.x = headX + Math.cos(electronAngle) * orbitRadius;
              p.y = headY + Math.sin(electronAngle) * orbitRadius;
              p.setRadius(2.5 * scale * pulseSize);
            }
            // ÏΩîÏñ¥
            else if (p.isCore) {
              p.x = headX + Math.cos(electronAngle) * orbitRadius;
              p.y = headY + Math.sin(electronAngle) * orbitRadius;
              p.setRadius(1.2 * scale * pulseSize);
            }
          });
        }
      });
    }
  }

  closeShop() {
    this.shopKeyboardEnabled = false;
    this.shopOpen = false;
    if (this.pauseHintText && this.pauseHintText.active) {
      this.pauseHintText.setVisible(true);
    }
    this.lastShopFocusKey = null;
    this.closePurchaseConfirmOverlay(true);

    // ÎÑ§Ïò® tween Ï†ïÎ¶¨
    if (this.shopNeonTween) {
      this.shopNeonTween.stop();
      this.shopNeonTween = null;
    }

    // ÏÉÅÏ†ê Í∂§ÎèÑ ÌååÌã∞ÌÅ¥ Ï†ïÎ¶¨
    if (this.shopOrbitalTween) {
      this.shopOrbitalTween.destroy();
      this.shopOrbitalTween = null;
    }
    if (this.shopOrbitalParticles) {
      this.shopOrbitalParticles.forEach(p => {
        if (p && p.active) p.destroy();
      });
      this.shopOrbitalParticles = [];
    }

    // Ïπ¥Îìú float tween Ï†ïÎ¶¨
    if (this.shopCards) {
      this.shopCards.forEach(card => {
        if (card.floatTween) {
          card.floatTween.stop();
        }
      });
    }

    // Î©ãÏßÑ Îã´Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
    // Ïπ¥ÎìúÎì§Ïù¥ Ìù©Ïñ¥ÏßÄÎ©∞ ÏÇ¨ÎùºÏßê
    if (this.shopCards) {
      this.shopCards.forEach((card, i) => {
        if (card.container && card.container.alpha > 0) {
          const angle = (Math.random() - 0.5) * 60;
          this.tweens.add({
            targets: card.container,
            y: -300,
            x: card.container.x + (Math.random() - 0.5) * 200,
            angle: angle,
            alpha: 0,
            duration: 400,
            delay: i * 50,
            ease: 'Power2.easeIn'
          });
        }
      });
    }

    // ÎÇòÎ®∏ÏßÄ ÏöîÏÜåÎì§ ÌéòÏù¥Îìú ÏïÑÏõÉ
    this.shopElements.forEach(element => {
      if (element && element.active !== false) {
        this.tweens.add({
          targets: element,
          alpha: 0,
          duration: 400,
          ease: 'Power2',
          onComplete: () => {
            if (element && element.destroy) {
              element.destroy();
            }
          }
        });
      }
    });

    this.shopElements = [];
    this.shopCards = [];

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ
    this.time.delayedCall(500, () => {
      this.shopCountdownAndStart();
    });
  }

  shopCountdownAndStart() {
    const { width, height } = this.cameras.main;

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏
    const countdownText = this.add.text(width / 2, height / 2, '', {
      fontSize: '96px',
      fill: '#00ffff',
      fontStyle: 'bold',
      stroke: '#0088ff',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(5001);

    let countdown = 3;
    countdownText.setText(countdown.toString());

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: countdownText,
      scaleX: { from: 0.5, to: 1 },
      scaleY: { from: 0.5, to: 1 },
      duration: 200,
      ease: 'Back.easeOut'
    });

    this.time.addEvent({
      delay: 500,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          countdownText.setText(countdown.toString());
          this.tweens.add({
            targets: countdownText,
            scaleX: { from: 0.5, to: 1 },
            scaleY: { from: 0.5, to: 1 },
            duration: 200,
            ease: 'Back.easeOut'
          });
        } else {
          countdownText.destroy();
          this.showNextStage();
        }
      },
      repeat: 2
    });
  }

  // =====================
  // Î±ÖÌÇπ/ÎåÄÏ∂ú ÏãúÏä§ÌÖú
  // =====================

  openLoanUI() {
    if (this.loanUIOpen) return;
    this.loanUIOpen = true;
    this.isLoanProcessing = false; // ÎåÄÏ∂ú Ï≤òÎ¶¨ ÌîåÎûòÍ∑∏ Î¶¨ÏÖã
    this.shopKeyboardEnabled = false;
    this.loanMode = 'borrow';

    const { width, height } = this.cameras.main;

    // Ïñ¥ÎëêÏö¥ Îî§ Ïò§Î≤ÑÎ†àÏù¥ (ÏÉÅÏ†ê ÏúÑÏóê)
    const dimOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0)
      .setDepth(6999);
    this.loanElements.push(dimOverlay);

    this.tweens.add({
      targets: dimOverlay,
      fillAlpha: 0.7,
      duration: 300
    });

    // Î©îÏù∏ Î±ÖÌÅ¨ UI Î∞∞Í≤Ω (Ïò§Î•∏Ï™Ω)
    const loanBg = this.add.rectangle(width / 2 + 60, height / 2, 380, 420, 0x0a0a1a, 0.98)
      .setDepth(7001)
      .setStrokeStyle(3, 0x4a9eff)
      .setAlpha(0);
    this.loanElements.push(loanBg);

    // ÌÉÄÏù¥ÌãÄ
    const loanTitle = this.add.text(width / 2 + 60, height / 2 - 180, 'BANK', {
      fontSize: '28px',
      fill: '#00ffff',
      fontStyle: 'bold',
      stroke: '#004444',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(loanTitle);

    // Î∞∞Í≤Ω Î®ºÏ†Ä ÌëúÏãú
    this.tweens.add({
      targets: [loanBg, loanTitle],
      alpha: 1,
      duration: 200,
      ease: 'Power2'
    });

    // Î∂ÄÏ±Ñ Ï†ïÎ≥¥Îäî ÏÉÅÏ†ê ÏÇ¨Ïù¥ÎìúÎ∞îÏóê ÌëúÏãúÎê®

    // ÏùÄÌñâ Í≤ÄÏÉâ ÏãúÏûë
    this.startBankSearch(width, height);

    // ESC ÌÇ§Î°ú Îã´Í∏∞
    this.loanEscHandler = this.input.keyboard.once('keydown-ESC', () => {
      this.closeLoanUI();
    });
  }

  showDebtSummary(width, height) {
    // ÏôºÏ™Ω Ï±ÑÎ¨¥ Ìå®ÎÑê Î∞∞Í≤Ω
    const debtPanelX = width / 2 - 150;
    const debtBg = this.add.rectangle(debtPanelX, height / 2, 160, 300, 0x1a0a0a, 0.95)
      .setDepth(7001)
      .setStrokeStyle(2, 0xff4444)
      .setAlpha(0);
    this.loanElements.push(debtBg);

    // Ìå®ÎÑê ÌÉÄÏù¥ÌãÄ
    const debtTitle = this.add.text(debtPanelX, height / 2 - 120, 'YOUR DEBTS', {
      fontSize: '14px',
      fill: '#ff6666',
      fontStyle: 'bold',
      stroke: '#440000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(debtTitle);

    let totalDue = 0;
    const debtTexts = [];

    this.loans.forEach((loan, i) => {
      totalDue += loan.due;

      // ÏùÄÌñâ Ïù¥Î¶Ñ
      const bankName = this.add.text(
        debtPanelX,
        height / 2 - 85 + i * 45,
        loan.bankName,
        {
          fontSize: '11px',
          fill: '#ffffff',
          fontStyle: 'bold'
        }
      ).setOrigin(0.5).setDepth(7002).setAlpha(0);

      // Í∏àÏï° Î∞è Ïù¥ÏûêÏú®
      const debtDetail = this.add.text(
        debtPanelX,
        height / 2 - 70 + i * 45,
        `$${loan.due} (${loan.interestRate}%)`,
        {
          fontSize: '10px',
          fill: '#ff8888'
        }
      ).setOrigin(0.5).setDepth(7002).setAlpha(0);

      debtTexts.push(bankName, debtDetail);
      this.loanElements.push(bankName, debtDetail);
    });

    this.totalDebt = totalDue;

    // Íµ¨Î∂ÑÏÑ†
    const divider = this.add.rectangle(debtPanelX, height / 2 + 70, 120, 2, 0xff4444)
      .setDepth(7002).setAlpha(0);
    this.loanElements.push(divider);

    // Ï¥ù Î∂ÄÏ±Ñ
    const totalText = this.add.text(
      debtPanelX,
      height / 2 + 90,
      `TOTAL`,
      {
        fontSize: '10px',
        fill: '#ff8888'
      }
    ).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(totalText);

    const totalAmount = this.add.text(
      debtPanelX,
      height / 2 + 108,
      `$${totalDue}`,
      {
        fontSize: '16px',
        fill: '#ff4444',
        fontStyle: 'bold'
      }
    ).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(totalAmount);

    // Ìå®ÎÑê Ïä¨ÎùºÏù¥ÎìúÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
    debtBg.x -= 50;
    this.tweens.add({
      targets: debtBg,
      alpha: 1,
      x: '+=50',
      duration: 300,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥ÌãÄ Îì±Ïû•
    this.tweens.add({
      targets: debtTitle,
      alpha: 1,
      duration: 200,
      delay: 150
    });

    // Ï±ÑÎ¨¥ Î™©Î°ù ÏàúÏ∞® Îì±Ïû•
    debtTexts.forEach((el, i) => {
      this.tweens.add({
        targets: el,
        alpha: 1,
        duration: 200,
        delay: 200 + i * 50,
        ease: 'Power2'
      });
    });

    // Íµ¨Î∂ÑÏÑ† Î∞è Ï¥ùÏï° Îì±Ïû•
    this.tweens.add({
      targets: [divider, totalText, totalAmount],
      alpha: 1,
      duration: 200,
      delay: 300 + debtTexts.length * 50
    });
  }

  startBankSearch(width, height) {
    const panelX = width / 2 + 60; // Ïò§Î•∏Ï™Ω Ìå®ÎÑê Ï§ëÏã¨

    // Ïä§ÌîºÎÑà (ÌöåÏ†ÑÌïòÎäî Ïõê) - ÌÅ¥ÎûòÏä§ ÏÜçÏÑ±ÏúºÎ°ú Ï†ÄÏû•
    this.bankSearchSpinner = this.add.circle(panelX, height / 2 - 30, 25, 0x4a9eff, 0)
      .setDepth(7002).setStrokeStyle(4, 0x4a9eff);
    this.loanElements.push(this.bankSearchSpinner);

    // Ïä§ÌîºÎÑà ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: this.bankSearchSpinner,
      angle: 360,
      duration: 1000,
      repeat: -1,
      ease: 'Linear'
    });

    // Ïä§ÌîºÎÑà ÌéÑÏä§ Ìö®Í≥º
    this.tweens.add({
      targets: this.bankSearchSpinner,
      scaleX: 1.2,
      scaleY: 1.2,
      alpha: 0.5,
      duration: 500,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // Í≤ÄÏÉâ Î©îÏãúÏßÄ ÌëúÏãú
    const searchText = this.add.text(panelX, height / 2 + 20, 'Searching for banks...', {
      fontSize: '14px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(searchText);

    // Î°úÎî© ÎèÑÌä∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
    let dots = 0;
    this.bankSearchDotAnimation = this.time.addEvent({
      delay: 300,
      callback: () => {
        if (searchText && searchText.active) {
          dots = (dots + 1) % 4;
          searchText.setText('Searching for banks' + '.'.repeat(dots));
        }
      },
      loop: true
    });

    // Í≤ÄÏÉâ ÌÖçÏä§Ìä∏ Îì±Ïû• + ÌéÑÏä§
    this.tweens.add({
      targets: searchText,
      alpha: 1,
      duration: 200,
      delay: 300,
      onComplete: () => {
        this.tweens.add({
          targets: searchText,
          scaleX: 1.05,
          scaleY: 1.05,
          duration: 800,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });
      }
    });

    // Ìã∞Ïñ¥Ïóê Îî∞Î•∏ Í≤ÄÏÉâ ÏãúÍ∞Ñ Í≤∞Ï†ï
    let searchDelay;
    let tierKey;

    if (this.loanTier === 0) {
      tierKey = 'tier1';
      searchDelay = getRandomInRange(bankData.searchAnimation.tier1.minDelay, bankData.searchAnimation.tier1.maxDelay);
    } else if (this.loanTier === 1) {
      tierKey = 'tier2';
      searchDelay = getRandomInRange(bankData.searchAnimation.tier2.minDelay, bankData.searchAnimation.tier2.maxDelay);
    } else if (this.loanTier === 2) {
      tierKey = 'tier3';
      searchDelay = getRandomInRange(bankData.searchAnimation.tier3.minDelay, bankData.searchAnimation.tier3.maxDelay);
    } else {
      // 4Ï∞® Ïù¥ÏÉÅ - ÎåÄÏ∂ú Î∂àÍ∞Ä
      tierKey = null;
      searchDelay = getRandomInRange(bankData.searchAnimation.noBank.minDelay, bankData.searchAnimation.noBank.maxDelay);
    }

    // Í≤ÄÏÉâ ÏôÑÎ£å ÌõÑ ÏùÄÌñâ Î™©Î°ù ÌëúÏãú
    this.time.delayedCall(searchDelay, () => {
      if (this.bankSearchDotAnimation) {
        this.bankSearchDotAnimation.destroy();
        this.bankSearchDotAnimation = null;
      }

      // Í≤ÄÏÉâ ÌÖçÏä§Ìä∏ ÏÇ¨ÎùºÏßê
      this.tweens.add({
        targets: searchText,
        alpha: 0,
        y: searchText.y - 20,
        duration: 200,
        onComplete: () => {
          if (tierKey) {
            this.showAvailableBanks(width, height, tierKey);
          } else {
            this.showNoBanksAvailable(width, height);
          }
        }
      });
    });
  }

  showAvailableBanks(width, height, tierKey) {
    // Ïä§ÌîºÎÑà Ï†úÍ±∞
    if (this.bankSearchSpinner) {
      this.tweens.killTweensOf(this.bankSearchSpinner);
      this.bankSearchSpinner.destroy();
      this.bankSearchSpinner = null;
    }

    const panelX = width / 2 + 60; // Ïò§Î•∏Ï™Ω Ìå®ÎÑê Ï§ëÏã¨

    // ÏùÄÌñâ Î™©Î°ù ÏÉùÏÑ±
    this.availableBanks = generateBankList(tierKey);
    this.selectedBankIndex = 0;
    this.bankTexts = [];

    // Í≤∞Í≥º ÌÉÄÏù¥ÌãÄ - Ìéë! ÌïòÍ≥† Îì±Ïû•
    const resultTitle = this.add.text(panelX, height / 2 - 130, 'Available Banks:', {
      fontSize: '20px',
      fill: '#00ff88',
      fontStyle: 'bold',
      stroke: '#003311',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(7002).setAlpha(0).setScale(0);
    this.loanElements.push(resultTitle);

    // ÏùÄÌñâ Î™©Î°ù ÌëúÏãú
    this.availableBanks.forEach((bank, i) => {
      // ÏùÄÌñâ Ïù¥Î¶Ñ Î∞∞Í≤Ω (Ïπ¥Îìú ÎäêÎÇå)
      const cardBg = this.add.rectangle(
        panelX,
        height / 2 - 80 + i * 50,
        320, 42, 0x1a2a3f, 0.9
      ).setDepth(7001).setAlpha(0).setStrokeStyle(2, 0x00aa44);
      this.loanElements.push(cardBg);

      const bankText = this.add.text(
        panelX,
        height / 2 - 90 + i * 50,
        `${bank.name}`,
        {
          fontSize: '16px',
          fill: '#ffffff',
          fontStyle: 'bold'
        }
      ).setOrigin(0.5).setDepth(7002).setAlpha(0).setScale(0.5);

      const detailText = this.add.text(
        panelX,
        height / 2 - 70 + i * 50,
        `Rate: ${bank.interestRate}% | Max: $${bank.maxLoan}`,
        {
          fontSize: '12px',
          fill: '#aaaaaa',
          fontStyle: 'bold'
        }
      ).setOrigin(0.5).setDepth(7002).setAlpha(0);

      this.bankTexts.push({ name: bankText, detail: detailText, bank, card: cardBg });
      this.loanElements.push(bankText, detailText);
    });

    // ÏïàÎÇ¥ ÌÖçÏä§Ìä∏
    const helpText = this.add.text(panelX, height / 2 + 170, '‚Üë‚Üì: Select  ENTER: Borrow  ESC: Cancel', {
      fontSize: '12px',
      fill: '#888888',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(helpText);

    // ÌÉÄÏù¥ÌãÄ Ìéë! Îì±Ïû•
    this.tweens.add({
      targets: resultTitle,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        // Î∞òÏßù Ìö®Í≥º
        this.tweens.add({
          targets: resultTitle,
          scaleX: 1.1,
          scaleY: 1.1,
          duration: 100,
          yoyo: true
        });
      }
    });

    this.bankTexts.forEach((item, i) => {
      // Ïπ¥Îìú Î∞∞Í≤Ω - ÏúÑÏóêÏÑú Îñ®Ïñ¥Ïßê
      item.card.y -= 30;
      this.tweens.add({
        targets: item.card,
        alpha: 1,
        y: '+=30',
        duration: 400,
        delay: 150 + i * 120,
        ease: 'Bounce.easeOut'
      });

      // Ïù¥Î¶Ñ - Ïä§ÏºÄÏùº ÏóÖ + Î∞îÏö¥Ïä§
      this.tweens.add({
        targets: item.name,
        alpha: 1,
        scaleX: 1,
        scaleY: 1,
        duration: 350,
        delay: 200 + i * 120,
        ease: 'Back.easeOut'
      });

      // ÏÉÅÏÑ∏ - ÌéòÏù¥Îìú + Ïä¨ÎùºÏù¥Îìú
      item.detail.y += 10;
      this.tweens.add({
        targets: item.detail,
        alpha: 1,
        y: '-=10',
        duration: 300,
        delay: 250 + i * 120,
        ease: 'Power2'
      });
    });

    this.tweens.add({
      targets: helpText,
      alpha: 1,
      duration: 200,
      delay: 300 + this.availableBanks.length * 100
    });

    // ÏÑ†ÌÉù ÏóÖÎç∞Ïù¥Ìä∏
    this.time.delayedCall(300 + this.availableBanks.length * 100, () => {
      this.updateBankSelection();
    });
  }

  showNoBanksAvailable(width, height) {
    // Ïä§ÌîºÎÑà Ï†úÍ±∞
    if (this.bankSearchSpinner) {
      this.tweens.killTweensOf(this.bankSearchSpinner);
      this.bankSearchSpinner.destroy();
      this.bankSearchSpinner = null;
    }

    const panelX = width / 2 + 60; // Ïò§Î•∏Ï™Ω Ìå®ÎÑê Ï§ëÏã¨

    // Î©îÏù∏ Î©îÏãúÏßÄ - ÏùÄÌñâ ÏóÜÏùå
    const noLoanText = this.add.text(panelX, height / 2 - 80, 'NO BANKS AVAILABLE!', {
      fontSize: '20px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#440000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(noLoanText);

    // ÏúÑÌä∏ÏûàÎäî Î©îÏãúÏßÄ
    const wittyText = this.add.text(panelX, height / 2 - 40,
      "You've maxed out every bank in town!", {
      fontSize: '12px',
      fill: '#ffaa00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(wittyText);

    const wittyText2 = this.add.text(panelX, height / 2 - 15,
      "Time to pay your debts, rookie!", {
      fontSize: '14px',
      fill: '#ff8888',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(wittyText2);

    // OK Î≤ÑÌäº
    const okBg = this.add.rectangle(panelX, height / 2 + 50, 100, 35, 0x006600)
      .setStrokeStyle(2, 0x00ff00)
      .setDepth(7001).setAlpha(0)
      .setInteractive({ useHandCursor: true });
    this.loanElements.push(okBg);

    const okText = this.add.text(panelX, height / 2 + 50, 'OK', {
      fontSize: '16px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(okText);

    const helpText = this.add.text(panelX, height / 2 + 90, 'Press ESC or click OK', {
      fontSize: '10px',
      fill: '#888888'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(helpText);

    // OK Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏
    okBg.on('pointerdown', () => {
      this.closeLoanUI();
    });

    okBg.on('pointerover', () => {
      okBg.setFillStyle(0x008800);
    });

    okBg.on('pointerout', () => {
      okBg.setFillStyle(0x006600);
    });

    // ÏóîÌÑ∞ÌÇ§Î°ú Îã´Í∏∞
    this.input.keyboard.once('keydown-ENTER', () => {
      this.closeLoanUI();
    });

    // Ïï†ÎãàÎ©îÏù¥ÏÖò
    const elements = [noLoanText, wittyText, wittyText2, okBg, okText, helpText];
    elements.forEach((el, i) => {
      el.setScale(0.5);
      this.tweens.add({
        targets: el,
        alpha: 1,
        scaleX: 1,
        scaleY: 1,
        duration: 300,
        delay: i * 80,
        ease: 'Back.easeOut',
        onComplete: () => {
          if (i === 0) {
            // ÌÉÄÏù¥ÌãÄ ÌùîÎì§Î¶º
            this.tweens.add({
              targets: el,
              x: el.x + 5,
              duration: 50,
              yoyo: true,
              repeat: 5
            });
          }
        }
      });
    });
  }

  showRepaymentOptions(width, height) {
    this.loanMode = 'repay';
    this.selectedBankIndex = 0;
    this.repayTexts = [];

    const panelX = width / 2 + 60; // Ïò§Î•∏Ï™Ω Ìå®ÎÑê Ï§ëÏã¨

    // ÏÉÅÌôò ÌÉÄÏù¥ÌãÄ - Îçî ÌôîÎ†§ÌïòÍ≤å
    const repayTitle = this.add.text(panelX, height / 2 - 60, 'üí≥ Your Loans üí≥', {
      fontSize: '18px',
      fill: '#ffaa00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(7002).setAlpha(0).setScale(0.3);
    this.loanElements.push(repayTitle);

    // ÎåÄÏ∂ú Î™©Î°ù ÌëúÏãú - Ïπ¥Îìú Ïä§ÌÉÄÏùº
    this.loans.forEach((loan, i) => {
      const canRepay = this.money >= loan.due;
      const yPos = height / 2 - 10 + i * 50;

      // Ïπ¥Îìú Î∞∞Í≤Ω
      const cardBg = this.add.rectangle(panelX, yPos + 5, 280, 40, canRepay ? 0x003322 : 0x331111)
        .setStrokeStyle(2, canRepay ? 0x00ff88 : 0xff4444)
        .setDepth(7001).setAlpha(0);
      this.loanElements.push(cardBg);

      const loanText = this.add.text(
        panelX,
        yPos - 5,
        `${loan.bankName}`,
        {
          fontSize: '13px',
          fill: canRepay ? '#ffffff' : '#888888',
          fontStyle: 'bold'
        }
      ).setOrigin(0.5).setDepth(7002).setAlpha(0);

      const detailText = this.add.text(
        panelX,
        yPos + 12,
        `Owe: $${loan.due} ${canRepay ? '‚úì Can Repay' : '‚úó Need $' + (loan.due - this.money) + ' more'}`,
        {
          fontSize: '9px',
          fill: canRepay ? '#00ff88' : '#ff6666'
        }
      ).setOrigin(0.5).setDepth(7002).setAlpha(0);

      this.repayTexts.push({ name: loanText, detail: detailText, card: cardBg, loan, canRepay });
      this.loanElements.push(loanText, detailText);
    });

    // ÏïàÎÇ¥ ÌÖçÏä§Ìä∏
    const helpText = this.add.text(panelX, height / 2 + 160, '‚Üë‚Üì: Select  ENTER: Repay  ESC: Cancel', {
      fontSize: '10px',
      fill: '#888888',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7002).setAlpha(0);
    this.loanElements.push(helpText);

    // ÌÉÄÏù¥ÌãÄ Ï§åÏù∏ + Î∞îÏö¥Ïä§
    this.tweens.add({
      targets: repayTitle,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 400,
      delay: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÌéÑÏä§ Ìö®Í≥º
        this.tweens.add({
          targets: repayTitle,
          scaleX: 1.05,
          scaleY: 1.05,
          duration: 800,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });
      }
    });

    // Ïπ¥Îìú Î∞îÏö¥Ïä§ Îì±Ïû•
    this.repayTexts.forEach((item, i) => {
      const startY = item.card.y - 50;
      item.card.y = startY;
      item.name.y = startY - 10;
      item.detail.y = startY + 7;

      // Ïπ¥Îìú Î∞∞Í≤Ω Î∞îÏö¥Ïä§
      this.tweens.add({
        targets: item.card,
        alpha: 1,
        y: '+=50',
        duration: 400,
        delay: 500 + i * 120,
        ease: 'Bounce.easeOut'
      });

      // ÌÖçÏä§Ìä∏Îì§ Î∞îÏö¥Ïä§
      this.tweens.add({
        targets: [item.name, item.detail],
        alpha: 1,
        y: '+=50',
        duration: 400,
        delay: 520 + i * 120,
        ease: 'Bounce.easeOut'
      });

      // Ï∞©ÏßÄ ÌååÌã∞ÌÅ¥
      this.time.delayedCall(700 + i * 120, () => {
        for (let p = 0; p < 8; p++) {
          const particle = this.add.circle(
            width / 2 + (Math.random() - 0.5) * 100,
            item.card.y + 20,
            2,
            item.canRepay ? 0x00ff88 : 0xff4444
          ).setDepth(7003).setAlpha(0.8);

          this.tweens.add({
            targets: particle,
            y: item.card.y + 20 + Math.random() * 15,
            x: particle.x + (Math.random() - 0.5) * 30,
            alpha: 0,
            duration: 400,
            onComplete: () => particle.destroy()
          });
        }
      });
    });

    // ÎèÑÏõÄÎßê ÌéòÏù¥ÎìúÏù∏ + ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: helpText,
      alpha: 1,
      duration: 300,
      delay: 800 + this.loans.length * 120,
      onComplete: () => {
        this.tweens.add({
          targets: helpText,
          alpha: 0.5,
          duration: 1000,
          yoyo: true,
          repeat: -1
        });
      }
    });

    // ÏÑ†ÌÉù ÏóÖÎç∞Ïù¥Ìä∏
    this.time.delayedCall(900 + this.loans.length * 120, () => {
      this.updateRepaySelection();
    });
  }

  updateRepaySelection() {
    if (!this.repayTexts || this.repayTexts.length === 0) return;

    this.repayTexts.forEach((item, i) => {
      if (i === this.selectedBankIndex) {
        // ÏÑ†ÌÉùÎêú Ìï≠Î™© - Í∞ïÏ°∞
        item.name.setFill(item.canRepay ? '#00ffff' : '#ff8888');
        item.detail.setFill(item.canRepay ? '#00ff88' : '#ff6666');

        // Ïπ¥Îìú Î∞∞Í≤Ω Í∞ïÏ°∞
        if (item.card) {
          item.card.setStrokeStyle(3, item.canRepay ? 0x00ffff : 0xff8888);
          this.tweens.add({
            targets: item.card,
            scaleX: 1.05,
            scaleY: 1.1,
            duration: 150,
            ease: 'Back.easeOut'
          });
        }

        // ÌÖçÏä§Ìä∏ Ïä§ÏºÄÏùº ÏóÖ + Îì§Ïç©ÏûÑ
        this.tweens.add({
          targets: [item.name, item.detail],
          scaleX: 1.1,
          scaleY: 1.1,
          duration: 100,
          ease: 'Power2'
        });

        // ÏÑ†ÌÉù Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        this.tweens.add({
          targets: item.name,
          alpha: { from: 0.8, to: 1 },
          duration: 300,
          yoyo: true,
          repeat: -1
        });
      } else {
        // ÏÑ†ÌÉù Ìï¥Ï†ú
        item.name.setFill(item.canRepay ? '#ffffff' : '#888888');
        item.detail.setFill(item.canRepay ? '#00ff88' : '#ff6666');

        if (item.card) {
          item.card.setStrokeStyle(2, item.canRepay ? 0x00ff88 : 0xff4444);
          this.tweens.add({
            targets: item.card,
            scaleX: 1,
            scaleY: 1,
            duration: 100,
            ease: 'Power2'
          });
        }

        this.tweens.killTweensOf(item.name);
        item.name.setAlpha(1);

        this.tweens.add({
          targets: [item.name, item.detail],
          scaleX: 1,
          scaleY: 1,
          duration: 100,
          ease: 'Power2'
        });
      }
    });
  }

  updateBankSelection() {
    if (!this.bankTexts || this.bankTexts.length === 0) return;

    this.bankTexts.forEach((item, i) => {
      if (i === this.selectedBankIndex) {
        // ÏÑ†ÌÉùÎêú ÏùÄÌñâ - Í∞ïÏ°∞
        item.name.setFill('#00ffff');
        item.detail.setFill('#00ff88');

        // Ïπ¥Îìú Î∞∞Í≤Ω Í∞ïÏ°∞
        if (item.card) {
          item.card.setStrokeStyle(3, 0x00ffff);
          this.tweens.add({
            targets: item.card,
            scaleX: 1.05,
            scaleY: 1.1,
            duration: 150,
            ease: 'Back.easeOut'
          });
        }

        // Ïä§ÏºÄÏùº ÏóÖ Ïï†ÎãàÎ©îÏù¥ÏÖò
        this.tweens.add({
          targets: [item.name, item.detail],
          scaleX: 1.1,
          scaleY: 1.1,
          duration: 100,
          ease: 'Power2'
        });

        // ÏÑ†ÌÉù Í∏ÄÎ°úÏö∞ Ìö®Í≥º
        this.tweens.add({
          targets: item.name,
          alpha: { from: 0.8, to: 1 },
          duration: 300,
          yoyo: true,
          repeat: -1
        });
      } else {
        // ÏÑ†ÌÉù Ìï¥Ï†ú
        item.name.setFill('#ffffff');
        item.detail.setFill('#888888');

        if (item.card) {
          item.card.setStrokeStyle(2, 0x00aa44);
          this.tweens.add({
            targets: item.card,
            scaleX: 1,
            scaleY: 1,
            duration: 100,
            ease: 'Power2'
          });
        }

        this.tweens.killTweensOf(item.name);
        item.name.setAlpha(1);

        this.tweens.add({
          targets: [item.name, item.detail],
          scaleX: 1,
          scaleY: 1,
          duration: 100,
          ease: 'Power2'
        });
      }
    });
  }

  handleLoanInput(direction) {
    if (!this.loanUIOpen) return;

    // ÏÉÅÌôò Î™®Îìú
    if (this.loanMode === 'repay') {
      if (!this.repayTexts || this.repayTexts.length === 0) return;

      if (direction === 'UP') {
        this.selectedBankIndex = (this.selectedBankIndex - 1 + this.loans.length) % this.loans.length;
        this.updateRepaySelection();
      } else if (direction === 'DOWN') {
        this.selectedBankIndex = (this.selectedBankIndex + 1) % this.loans.length;
        this.updateRepaySelection();
      } else if (direction === 'ENTER') {
        this.repayLoan(this.selectedBankIndex);
      }
      return;
    }

    // ÎåÄÏ∂ú Î™®Îìú
    if (!this.bankTexts || this.bankTexts.length === 0) return;

    if (direction === 'UP') {
      this.selectedBankIndex = (this.selectedBankIndex - 1 + this.availableBanks.length) % this.availableBanks.length;
      this.updateBankSelection();
    } else if (direction === 'DOWN') {
      this.selectedBankIndex = (this.selectedBankIndex + 1) % this.availableBanks.length;
      this.updateBankSelection();
    } else if (direction === 'ENTER') {
      // ÎåÄÏ∂ú Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Î¨¥Ïãú (ÏóîÌÑ∞ Ïó∞ÌÉÄ Î∞©ÏßÄ)
      if (this.isLoanProcessing) return;

      const selectedBank = this.availableBanks[this.selectedBankIndex];
      if (selectedBank) {
        this.isLoanProcessing = true;
        this.takeLoanFromBank(selectedBank);
      }
    }
  }

  takeLoanFromBank(bank) {
    const amount = bank.maxLoan;
    const interest = Math.ceil(amount * bank.interestRate / 100);
    const totalDue = amount + interest;
    const paymentPerStage = Math.ceil(totalDue / 5); // 5Ïä§ÌÖåÏù¥ÏßÄÎ°ú Î∂ÑÌï†

    // ÎåÄÏ∂ú Í∏∞Î°ù Ï∂îÍ∞Ä
    this.loans.push({
      bankId: bank.id,
      bankName: bank.name,
      principal: amount,
      interest: interest,
      interestRate: bank.interestRate,
      totalDue: totalDue,
      remaining: totalDue,
      paymentPerStage: paymentPerStage,
      stagesLeft: 5,
      missedPayments: 0
    });

    // Ìã∞Ïñ¥ Ï¶ùÍ∞Ä
    this.loanTier++;

    // Îèà Ï∂îÍ∞Ä
    this.money += amount;
    this.totalDebt += totalDue;

    // Îèà ÌöçÎìù Ïï†ÎãàÎ©îÏù¥ÏÖò
    const { width, height } = this.cameras.main;

    // ÏΩîÏù∏ ÌååÌã∞ÌÅ¥ Ìö®Í≥º
    for (let i = 0; i < 30; i++) {
      const coin = this.add.circle(
        width / 2 + (Math.random() - 0.5) * 150,
        height / 2,
        3 + Math.random() * 3,
        0xffff00
      ).setDepth(7003);

      this.tweens.add({
        targets: coin,
        x: 80,
        y: 180,
        alpha: 0,
        duration: 600 + Math.random() * 600,
        ease: 'Power2',
        onComplete: () => coin.destroy()
      });
    }

    // ÌöçÎìù ÌÖçÏä§Ìä∏
    const gainText = this.add.text(width / 2, height / 2, `+$${amount}`, {
      fontSize: '48px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#004400',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(7003).setScale(0.5);

    this.tweens.add({
      targets: gainText,
      y: height / 2 - 60,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 400,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: gainText,
          alpha: 0,
          y: height / 2 - 100,
          duration: 500,
          onComplete: () => gainText.destroy()
        });
      }
    });

    // ÏùÄÌñâÎ™Ö ÌëúÏãú
    const bankText = this.add.text(width / 2, height / 2 + 40, `Borrowed from ${bank.name}`, {
      fontSize: '14px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7003).setAlpha(0);

    this.tweens.add({
      targets: bankText,
      alpha: 1,
      duration: 200,
      delay: 200,
      onComplete: () => {
        this.tweens.add({
          targets: bankText,
          alpha: 0,
          duration: 300,
          delay: 800,
          onComplete: () => bankText.destroy()
        });
      }
    });

    // UI Îã´Í∏∞ Î∞è ÏÉÅÏ†ê ÏóÖÎç∞Ïù¥Ìä∏
    this.time.delayedCall(800, () => {
      this.closeLoanUI();
      if (this.shopMoneyText) {
        this.shopMoneyText.setText(`$${this.money}`);
        // Îèà ÌéÑÏä§ Ìö®Í≥º
        this.tweens.add({
          targets: this.shopMoneyText,
          scaleX: 1.3,
          scaleY: 1.3,
          duration: 150,
          yoyo: true,
          ease: 'Back.easeOut'
        });
      }
      // Îπö Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
      this.updateShopDebtInfo();
      // Ïã§ÏãúÍ∞Ñ ÏÉÅÏ†ê ÏïÑÏù¥ÌÖú ÏóÖÎç∞Ïù¥Ìä∏
      this.updateShopAffordability();
      this.updateShopSelection();
    });
  }

  updateShopDebtInfo() {
    if (!this.shopOpen) return;

    const sidebarMargin = 10;
    const sidebarWidth = 140;
    const contentX = sidebarMargin + 8;
    const contentCenterX = sidebarMargin + sidebarWidth / 2;
    const rightX = sidebarMargin + sidebarWidth - 8;

    // Í∏∞Ï°¥ Îπö Ï†ïÎ≥¥ ÏöîÏÜå Ï†úÍ±∞ (shopElementsÏóêÏÑúÎèÑ Ï†úÍ±∞)
    if (this.shopDebtElements) {
      this.shopDebtElements.forEach(el => {
        if (el && el.destroy) {
          // shopElements Î∞∞Ïó¥ÏóêÏÑúÎèÑ Ï†úÍ±∞
          const idx = this.shopElements.indexOf(el);
          if (idx > -1) this.shopElements.splice(idx, 1);
          el.destroy();
        }
      });
    }
    this.shopDebtElements = [];

    // ÎåÄÏ∂úÏù¥ ÏóÜÏúºÎ©¥ Ï¢ÖÎ£å
    if (!this.loans || this.loans.length === 0) return;

    let debtY = 240;

    // Íµ¨Î∂ÑÏÑ†
    const debtDivider = this.add.rectangle(contentCenterX, debtY, sidebarWidth - 16, 1, 0xff4444, 0.5)
      .setDepth(6002).setAlpha(0);
    this.shopDebtElements.push(debtDivider);
    this.shopElements.push(debtDivider);
    debtY += 12;

    // DEBTS ÎùºÎ≤®
    const debtLabel = this.add.text(contentX, debtY, 'DEBTS', {
      fontSize: '11px',
      fill: '#ff4444',
      fontStyle: 'bold'
    }).setDepth(6002).setAlpha(0);
    this.shopDebtElements.push(debtLabel);
    this.shopElements.push(debtLabel);
    debtY += 16;

    // Í∞Å ÏùÄÌñâÎ≥Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
    this.loans.forEach(loan => {
      const payment = loan.stagesLeft === 1 ? loan.remaining : Math.min(loan.paymentPerStage, loan.remaining);
      const afterPayment = loan.remaining - payment;

      // ÏùÄÌñâ Ïù¥Î¶Ñ
      const shortName = loan.bankName.length > 12 ? loan.bankName.substring(0, 10) + '..' : loan.bankName;
      const bankText = this.add.text(contentX, debtY, shortName, {
        fontSize: '10px',
        fill: '#ffffff',
        fontStyle: 'bold'
      }).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(bankText);
      this.shopElements.push(bankText);
      debtY += 14;

      // ÏõêÍ∏à/Ïù¥Ïûê
      const principalText = this.add.text(contentX, debtY, `P:$${loan.principal}`, {
        fontSize: '9px',
        fill: '#888888'
      }).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(principalText);
      this.shopElements.push(principalText);

      const interestText = this.add.text(rightX, debtY, `I:$${loan.interest}`, {
        fontSize: '9px',
        fill: '#888888'
      }).setOrigin(1, 0).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(interestText);
      this.shopElements.push(interestText);
      debtY += 12;

      // ÏûîÍ∏à
      const remainText = this.add.text(contentX, debtY, `Remain:`, {
        fontSize: '9px',
        fill: '#aaaaaa'
      }).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(remainText);
      this.shopElements.push(remainText);

      const remainValue = this.add.text(rightX, debtY, `$${loan.remaining}`, {
        fontSize: '10px',
        fill: '#ff6666',
        fontStyle: 'bold'
      }).setOrigin(1, 0).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(remainValue);
      this.shopElements.push(remainValue);
      debtY += 12;

      // Îã§ÏùåÏÉÅÌôò
      const nextText = this.add.text(contentX, debtY, `Next:`, {
        fontSize: '9px',
        fill: '#aaaaaa'
      }).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(nextText);
      this.shopElements.push(nextText);

      const nextValue = this.add.text(rightX, debtY, `-$${payment}`, {
        fontSize: '10px',
        fill: '#ff4444',
        fontStyle: 'bold'
      }).setOrigin(1, 0).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(nextValue);
      this.shopElements.push(nextValue);
      debtY += 12;

      // ÏÉÅÌôòÌõÑ
      const afterText = this.add.text(contentX, debtY, `After:`, {
        fontSize: '9px',
        fill: '#aaaaaa'
      }).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(afterText);
      this.shopElements.push(afterText);

      const afterValue = this.add.text(rightX, debtY, `$${afterPayment}`, {
        fontSize: '10px',
        fill: '#ffaa00',
        fontStyle: 'bold'
      }).setOrigin(1, 0).setDepth(6002).setAlpha(0);
      this.shopDebtElements.push(afterValue);
      this.shopElements.push(afterValue);
      debtY += 16;
    });

    // Ï¥ù Î∂ÄÏ±Ñ
    const totalLine = this.add.rectangle(contentCenterX, debtY, sidebarWidth - 20, 1, 0xff4444, 0.3)
      .setDepth(6002).setAlpha(0);
    this.shopDebtElements.push(totalLine);
    this.shopElements.push(totalLine);
    debtY += 10;

    const totalDebtLabel = this.add.text(contentX, debtY, 'TOTAL', {
      fontSize: '10px',
      fill: '#ff4444'
    }).setDepth(6002).setAlpha(0);
    this.shopDebtElements.push(totalDebtLabel);
    this.shopElements.push(totalDebtLabel);

    const totalDebtValue = this.add.text(rightX, debtY, `$${this.totalDebt}`, {
      fontSize: '14px',
      fill: '#ff4444',
      fontStyle: 'bold'
    }).setOrigin(1, 0).setDepth(6002).setAlpha(0);
    this.shopDebtElements.push(totalDebtValue);
    this.shopElements.push(totalDebtValue);

    // Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú ÌëúÏãú (Ïä¨ÎùºÏù¥Îìú + ÌéòÏù¥ÎìúÏù∏)
    this.shopDebtElements.forEach((el, i) => {
      const originalX = el.x;
      el.x = originalX - 20;
      this.tweens.add({
        targets: el,
        x: originalX,
        alpha: 1,
        duration: 250,
        delay: i * 30,
        ease: 'Power2'
      });
    });
  }

  updateShopAffordability() {
    // ÏÉÅÏ†ê Ïπ¥ÎìúÏùò Íµ¨Îß§ Í∞ÄÎä• Ïó¨Î∂Ä Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
    if (!this.shopCards) return;

    this.shopCards.forEach((card, index) => {
      const item = this.shopItems[index];
      if (item.purchased) return;

      const canAfford = this.money >= item.price;

      // Í∞ÄÍ≤© ÌÉúÍ∑∏ ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
      if (card.priceTag) {
        const priceTagColor = canAfford ? 0x00aa00 : 0x661111;
        const priceTagStroke = canAfford ? 0x00ff00 : 0xff4444;
        card.priceTag.setFillStyle(priceTagColor);
        card.priceTag.setStrokeStyle(2, priceTagStroke);
      }

      if (card.price) {
        const priceTextColor = canAfford ? '#00ff00' : '#ff4444';
        card.price.setFill(priceTextColor);

        // Íµ¨Îß§ Í∞ÄÎä•Ìï¥Ï°åÏùÑ Îïå Î∞òÏßù Ìö®Í≥º
        if (canAfford) {
          this.tweens.add({
            targets: card.price,
            scaleX: 1.3,
            scaleY: 1.3,
            duration: 150,
            yoyo: true,
            ease: 'Power2'
          });
        }
      }
    });
  }

  applyLoanInterest() {
    // Ïä§ÌÖåÏù¥ÏßÄ Ï¢ÖÎ£å Ïãú Ïù¥Ïûê Ï†ÅÏö©
    this.loans.forEach(loan => {
      const interest = Math.ceil(loan.due * loan.interestRate / 100);
      loan.due += interest;
    });

    // Ï¥ù Î∂ÄÏ±Ñ Ïû¨Í≥ÑÏÇ∞
    this.totalDebt = this.loans.reduce((sum, loan) => sum + loan.due, 0);
  }

  checkMinimumPayment() {
    if (this.loans.length === 0) return;

    // ÏûëÏùÄ Í∏àÏï° ÏàúÏúºÎ°ú Ï†ïÎ†¨
    this.loans.sort((a, b) => a.due - b.due);

    let totalPaid = 0;
    let missedLoans = [];
    let paidLoans = [];
    let bankruptBank = null;

    // Í∞Å ÎåÄÏ∂úÎ≥ÑÎ°ú ÏµúÏÜå ÏÉÅÌôò ÏãúÎèÑ
    this.loans.forEach(loan => {
      // ÏµúÏÜå ÏÉÅÌôòÍ∏àÏï° (ÎåÄÏ∂úÏùò 10% ÎòêÎäî ÎÇ®ÏùÄ Í∏àÏï°)
      const minPayment = Math.min(Math.ceil(loan.due * this.minimumPaymentRate), loan.due);

      if (this.money >= minPayment) {
        // ÏÉÅÌôò ÏÑ±Í≥µ
        this.money -= minPayment;
        loan.due -= minPayment;
        loan.missedPayments = 0; // Ïó∞Ï≤¥ ÌöüÏàò Î¶¨ÏÖã
        totalPaid += minPayment;
        paidLoans.push({ name: loan.bankName, amount: minPayment });
      } else {
        // Ïó∞Ï≤¥
        loan.missedPayments++;
        missedLoans.push({ name: loan.bankName, missed: loan.missedPayments });

        if (loan.missedPayments >= 2) {
          bankruptBank = loan.bankName;
        }
      }
    });

    // ÏôÑÏ†Ñ ÏÉÅÌôòÎêú ÎåÄÏ∂ú Ï†úÍ±∞
    this.loans = this.loans.filter(loan => loan.due > 0);
    this.loanTier = this.loans.length;

    // Ï¥ù Î∂ÄÏ±Ñ Ïû¨Í≥ÑÏÇ∞
    this.totalDebt = this.loans.reduce((sum, loan) => sum + loan.due, 0);

    // ÌååÏÇ∞ Ï≤¥ÌÅ¨ (2Ìöå Ïó∞ÏÜç Ïó∞Ï≤¥)
    if (bankruptBank) {
      this.time.delayedCall(500, () => {
        this.showBankruptcyGameOver(bankruptBank);
      });
      return;
    }

    // Í≤∞Í≥º ÌëúÏãú
    if (missedLoans.length > 0) {
      this.showPaymentWarning(missedLoans);
    } else if (totalPaid > 0) {
      this.showPaymentSuccess(totalPaid, paidLoans);
    }
  }

  showPaymentSuccess(totalAmount, paidLoans) {
    const { width, height } = this.cameras.main;

    // Î∞∞Í≤Ω ÌîåÎûòÏãú
    const flashBg = this.add.rectangle(width / 2, 110, 350, 80, 0x00ff88, 0)
      .setDepth(6999);
    this.tweens.add({
      targets: flashBg,
      fillAlpha: 0.3,
      duration: 100,
      yoyo: true,
      repeat: 2,
      onComplete: () => flashBg.destroy()
    });

    // ÏΩîÏù∏ ÌååÌã∞ÌÅ¥ Ìö®Í≥º (ÏúÑÏóêÏÑú Îñ®Ïñ¥Ïßê)
    for (let i = 0; i < 20; i++) {
      const coin = this.add.circle(
        width / 2 + (Math.random() - 0.5) * 200,
        70,
        3 + Math.random() * 2,
        0x00ff88
      ).setDepth(7001).setAlpha(0.9);

      this.tweens.add({
        targets: coin,
        y: 150 + Math.random() * 30,
        alpha: 0,
        duration: 800 + Math.random() * 400,
        delay: Math.random() * 200,
        ease: 'Bounce.easeOut',
        onComplete: () => coin.destroy()
      });
    }

    // ÌÉÄÏù¥ÌãÄ - Ï§åÏù∏ Îì±Ïû•
    const titleText = this.add.text(width / 2, 85, '‚úì AUTO PAYMENT ‚úì', {
      fontSize: '16px',
      fill: '#00ff88',
      fontStyle: 'bold',
      stroke: '#003311',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(7000).setScale(0.3).setAlpha(0);

    // Ï¥ù ÏÉÅÌôòÏï° - ÌÅ∞ Í∏ÄÏî® Î∞îÏö¥Ïä§
    const totalText = this.add.text(width / 2, 110, `-$${totalAmount}`, {
      fontSize: '24px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#004400',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(7000).setScale(0).setAlpha(0);

    // ÏùÄÌñâÎ≥Ñ ÏÉÅÏÑ∏
    const detailText = this.add.text(width / 2, 140,
      paidLoans.map(l => `${l.name}: -$${l.amount}`).join(' | '), {
      fontSize: '10px',
      fill: '#88ff88',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7000).setAlpha(0);

    // ÌÉÄÏù¥ÌãÄ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: titleText,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÌéÑÏä§
        this.tweens.add({
          targets: titleText,
          scaleX: 1.05,
          scaleY: 1.05,
          duration: 400,
          yoyo: true,
          repeat: 3
        });
      }
    });

    // Í∏àÏï° Î∞îÏö¥Ïä§
    this.tweens.add({
      targets: totalText,
      alpha: 1,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 400,
      delay: 150,
      ease: 'Bounce.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: totalText,
          scaleX: 1,
          scaleY: 1,
          duration: 200
        });
      }
    });

    // ÏÉÅÏÑ∏ Ïä¨ÎùºÏù¥ÎìúÏù∏
    detailText.x -= 50;
    this.tweens.add({
      targets: detailText,
      alpha: 1,
      x: '+=50',
      duration: 300,
      delay: 300,
      ease: 'Power2'
    });

    // Ï†ÑÏ≤¥ ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.time.delayedCall(2500, () => {
      [titleText, totalText, detailText].forEach((el, i) => {
        this.tweens.add({
          targets: el,
          alpha: 0,
          y: el.y - 20,
          duration: 400,
          delay: i * 50,
          onComplete: () => el.destroy()
        });
      });
    });
  }

  showDebtFreeAnimation() {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    // Î©îÏù∏ ÌÖçÏä§Ìä∏
    const debtFreeText = this.add.text(centerX, centerY - 20, 'DEBT FREE', {
      fontSize: '28px',
      fill: '#00ff88',
      fontStyle: 'bold',
      stroke: '#004422',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(7200).setAlpha(0).setScale(0.5);

    // ÏÑúÎ∏å ÌÖçÏä§Ìä∏
    const subText = this.add.text(centerX, centerY + 20, 'Good work. Keep it up.', {
      fontSize: '12px',
      fill: '#aaaaaa'
    }).setOrigin(0.5).setDepth(7200).setAlpha(0);

    // Î©îÏù∏ ÌÖçÏä§Ìä∏ Îì±Ïû•
    this.tweens.add({
      targets: debtFreeText,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 400,
      ease: 'Back.easeOut'
    });

    // ÏÑúÎ∏å ÌÖçÏä§Ìä∏ Îì±Ïû•
    this.tweens.add({
      targets: subText,
      alpha: 1,
      duration: 300,
      delay: 300,
      ease: 'Power2'
    });

    // 2Ï¥à ÌõÑ ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.time.delayedCall(2000, () => {
      this.tweens.add({
        targets: [debtFreeText, subText],
        alpha: 0,
        duration: 500,
        ease: 'Power2',
        onComplete: () => {
          debtFreeText.destroy();
          subText.destroy();
        }
      });
    });
  }

  showPaymentWarning(missedLoans) {
    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥† Ï§ë ÌÇ§Î≥¥Îìú ÏûÖÎ†• ÎπÑÌôúÏÑ±Ìôî
    this.shopKeyboardEnabled = false;

    // ÌôîÎ©¥ ÌùîÎì§Í∏∞
    this.cameras.main.shake(500, 0.02);

    // Îπ®Í∞Ñ ÌîåÎûòÏãú Ìö®Í≥º
    const redFlash = this.add.rectangle(width / 2, height / 2, width, height, 0xff0000, 0)
      .setDepth(7999);
    this.tweens.add({
      targets: redFlash,
      fillAlpha: 0.4,
      duration: 100,
      yoyo: true,
      repeat: 3,
      onComplete: () => redFlash.destroy()
    });

    // Í≤ΩÍ≥† Ïò§Î≤ÑÎ†àÏù¥
    const warningOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0x330000, 0)
      .setDepth(8000);

    this.tweens.add({
      targets: warningOverlay,
      fillAlpha: 0.85,
      duration: 300
    });

    // Í≤ΩÍ≥† ÏïÑÏù¥ÏΩò ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 15; i++) {
      const spark = this.add.text(
        width / 2 + (Math.random() - 0.5) * 300,
        height / 2 + (Math.random() - 0.5) * 200,
        '‚ö†',
        { fontSize: '20px' }
      ).setOrigin(0.5).setDepth(8001).setAlpha(0.8);

      this.tweens.add({
        targets: spark,
        y: spark.y - 50,
        alpha: 0,
        rotation: Math.random() * 2,
        duration: 1000 + Math.random() * 500,
        onComplete: () => spark.destroy()
      });
    }

    // Í≤ΩÍ≥† ÌÉÄÏù¥ÌãÄ - Ïä§ÏºÄÏùº Ìè≠Î∞ú Îì±Ïû•
    const warningTitle = this.add.text(width / 2, height / 2 - 80, '‚ö† PAYMENT WARNING! ‚ö†', {
      fontSize: '32px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(8001).setScale(3).setAlpha(0);

    // Ïó∞Ï≤¥ ÏùÄÌñâ Î™©Î°ù
    const missedText = this.add.text(width / 2, height / 2 - 30,
      'Failed to pay:', {
      fontSize: '14px',
      fill: '#ff8888',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(8001).setAlpha(0);

    // ÏùÄÌñâÎ≥Ñ Ïó∞Ï≤¥ ÏÉÅÌÉú - Í∞Å ÏùÄÌñâ Î≥ÑÎèÑ ÌëúÏãú
    const bankElements = [];
    missedLoans.forEach((l, i) => {
      const bankEntry = this.add.text(width / 2, height / 2 + i * 25,
        `${l.name}: Strike ${l.missed}/2`, {
        fontSize: '16px',
        fill: l.missed >= 2 ? '#ff0000' : '#ffffff',
        align: 'center',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 2
      }).setOrigin(0.5).setDepth(8001).setAlpha(0);
      bankElements.push(bankEntry);
    });

    // Í≤ΩÍ≥† Î©îÏãúÏßÄ - ÍπúÎπ°ÏûÑ
    const strikeText = this.add.text(width / 2, height / 2 + 80,
      'üíÄ One more miss = BANKRUPT! üíÄ', {
      fontSize: '14px',
      fill: '#ffaa00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(8001).setAlpha(0);

    // ÌÉÄÏù¥ÌãÄ Ìè≠Î∞ú Îì±Ïû•
    this.tweens.add({
      targets: warningTitle,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 400,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÏßÄÏÜç ÌùîÎì§Î¶º
        this.tweens.add({
          targets: warningTitle,
          x: warningTitle.x + 3,
          duration: 50,
          yoyo: true,
          repeat: -1
        });
        // Îπ®Í∞Ñ ÌéÑÏä§
        this.tweens.add({
          targets: warningTitle,
          fill: { from: '#ff4444', to: '#ff0000' },
          scaleX: 1.05,
          scaleY: 1.05,
          duration: 300,
          yoyo: true,
          repeat: -1
        });
      }
    });

    // Ïó∞Ï≤¥ ÌÖçÏä§Ìä∏ Ïä¨ÎùºÏù¥Îìú
    missedText.x -= 100;
    this.tweens.add({
      targets: missedText,
      alpha: 1,
      x: '+=100',
      duration: 300,
      delay: 400,
      ease: 'Power2'
    });

    // ÏùÄÌñâÎ≥Ñ ÏàúÏ∞® Îì±Ïû• + ÌùîÎì§Î¶º
    bankElements.forEach((el, i) => {
      el.x += 100;
      this.tweens.add({
        targets: el,
        alpha: 1,
        x: '-=100',
        duration: 300,
        delay: 500 + i * 100,
        ease: 'Back.easeOut',
        onComplete: () => {
          // Strike 2Î©¥ Í≤©Î†¨Ìïú ÌùîÎì§Î¶º
          if (missedLoans[i].missed >= 2) {
            this.tweens.add({
              targets: el,
              x: el.x + 5,
              duration: 30,
              yoyo: true,
              repeat: -1
            });
          }
        }
      });
    });

    // Í≤ΩÍ≥† Î©îÏãúÏßÄ ÍπúÎπ°ÏûÑ Îì±Ïû•
    this.tweens.add({
      targets: strikeText,
      alpha: 1,
      duration: 300,
      delay: 700 + missedLoans.length * 100,
      onComplete: () => {
        this.tweens.add({
          targets: strikeText,
          alpha: 0.3,
          duration: 300,
          yoyo: true,
          repeat: -1
        });
      }
    });

    // ÏûêÎèôÏúºÎ°ú Îã´Í∏∞
    this.time.delayedCall(4000, () => {
      const allElements = [warningOverlay, warningTitle, missedText, strikeText, ...bankElements];
      allElements.forEach((el, i) => {
        this.tweens.killTweensOf(el);
        this.tweens.add({
          targets: el,
          alpha: 0,
          scaleX: el === warningTitle ? 0.5 : 1,
          scaleY: el === warningTitle ? 0.5 : 1,
          duration: 300,
          delay: i * 30,
          onComplete: () => el.destroy()
        });
      });

      // Í≤ΩÍ≥† Ï¢ÖÎ£å ÌõÑ ÌÇ§Î≥¥Îìú Ïû¨ÌôúÏÑ±Ìôî
      this.time.delayedCall(allElements.length * 30 + 350, () => {
        this.shopKeyboardEnabled = true;
      });
    });
  }

  showBankruptcyGameOver(bankruptBank = null) {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ Ï†ïÏßÄ
    if (this.moveTimer) {
      this.moveTimer.paused = true;
    }

    // ÏÉÅÏ†ê Îã´Í∏∞
    this.closeShop();

    // Í∞ïÎ†•Ìïú ÌôîÎ©¥ ÌùîÎì§Í∏∞
    this.cameras.main.shake(1000, 0.05);

    // Ìè≠Î∞ú ÌîåÎûòÏãú
    const explosionFlash = this.add.rectangle(width / 2, height / 2, width, height, 0xff0000, 0)
      .setDepth(8999);
    this.tweens.add({
      targets: explosionFlash,
      fillAlpha: 0.8,
      duration: 100,
      yoyo: true,
      repeat: 5,
      onComplete: () => explosionFlash.destroy()
    });

    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥ - Îπ®Í∞ÑÏÉâ/Ï£ºÌô©ÏÉâ
    for (let i = 0; i < 40; i++) {
      const particle = this.add.circle(
        width / 2,
        height / 2,
        5 + Math.random() * 10,
        [0xff0000, 0xff4400, 0xff8800, 0xffaa00][Math.floor(Math.random() * 4)]
      ).setDepth(9002).setAlpha(0.9);

      const angle = Math.random() * Math.PI * 2;
      const speed = 150 + Math.random() * 200;

      this.tweens.add({
        targets: particle,
        x: particle.x + Math.cos(angle) * speed,
        y: particle.y + Math.sin(angle) * speed,
        alpha: 0,
        scaleX: 0.1,
        scaleY: 0.1,
        duration: 800 + Math.random() * 400,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // Ìï¥Í≥® ÌååÌã∞ÌÅ¥ Îñ®Ïñ¥Ïßê
    for (let i = 0; i < 20; i++) {
      const skull = this.add.text(
        Math.random() * width,
        -50,
        'üíÄ',
        { fontSize: (16 + Math.random() * 16) + 'px' }
      ).setOrigin(0.5).setDepth(9001).setAlpha(0.8);

      this.tweens.add({
        targets: skull,
        y: height + 50,
        rotation: Math.random() * 4 - 2,
        duration: 2000 + Math.random() * 2000,
        delay: Math.random() * 1000,
        ease: 'Power1',
        onComplete: () => skull.destroy()
      });
    }

    // ÌååÏÇ∞ Ïò§Î≤ÑÎ†àÏù¥ - Îçî Ïñ¥Îë°Í≤å
    const bankruptOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0x110000, 0)
      .setDepth(9000);

    this.tweens.add({
      targets: bankruptOverlay,
      fillAlpha: 0.95,
      duration: 800,
      delay: 300
    });

    // ÌååÏÇ∞ ÌÉÄÏù¥ÌãÄ - Ìè≠Î∞úÏ†Å Îì±Ïû•
    const bankruptTitle = this.add.text(width / 2, height / 2 - 80, 'üíÄ BANKRUPT! üíÄ', {
      fontSize: '56px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(9001).setScale(5).setAlpha(0);

    this.tweens.add({
      targets: bankruptTitle,
      scaleX: 1,
      scaleY: 1,
      alpha: 1,
      duration: 600,
      ease: 'Back.easeOut',
      delay: 400,
      onComplete: () => {
        // ÏßÄÏÜç ÌùîÎì§Î¶º
        this.tweens.add({
          targets: bankruptTitle,
          x: bankruptTitle.x + 4,
          duration: 40,
          yoyo: true,
          repeat: -1
        });
        // ÏÉâÏÉÅ ÌéÑÏä§
        this.tweens.add({
          targets: bankruptTitle,
          scaleX: 1.05,
          scaleY: 1.05,
          duration: 500,
          yoyo: true,
          repeat: -1
        });
      }
    });

    // Î©îÏãúÏßÄ - ÌÉÄÏù¥Ìïë Ìö®Í≥ºÏ≤òÎüº ÏàúÏ∞® Îì±Ïû•
    const msgContent = bankruptBank
      ? `${bankruptBank} reported you!\n2 consecutive missed payments.`
      : 'You failed to make minimum payments\nfor 2 consecutive stages.';

    const bankruptMsg = this.add.text(width / 2, height / 2 - 10, msgContent, {
      fontSize: '16px',
      fill: '#ff8888',
      align: 'center',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(9001).setAlpha(0).setScale(0.5);

    this.tweens.add({
      targets: bankruptMsg,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 400,
      delay: 1000,
      ease: 'Back.easeOut'
    });

    // Î∂ÄÏ±Ñ ÌëúÏãú - Ïà´Ïûê Ïπ¥Ïö¥Ìä∏ÏóÖ Ìö®Í≥º
    const debtText = this.add.text(width / 2, height / 2 + 50,
      `Total Debt: $0`, {
      fontSize: '22px',
      fill: '#ff4444',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(9001).setAlpha(0);

    this.tweens.add({
      targets: debtText,
      alpha: 1,
      duration: 300,
      delay: 1300,
      onComplete: () => {
        // Ïà´Ïûê Ïπ¥Ïö¥Ìä∏ÏóÖ
        let currentDebt = 0;
        const targetDebt = this.totalDebt;
        const countDuration = 1000;
        const steps = 30;
        const increment = targetDebt / steps;

        for (let i = 0; i <= steps; i++) {
          this.time.delayedCall((countDuration / steps) * i, () => {
            currentDebt = Math.min(Math.floor(increment * i), targetDebt);
            debtText.setText(`Total Debt: $${currentDebt}`);

            // ÎßàÏßÄÎßâÏóê ÌéÑÏä§
            if (i === steps) {
              this.tweens.add({
                targets: debtText,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 100,
                yoyo: true,
                repeat: 2
              });
            }
          });
        }
      }
    });

    // Í≤åÏûÑ Ïò§Î≤Ñ ÌîåÎûòÍ∑∏
    this.gameOver = true;

    // Ïû¨ÏãúÏûë ÏïàÎÇ¥ - Îçî Í∑πÏ†ÅÏúºÎ°ú
    this.time.delayedCall(3000, () => {
      const restartBg = this.add.rectangle(width / 2, height / 2 + 110, 250, 35, 0x222222)
        .setStrokeStyle(2, 0x666666)
        .setDepth(9001).setAlpha(0);

      const restartText = this.add.text(width / 2, height / 2 + 110,
        '[ Press SPACE to restart ]', {
        fontSize: '14px',
        fill: '#aaaaaa',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(9001).setAlpha(0);

      // Î∞îÏö¥Ïä§ Îì±Ïû•
      restartBg.y += 30;
      restartText.y += 30;

      this.tweens.add({
        targets: [restartBg, restartText],
        alpha: 1,
        y: '-=30',
        duration: 400,
        ease: 'Back.easeOut'
      });

      // ÍπúÎπ°ÏûÑ
      this.tweens.add({
        targets: restartText,
        alpha: 0.4,
        duration: 600,
        yoyo: true,
        repeat: -1,
        delay: 500
      });

      // Ïû¨ÏãúÏûë ÌÇ§ ÏûÖÎ†•
      this.input.keyboard.once('keydown-SPACE', () => {
        // ÌéòÏù¥ÎìúÏïÑÏõÉ ÌõÑ Ïû¨ÏãúÏûë
        this.cameras.main.fadeOut(500, 0, 0, 0);
        this.time.delayedCall(500, () => {
          this.scene.restart();
        });
      });
    });
  }

  repayLoan(loanIndex) {
    if (loanIndex < 0 || loanIndex >= this.loans.length) return;

    const loan = this.loans[loanIndex];

    // ÎèàÏù¥ Ï∂©Î∂ÑÌïúÏßÄ ÌôïÏù∏
    if (this.money < loan.due) {
      // Îèà Î∂ÄÏ°± - ÌùîÎì§Î¶º Ìö®Í≥º
      if (this.repayTexts && this.repayTexts[loanIndex]) {
        const item = this.repayTexts[loanIndex];
        this.tweens.add({
          targets: [item.name, item.detail],
          x: '+=5',
          duration: 50,
          yoyo: true,
          repeat: 3
        });
      }
      return;
    }

    // ÏÉÅÌôò Ï≤òÎ¶¨
    this.money -= loan.due;
    this.loans.splice(loanIndex, 1);
    this.loanTier = Math.max(0, this.loanTier - 1);

    // Ï¥ù Î∂ÄÏ±Ñ Ïû¨Í≥ÑÏÇ∞
    this.totalDebt = this.loans.reduce((sum, l) => sum + l.due, 0);

    const { width, height } = this.cameras.main;

    // ÏÉÅÌôò ÏôÑÎ£å Ìö®Í≥º
    const paidText = this.add.text(width / 2, height / 2, `PAID OFF!\n-$${loan.due}`, {
      fontSize: '24px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#004400',
      strokeThickness: 3,
      align: 'center'
    }).setOrigin(0.5).setDepth(7003).setScale(0.5);

    this.tweens.add({
      targets: paidText,
      scaleX: 1,
      scaleY: 1,
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: paidText,
          alpha: 0,
          y: height / 2 - 30,
          duration: 500,
          delay: 500,
          onComplete: () => paidText.destroy()
        });
      }
    });

    // UI Îã´Í≥† Îã§Ïãú Ïó¥Í∏∞
    this.time.delayedCall(800, () => {
      this.closeLoanUI();
      if (this.shopMoneyText) {
        this.shopMoneyText.setText(`$${this.money}`);
      }
      this.updateShopAffordability();
    });
  }

  closeLoanUI() {
    if (!this.loanUIOpen) return;
    this.loanUIOpen = false;
    this.isLoanProcessing = false; // ÎåÄÏ∂ú Ï≤òÎ¶¨ ÌîåÎûòÍ∑∏ Î¶¨ÏÖã

    // ÏöîÏÜå Ï†ïÎ¶¨ - Ìù©Ïñ¥ÏßÄÎ©∞ ÏÇ¨ÎùºÏßê
    this.loanElements.forEach((el, i) => {
      if (el && el.active) {
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 50;

        this.tweens.add({
          targets: el,
          alpha: 0,
          x: el.x + Math.cos(angle) * distance,
          y: el.y + Math.sin(angle) * distance,
          scaleX: 0.5,
          scaleY: 0.5,
          duration: 300,
          delay: i * 20,
          ease: 'Power2',
          onComplete: () => el.destroy()
        });
      }
    });

    this.loanElements = [];
    this.bankTexts = [];
    this.repayTexts = [];
    this.availableBanks = [];
    this.loanMode = 'borrow';

    // ÏÉÅÏ†ê ÌÇ§Î≥¥Îìú Îã§Ïãú ÌôúÏÑ±Ìôî
    this.time.delayedCall(400, () => {
      this.shopKeyboardEnabled = true;
    });
  }

  // ==================== Î≥¥Ïä§Ï†Ñ ÏãúÏä§ÌÖú ====================

  showSnakeDialogue() {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubble = this.add.rectangle(headX, headY - 50, 200, 40, 0xffffff, 0.95)
      .setDepth(5001).setScale(0).setStrokeStyle(2, 0x000000);

    this.tweens.add({
      targets: bubble,
      scale: 1,
      duration: 200,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º ÌÖçÏä§Ìä∏
    const dialogue = "Where did the frog go?";
    const dialogueText = this.add.text(headX, headY - 50, '', {
      fontSize: '12px',
      fill: '#000000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5002);

    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        dialogueText.setText(dialogue.substring(0, charIndex + 1));
        charIndex++;
        if (charIndex >= dialogue.length) {
          typeTimer.destroy();
          // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ Ï∞æÎäî Ïï°ÏÖò
          this.time.delayedCall(800, () => {
            this.tweens.add({
              targets: [bubble, dialogueText],
              alpha: 0,
              duration: 200,
              onComplete: () => {
                bubble.destroy();
                dialogueText.destroy();
                this.snakeLookAround();
              }
            });
          });
        }
      },
      loop: true
    });
  }

  snakeLookAround() {
    // Î±ÄÏù¥ Ï¢åÏö∞Î°ú Í≥†Í∞úÎ•º ÎèåÎ¶¨Îäî Ìö®Í≥º
    const head = this.snake[0];
    let lookCount = 0;
    const directions = ['LEFT', 'RIGHT', 'LEFT', 'RIGHT'];

    const lookTimer = this.time.addEvent({
      delay: 400,
      callback: () => {
        if (lookCount < directions.length) {
          // Î®∏Î¶¨ ÏúÑÏπòÏóê ÏãúÏÑ† ÌëúÏãú
          const headX = head.x * this.gridSize + this.gridSize / 2;
          const headY = head.y * this.gridSize + this.gridSize / 2 + 60;
          const dir = directions[lookCount];
          const offsetX = dir === 'LEFT' ? -20 : 20;

          const eye = this.add.text(headX + offsetX, headY - 20, 'üëÄ', {
            fontSize: '16px'
          }).setOrigin(0.5).setDepth(5001).setAlpha(0);

          this.tweens.add({
            targets: eye,
            alpha: 1,
            duration: 100,
            yoyo: true,
            hold: 200,
            onComplete: () => eye.destroy()
          });

          lookCount++;
        } else {
          lookTimer.destroy();
          this.time.delayedCall(500, () => {
            this.showBossAppear();
          });
        }
      },
      loop: true
    });
  }

  showBossAppear() {
    const { width, height } = this.cameras.main;

    const spawn = this.getPoisonFrogSpawnPosition();
    let bossX = spawn.x;
    let bossY = spawn.y;

    this.bossPosition = { x: bossX, y: bossY };

    // ÌôîÎ©¥ ÌîåÎûòÏãú
    const flash = this.add.rectangle(width / 2, height / 2, width, height, 0xff00ff, 0)
      .setDepth(4999);
    this.tweens.add({
      targets: flash,
      fillAlpha: 0.8,
      duration: 100,
      yoyo: true,
      repeat: 2,
      onComplete: () => flash.destroy()
    });

    // Î≥¥Ïä§ Îì±Ïû• Ïô∏Ïπ®
    const bossShout = this.add.text(width / 2, height / 2 - 80, "Hey, you trash snake!", {
      fontSize: '28px',
      fill: '#ff00ff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5001).setAlpha(0).setScale(0.5);

    this.tweens.add({
      targets: bossShout,
      alpha: 1,
      scale: 1.2,
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.cameras.main.shake(200, 0.015);
        this.time.delayedCall(1500, () => {
          this.tweens.add({
            targets: bossShout,
            alpha: 0,
            y: bossShout.y - 30,
            duration: 300,
            onComplete: () => bossShout.destroy()
          });
        });
      }
    });

    // Î≥¥Ïä§ Í∑∏Î¶¨Í∏∞ (Îøî Îã¨Î¶∞ Î≥¥ÎùºÏÉâ Î®πÏù¥)
    this.time.delayedCall(500, () => {
      this.drawBoss(bossX, bossY);

      // Î≥¥Ïä§ ÎåÄÏÇ¨
      this.time.delayedCall(1000, () => {
        this.showBossDialogue("Take my poison!", () => {
          // ÎåÄÏÇ¨ ÌõÑ Î∞îÎ°ú Í≤åÏûÑ Ïû¨Í∞ú
          this.time.delayedCall(500, () => {
            this.bossPhase = 'trap';
            this.moveTimer.paused = false;
            this.bossInputBlocked = false;
          });
        });
      });
    });
  }

  drawBoss(x, y) {
    const bossX = x * this.gridSize + this.gridSize / 2;
    const bossY = y * this.gridSize + this.gridSize / 2 + 60;

    // Î≥¥Ïä§ Ïª®ÌÖåÏù¥ÎÑà
    const bossContainer = this.add.container(bossX, bossY).setDepth(100);

    // Î≥¥Ïä§ Î™∏Ï≤¥ (Î≥¥ÎùºÏÉâ)
    const body = this.add.rectangle(0, 0, this.gridSize - 2, this.gridSize - 2, 0x9900ff);
    bossContainer.add(body);

    // Îøî (4Í∞ú Î™®ÏÑúÎ¶¨Ïóê)
    const hornSize = 4;
    const offset = this.gridSize / 2 - 2;
    const horns = [
      this.add.triangle(-offset, -offset, 0, hornSize, hornSize, hornSize, hornSize / 2, 0, 0xff00ff),
      this.add.triangle(offset, -offset, 0, hornSize, hornSize, hornSize, hornSize / 2, 0, 0xff00ff),
      this.add.triangle(-offset, offset, 0, 0, hornSize, 0, hornSize / 2, hornSize, 0xff00ff),
      this.add.triangle(offset, offset, 0, 0, hornSize, 0, hornSize / 2, hornSize, 0xff00ff)
    ];
    horns.forEach(horn => bossContainer.add(horn));

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    bossContainer.setScale(0).setAlpha(0);
    this.tweens.add({
      targets: bossContainer,
      scale: 1,
      alpha: 1,
      duration: 400,
      ease: 'Back.easeOut'
    });

    // ÌéÑÏä§ Ìö®Í≥º
    this.tweens.add({
      targets: bossContainer,
      scaleX: 1.1,
      scaleY: 1.1,
      duration: 500,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    this.bossElement = bossContainer;

    // Î®πÏù¥Î°ú ÏÑ§Ï†ï
    this.food = { x, y };
  }

  showBossDialogue(text, callback, options = {}) {
    const { width, height } = this.cameras.main;
    const posX = options.x !== undefined ? options.x : width / 2;
    const posY = options.y !== undefined ? options.y : height / 2;
    const depth = options.depth !== undefined ? options.depth : 5002;

    const baseStyle = {
      fontSize: '20px',
      fill: '#ff00ff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    };
    const style = options.style ? { ...baseStyle, ...options.style } : baseStyle;

    const dialogue = this.add.text(posX, posY, '', style)
      .setOrigin(0.5)
      .setDepth(depth);

    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 40,
      callback: () => {
        dialogue.setText(text.substring(0, charIndex + 1));
        charIndex++;
        if (charIndex >= text.length) {
          typeTimer.destroy();
          this.time.delayedCall(1500, () => {
            this.tweens.add({
              targets: dialogue,
              alpha: 0,
              duration: 300,
              onComplete: () => {
                dialogue.destroy();
                if (callback) callback();
              }
            });
          });
        }
      },
      loop: true
    });
  }

  showSnakeStyleDialogue(text, callback, options = {}) {
    const head = this.snake[0];
    const defaultX = head ? head.x * this.gridSize + this.gridSize / 2 : this.cameras.main.width / 2;
    const defaultY = head ? head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY - 50 : this.cameras.main.height / 2;
    const posX = options.x !== undefined ? options.x : defaultX;
    const posY = options.y !== undefined ? options.y : defaultY;
    const depth = options.depth !== undefined ? options.depth : 1300;
    const fontSize = options.fontSize || '12px';

    const bubbleWidth = 260;
    const bubble = this.add.rectangle(posX, posY, bubbleWidth, 52, 0xffffff, 0.95)
      .setDepth(depth)
      .setScale(0)
      .setStrokeStyle(2, 0x000000);

    this.tweens.add({
      targets: bubble,
      scale: 1,
      duration: 200,
      ease: 'Back.easeOut'
    });

    const dialogueText = this.add.text(posX, posY, '', {
      fontSize,
      fill: '#000000',
      fontStyle: 'bold',
      wordWrap: { width: bubbleWidth - 16 }
    }).setOrigin(0.5).setDepth(depth + 1);

    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 45,
      callback: () => {
        dialogueText.setText(text.substring(0, charIndex + 1));
        charIndex++;
        if (charIndex >= text.length) {
          typeTimer.destroy();
          this.time.delayedCall(1100, () => {
            this.tweens.add({
              targets: [bubble, dialogueText],
              alpha: 0,
              duration: 200,
              onComplete: () => {
                bubble.destroy();
                dialogueText.destroy();
                if (callback) callback();
              }
            });
          });
        }
      },
      loop: true
    });
  }

  bossPreBattleCountdown() {
    const { width, height } = this.cameras.main;

    const countdownText = this.add.text(width / 2, height / 2, '', {
      fontSize: '72px',
      fill: '#ff00ff',
      fontStyle: 'bold',
      stroke: '#660066',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000);

    let count = 3;
    const countdownTimer = this.time.addEvent({
      delay: 700,
      callback: () => {
        if (count > 0) {
          countdownText.setText(count.toString());
          countdownText.setScale(1.5);
          this.tweens.add({
            targets: countdownText,
            scale: 1,
            duration: 200,
            ease: 'Back.easeOut'
          });
          count--;
        } else {
          countdownText.destroy();
          this.moveTimer.paused = false;
          this.bossInputBlocked = false; // ÏûÖÎ†• Ï∞®Îã® Ìï¥Ï†ú
        }
      },
      repeat: 3
    });
  }

  handleBossTrap() {
    const { width, height } = this.cameras.main;

    // Î®πÏù¥ Ï¶âÏãú Ï†úÍ±∞ (ÌôîÎ©¥ÏóêÏÑú ÏôÑÏ†ÑÌûà Ïà®ÍπÄ)
    this.food = { x: -100, y: -100 };
    if (this.bossElement) {
      this.bossElement.destroy();
      this.bossElement = null;
    }

    // Î≥¥Ïä§ ÎåÄÏÇ¨
    const trapText = this.add.text(width / 2, height / 2 - 100, "Good luck!", {
      fontSize: '32px',
      fill: '#ff00ff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5001).setAlpha(0);

    this.tweens.add({
      targets: trapText,
      alpha: 1,
      scale: { from: 0.5, to: 1.2 },
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.time.delayedCall(1000, () => {
          this.tweens.add({
            targets: trapText,
            alpha: 0,
            duration: 300,
            onComplete: () => trapText.destroy()
          });
        });
      }
    });

    // 3ÌÉÑ Î≥¥Ïä§ BGMÏúºÎ°ú Î≥ÄÍ≤Ω
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.bgMusic.stop();
    }
    if (this.boss3Music) {
      this.boss3Music.play();
    }

    // ÎèÖ Ìö®Í≥º ÏãúÏûë
    this.bossPhase = 'poisoned';
    this.applyPoison();
  }

  applyPoison() {
    const { width, height } = this.cameras.main;

    // Î±Ä ÏÉâÏÉÅÏùÑ Ï†êÏ†ê Î≥¥ÎùºÏÉâÏúºÎ°ú
    let blinkCount = 0;
    const blinkTimer = this.time.addEvent({
      delay: 200,
      callback: () => {
        blinkCount++;
        // ÍπúÎπ°ÏûÑ Ìö®Í≥º
        this.snakePoisoned = blinkCount % 2 === 0;
        this.draw();

        if (blinkCount >= 10) {
          blinkTimer.destroy();
          this.snakePoisoned = true;
          this.draw();

          // Î≥¥Ïä§ ÎåÄÏÇ¨: "Gotcha!"
          const gotchaText = this.add.text(width / 2, height / 2 - 80, "Gotcha!", {
            fontSize: '36px',
            fill: '#ff00ff',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 4
          }).setOrigin(0.5).setDepth(5001).setAlpha(0);

          this.tweens.add({
            targets: gotchaText,
            alpha: 1,
            scale: { from: 0.5, to: 1.3 },
            duration: 300,
            ease: 'Back.easeOut',
            onComplete: () => {
              this.time.delayedCall(800, () => {
                this.tweens.add({
                  targets: gotchaText,
                  alpha: 0,
                  duration: 200,
                  onComplete: () => gotchaText.destroy()
                });
              });
            }
          });

          // ÏÑ±Ïû• ÏãúÏûë
          this.startPoisonGrowth();
        }
      },
      loop: true
    });
  }

  startPoisonGrowth() {
    // Îß§ Ïù¥ÎèôÎßàÎã§ 1Ïπ∏ ÏÑ±Ïû• + ÏÜçÎèÑ Ï¶ùÍ∞Ä
    this.poisonGrowthActive = true;
    this.poisonGrowthCount = 0;
    this.originalSpeed = this.moveTimer.delay;

    // Î™©Ìëú: 20Ïπ∏, 40ms
    const targetLength = this.poisonGrowthTarget;
    const targetSpeed = this.poisonSpeedTarget;
    const currentLength = this.snake.length;
    const growthNeeded = targetLength - currentLength;
    const speedDecrease = (this.originalSpeed - targetSpeed) / growthNeeded;

    this.poisonGrowthData = {
      targetLength,
      targetSpeed,
      growthNeeded,
      speedDecrease,
      currentGrowth: 0
    };
  }

  handlePoisonGrowth() {
    if (!this.poisonGrowthActive || !this.poisonGrowthData) return false;

    const data = this.poisonGrowthData;
    if (data.currentGrowth < data.growthNeeded) {
      // Î±Ä ÏÑ±Ïû•
      const tail = this.snake[this.snake.length - 1];
      this.snake.push({ x: tail.x, y: tail.y });

      // ÏÜçÎèÑ Ï¶ùÍ∞Ä
      this.moveTimer.delay = Math.max(data.targetSpeed, this.moveTimer.delay - data.speedDecrease);

      data.currentGrowth++;

      // ÏÑ±Ïû• ÏôÑÎ£å Ï≤¥ÌÅ¨
      if (data.currentGrowth >= data.growthNeeded) {
        this.poisonGrowthActive = false;
        // Î≥¥Ïä§Ï†Ñ Î≥∏Í≤© ÏãúÏûë
        this.time.delayedCall(500, () => {
          this.startBossBattle();
        });
      }
      return true; // ÏÑ±Ïû•Ìï®
    }
    return false;
  }

  startBossBattle() {
    if (this.gameOver || this.isReviving) return;
    if (!this.bossMode || this.bossPhase !== 'poisoned') return;

    const { width, height } = this.cameras.main;
    this.bossPhase = 'battle';
    this.bossHitCount = 0;

    // Î≥¥Ïä§Í∞Ä ÎÇòÌÉÄÎÇ† ÏΩîÎÑà ÏúÑÏπò (Î™®ÏÑúÎ¶¨ 4Í∞ú)
    this.bossCorners = [
      { x: 0, y: 0 },                           // Ï¢åÏÉÅ Î™®ÏÑúÎ¶¨
      { x: this.cols - 1, y: 0 },               // Ïö∞ÏÉÅ Î™®ÏÑúÎ¶¨
      { x: 0, y: this.rows - 1 },               // Ï¢åÌïò Î™®ÏÑúÎ¶¨
      { x: this.cols - 1, y: this.rows - 1 }    // Ïö∞Ìïò Î™®ÏÑúÎ¶¨
    ];

    // Î∞∞ÌãÄ ÏãúÏûë Î©îÏãúÏßÄ
    const battleText = this.add.text(width / 2, height / 2, "BATTLE START!", {
      fontSize: '48px',
      fill: '#ff00ff',
      fontStyle: 'bold',
      stroke: '#660066',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5001).setAlpha(0);

    this.tweens.add({
      targets: battleText,
      alpha: 1,
      scale: { from: 0.5, to: 1.2 },
      duration: 400,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.cameras.main.shake(300, 0.01);
        this.time.delayedCall(1000, () => {
          this.tweens.add({
            targets: battleText,
            alpha: 0,
            duration: 300,
            onComplete: () => {
              battleText.destroy();
              this.spawnBossAtCorner();
            }
          });
        });
      }
    });
  }

  spawnBossAtCorner() {
    if (this.gameOver || this.isReviving) return;
    if (!this.bossMode || this.bossPhase !== 'battle') return;
    if (this.bossHitCount >= 4) return;

    // ÏΩîÎÑàÏóêÏÑú ÎûúÎç§ ÏÑ†ÌÉù (ÏàúÏÑúÎåÄÎ°ú)
    let corner = { ...this.bossCorners[this.bossHitCount] };

    // Îç∞ÎìúÏ°¥Í≥º Í≤πÏπòÎ©¥ ÏòÜÏúºÎ°ú Ïù¥Îèô
    const isOnDeadZone = this.deadZones.some(dz => dz.x === corner.x && dz.y === corner.y);
    if (isOnDeadZone) {
      // Ïù∏Ï†ëÌïú ÏúÑÏπò Ï∞æÍ∏∞ (ÏÉÅÌïòÏ¢åÏö∞)
      const offsets = [
        { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 },
        { x: 1, y: 1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }
      ];
      for (const offset of offsets) {
        const newX = corner.x + offset.x;
        const newY = corner.y + offset.y;
        // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Îç∞ÎìúÏ°¥ Ï≤¥ÌÅ¨
        if (newX >= 0 && newX < this.cols && newY >= 0 && newY < this.rows) {
          const alsoOnDeadZone = this.deadZones.some(dz => dz.x === newX && dz.y === newY);
          if (!alsoOnDeadZone) {
            corner = { x: newX, y: newY };
            break;
          }
        }
      }
    }

    this.bossPosition = corner;

    // Î≥¥Ïä§ Í∑∏Î¶¨Í∏∞
    this.drawBoss(corner.x, corner.y);
  }

  handleBossHit() {
    const { width, height } = this.cameras.main;
    this.bossHitCount++;

    // Î≥¥Ïä§ ÌîºÍ≤© Ìö®Í≥º
    if (this.bossElement) {
      this.tweens.add({
        targets: this.bossElement,
        alpha: 0,
        scale: 1.5,
        duration: 200,
        onComplete: () => {
          if (this.bossElement) {
            this.bossElement.destroy();
            this.bossElement = null;
          }
        }
      });
    }

    // ÌûàÌä∏ Ïπ¥Ïö¥Ìä∏ ÌëúÏãú
    // Í∏∞Ï°¥ hitText Ï†úÍ±∞
    if (this.bossHitText) {
      this.tweens.killTweensOf(this.bossHitText);
      this.bossHitText.destroy();
      this.bossHitText = null;
    }

    this.bossHitText = this.add.text(width / 2, height / 2 - 100, `HIT ${this.bossHitCount}/4`, {
      fontSize: '36px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5001).setAlpha(0);

    this.tweens.add({
      targets: this.bossHitText,
      alpha: 1,
      scale: { from: 0.5, to: 1.2 },
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.time.delayedCall(500, () => {
          if (this.bossHitText) {
            this.tweens.add({
              targets: this.bossHitText,
              alpha: 0,
              duration: 200,
              onComplete: () => {
                if (this.bossHitText) {
                  this.bossHitText.destroy();
                  this.bossHitText = null;
                }
              }
            });
          }
        });
      }
    });

    // ÎßàÏßÄÎßâ ÌûàÌä∏Î©¥ ÏäπÎ¶¨
    if (this.bossHitCount >= 4) {
      this.showBossVictory();
    } else {
      // Îã§Ïùå Î≥¥Ïä§ ÏÉùÏÑ±
      this.time.delayedCall(800, () => {
        this.spawnBossAtCorner();
      });
    }
  }

  handleBossFinalHit() {
    // Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ: Ï¶âÏãú phase Î≥ÄÍ≤Ω
    if (this.bossPhase === 'final') return;
    this.bossPhase = 'final';
    this.bossHitCount = 4;

    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // Ïö∏Ìä∏Îùº Ïä¨Î°úÏö∞Î™®ÏÖò + Ï§å
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + 60;

    // ÌôîÎ©¥ Ïä¨Î°úÏö∞ Î™®ÏÖò Ìö®Í≥º
    this.time.timeScale = 0.3;

    // Ïπ¥Î©îÎùºÎ•º Î±Ä Î®∏Î¶¨ ÏúÑÏπòÎ°ú Ïù¥Îèô ÌõÑ Ï§å Ïù∏
    this.cameras.main.pan(headX, headY, 300, 'Power2', false, (camera, progress) => {
      if (progress === 1) {
        this.cameras.main.zoomTo(2, 500, 'Power2', false, (cam, zoomProgress) => {
          if (zoomProgress === 1) {
            // Ï∂©Îèå!
            this.cameras.main.shake(500, 0.03);

            // Î≥¥Ïä§ ÎπÑÎ™Ö
            const scream = this.add.text(headX, headY - 50, "AAARGH! RIBBIT!", {
              fontSize: '24px',
              fill: '#ff0000',
              fontStyle: 'bold',
              stroke: '#000000',
              strokeThickness: 3
            }).setOrigin(0.5).setDepth(5002).setAlpha(0);

            this.tweens.add({
              targets: scream,
              alpha: 1,
              y: headY - 80,
              scale: { from: 0.5, to: 1.5 },
              duration: 500,
              onComplete: () => {
                this.time.delayedCall(800, () => {
                  this.tweens.add({
                    targets: scream,
                    alpha: 0,
                    duration: 300,
                    onComplete: () => scream.destroy()
                  });
                });
              }
            });

            // Î≥¥Ïä§ Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
            if (this.bossElement) {
              for (let i = 0; i < 20; i++) {
                const particle = this.add.rectangle(
                  this.bossElement.x,
                  this.bossElement.y,
                  4, 4, 0xff00ff
                ).setDepth(5001);

                const angle = (i / 20) * Math.PI * 2;
                this.tweens.add({
                  targets: particle,
                  x: this.bossElement.x + Math.cos(angle) * 100,
                  y: this.bossElement.y + Math.sin(angle) * 100,
                  alpha: 0,
                  duration: 800,
                  onComplete: () => particle.destroy()
                });
              }

              this.bossElement.destroy();
              this.bossElement = null;
            }

            // Ï§å ÏïÑÏõÉ Î∞è Ï†ïÏÉÅ ÏÜçÎèÑ Î≥µÏõê
            this.time.delayedCall(1000, () => {
              this.time.timeScale = 1;
              // Ïπ¥Î©îÎùº ÏúÑÏπò Ï¥àÍ∏∞Ìôî ÌõÑ Ï§å ÏïÑÏõÉ
              const { width, height } = this.cameras.main;
              this.cameras.main.pan(width / 2, height / 2, 300, 'Power2');
              this.cameras.main.zoomTo(1, 500, 'Power2', false, () => {
                this.showBossVictory();
              });
            });
          }
        });
      }
    });
  }

  showBossVictory() {
    const { width, height } = this.cameras.main;
    this.bossPhase = 'victory';

    // Î≥¥ÎÑàÏä§ Ï†êÏàò Ï∂îÍ∞Ä (Î≥¥Ïä§Ï†ÑÏùÄ 1000Ï†ê Î≥¥ÎÑàÏä§Îßå)
    this.score = 1000;
    this.scoreText.setText(this.score.toString());

    // Î≥¥Ïä§ ÌÅ¥Î¶¨Ïñ¥ ÌÖçÏä§Ìä∏
    const clearText = this.add.text(width / 2, height / 2 - 50, 'BOSS CLEAR!', {
      fontSize: '64px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff6600',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(5001).setAlpha(0).setScale(0.5);

    this.tweens.add({
      targets: clearText,
      alpha: 1,
      scale: 1.2,
      duration: 500,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÌôîÎ©¥ ÌîåÎûòÏãú
        const flash = this.add.rectangle(width / 2, height / 2, width, height, 0xffff00, 0.5)
          .setDepth(5000);
        this.tweens.add({
          targets: flash,
          alpha: 0,
          duration: 500,
          onComplete: () => flash.destroy()
        });

        // ÌôîÎ©¥ ÌùîÎì§Î¶º
        this.cameras.main.shake(500, 0.02);

        // Î≥¥ÎÑàÏä§ Ï†êÏàò ÌëúÏãú
        const bonusText = this.add.text(width / 2, height / 2 + 30, '+1000 BONUS!', {
          fontSize: '32px',
          fill: '#00ff00',
          fontStyle: 'bold',
          stroke: '#008800',
          strokeThickness: 4
        }).setOrigin(0.5).setDepth(5001).setAlpha(0);

        this.tweens.add({
          targets: bonusText,
          alpha: 1,
          y: height / 2 + 10,
          duration: 300,
          delay: 500
        });

        // ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú
        for (let i = 0; i < 30; i++) {
          const colors = [0xffff00, 0xff00ff, 0x00ffff, 0xff0000, 0x00ff00];
          const particle = this.add.rectangle(
            width / 2, height / 2, 8, 8,
            colors[Math.floor(Math.random() * colors.length)]
          ).setDepth(5001);

          const angle = (i / 30) * Math.PI * 2;
          const distance = 150 + Math.random() * 100;
          this.tweens.add({
            targets: particle,
            x: width / 2 + Math.cos(angle) * distance,
            y: height / 2 + Math.sin(angle) * distance,
            alpha: 0,
            rotation: Math.random() * 10,
            duration: 1000,
            onComplete: () => particle.destroy()
          });
        }

        // Î≥¥Ïä§ Î™®Îìú Ï¢ÖÎ£å Î∞è ÏÉÅÏ†ê Ïó¥Í∏∞
        this.time.delayedCall(2000, () => {
          this.tweens.add({
            targets: [clearText, bonusText],
            alpha: 0,
            duration: 300,
            onComplete: () => {
              clearText.destroy();
              bonusText.destroy();

              // Î≥¥Ïä§ Î™®Îìú Ï¢ÖÎ£å
              this.snakePoisoned = false;
              this.bossMode = false;
              this.bossPhase = 'none';

              // 3ÌÉÑ Î≥¥Ïä§ BGM Ï†ïÏßÄ ÌõÑ Í∏∞Î≥∏ BGMÏúºÎ°ú ÏõêÎ≥µ
              if (this.boss3Music && this.boss3Music.isPlaying) {
                this.boss3Music.stop();
              }
              if (this.bgMusic && !this.bgMusic.isPlaying) {
                this.bgMusic.play();
              }

              // Í∏∞Ï°¥ Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ ÌîåÎ°úÏö∞ (ÏÉÅÏ†ê Ïó¥Í∏∞)
              if (this.currentStage >= 3) {
                this.openShop();
              } else {
                this.showStageClearText();
              }
            }
          });
        });
      }
    });
  }

  snakeJumpAnimation(callback) {
    // Î±ÄÏù¥ Îßµ Î∞ñÏúºÎ°ú ÎÇ†ÏïÑÍ∞ÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
    const { width, height } = this.cameras.main;

    // Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏Î•º ÏúÑÎ°ú ÎÇ†Î¶º
    this.snake.forEach((segment, i) => {
      const segX = segment.x * this.gridSize + this.gridSize / 2;
      const segY = segment.y * this.gridSize + this.gridSize / 2 + 60;

      const jumpRect = this.add.rectangle(segX, segY, this.gridSize - 2, this.gridSize - 2,
        i === 0 ? (this.comboShieldCount > 0 ? 0xffff00 : 0x00ff00) : 0x00cc00
      ).setDepth(5001);

      this.tweens.add({
        targets: jumpRect,
        y: -50,
        x: segX + (Math.random() - 0.5) * 100,
        rotation: Math.random() * 5,
        delay: i * 30,
        duration: 500,
        ease: 'Power2.easeIn',
        onComplete: () => jumpRect.destroy()
      });
    });

    this.time.delayedCall(800, callback);
  }

  // =====================
  // ÌôïÏÇ∞Ìòï ÎèÖÍ∞ÄÏä§ ÏãúÏä§ÌÖú
  // =====================

  startGasZone() {
    if (this.gasZoneEnabled) return;

    this.gasZoneEnabled = true;

    // Ïõê Ï§ëÏã¨ Í≥ÑÏÇ∞ (Îßµ Ï§ëÏïô)
    this.gasZoneCenterX = this.cols / 2;
    this.gasZoneCenterY = this.rows / 2;

    // Ï¥àÍ∏∞ Î∞òÍ≤Ω: Îßµ Î™®ÏÑúÎ¶¨ÍπåÏßÄÏùò Í±∞Î¶¨ (Ï†ÑÏ≤¥ Îßµ Ïª§Î≤Ñ)
    this.gasZoneRadius = Math.sqrt(
      Math.pow(this.cols / 2, 2) + Math.pow(this.rows / 2, 2)
    ) + 1;

    // ÎèÖÍ∞ÄÏä§ ÌôïÏû• ÌÉÄÏù¥Î®∏ ÏãúÏûë
    this.gasZoneTimer = this.time.addEvent({
      delay: this.gasZoneExpandInterval,
      callback: this.expandGasZone,
      callbackScope: this,
      loop: true
    });

    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏Ïö© ÌÉÄÏù¥Î®∏ (60fps)
    this.gasZoneAnimTimer = this.time.addEvent({
      delay: 16, // ~60fps
      callback: this.updateGasZoneAnimation,
      callbackScope: this,
      loop: true
    });

    // Ï¥àÍ∏∞ Î†åÎçîÎßÅ
    this.renderGasZone();
  }

  stopGasZone() {
    this.gasZoneEnabled = false;
    this.gasZoneRadius = 0;

    if (this.gasZoneTimer) {
      this.gasZoneTimer.destroy();
      this.gasZoneTimer = null;
    }

    if (this.gasZoneAnimTimer) {
      this.gasZoneAnimTimer.destroy();
      this.gasZoneAnimTimer = null;
    }

    // ÌååÌã∞ÌÅ¥ Ï†ïÎ¶¨
    this.gasZoneParticles.forEach(p => {
      if (p && p.destroy) p.destroy();
    });
    this.gasZoneParticles = [];

    // Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨
    if (this.gasZoneGraphics) {
      this.gasZoneGraphics.clear();
    }
  }

  expandGasZone() {
    if (!this.gasZoneEnabled) return;
    if (this.gasZoneRadius <= this.gasZoneMinRadius) return;

    // Î®ºÏ†Ä Í≤ΩÍ≥† ÌëúÏãú ÌõÑ ÌôïÏû•
    this.showGasZonePreWarning(() => {
      // Î∞òÍ≤Ω Í∞êÏÜå (1.5 ÌÉÄÏùºÏî©)
      this.gasZoneRadius = Math.max(this.gasZoneMinRadius, this.gasZoneRadius - 1.5);

      // ÌôïÏû• Ïãú EMP ÌéÑÏä§ Ìö®Í≥º
      this.showGasZoneExpandEffect();

      // Î†åÎçîÎßÅ ÏóÖÎç∞Ïù¥Ìä∏
      this.renderGasZone();

      // Î®πÏù¥Í∞Ä ÎèÖÍ∞ÄÏä§ ÏòÅÏó≠Ïóê Îì§Ïñ¥Í∞îÎäîÏßÄ Ï≤¥ÌÅ¨ - ÏïàÏ†Ñ ÏòÅÏó≠Ïóê Ïû¨ÏÉùÏÑ± (Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä ÏóÜÏùå)
      if (this.food && this.isInGasZone(this.food.x, this.food.y)) {
        // Í∏∞Ï°¥ ÎßêÌíçÏÑ† Ï†úÍ±∞
        if (this.foodBubble) {
          if (this.foodBubble.image) this.foodBubble.image.destroy();
          if (this.foodBubble.text) this.foodBubble.text.destroy();
          this.foodBubble = null;
        }
        this.food = this.generateFood();
      }

      // NEXUS ÏΩîÎìúÍ∞Ä ÎèÖÍ∞ÄÏä§Ïóê Ïû†Í∏∞Î©¥ ÎÇ®ÏùÄ ÏΩîÎìú Ï†ÑÏ≤¥ Ïû¨Ïä§Ìè∞
      if (this.nexusMode && this.nexusBinaryNodes && this.nexusBinaryNodes.length > 0) {
        const hasUnsafeNode = this.nexusBinaryNodes.some(node => !node.collected && this.isInGasZone(node.x, node.y));
        if (hasUnsafeNode) {
          this.respawnRemainingBinaryNodes();
        }
      }

      // Í≤ΩÍ≥† ÌëúÏãú
      if (this.gasZoneRadius <= this.gasZoneMinRadius + 3) {
        this.showGasZoneWarning('DANGER! GAS CLOSING IN!');
      }
    });
  }

  showGasZonePreWarning(callback) {
    const gs = this.gridSize;
    const nextRadius = this.gasZoneRadius - 1.5;
    const centerX = this.gasZoneCenterX;
    const centerY = this.gasZoneCenterY;

    // Í≤ΩÍ≥† Í∑∏ÎûòÌîΩ ÏÉùÏÑ±
    const warningGraphics = this.add.graphics();
    warningGraphics.setDepth(55);

    // Í∏¥Î∞ïÌïú ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    let blinkCount = 0;
    const maxBlinks = 6;
    const blinkInterval = 80;

    const blinkTimer = this.time.addEvent({
      delay: blinkInterval,
      callback: () => {
        warningGraphics.clear();

        if (blinkCount % 2 === 0) {
          // Í≤ΩÍ≥† ÏÉâÏÉÅ (Îπ®Í∞ÑÏÉâ/ÎÖ∏ÎûÄÏÉâ ÍµêÏ∞®)
          const color = blinkCount % 4 === 0 ? 0xff0000 : 0xffff00;

          // Îã§ÏùåÏóê ÎèÖÍ∞ÄÏä§Í∞Ä Îê† ÏòÅÏó≠ (ÌòÑÏû¨ Î∞òÍ≤ΩÍ≥º Îã§Ïùå Î∞òÍ≤Ω ÏÇ¨Ïù¥Ïùò ÎßÅ)
          for (let x = 0; x < this.cols; x++) {
            for (let y = 0; y < this.rows; y++) {
              const dist = Math.sqrt(
                Math.pow(x + 0.5 - centerX, 2) + Math.pow(y + 0.5 - centerY, 2)
              );
              // Îã§Ïùå Î∞òÍ≤ΩÍ≥º ÌòÑÏû¨ Î∞òÍ≤Ω ÏÇ¨Ïù¥Ïùò ÌÉÄÏùºÎßå
              if (dist > nextRadius && dist <= this.gasZoneRadius) {
                warningGraphics.fillStyle(color, 0.7);
                warningGraphics.fillRect(
                  x * gs,
                  y * gs + this.gameAreaY,
                  gs,
                  gs
                );
              }
            }
          }

          // ÏõêÌòï Í≤ΩÍ≥ÑÏÑ† Í∞ïÏ°∞
          const pixelCenterX = centerX * gs;
          const pixelCenterY = centerY * gs + this.gameAreaY;
          warningGraphics.lineStyle(3, 0xffffff, 0.9);
          warningGraphics.strokeCircle(pixelCenterX, pixelCenterY, nextRadius * gs);
        }

        blinkCount++;

        if (blinkCount >= maxBlinks) {
          blinkTimer.destroy();
          warningGraphics.destroy();
          callback();
        }
      },
      callbackScope: this,
      loop: true
    });

    // ÏõêÌòï Í∏ÄÎ°úÏö∞ Ìö®Í≥º
    const pixelCenterX = centerX * gs;
    const pixelCenterY = centerY * gs + this.gameAreaY;
    const glowCircle = this.add.graphics();
    glowCircle.setDepth(54);
    glowCircle.lineStyle(6, 0xff0000, 0.8);
    glowCircle.strokeCircle(pixelCenterX, pixelCenterY, this.gasZoneRadius * gs);

    this.tweens.add({
      targets: glowCircle,
      alpha: { from: 0.8, to: 0 },
      duration: maxBlinks * blinkInterval,
      ease: 'Power2.easeIn',
      onComplete: () => glowCircle.destroy()
    });
  }

  isInGasZone(x, y) {
    if (!this.gasZoneEnabled) return false;

    // ÌÉÄÏùº Ï§ëÏã¨ÏóêÏÑú Ïõê Ï§ëÏã¨ÍπåÏßÄÏùò Í±∞Î¶¨ Í≥ÑÏÇ∞
    const dist = Math.sqrt(
      Math.pow(x + 0.5 - this.gasZoneCenterX, 2) +
      Math.pow(y + 0.5 - this.gasZoneCenterY, 2)
    );

    // Î∞òÍ≤Ω Î∞ñÏù¥Î©¥ ÎèÖÍ∞ÄÏä§ ÏòÅÏó≠
    return dist > this.gasZoneRadius;
  }

  renderGasZone() {
    if (!this.gasZoneGraphics) return;
    this.gasZoneGraphics.clear();

    if (!this.gasZoneEnabled) return;

    const radius = this.gasZoneRadius;
    const time = this.gasZonePulseTime;
    const gs = this.gridSize;
    const centerX = this.gasZoneCenterX;
    const centerY = this.gasZoneCenterY;

    // ÌéÑÏä§ Ìö®Í≥ºÎ•º ÏúÑÌïú ÏïåÌååÍ∞í Î≥ÄÎèô
    const pulseAlpha = 0.6 + Math.sin(time * 0.005) * 0.15;

    // EMP ÏÉâÏÉÅ (ÏãúÍ∞ÑÏóê Îî∞Îùº Î≥ÄÌôî)
    const colorPhase = (time * 0.003) % (Math.PI * 2);
    const r = Math.floor(80 + Math.sin(colorPhase) * 40);
    const g = Math.floor(20 + Math.sin(colorPhase + 2) * 20);
    const b = Math.floor(180 + Math.sin(colorPhase + 4) * 60);
    const baseColor = (r << 16) | (g << 8) | b;

    // ÏõêÌòï ÎèÖÍ∞ÄÏä§ ÏòÅÏó≠ Í∑∏Î¶¨Í∏∞ (Î∞òÍ≤Ω Î∞ñÏùò ÌÉÄÏùºÎì§)
    for (let x = 0; x < this.cols; x++) {
      for (let y = 0; y < this.rows; y++) {
        const dist = Math.sqrt(
          Math.pow(x + 0.5 - centerX, 2) + Math.pow(y + 0.5 - centerY, 2)
        );

        if (dist > radius) {
          // Í±∞Î¶¨Ïóê Îî∞Î•∏ ÏïåÌååÍ∞í (Í≤ΩÍ≥ÑÏóêÏÑú Î©ÄÏàòÎ°ù ÏßÑÌï®)
          const distFromEdge = dist - radius;
          const distAlpha = Math.min(1, distFromEdge / 3) * pulseAlpha;

          this.gasZoneGraphics.fillStyle(baseColor, distAlpha);
          this.gasZoneGraphics.fillRect(
            x * gs,
            y * gs + this.gameAreaY,
            gs,
            gs
          );
        }
      }
    }

    // ÏõêÌòï Í≤ΩÍ≥ÑÏÑ† Í∞ïÏ°∞
    const pixelCenterX = centerX * gs;
    const pixelCenterY = centerY * gs + this.gameAreaY;
    const edgeAlpha = 0.8 + Math.sin(time * 0.01) * 0.2;

    this.gasZoneGraphics.lineStyle(3, 0x00ffff, edgeAlpha);
    this.gasZoneGraphics.strokeCircle(pixelCenterX, pixelCenterY, radius * gs);

    // ÎÇ¥Î∂Ä Í∏ÄÎ°úÏö∞ Ìö®Í≥º (Îëê Î≤àÏß∏ Í≤ΩÍ≥ÑÏÑ†)
    const innerGlow = 0.4 + Math.sin(time * 0.008) * 0.2;
    this.gasZoneGraphics.lineStyle(1, 0xff00ff, innerGlow);
    this.gasZoneGraphics.strokeCircle(pixelCenterX, pixelCenterY, (radius + 0.5) * gs);

    // Ï†ÑÍ∏∞ Ïä§ÌååÌÅ¨ Ìö®Í≥º (ÏõêÌòï Í≤ΩÍ≥ÑÏÑ†ÏóêÏÑú)
    this.renderGasZoneSparks(radius, time);
  }

  renderGasZoneSparks(radius, time) {
    if (radius <= 0) return;

    const gs = this.gridSize;
    const centerX = this.gasZoneCenterX;
    const centerY = this.gasZoneCenterY;
    const pixelCenterX = centerX * gs;
    const pixelCenterY = centerY * gs + this.gameAreaY;

    const sparkCount = 12;
    for (let i = 0; i < sparkCount; i++) {
      const sparkPhase = (time * 0.008 + i * (Math.PI * 2 / sparkCount)) % (Math.PI * 2);
      const sparkIntensity = Math.pow(Math.sin(sparkPhase), 4);

      if (sparkIntensity > 0.3) {
        // ÏõêÌòï Í≤ΩÍ≥ÑÏÑ† ÏúÑÏùò ÏúÑÏπò (Í∞ÅÎèÑ Í∏∞Î∞ò)
        const angle = (time * 0.002 + i * (Math.PI * 2 / sparkCount)) % (Math.PI * 2);
        const px = pixelCenterX + Math.cos(angle) * radius * gs;
        const py = pixelCenterY + Math.sin(angle) * radius * gs;

        // Ïä§ÌååÌÅ¨ Í∏ÄÎ°úÏö∞
        this.gasZoneGraphics.fillStyle(0x00ffff, sparkIntensity * 0.8);
        this.gasZoneGraphics.fillCircle(px, py, 6 + sparkIntensity * 4);

        // Ïä§ÌååÌÅ¨ ÏΩîÏñ¥
        this.gasZoneGraphics.fillStyle(0xffffff, sparkIntensity);
        this.gasZoneGraphics.fillCircle(px, py, 2 + sparkIntensity * 2);
      }
    }
  }

  updateGasZoneAnimation() {
    if (!this.gasZoneEnabled) return;
    this.gasZonePulseTime += 16;
    this.renderGasZone();
  }

  showGasZoneExpandEffect() {
    const { width, height } = this.cameras.main;
    const gs = this.gridSize;

    // ÌôîÎ©¥ Ï†ÑÏ≤¥ EMP ÌîåÎûòÏãú
    const flash = this.add.rectangle(
      width / 2, height / 2, width, height,
      0x00ffff, 0.4
    ).setDepth(5500);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 300,
      ease: 'Power2.easeOut',
      onComplete: () => flash.destroy()
    });

    // ÏõêÌòï ÏàòÏ∂ï ÎßÅ Ìö®Í≥º
    const centerX = this.gasZoneCenterX * gs;
    const centerY = this.gasZoneCenterY * gs + this.gameAreaY;

    const ring = this.add.graphics();
    ring.setDepth(5501);

    const startRadius = (this.gasZoneRadius + 1.5) * gs;
    const targetRadius = this.gasZoneRadius * gs;

    this.tweens.add({
      targets: { radius: startRadius },
      radius: targetRadius,
      duration: 400,
      ease: 'Power2.easeIn',
      onUpdate: (tween) => {
        const r = tween.targets[0].radius;
        ring.clear();
        ring.lineStyle(4, 0xff00ff, 0.8 * (1 - tween.progress));
        ring.strokeCircle(centerX, centerY, r);
      },
      onComplete: () => ring.destroy()
    });

    // Ï†ÑÍ∏∞ ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú (ÏõêÌòïÏúºÎ°ú ÏïàÏ™ΩÏúºÎ°ú)
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      const dist = this.gasZoneRadius * gs + 20;

      const particle = this.add.circle(
        centerX + Math.cos(angle) * dist,
        centerY + Math.sin(angle) * dist,
        3 + Math.random() * 3,
        0x00ffff
      ).setDepth(5502).setAlpha(0.9);

      this.tweens.add({
        targets: particle,
        x: centerX + Math.cos(angle) * (dist - 60),
        y: centerY + Math.sin(angle) * (dist - 60),
        alpha: 0,
        scale: 0,
        duration: 400,
        ease: 'Power2.easeIn',
        onComplete: () => particle.destroy()
      });
    }
  }

  showGasZoneWarning(message) {
    const { width, height } = this.cameras.main;

    const warningText = this.add.text(width / 2, height / 2, message, {
      fontSize: '24px',
      fontStyle: 'bold',
      fill: '#ff0000',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(6000).setAlpha(0);

    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scale: { from: 0.5, to: 1.2 },
      duration: 300,
      ease: 'Back.easeOut',
      yoyo: true,
      hold: 1000,
      onComplete: () => warningText.destroy()
    });
  }

  // =====================================================
  // ===== POLARITY SYSTEM (Stage 14: Flux Maze) =====
  // =====================================================

  startPolaritySystem() {
    if (this.polarityEnabled) return;

    this.polarityEnabled = true;
    this.currentPolarity = Phaser.Math.RND.pick(['N', 'S']);

    // Î±Ä Î®∏Î¶¨ ÏúÑ Í∑πÏÑ± ÎßàÏª§ ÏÉùÏÑ±
    this.createPolarityMarker();

    // ÌôîÎ©¥ UI ÏÉùÏÑ±
    this.createPolarityUI();

    // Í∑πÏÑ± Î≥ÄÍ≤Ω ÌÉÄÏù¥Î®∏ ÏãúÏûë
    this.polarityTimer = this.time.addEvent({
      delay: this.polarityChangeInterval,
      callback: this.changePolarity,
      callbackScope: this,
      loop: true
    });

    // Í≤ΩÍ≥† ÌÉÄÏù¥Î®∏ (Î≥ÄÍ≤Ω 2Ï¥à Ï†Ñ)
    this.polarityWarningTimer = this.time.addEvent({
      delay: this.polarityChangeInterval - this.polarityChangeWarningTime,
      callback: this.showPolarityChangeWarning,
      callbackScope: this,
      loop: true
    });

    console.log('[Polarity] System started with polarity:', this.currentPolarity);
  }

  stopPolaritySystem() {
    this.polarityEnabled = false;

    if (this.polarityTimer) {
      this.polarityTimer.destroy();
      this.polarityTimer = null;
    }

    if (this.polarityWarningTimer) {
      this.polarityWarningTimer.destroy();
      this.polarityWarningTimer = null;
    }

    if (this.polarityMarker) {
      this.polarityMarker.destroy();
      this.polarityMarker = null;
    }

    if (this.polarityUI) {
      this.polarityUI.destroy();
      this.polarityUI = null;
      this.polarityUILabel = null;
    }

    console.log('[Polarity] System stopped');
  }

  createPolarityMarker() {
    const color = this.currentPolarity === 'N' ? '#00aaff' : '#ff4400';

    this.polarityMarker = this.add.text(0, 0, `[${this.currentPolarity}]`, {
      fontSize: '14px',
      fill: color,
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(150);

    this.updatePolarityMarkerPosition();
  }

  updatePolarityMarkerPosition() {
    if (!this.polarityMarker || !this.snake || !this.snake[0]) return;

    const head = this.snake[0];
    const x = head.x * this.gridSize + this.gridSize / 2;
    const y = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY - 18;

    this.polarityMarker.setPosition(x, y);
  }

  createPolarityUI() {
    const { width } = this.cameras.main;

    // Ïö∞Ï∏° ÏÉÅÎã®Ïóê Í∑πÏÑ± ÌëúÏãú UI
    this.polarityUI = this.add.container(width - 60, 30).setDepth(2500);

    const bg = this.add.rectangle(0, 0, 50, 28, 0x222222, 0.9);
    bg.setStrokeStyle(2, this.currentPolarity === 'N' ? 0x00aaff : 0xff4400);

    const label = this.add.text(0, 0, `[${this.currentPolarity}]`, {
      fontSize: '18px',
      fill: this.currentPolarity === 'N' ? '#00aaff' : '#ff4400',
      fontStyle: 'bold'
    }).setOrigin(0.5);

    this.polarityUI.add([bg, label]);
    this.polarityUILabel = label;
    this.polarityUIBg = bg;
  }

  updatePolarityUI() {
    if (!this.polarityUILabel) return;

    const color = this.currentPolarity === 'N' ? '#00aaff' : '#ff4400';
    const hexColor = this.currentPolarity === 'N' ? 0x00aaff : 0xff4400;

    this.polarityUILabel.setText(`[${this.currentPolarity}]`);
    this.polarityUILabel.setColor(color);

    if (this.polarityUIBg) {
      this.polarityUIBg.setStrokeStyle(2, hexColor);
    }

    // ÎßàÏª§ ÏóÖÎç∞Ïù¥Ìä∏
    if (this.polarityMarker) {
      this.polarityMarker.setText(`[${this.currentPolarity}]`);
      this.polarityMarker.setColor(color);
    }
  }

  showPolarityChangeWarning() {
    if (!this.polarityEnabled) return;
    this.isPolarityWarning = true;

    // ÎßàÏª§ ÍπúÎπ°ÏûÑ
    if (this.polarityMarker) {
      this.tweens.add({
        targets: this.polarityMarker,
        alpha: 0.3,
        duration: 150,
        yoyo: true,
        repeat: 5
      });
    }

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const { width, height } = this.cameras.main;
    const warningText = this.add.text(width / 2, height / 2 - 80, 'POLARITY SHIFT!', {
      fontSize: '28px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(3000).setAlpha(0);

    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scale: { from: 0.8, to: 1.1 },
      duration: 150,
      yoyo: true,
      repeat: 5,
      onComplete: () => warningText.destroy()
    });

    // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Í∏ÄÎ°úÏö∞
    const flash = this.add.rectangle(width / 2, height / 2, width, height, 0xffff00, 0);
    flash.setDepth(2999);
    this.tweens.add({
      targets: flash,
      fillAlpha: 0.15,
      duration: 200,
      yoyo: true,
      repeat: 4,
      onComplete: () => flash.destroy()
    });
  }

  changePolarity() {
    if (!this.polarityEnabled) return;
    this.isPolarityWarning = false;

    const oldPolarity = this.currentPolarity;
    this.currentPolarity = this.currentPolarity === 'N' ? 'S' : 'N';

    // ÏãúÍ∞Å Ìö®Í≥º
    this.showPolarityChangeEffect(oldPolarity, this.currentPolarity);

    // UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updatePolarityUI();

    // ÏûêÍ∏∞Î†• Ìö®Í≥º Ïû¨Í≥ÑÏÇ∞
    if (this.magneticTurrets.length > 0) {
      this.applyMagneticSpeedEffect();
    }

    console.log('[Polarity] Changed from', oldPolarity, 'to', this.currentPolarity);
  }

  showPolarityChangeEffect(from, to) {
    if (!this.snake || !this.snake[0]) return;

    const head = this.snake[0];
    const x = head.x * this.gridSize + this.gridSize / 2;
    const y = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const color = to === 'N' ? 0x00aaff : 0xff4400;

    // EMP ÎßÅ Ìö®Í≥º
    const ring = this.add.graphics().setDepth(200);
    ring.lineStyle(4, color, 1);
    ring.strokeCircle(x, y, 10);

    this.tweens.add({
      targets: ring,
      scaleX: 6,
      scaleY: 6,
      alpha: 0,
      duration: 400,
      ease: 'Power2',
      onComplete: () => ring.destroy()
    });

    // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const particle = this.add.graphics().setDepth(200);
      particle.fillStyle(color, 1);
      particle.fillCircle(0, 0, 4);
      particle.x = x;
      particle.y = y;

      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * 40,
        y: y + Math.sin(angle) * 40,
        alpha: 0,
        duration: 350,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(150, 0.008);
  }

  // =====================================================
  // ===== MAGNETIC TURRETS (Stage 14: Flux Maze) =====
  // =====================================================

  initMagneticTurrets() {
    if (this.magneticTurrets.length > 0) return;

    // 4Í∞ú Í≥†Ï†ï ÏúÑÏπò (ÎåÄÏπ≠ Î∞∞Ïπò)
    const positions = [
      { x: 8, y: 6, polarity: 'N' },
      { x: 32, y: 6, polarity: 'S' },
      { x: 8, y: 21, polarity: 'S' },
      { x: 32, y: 21, polarity: 'N' }
    ];

    positions.forEach(pos => {
      this.createMagneticTurret(pos.x, pos.y, pos.polarity);
    });

    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏ ÏãúÏûë
    this.turretAnimTimer = this.time.addEvent({
      delay: 16, // 60fps
      callback: this.updateTurretAnimations,
      callbackScope: this,
      loop: true
    });

    console.log('[Turrets] Initialized', this.magneticTurrets.length, 'turrets');
  }

  createMagneticTurret(tileX, tileY, polarity) {
    const gs = this.gridSize;
    const x = tileX * gs + gs / 2;
    const y = tileY * gs + gs / 2 + this.gameAreaY;

    const container = this.add.container(x, y).setDepth(65);

    // ÏòÅÌñ• Î≤îÏúÑ ÌëúÏãúÏö© Í∑∏ÎûòÌîΩ
    const forceField = this.add.graphics();
    container.add(forceField);

    // Î≤†Ïù¥Ïä§ (Í∏àÏÜç ÏõêÌòï)
    const base = this.add.graphics();
    base.fillStyle(0x333344, 1);
    base.fillCircle(0, 0, gs * 0.7);
    base.lineStyle(3, polarity === 'N' ? 0x00aaff : 0xff4400, 1);
    base.strokeCircle(0, 0, gs * 0.7);
    container.add(base);

    // Í∑πÏÑ± ÌÖçÏä§Ìä∏
    const polarityText = this.add.text(0, 0, polarity, {
      fontSize: '14px',
      fill: polarity === 'N' ? '#00aaff' : '#ff4400',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add(polarityText);

    // ÏΩîÏñ¥ Í∏ÄÎ°úÏö∞
    const coreGlow = this.add.graphics();
    coreGlow.fillStyle(polarity === 'N' ? 0x00aaff : 0xff4400, 0.3);
    coreGlow.fillCircle(0, 0, gs * 0.4);
    container.add(coreGlow);
    container.sendToBack(coreGlow);

    const turret = {
      x: tileX,
      y: tileY,
      polarity: polarity,
      element: container,
      forceField: forceField,
      forceRadius: this.turretForceRadius,
      pulsePhase: Math.random() * Math.PI * 2,
      base: base,
      coreGlow: coreGlow
    };

    this.magneticTurrets.push(turret);

    // ÏÉùÏÑ± Ïï†ÎãàÎ©îÏù¥ÏÖò
    container.setScale(0).setAlpha(0);
    this.tweens.add({
      targets: container,
      scale: 1,
      alpha: 1,
      duration: 500,
      ease: 'Back.easeOut'
    });
  }

  updateTurretAnimations() {
    if (!this.polarityEnabled) return;

    this.turretPulseTime += 0.05;

    this.magneticTurrets.forEach(turret => {
      if (!turret.forceField) return;

      turret.forceField.clear();

      const alpha = 0.15 + Math.sin(this.turretPulseTime + turret.pulsePhase) * 0.1;
      const radius = turret.forceRadius * this.gridSize;
      const color = turret.polarity === 'N' ? 0x00aaff : 0xff4400;

      // Ïô∏Í≥Ω ÎßÅ
      turret.forceField.lineStyle(2, color, alpha * 1.5);
      turret.forceField.strokeCircle(0, 0, radius);

      // ÎÇ¥Î∂Ä ÌéÑÏä§ ÎßÅÎì§
      for (let i = 1; i <= 3; i++) {
        const ringRadius = radius * (i / 4);
        const ringAlpha = alpha * (1 - i / 5);
        turret.forceField.lineStyle(1, color, ringAlpha);
        turret.forceField.strokeCircle(0, 0, ringRadius);
      }

      // ÏΩîÏñ¥ Í∏ÄÎ°úÏö∞ ÌéÑÏä§
      if (turret.coreGlow) {
        const glowScale = 1 + Math.sin(this.turretPulseTime * 2 + turret.pulsePhase) * 0.15;
        turret.coreGlow.setScale(glowScale);
      }
    });
  }

  calculateMagneticSpeedModifier() {
    if (!this.polarityEnabled || this.magneticTurrets.length === 0) {
      return 1.0;
    }

    if (!this.snake || !this.snake[0]) return 1.0;

    const head = this.snake[0];
    let totalModifier = 1.0;

    this.magneticTurrets.forEach(turret => {
      const dist = Math.sqrt(
        Math.pow(head.x - turret.x, 2) +
        Math.pow(head.y - turret.y, 2)
      );

      if (dist <= turret.forceRadius && dist > 0.5) {
        const distanceRatio = dist / turret.forceRadius;
        const samePolarity = this.currentPolarity === turret.polarity;

        if (samePolarity) {
          // Ï≤ôÎ†•: ÏÜçÎèÑ Í∞êÏÜå (Í±∞Î¶¨ Í∞ÄÍπåÏö∞Î©¥ 0.5xÍπåÏßÄ)
          const modifier = 0.5 + distanceRatio * 0.5;
          totalModifier = Math.min(totalModifier, modifier);
        } else {
          // Ïù∏Î†•: ÏÜçÎèÑ Ï¶ùÍ∞Ä (Í±∞Î¶¨ Í∞ÄÍπåÏö∞Î©¥ 1.5xÍπåÏßÄ)
          const modifier = 1.5 - distanceRatio * 0.5;
          totalModifier = Math.max(totalModifier, modifier);
        }
      }
    });

    return totalModifier;
  }

  applyMagneticSpeedEffect() {
    if (!this.polarityEnabled) return;

    const newModifier = this.calculateMagneticSpeedModifier();
    const prevModifier = this.currentSpeedModifier;

    // ÏÜçÎèÑ Î∞∞Ïú®Ïù¥ Î≥ÄÍ≤ΩÎêòÏóàÏùÑ ÎïåÎßå ÏóÖÎç∞Ïù¥Ìä∏
    if (Math.abs(newModifier - prevModifier) > 0.01) {
      this.currentSpeedModifier = newModifier;

      // Ïã§Ï†ú ÏÜçÎèÑ Ï†ÅÏö© (baseSpeedÍ∞Ä ÏóÜÏúºÎ©¥ ÌòÑÏû¨ delay Í∏∞Ï§Ä)
      if (!this.baseSpeed) {
        this.baseSpeed = this.moveTimer.delay;
      }

      // ÏÜçÎèÑ Î∞∞Ïú® Ï†ÅÏö©: modifierÍ∞Ä ÌÅ¨Î©¥ Îπ†Î¶Ñ (delay Í∞êÏÜå)
      const newDelay = Math.round(this.baseSpeed / newModifier);
      this.moveTimer.delay = Math.max(30, Math.min(150, newDelay)); // 30~150ms Î≤îÏúÑ

      // ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞±
      this.showMagneticSpeedFeedback(newModifier, prevModifier);
    }

    // Îß§ ÌîÑÎ†àÏûÑ ÏûêÍ∏∞Î†• ÌååÌã∞ÌÅ¥ Ìö®Í≥º
    this.updateMagneticParticles();
  }

  updateMagneticParticles() {
    if (!this.snake || !this.snake[0]) return;

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Í∞ÄÍπåÏö¥ ÌÉëÏùÑ Ï∞æÏïÑÏÑú ÏûêÍ∏∞Î†• ÏÑ† ÌëúÏãú
    this.magneticTurrets.forEach(turret => {
      const dist = Math.sqrt(
        Math.pow(head.x - turret.x, 2) +
        Math.pow(head.y - turret.y, 2)
      );

      if (dist <= turret.forceRadius && dist > 1) {
        const turretX = turret.x * this.gridSize + this.gridSize / 2;
        const turretY = turret.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
        const samePolarity = this.currentPolarity === turret.polarity;
        const color = samePolarity ? 0xff4400 : 0x00aaff;

        // 10% ÌôïÎ•†Î°ú ÏûêÍ∏∞Î†• ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
        if (Math.random() < 0.1) {
          this.createMagneticFieldParticle(headX, headY, turretX, turretY, color, samePolarity);
        }
      }
    });
  }

  createMagneticFieldParticle(fromX, fromY, toX, toY, color, isRepulsion) {
    const particle = this.add.circle(fromX, fromY, 3, color, 0.8);
    particle.setDepth(90);

    if (isRepulsion) {
      // Ï≤ôÎ†•: ÌÉëÏóêÏÑú Î±ÄÏúºÎ°ú Î∞ÄÎ†§ÎÇòÏò§Îäî Î∞©Ìñ•
      const angle = Math.atan2(fromY - toY, fromX - toX);
      const targetX = fromX + Math.cos(angle) * 30;
      const targetY = fromY + Math.sin(angle) * 30;

      this.tweens.add({
        targets: particle,
        x: targetX,
        y: targetY,
        alpha: 0,
        scale: 0.3,
        duration: 400,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    } else {
      // Ïù∏Î†•: Î±ÄÏóêÏÑú ÌÉëÏúºÎ°ú ÎÅåÎ†§Í∞ÄÎäî Î∞©Ìñ•
      const midX = (fromX + toX) / 2 + Phaser.Math.Between(-20, 20);
      const midY = (fromY + toY) / 2 + Phaser.Math.Between(-20, 20);

      this.tweens.add({
        targets: particle,
        x: midX,
        y: midY,
        alpha: 0,
        scale: 0.5,
        duration: 300,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }
  }

  showMagneticSpeedFeedback(modifier, prevModifier) {
    if (!this.snake || !this.snake[0]) return;

    const head = this.snake[0];
    const x = head.x * this.gridSize + this.gridSize / 2;
    const y = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÏÜçÎèÑ Î≥ÄÌôî ÌåêÎã®
    let color, text, particleCount;
    if (modifier < 0.8) {
      color = 0xff4400; // Ï≤ôÎ†• - Îπ®Í∞ÑÏÉâ (ÎäêÎ†§Ïßê)
      text = 'SLOW!';
      particleCount = 8;
    } else if (modifier > 1.2) {
      color = 0x00aaff; // Ïù∏Î†• - ÌååÎûÄÏÉâ (Îπ®ÎùºÏßê)
      text = 'FAST!';
      particleCount = 8;
    } else if (modifier < 0.95) {
      color = 0xff6644;
      text = null;
      particleCount = 4;
    } else if (modifier > 1.05) {
      color = 0x44aaff;
      text = null;
      particleCount = 4;
    } else {
      // Ìö®Í≥º Î≤îÏúÑ Î≤óÏñ¥ÎÇ® - ÏõêÎûò ÏÜçÎèÑÎ°ú Î≥µÏõê
      if (this.baseSpeed) {
        this.moveTimer.delay = this.baseSpeed;
      }
      return;
    }

    // Í∏ÄÎ°úÏö∞ ÎßÅ Ìö®Í≥º
    const glow = this.add.graphics().setDepth(95);
    glow.lineStyle(3, color, 0.8);
    glow.strokeCircle(x, y, this.gridSize * 0.6);

    this.tweens.add({
      targets: glow,
      alpha: 0,
      scaleX: 2,
      scaleY: 2,
      duration: 400,
      ease: 'Power2',
      onComplete: () => glow.destroy()
    });

    // ÌååÌã∞ÌÅ¥ Î≤ÑÏä§Ìä∏
    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const particle = this.add.circle(x, y, 4, color, 0.9);
      particle.setDepth(95);

      const dist = modifier < 1 ? 25 : 40; // Ï≤ôÎ†•ÏùÄ ÏßßÍ≤å, Ïù∏Î†•ÏùÄ Í∏∏Í≤å
      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * dist,
        y: y + Math.sin(angle) * dist,
        alpha: 0,
        scale: 0.3,
        duration: 350,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // ÌÖçÏä§Ìä∏ ÌëúÏãú (Í∞ïÌïú Ìö®Í≥ºÏùº ÎïåÎßå)
    if (text) {
      const feedbackText = this.add.text(x, y - 25, text, {
        fontSize: '14px',
        fontFamily: 'monospace',
        color: color === 0xff4400 ? '#ff4400' : '#00aaff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(100);

      this.tweens.add({
        targets: feedbackText,
        y: y - 45,
        alpha: 0,
        duration: 600,
        ease: 'Power2',
        onComplete: () => feedbackText.destroy()
      });

      // ÌôîÎ©¥ ÌÖåÎëêÎ¶¨ Ìö®Í≥º
      this.showMagneticBorderEffect(color);
    }
  }

  showMagneticBorderEffect(color) {
    const { width, height } = this.cameras.main;

    const border = this.add.graphics().setDepth(200);
    border.lineStyle(4, color, 0.6);
    border.strokeRect(5, 5, width - 10, height - 10);

    this.tweens.add({
      targets: border,
      alpha: 0,
      duration: 300,
      onComplete: () => border.destroy()
    });

    // ÌÖçÏä§Ìä∏ ÌîºÎìúÎ∞± (Í∞ÄÎÅîÎßå ÌëúÏãú)
    if (Math.random() < 0.3) {
      const feedbackText = this.add.text(x, y - 25, text, {
        fontSize: '12px',
        fill: modifier < 0.9 ? '#ff4400' : '#00aaff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(200).setAlpha(0.8);

      this.tweens.add({
        targets: feedbackText,
        y: y - 45,
        alpha: 0,
        duration: 500,
        onComplete: () => feedbackText.destroy()
      });
    }
  }

  getAdjustedMoveDelay() {
    // ÏûêÍ∏∞Î†• ÏòÅÌñ• Î∞òÏòÅÌïú Ïã§Ï†ú Ïù¥Îèô ÎîúÎ†àÏù¥
    const baseDelay = this.moveTimer ? this.moveTimer.delay : this.baseSpeed;
    return Math.round(baseDelay / this.currentSpeedModifier);
  }

  cleanupMagneticTurrets() {
    this.magneticTurrets.forEach(turret => {
      if (turret.element) turret.element.destroy();
    });
    this.magneticTurrets = [];

    if (this.turretAnimTimer) {
      this.turretAnimTimer.destroy();
      this.turretAnimTimer = null;
    }

    this.currentSpeedModifier = 1.0;

    console.log('[Turrets] Cleaned up');
  }

  isTurretAtPosition(x, y) {
    return this.magneticTurrets.some(t => t.x === x && t.y === y) ||
           this.laserTurrets.some(t => t.x === x && t.y === y);
  }

  // =====================================================
  // ===== LASER TURRETS (Stage 14: Flux Maze) =====
  // =====================================================

  initLaserTurrets() {
    if (this.laserTurrets.length > 0) return;

    console.log('[LaserTurrets] Initializing laser turrets...');

    // 4Í∞ú Í≥†Ï†ï ÏúÑÏπòÏóê ÌÑ∞Î†õ ÏÉùÏÑ±
    this.laserTurretPositions.forEach((pos, index) => {
      this.createLaserTurret(pos.x, pos.y, index);
    });

    // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.laserAnimTimer = this.time.addEvent({
      delay: 16,
      callback: this.updateLaserTurretAnimations,
      callbackScope: this,
      loop: true
    });

    // Î∞úÏÇ¨ Ï£ºÍ∏∞ ÌÉÄÏù¥Î®∏ ÏãúÏûë
    this.startLaserFireCycle();

    console.log('[LaserTurrets] Initialized', this.laserTurrets.length, 'turrets');
  }

  createLaserTurret(tileX, tileY, index) {
    const gs = this.gridSize;
    const x = tileX * gs + gs / 2;
    const y = tileY * gs + gs / 2 + this.gameAreaY;

    const container = this.add.container(x, y).setDepth(70);

    // EMP Ïä§ÌÉÄÏùº Î≤†Ïù¥Ïä§ - Í∞ÄÏä§Ï°¥Í≥º ÌÜµÏùºÎêú ÎπÑÏ£ºÏñº
    const baseGlow = this.add.graphics();
    baseGlow.fillStyle(0x00ffff, 0.3);
    baseGlow.fillCircle(0, 0, gs * 1.2);
    container.add(baseGlow);

    // ÌÑ∞Î†õ ÏΩîÏñ¥ (ÎßàÏ††ÌÉÄ/ÏãúÏïà Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎäêÎÇå)
    const core = this.add.graphics();
    core.fillStyle(0xff00ff, 0.8);
    core.fillCircle(0, 0, gs * 0.6);
    core.fillStyle(0x00ffff, 1);
    core.fillCircle(0, 0, gs * 0.35);
    core.fillStyle(0xffffff, 1);
    core.fillCircle(0, 0, gs * 0.15);
    container.add(core);

    // ÌöåÏ†ÑÌïòÎäî Ïô∏Í≥Ω ÎßÅ
    const outerRing = this.add.graphics();
    outerRing.lineStyle(2, 0x00ffff, 0.8);
    outerRing.strokeCircle(0, 0, gs * 0.9);
    // ÏûëÏùÄ ÎÖ∏Îìú 4Í∞ú
    for (let i = 0; i < 4; i++) {
      const angle = (i * Math.PI / 2);
      const nx = Math.cos(angle) * gs * 0.9;
      const ny = Math.sin(angle) * gs * 0.9;
      outerRing.fillStyle(0xff00ff, 1);
      outerRing.fillCircle(nx, ny, 3);
    }
    container.add(outerRing);

    // Î†àÏù¥Ï†Ä Í∑∏ÎûòÌîΩ (Î∞úÏÇ¨ ÏãúÏóêÎßå ÌëúÏãú)
    const laserGraphics = this.add.graphics();
    laserGraphics.setVisible(false);
    container.add(laserGraphics);

    // Í≤ΩÍ≥† Í∑∏ÎûòÌîΩ (Í≤ΩÍ≥† ÏãúÏóêÎßå ÌëúÏãú)
    const warningGraphics = this.add.graphics();
    warningGraphics.setVisible(false);
    container.add(warningGraphics);

    // Ï¥àÍ∏∞ Í∞ÅÎèÑ ÏÑ§Ï†ï (Í∞Å ÌÑ∞Î†õÏù¥ ÏÑúÎ°ú Îã§Î•∏ Î∞©Ìñ•)
    const initialAngle = (index * Math.PI / 2) + Math.PI / 4;

    const turret = {
      x: tileX,
      y: tileY,
      container,
      core,
      outerRing,
      baseGlow,
      laserGraphics,
      warningGraphics,
      angle: initialAngle,
      isActive: false,
      isWarning: false,
      pulsePhase: Math.random() * Math.PI * 2
    };

    this.laserTurrets.push(turret);
  }

  startLaserFireCycle() {
    // Ï≤´ Î∞úÏÇ¨ Ï†Ñ ÎåÄÍ∏∞
    this.time.delayedCall(2000, () => {
      this.fireLaserSequence();
    });
  }

  fireLaserSequence() {
    if (this.laserTurrets.length === 0) return;
    if (this.gameOver || this.bossPhase === 'victory') return;

    // Í≤ΩÍ≥† Îã®Í≥Ñ
    this.laserPhase = 'warning';
    this.showLaserTurretWarning();

    // Í≤ΩÍ≥† ÌõÑ Î∞úÏÇ¨
    this.time.delayedCall(this.laserWarningDuration, () => {
      if (this.gameOver) return;
      this.laserPhase = 'firing';
      this.activateLasers();

      // Î∞úÏÇ¨ Ï¢ÖÎ£å
      this.time.delayedCall(this.laserActiveDuration, () => {
        this.deactivateLasers();
        this.laserPhase = 'idle';

        // Îã§Ïùå Î∞úÏÇ¨ ÏÇ¨Ïù¥ÌÅ¥
        this.time.delayedCall(this.laserFireInterval - this.laserWarningDuration - this.laserActiveDuration, () => {
          this.fireLaserSequence();
        });
      });
    });
  }

  showLaserTurretWarning() {
    this.laserTurrets.forEach(turret => {
      turret.isWarning = true;
      turret.warningGraphics.setVisible(true);

      // Í≤ΩÍ≥† ÏÇ¨Ïö¥Îìú/Ìö®Í≥º
      this.cameras.main.shake(100, 0.003);
    });

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warningText = this.add.text(
      this.cameras.main.width / 2,
      this.cameras.main.height / 2 - 50,
      'LASER WARNING!',
      {
        fontSize: '32px',
        fill: '#ff0000',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 4
      }
    ).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: warningText,
      alpha: { from: 1, to: 0.3 },
      yoyo: true,
      repeat: 2,
      duration: 250,
      onComplete: () => warningText.destroy()
    });
  }

  activateLasers() {
    // 14ÌÉÑ Î†àÏù¥Ï†Ä Ìö®Í≥ºÏùå
    this.sound.play('laser14_effect', { volume: 0.3 });

    this.laserTurrets.forEach(turret => {
      turret.isWarning = false;
      turret.isActive = true;
      turret.warningGraphics.setVisible(false);
      turret.laserGraphics.setVisible(true);
    });

    // Î∞úÏÇ¨ ÌîåÎûòÏãú Ìö®Í≥º
    this.cameras.main.flash(200, 0, 255, 255, false, null, this);
  }

  deactivateLasers() {
    this.laserTurrets.forEach(turret => {
      turret.isActive = false;
      turret.laserGraphics.setVisible(false);
    });
  }

  updateLaserTurretAnimations() {
    const time = this.time.now;

    this.laserTurrets.forEach(turret => {
      // ÌöåÏ†Ñ
      turret.angle += this.laserRotationSpeed;
      if (turret.outerRing) {
        turret.outerRing.rotation = turret.angle;
      }

      // ÌéÑÏä§ Ìö®Í≥º
      turret.pulsePhase += 0.05;
      const pulse = 0.8 + Math.sin(turret.pulsePhase) * 0.2;
      if (turret.baseGlow) {
        turret.baseGlow.setAlpha(0.3 * pulse);
      }

      // Í≤ΩÍ≥† Í∑∏ÎûòÌîΩ ÏóÖÎç∞Ïù¥Ìä∏
      if (turret.isWarning) {
        this.drawLaserWarning(turret);
      }

      // Î†àÏù¥Ï†Ä Í∑∏ÎûòÌîΩ ÏóÖÎç∞Ïù¥Ìä∏
      if (turret.isActive) {
        this.drawActiveLaser(turret);
      }
    });
  }

  drawLaserWarning(turret) {
    const gs = this.gridSize;
    const g = turret.warningGraphics;
    g.clear();

    // Ï†êÏÑ† Í≤ΩÍ≥† ÎùºÏù∏ (2Î∞©Ìñ• - Î∞òÎåÄ Î∞©Ìñ•)
    const angles = [turret.angle, turret.angle + Math.PI];

    angles.forEach(angle => {
      g.lineStyle(3, 0xffff00, 0.6 + Math.sin(this.time.now * 0.01) * 0.4);

      const dashLength = gs * 0.8;
      const gapLength = gs * 0.4;
      const totalLength = this.laserLength * gs;

      for (let dist = gs; dist < totalLength; dist += dashLength + gapLength) {
        const x1 = Math.cos(angle) * dist;
        const y1 = Math.sin(angle) * dist;
        const x2 = Math.cos(angle) * Math.min(dist + dashLength, totalLength);
        const y2 = Math.sin(angle) * Math.min(dist + dashLength, totalLength);

        g.beginPath();
        g.moveTo(x1, y1);
        g.lineTo(x2, y2);
        g.strokePath();
      }
    });
  }

  drawActiveLaser(turret) {
    const gs = this.gridSize;
    const g = turret.laserGraphics;
    g.clear();

    // Î©îÏù∏ Î†àÏù¥Ï†Ä Îπî (2Î∞©Ìñ•)
    const angles = [turret.angle, turret.angle + Math.PI];

    angles.forEach(angle => {
      const endX = Math.cos(angle) * this.laserLength * gs;
      const endY = Math.sin(angle) * this.laserLength * gs;

      // Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞
      g.lineStyle(12, 0xff00ff, 0.3);
      g.beginPath();
      g.moveTo(0, 0);
      g.lineTo(endX, endY);
      g.strokePath();

      // Ï§ëÍ∞Ñ Îπî
      g.lineStyle(6, 0x00ffff, 0.7);
      g.beginPath();
      g.moveTo(0, 0);
      g.lineTo(endX, endY);
      g.strokePath();

      // ÏΩîÏñ¥ Îπî
      g.lineStyle(2, 0xffffff, 1);
      g.beginPath();
      g.moveTo(0, 0);
      g.lineTo(endX, endY);
      g.strokePath();
    });
  }

  checkLaserCollision(headX, headY) {
    if (this.laserPhase !== 'firing') return false;

    const gs = this.gridSize;
    const headPixelX = headX * gs + gs / 2;
    const headPixelY = headY * gs + gs / 2 + this.gameAreaY;

    for (const turret of this.laserTurrets) {
      if (!turret.isActive) continue;

      const turretPixelX = turret.x * gs + gs / 2;
      const turretPixelY = turret.y * gs + gs / 2 + this.gameAreaY;

      // Îëê Î∞©Ìñ• Î†àÏù¥Ï†Ä Ï≤¥ÌÅ¨
      const angles = [turret.angle, turret.angle + Math.PI];

      for (const angle of angles) {
        // ÏÑ†Î∂Ñ-Ï†ê Í±∞Î¶¨ Í≥ÑÏÇ∞
        const laserEndX = turretPixelX + Math.cos(angle) * this.laserLength * gs;
        const laserEndY = turretPixelY + Math.sin(angle) * this.laserLength * gs;

        const dist = this.pointToLineDistance(
          headPixelX, headPixelY,
          turretPixelX, turretPixelY,
          laserEndX, laserEndY
        );

        // Î†àÏù¥Ï†Ä ÎëêÍªò ÎÇ¥Ïóê ÏûàÏúºÎ©¥ Ï∂©Îèå
        if (dist < gs * 0.6) {
          return true;
        }
      }
    }

    return false;
  }

  pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) {
      param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  cleanupLaserTurrets() {
    this.laserTurrets.forEach(turret => {
      if (turret.container) turret.container.destroy(true);
    });
    this.laserTurrets = [];

    if (this.laserAnimTimer) {
      this.laserAnimTimer.destroy();
      this.laserAnimTimer = null;
    }

    if (this.laserFireTimer) {
      this.laserFireTimer.destroy();
      this.laserFireTimer = null;
    }

    this.laserPhase = 'idle';

    console.log('[LaserTurrets] Cleaned up');
  }

  // =====================================================
  // ===== FLOATING MINES (Stage 14: Flux Maze) =====
  // =====================================================

  startMineSpawner() {
    if (this.mineSpawnTimer) return;

    this.mineSpawnTimer = this.time.addEvent({
      delay: this.mineSpawnInterval,
      callback: this.spawnFloatingMine,
      callbackScope: this,
      loop: true
    });

    console.log('[Mines] Spawner started');
  }

  stopMineSpawner() {
    if (this.mineSpawnTimer) {
      this.mineSpawnTimer.destroy();
      this.mineSpawnTimer = null;
    }
  }

  spawnFloatingMine() {
    if (this.floatingMines.length >= this.maxFloatingMines) return;
    if (this.gameOver) return;

    const pos = this.getMineSpawnPosition();
    if (!pos) return;

    const gs = this.gridSize;
    const x = pos.x * gs + gs / 2;
    const y = pos.y * gs + gs / 2 + this.gameAreaY;

    const container = this.add.container(x, y).setDepth(70);

    // Í≤ΩÍ≥† Í∏ÄÎ°úÏö∞ (Îí§)
    const glow = this.add.graphics();
    glow.fillStyle(0xff6600, 0.25);
    glow.fillCircle(0, 0, gs * 0.6);
    container.add(glow);

    // Í∏∞Î¢∞ Î≥∏Ï≤¥
    const body = this.add.graphics();
    body.fillStyle(0x444444, 1);
    body.fillCircle(0, 0, gs * 0.35);
    body.lineStyle(2, 0x666666, 1);
    body.strokeCircle(0, 0, gs * 0.35);
    container.add(body);

    // Ïä§ÌååÏù¥ÌÅ¨Îì§
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const spike = this.add.graphics();
      spike.fillStyle(0x888888, 1);
      spike.beginPath();
      const innerR = gs * 0.3;
      const outerR = gs * 0.5;
      spike.moveTo(Math.cos(angle - 0.15) * innerR, Math.sin(angle - 0.15) * innerR);
      spike.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      spike.lineTo(Math.cos(angle + 0.15) * innerR, Math.sin(angle + 0.15) * innerR);
      spike.closePath();
      spike.fillPath();
      container.add(spike);
    }

    // ÏúÑÌóò ÌëúÏãú (Ï§ëÏïô)
    const danger = this.add.text(0, 0, '!', {
      fontSize: '12px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add(danger);

    // ÎûúÎç§ Î∞©Ìñ•
    const directions = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
      { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
    ];
    const dir = Phaser.Math.RND.pick(directions);

    const mine = {
      x: pos.x,
      y: pos.y,
      element: container,
      glow: glow,
      dx: dir.dx,
      dy: dir.dy,
      moveTimer: null
    };

    // ÏÉùÏÑ± Ïï†ÎãàÎ©îÏù¥ÏÖò
    container.setScale(0).setAlpha(0);
    this.tweens.add({
      targets: container,
      scale: 1,
      alpha: 1,
      duration: 400,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.startMineMovement(mine);
      }
    });

    // Ìò∏Ìù° Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: glow,
      alpha: 0.15,
      duration: 800,
      yoyo: true,
      repeat: -1
    });

    this.floatingMines.push(mine);

    console.log('[Mines] Spawned mine at', pos.x, pos.y, '- total:', this.floatingMines.length);
  }

  getMineSpawnPosition() {
    const edges = [];

    // Îßµ Í∞ÄÏû•ÏûêÎ¶¨
    for (let x = 2; x < this.cols - 2; x++) {
      edges.push({ x, y: 1 });
      edges.push({ x, y: this.rows - 2 });
    }
    for (let y = 2; y < this.rows - 2; y++) {
      edges.push({ x: 1, y });
      edges.push({ x: this.cols - 2, y });
    }

    Phaser.Utils.Array.Shuffle(edges);

    for (const pos of edges) {
      const notOnSnake = !this.snake.some(s => s.x === pos.x && s.y === pos.y);
      const notOnFood = !(this.food && this.food.x === pos.x && this.food.y === pos.y);
      const notOnTurret = !this.isTurretAtPosition(pos.x, pos.y);
      const notOnMine = !this.floatingMines.some(m => m.x === pos.x && m.y === pos.y);
      const notOnDeadzone = !this.deadZones.some(d => d.x === pos.x && d.y === pos.y);
      const notInGas = !this.isInGasZone(pos.x, pos.y);

      if (notOnSnake && notOnFood && notOnTurret && notOnMine && notOnDeadzone && notInGas) {
        return pos;
      }
    }

    return null;
  }

  startMineMovement(mine) {
    mine.moveTimer = this.time.addEvent({
      delay: this.mineSpeed,
      callback: () => this.moveFloatingMine(mine),
      loop: true
    });
  }

  moveFloatingMine(mine) {
    if (this.gameOver || !mine || !mine.element) return;

    let newX = mine.x + mine.dx;
    let newY = mine.y + mine.dy;

    // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Î∞òÏÇ¨
    let bounced = false;
    if (newX < 1 || newX >= this.cols - 1) {
      mine.dx *= -1;
      newX = mine.x;
      bounced = true;
    }
    if (newY < 1 || newY >= this.rows - 1) {
      mine.dy *= -1;
      newY = mine.y;
      bounced = true;
    }

    // ÌÑ∞Î†õ Ï∂©Îèå Ï≤¥ÌÅ¨ (Î∞òÏÇ¨)
    if (this.isTurretAtPosition(newX, newY)) {
      mine.dx *= -1;
      mine.dy *= -1;
      bounced = true;
      newX = mine.x;
      newY = mine.y;
    }

    // Í∞ÄÏä§Ï°¥ Ï≤¥ÌÅ¨ (Îì§Ïñ¥Í∞ÄÏßÄ ÏïäÏùå)
    if (this.isInGasZone(newX, newY)) {
      mine.dx *= -1;
      mine.dy *= -1;
      bounced = true;
      newX = mine.x;
      newY = mine.y;
    }

    if (!bounced) {
      // Í∞ÄÎÅî Î∞©Ìñ• Î≥ÄÍ≤Ω (15%)
      if (Math.random() < 0.15) {
        const directions = [
          { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
          { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
        ];
        const newDir = Phaser.Math.RND.pick(directions);
        mine.dx = newDir.dx;
        mine.dy = newDir.dy;
      }

      // Ïù¥Îèô
      mine.x = newX;
      mine.y = newY;

      const gs = this.gridSize;
      const targetX = newX * gs + gs / 2;
      const targetY = newY * gs + gs / 2 + this.gameAreaY;

      this.tweens.add({
        targets: mine.element,
        x: targetX,
        y: targetY,
        duration: this.mineSpeed * 0.7,
        ease: 'Linear'
      });
    }
  }

  checkMineCollision() {
    if (this.floatingMines.length === 0) return false;
    if (!this.snake || !this.snake[0]) return false;

    const head = this.snake[0];

    for (let i = this.floatingMines.length - 1; i >= 0; i--) {
      const mine = this.floatingMines[i];
      if (mine.x === head.x && mine.y === head.y) {
        this.handleMineHit(mine, i);
        return true;
      }
    }

    return false;
  }

  handleMineHit(mine, index) {
    const x = mine.element.x;
    const y = mine.element.y;

    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      const particle = this.add.graphics().setDepth(200);
      particle.fillStyle(0xff6600, 1);
      particle.fillCircle(0, 0, 4);
      particle.x = x;
      particle.y = y;

      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * 50,
        y: y + Math.sin(angle) * 50,
        alpha: 0,
        duration: 350,
        onComplete: () => particle.destroy()
      });
    }

    // Ìè≠Î∞ú ÌîåÎûòÏãú
    const flash = this.add.graphics().setDepth(195);
    flash.fillStyle(0xff6600, 0.6);
    flash.fillCircle(x, y, this.gridSize);
    this.tweens.add({
      targets: flash,
      alpha: 0,
      scaleX: 2,
      scaleY: 2,
      duration: 200,
      onComplete: () => flash.destroy()
    });

    // Í∏∞Î¢∞ Ï†úÍ±∞
    this.destroyMine(mine, index);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(150, 0.015);

    // Î™∏ÌÜµ 1Ïπ∏ Ï†úÍ±∞
    if (this.snake.length > 3) {
      const removedSegment = this.snake.pop();

      // Ï†úÍ±∞Îêú ÏÑ∏Í∑∏Î®ºÌä∏ ÌîåÎûòÏãú
      const segX = removedSegment.x * this.gridSize + this.gridSize / 2;
      const segY = removedSegment.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      const segFlash = this.add.graphics().setDepth(150);
      segFlash.fillStyle(0xff0000, 0.8);
      segFlash.fillRect(
        removedSegment.x * this.gridSize,
        removedSegment.y * this.gridSize + this.gameAreaY,
        this.gridSize,
        this.gridSize
      );

      this.tweens.add({
        targets: segFlash,
        alpha: 0,
        duration: 300,
        onComplete: () => segFlash.destroy()
      });

      // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
      const warningText = this.add.text(segX, segY - 20, '-1 SEGMENT!', {
        fontSize: '14px',
        fill: '#ff4400',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 2
      }).setOrigin(0.5).setDepth(200);

      this.tweens.add({
        targets: warningText,
        y: segY - 50,
        alpha: 0,
        duration: 800,
        onComplete: () => warningText.destroy()
      });

      // Î±Ä Îã§Ïãú Í∑∏Î¶¨Í∏∞
      this.draw();

      console.log('[Mines] Snake hit! Length:', this.snake.length);
    } else {
      // Î±ÄÏù¥ ÎÑàÎ¨¥ ÏßßÏúºÎ©¥ Ï¶âÏÇ¨
      console.log('[Mines] Snake too short - game over!');
      this.endGame();
    }
  }

  destroyMine(mine, index) {
    if (mine.moveTimer) {
      mine.moveTimer.destroy();
      mine.moveTimer = null;
    }

    if (mine.element) {
      mine.element.destroy();
    }

    if (index !== undefined) {
      this.floatingMines.splice(index, 1);
    } else {
      const idx = this.floatingMines.indexOf(mine);
      if (idx > -1) this.floatingMines.splice(idx, 1);
    }
  }

  cleanupFloatingMines() {
    this.stopMineSpawner();

    this.floatingMines.forEach(mine => {
      if (mine.moveTimer) mine.moveTimer.destroy();
      if (mine.element) mine.element.destroy();
    });
    this.floatingMines = [];

    console.log('[Mines] Cleaned up');
  }

  isMineAtPosition(x, y) {
    return this.floatingMines.some(m => m.x === x && m.y === y);
  }

  // ========== NEXUS Î≥¥Ïä§ ÏãúÏä§ÌÖú (Stage 15) ==========

  startNexusBoss() {
    console.log('[NEXUS] Starting boss battle');
    this.nexusMode = true;
    this.nexusPhase = 'intro';
    this.nexusHitCount = 0;
    this.nexusVulnerable = false;
    this.nexusPosition = {
      x: Math.floor(this.cols / 2),
      y: Math.floor(this.rows / 2)
    };

    // Í∞ÄÏä§Ï°¥ ÏùºÏãú Ï†ïÏßÄ
    if (this.gasZoneTimer) {
      this.gasZoneTimer.paused = true;
    }

    // 15ÌÉÑ Î≥¥Ïä§ BGMÏúºÎ°ú Î≥ÄÍ≤Ω
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.bgMusic.stop();
    }
    if (this.boss15Music) {
      this.boss15Music.play();
    }

    // Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§ ÏãúÏûë
    this.showNexusIntro();
  }

  createNexusBoss() {
    const centerX = this.nexusPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.nexusPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Î≥¥Ïä§ Ïª®ÌÖåÏù¥ÎÑà
    this.nexusElement = this.add.container(centerX, centerY);
    this.nexusElement.setDepth(100);

    // === Î∞îÏù¥Îü¨Ïä§ Ïä§ÌÉÄÏùº ÎîîÏûêÏù∏ ===

    // 1. ÎèÖÏÑ± Ïò§Îùº (Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞)
    this.nexusAura = this.add.graphics();
    this.nexusAura.fillStyle(0x00ff00, 0.15);
    this.nexusAura.fillCircle(0, 0, 70);
    this.nexusAura.fillStyle(0xff0000, 0.1);
    this.nexusAura.fillCircle(0, 0, 55);
    this.nexusElement.add(this.nexusAura);

    // 2. Ïä§ÌååÏù¥ÌÅ¨ (Î∞îÏù¥Îü¨Ïä§ ÎèåÍ∏∞) - 12Í∞ú
    this.nexusSpikes = [];
    const spikeCount = 12;
    for (let i = 0; i < spikeCount; i++) {
      const angle = (i / spikeCount) * Math.PI * 2;
      const spike = this.add.graphics();

      // Ïä§ÌååÏù¥ÌÅ¨ ÏÇºÍ∞ÅÌòï Í∑∏Î¶¨Í∏∞
      spike.fillStyle(0xff3300, 0.9);
      spike.beginPath();
      spike.moveTo(0, -8);  // ÎÅùÏ†ê
      spike.lineTo(-4, 8);   // Ï¢åÌïò
      spike.lineTo(4, 8);    // Ïö∞Ìïò
      spike.closePath();
      spike.fillPath();

      // Ïä§ÌååÏù¥ÌÅ¨ ÏúÑÏπò Î∞è ÌöåÏ†Ñ
      spike.x = Math.cos(angle) * 40;
      spike.y = Math.sin(angle) * 40;
      spike.rotation = angle + Math.PI / 2;

      this.nexusElement.add(spike);
      this.nexusSpikes.push({ graphics: spike, baseAngle: angle, phase: i * 0.3 });
    }

    // 3. Ïô∏Îßâ (Î∞îÏù¥Îü¨Ïä§ Ï∫°ÏãúÎìú) - Î∂àÍ∑úÏπôÌïú Ïõê
    this.nexusMembrane = this.add.graphics();
    this.nexusMembrane.lineStyle(4, 0xcc0000, 0.8);
    this.nexusMembrane.fillStyle(0x330000, 0.6);
    this.nexusMembrane.beginPath();
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * Math.PI * 2;
      const wobble = 28 + Math.sin(i * 1.5) * 5;
      const x = Math.cos(angle) * wobble;
      const y = Math.sin(angle) * wobble;
      if (i === 0) this.nexusMembrane.moveTo(x, y);
      else this.nexusMembrane.lineTo(x, y);
    }
    this.nexusMembrane.closePath();
    this.nexusMembrane.fillPath();
    this.nexusMembrane.strokePath();
    this.nexusElement.add(this.nexusMembrane);

    // 4. ÎÇ¥Î∂Ä Ìïµ (ÎÖπÏÉâ ÎèÖÏÑ± ÏΩîÏñ¥)
    this.nexusCore = this.add.graphics();
    this.nexusCore.fillStyle(0x003300, 1);
    this.nexusCore.fillCircle(0, 0, 18);
    this.nexusCore.fillStyle(0x00ff00, 0.8);
    this.nexusCore.fillCircle(0, 0, 12);
    this.nexusCore.fillStyle(0xccff00, 0.9);
    this.nexusCore.fillCircle(0, 0, 6);
    this.nexusElement.add(this.nexusCore);

    // 5. Îàà (ÏÇ¨ÏïÖÌïú ÎäêÎÇå)
    const eyeGraphics = this.add.graphics();
    eyeGraphics.fillStyle(0x000000, 1);
    eyeGraphics.fillEllipse(0, 0, 16, 10);
    eyeGraphics.fillStyle(0xff0000, 1);
    eyeGraphics.fillCircle(0, 0, 4);
    eyeGraphics.fillStyle(0xffffff, 1);
    eyeGraphics.fillCircle(-1, -1, 1.5);
    this.nexusElement.add(eyeGraphics);

    // 6. Îñ†Îã§ÎãàÎäî ÎèÖÏÑ± ÏûÖÏûêÎì§
    this.nexusParticles = [];
    for (let i = 0; i < 8; i++) {
      const particle = this.add.circle(
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100,
        2 + Math.random() * 3,
        0x00ff00,
        0.6
      );
      this.nexusElement.add(particle);
      this.nexusParticles.push({
        obj: particle,
        orbitRadius: 50 + Math.random() * 30,
        orbitSpeed: 0.02 + Math.random() * 0.02,
        angle: Math.random() * Math.PI * 2
      });
    }

    // ÏΩîÏñ¥ ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò (Îçî Î∂àÏïàÏ†ïÌïòÍ≤å)
    this.tweens.add({
      targets: this.nexusElement,
      scaleX: 1.1,
      scaleY: 1.15,
      duration: 800,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏
    this.nexusAnimTimer = this.time.addEvent({
      delay: 30,
      callback: () => this.updateNexusAnimation(),
      loop: true
    });

    this.nexusElement.setAlpha(0);

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º ÌÉÄÏù¥Î®∏
    this.nexusGlitchTimer = this.time.addEvent({
      delay: 2000 + Math.random() * 3000,
      callback: () => this.showNexusGlitch(),
      loop: true
    });
  }

  updateNexusAnimation() {
    if (!this.nexusElement || !this.nexusElement.active) return;

    const time = Date.now() * 0.001;

    // Ïä§ÌååÏù¥ÌÅ¨ ÏõÄÏßÅÏûÑ (Îß•Îèô + ÌöåÏ†Ñ)
    if (this.nexusSpikes) {
      this.nexusSpikes.forEach((spike, i) => {
        const pulseFactor = 1 + Math.sin(time * 3 + spike.phase) * 0.15;
        const baseAngle = spike.baseAngle + time * 0.3;
        spike.graphics.x = Math.cos(baseAngle) * 40 * pulseFactor;
        spike.graphics.y = Math.sin(baseAngle) * 40 * pulseFactor;
        spike.graphics.rotation = baseAngle + Math.PI / 2;
      });
    }

    // ÎèÖÏÑ± ÏûÖÏûêÎì§ Í∂§ÎèÑ Ïö¥Îèô
    if (this.nexusParticles) {
      this.nexusParticles.forEach(p => {
        p.angle += p.orbitSpeed;
        p.obj.x = Math.cos(p.angle) * p.orbitRadius;
        p.obj.y = Math.sin(p.angle) * p.orbitRadius;
        p.obj.setAlpha(0.4 + Math.sin(time * 5 + p.angle) * 0.3);
      });
    }

    // Ïò§Îùº ÌéÑÏä§
    if (this.nexusAura) {
      const auraScale = 1 + Math.sin(time * 2) * 0.1;
      this.nexusAura.setScale(auraScale);
    }
  }

  showNexusGlitch() {
    if (!this.nexusElement || !this.nexusElement.active || this.nexusPhase === 'victory') return;

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º: ÏúÑÏπò Îñ®Î¶º
    const originalX = this.nexusElement.x;
    const originalY = this.nexusElement.y;

    this.tweens.add({
      targets: this.nexusElement,
      x: originalX + Phaser.Math.Between(-5, 5),
      y: originalY + Phaser.Math.Between(-5, 5),
      duration: 50,
      yoyo: true,
      repeat: 2,
      onComplete: () => {
        if (this.nexusElement && this.nexusElement.active) {
          this.nexusElement.setPosition(originalX, originalY);
        }
      }
    });
  }

  showNexusIntro() {
    const { width, height } = this.cameras.main;
    this.nexusIntroElements = [];

    // ÌôîÎ©¥ Ïñ¥Îë°Í≤å
    const overlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.85);
    overlay.setDepth(90);
    this.nexusIntroElements.push(overlay);

    // ÎåÄÌôî Î∞ïÏä§ Ìó¨Ìçº
    const createDialogue = (speaker, text, color, y) => {
      const prefix = speaker === 'NEXUS' ? '> NEXUS: ' : '> SNAKE: ';
      const dialogue = this.add.text(width / 2, y, prefix + text, {
        fontSize: '16px',
        fontFamily: 'monospace',
        color: color,
        wordWrap: { width: width - 100 }
      }).setOrigin(0.5).setDepth(96);
      dialogue.setAlpha(0);
      this.tweens.add({
        targets: dialogue,
        alpha: 1,
        duration: 200
      });
      return dialogue;
    };

    // 1Îã®Í≥Ñ: Í≤ΩÍ≥† (0s)
    const alertText = this.add.text(width / 2, height / 2 - 100, '[ SYSTEM ALERT ]', {
      fontSize: '32px',
      fontFamily: 'monospace',
      color: '#ff0000'
    }).setOrigin(0.5).setDepth(95);
    this.nexusIntroElements.push(alertText);

    this.tweens.add({
      targets: alertText,
      alpha: 0.2,
      duration: 150,
      yoyo: true,
      repeat: 3
    });
    this.cameras.main.shake(300, 0.01);

    // 2Îã®Í≥Ñ: ÌîåÎûòÏãú + Î≥¥Ïä§ Îì±Ïû• (0.8s)
    this.time.delayedCall(800, () => {
      this.cameras.main.flash(200, 0, 255, 255);
      this.createNexusBoss();
      alertText.destroy();

      // Î≥¥Ïä§ ÌéòÏù¥ÎìúÏù∏
      this.tweens.add({
        targets: this.nexusElement,
        alpha: 1,
        duration: 400,
        ease: 'Power2'
      });
    });

    // 3Îã®Í≥Ñ: ÎåÄÌôî ÏãúÏûë (1.5s)
    let dialogues = [];

    this.time.delayedCall(1500, () => {
      // NEXUS Ï≤´ ÎåÄÏÇ¨
      const d1 = createDialogue('NEXUS', 'VIRUS DETECTED... TARGET: SNAKE.EXE', '#ff0000', height / 2 - 40);
      dialogues.push(d1);
    });

    this.time.delayedCall(2500, () => {
      // Î±Ä ÎåÄÏÇ¨
      const d2 = createDialogue('SNAKE', 'I am the antivirus. You are the infection!', '#00ff00', height / 2);
      dialogues.push(d2);
    });

    this.time.delayedCall(3500, () => {
      // NEXUS ÎåÄÏÇ¨
      const d3 = createDialogue('NEXUS', 'INITIATING PURGE... DECRYPT IF YOU CAN!', '#ff00ff', height / 2 + 40);
      dialogues.push(d3);
    });

    // 4Îã®Í≥Ñ: ÌÉÄÏù¥ÌãÄ + ÎßàÎ¨¥Î¶¨ (4.5s)
    this.time.delayedCall(4500, () => {
      // ÎåÄÌôî Ï†ïÎ¶¨
      dialogues.forEach(d => {
        this.tweens.add({
          targets: d,
          alpha: 0,
          duration: 200,
          onComplete: () => d.destroy()
        });
      });

      // "NEXUS ONLINE" ÌÉÄÏù¥ÌãÄ
      const titleText = this.add.text(width / 2, height / 2 - 50, 'NEXUS ONLINE', {
        fontSize: '48px',
        fontFamily: 'monospace',
        color: '#00ffff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(96);
      titleText.setScale(0.5);
      titleText.setAlpha(0);

      this.tweens.add({
        targets: titleText,
        scaleX: 1,
        scaleY: 1,
        alpha: 1,
        duration: 400,
        ease: 'Back.easeOut'
      });

      // HP Î∞î ÏÉùÏÑ±
      this.createNexusHPBar();

      // 5Îã®Í≥Ñ: Ïù∏Ìä∏Î°ú Ï¢ÖÎ£å + ÌäúÌÜ†Î¶¨Ïñº (6s)
      this.time.delayedCall(1500, () => {
        overlay.destroy();
        titleText.destroy();
        this.nexusIntroElements = [];

        // Í≤åÏûÑ ÏãúÏûë
        this.nexusPhase = 'phase1';
        this.moveTimer.paused = false;

        // ÏûêÍ∏∞Ïû• ÏãúÏûë
        this.startGasZone();

        // ÌäúÌÜ†Î¶¨Ïñº ÌëúÏãú
        this.showNexusTutorial();
      });
    });
  }

  showNexusGlitchOverlay() {
    const { width, height } = this.cameras.main;

    // Ïä§Ï∫îÎùºÏù∏ Ìö®Í≥º
    for (let i = 0; i < 5; i++) {
      const line = this.add.rectangle(width / 2, Math.random() * height, width, 2, 0x00ffff, 0.3);
      line.setDepth(89);
      this.tweens.add({
        targets: line,
        y: line.y + 50,
        alpha: 0,
        duration: 500,
        delay: i * 100,
        onComplete: () => line.destroy()
      });
    }
  }

  showNexusDialogue(text, x, y, callback) {
    const dialogueText = this.add.text(x, y, '', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0.5).setDepth(95);
    this.nexusIntroElements.push(dialogueText);

    // ÌÉÄÏûêÍ∏∞ Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 40,
      callback: () => {
        charIndex++;
        dialogueText.setText('> ' + text.substring(0, charIndex) + '_');
        if (charIndex >= text.length) {
          typeTimer.destroy();
          // Ïª§ÏÑú ÍπúÎπ°ÏûÑ
          this.tweens.add({
            targets: dialogueText,
            alpha: 0.7,
            duration: 300,
            yoyo: true,
            repeat: 2,
            onComplete: () => {
              dialogueText.setText('> ' + text);
              if (callback) callback();
            }
          });
        }
      },
      loop: true
    });
  }

  // NEXUS v2: ÌäúÌÜ†Î¶¨Ïñº ÌëúÏãú
  showNexusTutorial() {
    const { width, height } = this.cameras.main;

    // Î∞òÌà¨Î™Ö Î∞∞Í≤Ω
    const tutorialBg = this.add.rectangle(width / 2, height / 2, width - 100, 280, 0x000000, 0.85);
    tutorialBg.setStrokeStyle(3, 0x00ffff);
    tutorialBg.setDepth(300);

    // ÌÉÄÏù¥ÌãÄ
    const title = this.add.text(width / 2, height / 2 - 100, 'üéØ HOW TO DEFEAT NEXUS üéØ', {
      fontSize: '24px',
      fontFamily: 'monospace',
      color: '#00ffff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(301);

    // ÏÑ§Î™Ö ÌÖçÏä§Ìä∏ (ÏòÅÏñ¥) - ÏïîÍ∏∞ Í≤åÏûÑ Î©îÏπ¥Îãâ ÏÑ§Î™Ö
    const instructions = [
      '1. MEMORIZE the code sequence (e.g. "1 0 1 1")',
      '2. After 2.5s, the code will be HIDDEN!',
      '3. Collect matching nodes in ORDER from memory',
      '4. All 0s are the same, all 1s are the same',
      '5. Wrong order = RESET + extra SCAN penalty!',
      'Survive 4 ROUNDS to WIN! (1‚Üí3‚Üí5‚Üí8 nodes)'
    ];

    const instructionTexts = [];
    instructions.forEach((text, idx) => {
      const t = this.add.text(width / 2, height / 2 - 50 + idx * 28, text, {
        fontSize: '14px',
        fontFamily: 'monospace',
        color: '#ffffff'
      }).setOrigin(0.5).setDepth(301);
      instructionTexts.push(t);
    });

    // ÏãúÏûë Î≤ÑÌäº
    const startBtn = this.add.text(width / 2, height / 2 + 100, '[ Press SPACE or ENTER to START ]', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#00ff00'
    }).setOrigin(0.5).setDepth(301);

    // ÍπúÎπ°ÏûÑ Ìö®Í≥º
    this.tweens.add({
      targets: startBtn,
      alpha: 0.5,
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // ÏûÖÎ†• ÎåÄÍ∏∞
    const startGame = () => {
      // Ï†ïÎ¶¨
      tutorialBg.destroy();
      title.destroy();
      instructionTexts.forEach(t => t.destroy());
      startBtn.destroy();

      // Í≤åÏûÑ ÏãúÏûë
      this.moveTimer.paused = false;
      this.startNexusRound(1);
    };

    this.input.keyboard.once('keydown-SPACE', startGame);
    this.input.keyboard.once('keydown-ENTER', startGame);
  }

  createNexusHPBar() {
    const { width } = this.cameras.main;

    // HP Î∞î Ïª®ÌÖåÏù¥ÎÑà
    this.nexusHPBar = this.add.container(width / 2, 25);
    this.nexusHPBar.setDepth(150);

    // Î∞∞Í≤Ω
    const bgBar = this.add.rectangle(0, 0, 200, 16, 0x222222, 0.8);
    bgBar.setStrokeStyle(2, 0x00ffff);
    this.nexusHPBar.add(bgBar);

    // HP Î∞î (4Ïπ∏)
    this.nexusHPSegments = [];
    for (let i = 0; i < 4; i++) {
      const segment = this.add.rectangle(-75 + i * 50, 0, 45, 10, 0x00ffff, 1);
      this.nexusHPBar.add(segment);
      this.nexusHPSegments.push(segment);
    }

    // ÎùºÎ≤®
    const label = this.add.text(0, -20, 'NEXUS', {
      fontSize: '12px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0.5);
    this.nexusHPBar.add(label);

    // NEXUS v2: ÎùºÏö¥Îìú ÌëúÏãú
    this.nexusRoundLabel = this.add.text(0, 20, 'ROUND 1/4', {
      fontSize: '10px',
      fontFamily: 'monospace',
      color: '#ff00ff'
    }).setOrigin(0.5);
    this.nexusHPBar.add(this.nexusRoundLabel);
  }

  // NEXUS v2: ÎùºÏö¥Îìú UI ÏóÖÎç∞Ïù¥Ìä∏
  updateNexusRoundUI() {
    if (this.nexusRoundLabel) {
      this.nexusRoundLabel.setText(`ROUND ${this.nexusRound}/4`);

      // ÎùºÏö¥Îìú Î≥ÄÍ≤Ω Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: this.nexusRoundLabel,
        scaleX: 1.2,
        scaleY: 1.2,
        duration: 200,
        yoyo: true
      });
    }
  }

  createNexusDashUI() {
    const { width, height } = this.cameras.main;

    // ÎåÄÏãú Í≤åÏù¥ÏßÄ Ïª®ÌÖåÏù¥ÎÑà
    this.nexusDashUI = this.add.container(width / 2, height - 30);
    this.nexusDashUI.setDepth(150);

    // Î∞∞Í≤Ω Ïõê
    const bgCircle = this.add.circle(0, 0, 20, 0x222222, 0.6);
    bgCircle.setStrokeStyle(2, 0x00ffff);
    this.nexusDashUI.add(bgCircle);

    // Ï∞®ÏßÄ Í≤åÏù¥ÏßÄ (ÏïÑÌÅ¨)
    this.nexusDashGauge = this.add.graphics();
    this.nexusDashUI.add(this.nexusDashGauge);

    // "DASH" ÌÖçÏä§Ìä∏
    this.nexusDashText = this.add.text(0, 0, 'DASH', {
      fontSize: '8px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0.5);
    this.nexusDashUI.add(this.nexusDashText);
  }

  // ========== NEXUS Phase ÏãúÏä§ÌÖú ==========

  startNexusPhase1() {
    console.log('[NEXUS] Phase 1: Scan Protocol');
    this.nexusPhase = 'phase1';

    // Phase ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    if (this.nexusPhaseLabel) {
      this.nexusPhaseLabel.setText('PHASE 1: SCAN PROTOCOL');
    }
    this.showNexusPhaseText('PHASE 1: SCAN PROTOCOL');

    // Í∞ÄÏä§Ï°¥ Ïû¨Í∞ú (ÎäêÎ¶∞ ÏÜçÎèÑ)
    if (this.gasZoneTimer) {
      this.gasZoneTimer.paused = false;
    }

    // Ïä§Ï∫î Îπî ÏÇ¨Ïù¥ÌÅ¥ ÏãúÏûë
    this.time.delayedCall(2000, () => {
      this.startScanBeamCycle();
    });

    // Ïä§Ï∫î 3Ìöå ÌõÑ vulnerable
    this.nexusScanCount = 0;
  }

  startScanBeamCycle() {
    if (this.nexusPhase !== 'phase1' || !this.nexusMode) return;

    this.nexusScanCount++;

    // Ïä§Ï∫î Î∞©Ìñ• Í≤∞Ï†ï (ÏàòÏßÅ/ÏàòÌèâ Î≤àÍ∞àÏïÑ)
    const isVertical = this.nexusScanCount % 2 === 1;

    // Í≤ΩÍ≥† ÌëúÏãú
    this.showScanWarning(isVertical);

    // 1Ï¥à ÌõÑ Î†àÏù¥Ï†Ä Î∞úÏÇ¨
    this.time.delayedCall(1000, () => {
      if (!this.nexusMode) return;
      this.fireScanBeam(isVertical);

      // NEXUS v2: Ïä§Ï∫îÏù¥ Í≥ÑÏÜç Î∞òÎ≥µÎê® (3Ï¥à Í∞ÑÍ≤© - Îçî Îπ†Î•¥Í≤å!)
      this.time.delayedCall(3000, () => {
        if (this.nexusMode && this.nexusPhase !== 'victory') {
          this.startScanBeamCycle();
        }
      });
    });
  }

  showScanWarning(isVertical) {
    const { width, height } = this.cameras.main;
    const centerX = this.nexusPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.nexusPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warnText = this.add.text(width / 2, 90, '‚ö† SCAN INCOMING ‚ö†', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#ff0000'
    }).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: warnText,
      alpha: 0.3,
      duration: 150,
      yoyo: true,
      repeat: 3,
      onComplete: () => warnText.destroy()
    });

    // Í≤ΩÍ≥†ÏÑ†
    this.nexusScanWarning = this.add.graphics();
    this.nexusScanWarning.setDepth(150);

    if (isVertical) {
      // ÏàòÏßÅ Í≤ΩÍ≥†ÏÑ† (Ï¢åÏóêÏÑú Ïö∞Î°ú Ïù¥Îèô)
      this.nexusScanWarning.lineStyle(3, 0xff0000, 0.5);
      this.nexusScanWarning.lineBetween(0, this.gameAreaY, 0, height);
    } else {
      // ÏàòÌèâ Í≤ΩÍ≥†ÏÑ† (ÏúÑÏóêÏÑú ÏïÑÎûòÎ°ú Ïù¥Îèô)
      this.nexusScanWarning.lineStyle(3, 0xff0000, 0.5);
      this.nexusScanWarning.lineBetween(0, this.gameAreaY, width, this.gameAreaY);
    }

    // Í≤ΩÍ≥†ÏÑ† ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: this.nexusScanWarning,
      alpha: 0.2,
      duration: 100,
      yoyo: true,
      repeat: 4,
      onComplete: () => {
        if (this.nexusScanWarning) {
          this.nexusScanWarning.destroy();
          this.nexusScanWarning = null;
        }
      }
    });
  }

  fireScanBeam(isVertical) {
    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ Î†àÏù¥Ï†ÄÍ∞Ä ÏûàÏúºÎ©¥ Î®ºÏ†Ä Ï†ïÎ¶¨ (Î≤ÑÍ∑∏ Î∞©ÏßÄ)
    if (this.nexusActiveLaser && this.nexusActiveLaser.graphics) {
      this.nexusActiveLaser.graphics.destroy();
      this.nexusActiveLaser = null;
    }

    // ÌîåÎûòÏãú Ìö®Í≥º
    this.cameras.main.flash(100, 255, 0, 255);

    // Î†àÏù¥Ï†Ä Í∑∏ÎûòÌîΩ
    const laser = this.add.graphics();
    laser.setDepth(160);

    // Í≥†Ïä§Ìä∏ Î±Ä ÏÉùÏÑ± Ïó¨Î∂Ä Ï∂îÏ†Å (Ìïú Î≤àÏùò Ïä§Ï∫îÏóê Ìïú Î≤àÎßå ÏÉùÏÑ±)
    let ghostCreated = false;

    if (isVertical) {
      // ÏàòÏßÅ Î†àÏù¥Ï†Ä (Ï¢åÏóêÏÑú Ïö∞Î°ú Ïä§Ï∫î)
      laser.fillStyle(0xff00ff, 0.9);
      laser.fillRect(0, this.gameAreaY, 16, height - this.gameAreaY);

      this.nexusActiveLaser = { graphics: laser, type: 'vertical', x: 0 };

      // Ïù¥Îèô Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: this.nexusActiveLaser,
        x: width,
        duration: 2000,
        ease: 'Linear',
        onUpdate: () => {
          if (this.nexusActiveLaser && this.nexusActiveLaser.graphics) {
            this.nexusActiveLaser.graphics.clear();
            this.nexusActiveLaser.graphics.fillStyle(0xff00ff, 0.9);
            this.nexusActiveLaser.graphics.fillRect(this.nexusActiveLaser.x - 8, this.gameAreaY, 16, height - this.gameAreaY);

            // NEXUS v2: Ïä§Ï∫î ÎπîÏù¥ Î±Ä Î®∏Î¶¨ ÏúÑÎ•º ÏßÄÎÇòÍ∞ÄÎ©¥ Í≥†Ïä§Ìä∏ Î±Ä ÏÉùÏÑ±
            if (!ghostCreated && this.snake && this.snake.length > 0) {
              const head = this.snake[0];
              const headPixelX = head.x * this.gridSize + this.gridSize / 2;
              if (Math.abs(this.nexusActiveLaser.x - headPixelX) < 16) {
                this.createGhostSnake();
                ghostCreated = true;
              }
            }
          }
        },
        onComplete: () => {
          if (this.nexusActiveLaser && this.nexusActiveLaser.graphics) {
            this.nexusActiveLaser.graphics.destroy();
            this.nexusActiveLaser = null;
          }
        }
      });
    } else {
      // ÏàòÌèâ Î†àÏù¥Ï†Ä (ÏúÑÏóêÏÑú ÏïÑÎûòÎ°ú Ïä§Ï∫î)
      laser.fillStyle(0xff00ff, 0.9);
      laser.fillRect(0, this.gameAreaY, width, 16);

      this.nexusActiveLaser = { graphics: laser, type: 'horizontal', y: this.gameAreaY };

      // Ïù¥Îèô Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: this.nexusActiveLaser,
        y: height,
        duration: 2000,
        ease: 'Linear',
        onUpdate: () => {
          if (this.nexusActiveLaser && this.nexusActiveLaser.graphics) {
            this.nexusActiveLaser.graphics.clear();
            this.nexusActiveLaser.graphics.fillStyle(0xff00ff, 0.9);
            this.nexusActiveLaser.graphics.fillRect(0, this.nexusActiveLaser.y - 8, width, 16);

            // NEXUS v2: Ïä§Ï∫î ÎπîÏù¥ Î±Ä Î®∏Î¶¨ ÏúÑÎ•º ÏßÄÎÇòÍ∞ÄÎ©¥ Í≥†Ïä§Ìä∏ Î±Ä ÏÉùÏÑ±
            if (!ghostCreated && this.snake && this.snake.length > 0) {
              const head = this.snake[0];
              const headPixelY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
              if (Math.abs(this.nexusActiveLaser.y - headPixelY) < 16) {
                this.createGhostSnake();
                ghostCreated = true;
              }
            }
          }
        },
        onComplete: () => {
          if (this.nexusActiveLaser && this.nexusActiveLaser.graphics) {
            this.nexusActiveLaser.graphics.destroy();
            this.nexusActiveLaser = null;
          }
        }
      });
    }
  }

  // NEXUS v2: Î∂àÌÉÄÎäî ÌÉÄÏùº ÏÉùÏÑ± (Ïä§Ï∫î Ïãú Î±ÄÏùò ÌòÑÏû¨ ÏúÑÏπòÏóê Î∂à Ìö®Í≥º)
  createGhostSnake() {
    if (!this.snake || this.snake.length === 0) return;

    console.log('[NEXUS] Burning tiles created!');

    // Î±ÄÏùò ÌòÑÏû¨ ÏúÑÏπòÏóê Î∂àÌÉÄÎäî ÌÉÄÏùº ÏÉùÏÑ±
    this.snake.forEach((seg, idx) => {
      this.createBurningTile(seg.x, seg.y);
    });

    // ÏÉùÏÑ± Ìö®Í≥ºÏùå Î∞è ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞±
    const { width } = this.cameras.main;
    const scanText = this.add.text(width / 2, 100, 'üî• SCANNED! üî•', {
      fontSize: '20px',
      fontFamily: 'monospace',
      color: '#ff6600'
    }).setOrigin(0.5).setDepth(250);

    this.tweens.add({
      targets: scanText,
      alpha: 0,
      y: 80,
      duration: 1500,
      onComplete: () => scanText.destroy()
    });

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(200, 0.01);
  }

  // Í∞úÎ≥Ñ Î∂àÌÉÄÎäî ÌÉÄÏùº ÏÉùÏÑ±
  createBurningTile(tileX, tileY) {
    const px = tileX * this.gridSize + this.gridSize / 2;
    const py = tileY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Î∂àÍΩÉ Ïª®ÌÖåÏù¥ÎÑà
    const container = this.add.container(px, py).setDepth(75);

    // Î∞îÍπ•Ï™Ω Î∂àÍΩÉ (Ï£ºÌô©ÏÉâ)
    const outerFlame = this.add.graphics();
    outerFlame.fillStyle(0xff6600, 0.7);
    outerFlame.fillCircle(0, 0, this.gridSize / 2 + 2);
    container.add(outerFlame);

    // ÏïàÏ™Ω Î∂àÍΩÉ (Îπ®Í∞ÑÏÉâ)
    const innerFlame = this.add.graphics();
    innerFlame.fillStyle(0xff0000, 0.8);
    innerFlame.fillCircle(0, 0, this.gridSize / 2 - 2);
    container.add(innerFlame);

    // Ï§ëÏã¨ Î∂àÍΩÉ (ÎÖ∏ÎûÄÏÉâ)
    const coreFlame = this.add.graphics();
    coreFlame.fillStyle(0xffff00, 0.9);
    coreFlame.fillCircle(0, 0, this.gridSize / 4);
    container.add(coreFlame);

    // Î∂àÌÉÄÎäî ÌÉÄÏùº Îç∞Ïù¥ÌÑ∞
    const burningTile = {
      x: tileX,
      y: tileY,
      container: container,
      outerFlame: outerFlame,
      innerFlame: innerFlame,
      coreFlame: coreFlame,
      flickerPhase: Math.random() * Math.PI * 2
    };

    // Í≥†Ïä§Ìä∏ Î±Ä Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    if (!this.nexusGhostSnakes) this.nexusGhostSnakes = [];
    this.nexusGhostSnakes.push({ body: [{ x: tileX, y: tileY }], container: container });

    // Î∂àÍΩÉ ÌùîÎì§Î¶º Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: container,
      scaleX: { from: 0.9, to: 1.1 },
      scaleY: { from: 1.1, to: 0.9 },
      duration: 200 + Math.random() * 100,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // Î∂àÍΩÉ ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: [outerFlame, innerFlame],
      alpha: { from: 0.5, to: 0.9 },
      duration: 150 + Math.random() * 100,
      yoyo: true,
      repeat: -1
    });

    // Ï¥àÍ∏∞ Î∂àÍΩÉ Ìè≠Î∞ú Ìö®Í≥º
    container.setScale(0);
    this.tweens.add({
      targets: container,
      scaleX: 1,
      scaleY: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    return burningTile;
  }

  // ========== NEXUS v2: ÎùºÏö¥Îìú ÏãúÏä§ÌÖú ==========

  // ÎùºÏö¥ÎìúÎ≥Ñ ÎÖ∏Îìú Ïàò: 1‚Üí1Í∞ú, 2‚Üí3Í∞ú, 3‚Üí5Í∞ú, 4‚Üí8Í∞ú
  getNodeCountForRound(roundNum) {
    const nodeCounts = { 1: 1, 2: 3, 3: 5, 4: 8 };
    return nodeCounts[roundNum] || roundNum;
  }

  startNexusRound(roundNum) {
    if (!this.nexusMode) return;

    console.log(`[NEXUS] Starting Round ${roundNum}`);
    this.nexusRound = roundNum;
    this.nexusBinaryCollected = [];
    this.nexusCurrentNodeCount = this.getNodeCountForRound(roundNum);

    const { width, height } = this.cameras.main;

    // ÎùºÏö¥Îìú ÏãúÏûë ÌÖçÏä§Ìä∏ (ÎÖ∏Îìú Ïàò ÌëúÏãú)
    const roundText = this.add.text(width / 2, height / 2, `ROUND ${roundNum}/4`, {
      fontSize: '36px',
      fontFamily: 'monospace',
      color: '#00ffff',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(250);

    const nodeCountText = this.add.text(width / 2, height / 2 + 40, `(${this.nexusCurrentNodeCount} codes)`, {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#ffff00'
    }).setOrigin(0.5).setDepth(250);

    this.tweens.add({
      targets: [roundText, nodeCountText],
      scaleX: 1.2,
      scaleY: 1.2,
      alpha: 0,
      duration: 1500,
      onComplete: () => {
        roundText.destroy();
        nodeCountText.destroy();
      }
    });

    // ÏãúÌÄÄÏä§ UI ÏÉùÏÑ± (ÎÖ∏Îìú Ïàò Í∏∞Î∞ò)
    this.createNexusSequenceUI(this.nexusCurrentNodeCount);

    // ÎùºÏö¥Îìú UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updateNexusRoundUI();

    // ÎùºÏö¥ÎìúÎ≥Ñ Í≥µÍ≤© Ìå®ÌÑ¥ ÏãúÏûë (2Ï¥à ÌõÑ)
    this.time.delayedCall(2000, () => {
      this.startNexusRoundAttacks(roundNum);
    });

    // Î∞îÏù¥ÎÑàÎ¶¨ ÎÖ∏Îìú Ïä§Ìè∞ (ÏãúÌÄÄÏä§ Ïà®Í∏¥ ÌõÑ - 3Ï¥à ÌõÑ)
    this.time.delayedCall(3000, () => {
      this.spawnBinaryNodes(this.nexusCurrentNodeCount);
    });
  }

  createNexusSequenceUI(nodeCount, keepSequence = false) {
    const { width } = this.cameras.main;

    // Í∏∞Ï°¥ UI Ï†úÍ±∞
    if (this.nexusSequenceUI) {
      if (this.nexusSequenceUI.container) {
        this.nexusSequenceUI.container.destroy();
      }
    }

    // Î™©Ìëú ÏãúÌÄÄÏä§ ÏÉùÏÑ± (ÎûúÎç§ 0/1) - keepSequenceÎ©¥ Ïú†ÏßÄ
    // Î∞òÎìúÏãú 0Í≥º 1Ïù¥ Î™®Îëê Ìè¨Ìï®ÎêòÎèÑÎ°ù Î≥¥Ïû•!
    if (!keepSequence || !this.nexusBinarySequence || this.nexusBinarySequence.length !== nodeCount) {
      this.nexusBinarySequence = [];

      if (nodeCount === 1) {
        // 1Í∞úÏùº ÎïåÎäî ÎûúÎç§
        this.nexusBinarySequence.push(Math.random() < 0.5 ? 0 : 1);
      } else {
        // 2Í∞ú Ïù¥ÏÉÅ: Î∞òÎìúÏãú 0Í≥º 1 Î™®Îëê Ìè¨Ìï®
        // Î®ºÏ†Ä ÎûúÎç§ÌïòÍ≤å ÏÉùÏÑ±
        for (let i = 0; i < nodeCount; i++) {
          this.nexusBinarySequence.push(Math.random() < 0.5 ? 0 : 1);
        }

        // Î™®Îëê Í∞ôÏùÄ Ïà´ÏûêÏù∏ÏßÄ Ï≤¥ÌÅ¨
        const hasZero = this.nexusBinarySequence.includes(0);
        const hasOne = this.nexusBinarySequence.includes(1);

        if (!hasZero) {
          // Î™®Îëê 1Ïù¥Î©¥, ÎûúÎç§ ÏúÑÏπòÎ•º 0ÏúºÎ°ú
          const randomIdx = Math.floor(Math.random() * nodeCount);
          this.nexusBinarySequence[randomIdx] = 0;
        } else if (!hasOne) {
          // Î™®Îëê 0Ïù¥Î©¥, ÎûúÎç§ ÏúÑÏπòÎ•º 1Î°ú
          const randomIdx = Math.floor(Math.random() * nodeCount);
          this.nexusBinarySequence[randomIdx] = 1;
        }
      }
    }

    // UI Ïª®ÌÖåÏù¥ÎÑà (Í≤åÏûÑÏòÅÏó≠ ÏïÑÎûòÏóê ÌëúÏãú)
    const container = this.add.container(width / 2, this.gameAreaY + 25).setDepth(200);

    // Î∞∞Í≤Ω
    const bgWidth = 140 + nodeCount * 32;
    const bg = this.add.rectangle(0, 0, bgWidth, 36, 0x000000, 0.85);
    bg.setStrokeStyle(2, 0x00ffff);
    container.add(bg);

    // "MEMORIZE:" ÎùºÎ≤®
    const label = this.add.text(-bgWidth / 2 + 10, 0, 'CODE:', {
      fontSize: '14px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0, 0.5);
    container.add(label);

    // ÏãúÌÄÄÏä§ Ïä¨Î°ØÎì§
    const slots = [];
    const startX = -bgWidth / 2 + 70;
    for (let i = 0; i < nodeCount; i++) {
      const slotBg = this.add.rectangle(startX + i * 30, 0, 26, 24, 0x333333, 0.8);
      slotBg.setStrokeStyle(1, 0x666666);
      container.add(slotBg);

      // Ï≤òÏùåÏóêÎäî Ïã§Ï†ú Í∞íÏùÑ Î≥¥Ïó¨Ï§å (ÎØ∏Î¶¨Î≥¥Í∏∞)
      const slotText = this.add.text(startX + i * 30, 0, this.nexusBinarySequence[i].toString(), {
        fontSize: '16px',
        fontFamily: 'monospace',
        color: '#ffff00',
        fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(slotText);

      slots.push({ bg: slotBg, text: slotText, collected: false });
    }

    this.nexusSequenceUI = {
      container: container,
      slots: slots,
      targetSequence: [...this.nexusBinarySequence]
    };

    // "MEMORIZE!" ÍπúÎπ°ÏûÑ Ìö®Í≥º
    const memorizeText = this.add.text(width / 2, this.gameAreaY + 55, 'MEMORIZE!', {
      fontSize: '14px',
      fontFamily: 'monospace',
      color: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(201);

    this.tweens.add({
      targets: memorizeText,
      alpha: 0.3,
      duration: 200,
      yoyo: true,
      repeat: 5
    });

    // 2.5Ï¥à ÌõÑ "?" Î°ú Ïà®Í∏∞Í∏∞
    this.time.delayedCall(2500, () => {
      if (memorizeText && memorizeText.active) {
        memorizeText.destroy();
      }
      // null Ï≤¥ÌÅ¨: Ïî¨Ïù¥ Ï†ÑÌôòÎêòÏóàÍ±∞ÎÇò UIÍ∞Ä ÌååÍ¥¥Îêú Í≤ΩÏö∞ ÎåÄÎπÑ
      if (this.nexusSequenceUI && this.nexusSequenceUI.slots) {
        this.nexusSequenceUI.slots.forEach((slot) => {
          if (slot && slot.text && slot.text.active) {
            slot.text.setText('?');
            slot.text.setColor('#888888');
            slot.text.setFontStyle('normal');
          }
        });
      }
    });
  }

  updateNexusSequenceUI() {
    if (!this.nexusSequenceUI || !this.nexusSequenceUI.slots) return;

    const slots = this.nexusSequenceUI.slots;

    for (let i = 0; i < slots.length; i++) {
      if (i < this.nexusBinaryCollected.length) {
        const collected = this.nexusBinaryCollected[i];
        const expected = this.nexusBinarySequence[i];
        const isCorrect = collected === expected;

        slots[i].text.setText(collected.toString());
        slots[i].text.setColor(isCorrect ? '#00ff00' : '#ff0000');
        slots[i].bg.setFillStyle(isCorrect ? 0x004400 : 0x440000, 0.8);
        slots[i].bg.setStrokeStyle(2, isCorrect ? 0x00ff00 : 0xff0000);
      }
    }
  }

  spawnBinaryNodes(count) {
    if (!this.nexusMode) return;

    console.log(`[NEXUS] Spawning ${count} binary nodes`);

    // Í∏∞Ï°¥ ÎÖ∏Îìú Ï†úÍ±∞
    if (this.nexusBinaryNodes) {
      this.nexusBinaryNodes.forEach(node => {
        if (node.element) node.element.destroy();
      });
      this.nexusBinaryNodes = [];
    }

    const safePositions = this.getSafePositionsForNodes(count);

    for (let i = 0; i < count; i++) {
      const pos = safePositions[i];
      const value = this.nexusBinarySequence[i];

      const node = this.createBinaryNode(pos.x, pos.y, value, i);
      this.nexusBinaryNodes.push(node);
    }
  }

  respawnRemainingBinaryNodes() {
    if (!this.nexusMode || !this.nexusBinaryNodes || this.nexusBinaryNodes.length === 0) return;

    const remainingValues = this.nexusBinarySequence.slice(this.nexusBinaryCollected.length);
    if (remainingValues.length === 0) return;

    // Í∏∞Ï°¥ ÎÇ®ÏùÄ ÎÖ∏Îìú Ï†úÍ±∞ ÌõÑ Îã§Ïãú Ïä§Ìè∞
    this.nexusBinaryNodes.forEach(node => {
      if (node.element) node.element.destroy();
    });
    this.nexusBinaryNodes = [];

    const safePositions = this.getSafePositionsForNodes(remainingValues.length);

    for (let i = 0; i < remainingValues.length; i++) {
      const pos = safePositions[i];
      if (!pos) break;
      const value = remainingValues[i];
      const index = i + this.nexusBinaryCollected.length;

      const node = this.createBinaryNode(pos.x, pos.y, value, index);
      this.nexusBinaryNodes.push(node);
    }
  }

  getSafePositionsForNodes(count) {
    const positions = [];
    const usedPositions = new Set();

    // Î±Ä ÏúÑÏπò Ï†úÏô∏
    this.snake.forEach(seg => usedPositions.add(`${seg.x},${seg.y}`));

    // Í≥†Ïä§Ìä∏ Î±Ä ÏúÑÏπò Ï†úÏô∏
    if (this.nexusGhostSnakes) {
      this.nexusGhostSnakes.forEach(ghost => {
        ghost.body.forEach(seg => usedPositions.add(`${seg.x},${seg.y}`));
      });
    }

    // Î®πÏù¥ ÏúÑÏπò Ï†úÏô∏
    if (this.food) {
      usedPositions.add(`${this.food.x},${this.food.y}`);
    }

    // Í∞ÄÏä§Ï°¥ Î∞ñ ÏòÅÏó≠Îßå ÏÇ¨Ïö©
    const centerX = this.gasZoneCenterX || this.cols / 2;
    const centerY = this.gasZoneCenterY || this.rows / 2;
    const radius = this.gasZoneRadius || 15;

    for (let attempt = 0; attempt < 100 && positions.length < count; attempt++) {
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * (radius - 3) + 2;
      const x = Math.floor(centerX + Math.cos(angle) * dist);
      const y = Math.floor(centerY + Math.sin(angle) * dist);

      if (x >= 1 && x < this.cols - 1 && y >= 1 && y < this.rows - 1) {
        const key = `${x},${y}`;
        if (!usedPositions.has(key)) {
          usedPositions.add(key);
          positions.push({ x, y });
        }
      }
    }

    return positions;
  }

  createBinaryNode(x, y, value, index) {
    const px = x * this.gridSize + this.gridSize / 2;
    const py = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const container = this.add.container(px, py).setDepth(100);

    // Î∞∞Í≤Ω Ïõê
    const bg = this.add.circle(0, 0, 12, value === 1 ? 0x00ff00 : 0xff00ff, 0.8);
    bg.setStrokeStyle(2, 0xffffff);
    container.add(bg);

    // Ïà´Ïûê ÌÖçÏä§Ìä∏
    const text = this.add.text(0, 0, value.toString(), {
      fontSize: '16px',
      fontFamily: 'monospace',
      color: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add(text);

    // ÏàúÏÑú ÌëúÏãú Ï†úÍ±∞ - Ïú†Ï†ÄÍ∞Ä ÏïîÍ∏∞Ìï¥Ïïº Ìï®!

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: container,
      scaleX: 1.1,
      scaleY: 1.1,
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    return {
      x: x,
      y: y,
      value: value,
      index: index,
      element: container,
      collected: false
    };
  }

  checkBinaryNodeCollision() {
    if (!this.nexusMode || !this.nexusBinaryNodes || this.nexusBinaryNodes.length === 0) return;

    const head = this.snake[0];

    for (const node of this.nexusBinaryNodes) {
      if (node.collected) continue;
      if (node.x === head.x && node.y === head.y) {
        this.collectBinaryNode(node);
        break;
      }
    }
  }

  collectBinaryNode(node) {
    const expectedIndex = this.nexusBinaryCollected.length;
    const expectedValue = this.nexusBinarySequence[expectedIndex];

    console.log(`[NEXUS] Collected node: ${node.value} (expected value: ${expectedValue})`);

    node.collected = true;

    // ÏàòÏßë Ìö®Í≥º
    if (node.element) {
      this.tweens.add({
        targets: node.element,
        scaleX: 1.5,
        scaleY: 1.5,
        alpha: 0,
        duration: 300,
        onComplete: () => {
          if (node.element) node.element.destroy();
        }
      });
    }

    // Í∞í(value)Îßå ÌôïÏù∏! Í∞ôÏùÄ Ïà´ÏûêÎäî Î™®Îëê ÎèôÎì±ÌïòÍ≤å Ï∑®Í∏â
    // Ïòà: ÏãúÌÄÄÏä§Í∞Ä "1011"Ïù¥Í≥† Ï≤´ Î≤àÏß∏Î°ú 1ÏùÑ Î®πÏñ¥Ïïº ÌïòÎ©¥, Ïñ¥Îñ§ 1 ÎÖ∏ÎìúÎì† OK
    this.nexusBinaryCollected.push(node.value);
    this.updateNexusSequenceUI();

    if (node.value !== expectedValue) {
      // ÏûòÎ™ªÎêú Í∞í ÏàòÏßë (Ïòà: 0ÏùÑ Î®πÏñ¥Ïïº ÌïòÎäîÎç∞ 1ÏùÑ Î®πÏùå)
      this.handleWrongSequence();
    } else {
      // Ïò¨Î∞îÎ•∏ Í∞í
      this.showCorrectFeedback();

      // Î™®Îì† ÎÖ∏Îìú ÏàòÏßë ÏôÑÎ£å Ï≤¥ÌÅ¨ (ÎùºÏö¥ÎìúÎ≥Ñ ÎÖ∏Îìú Ïàò Í∏∞Î∞ò)
      if (this.nexusBinaryCollected.length === this.nexusCurrentNodeCount) {
        this.handleRoundComplete();
      }
    }
  }

  handleWrongSequence() {
    console.log('[NEXUS] Wrong sequence! Penalty: extra scan');

    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const wrongText = this.add.text(width / 2, height / 2, 'WRONG CODE!', {
      fontSize: '32px',
      fontFamily: 'monospace',
      color: '#ff0000',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(250);

    const penaltyText = this.add.text(width / 2, height / 2 + 40, 'EXTRA SCAN INCOMING...', {
      fontSize: '16px',
      fontFamily: 'monospace',
      color: '#ff6600'
    }).setOrigin(0.5).setDepth(250);

    this.cameras.main.shake(400, 0.03);

    this.tweens.add({
      targets: [wrongText, penaltyText],
      alpha: 0,
      y: '-=30',
      duration: 2000,
      onComplete: () => {
        wrongText.destroy();
        penaltyText.destroy();
      }
    });

    // ÏãúÌÄÄÏä§ Î¶¨ÏÖã (Í∞ôÏùÄ ÏãúÌÄÄÏä§ Ïú†ÏßÄ!)
    this.nexusBinaryCollected = [];

    // ÌéòÎÑêÌã∞: Ï∂îÍ∞Ä Ïä§Ï∫î Îπî Î∞úÏÇ¨!
    this.time.delayedCall(500, () => {
      this.fireScanBeam(Math.random() < 0.5);
    });

    // ÎÖ∏Îìú Ïû¨Ïä§Ìè∞ (Í∞ôÏùÄ ÏãúÌÄÄÏä§Î°ú Îã§Ïãú Î≥¥Ïó¨Ï£ºÍ∏∞)
    this.time.delayedCall(2000, () => {
      this.createNexusSequenceUI(this.nexusCurrentNodeCount, true); // keepSequence = true
      this.spawnBinaryNodes(this.nexusCurrentNodeCount);
    });
  }

  showCorrectFeedback() {
    const { width } = this.cameras.main;

    const correctText = this.add.text(width / 2, 80, '+1', {
      fontSize: '20px',
      fontFamily: 'monospace',
      color: '#00ff00'
    }).setOrigin(0.5).setDepth(250);

    this.tweens.add({
      targets: correctText,
      y: 60,
      alpha: 0,
      duration: 800,
      onComplete: () => correctText.destroy()
    });
  }

  handleRoundComplete() {
    console.log(`[NEXUS] Round ${this.nexusRound} complete!`);

    const { width, height } = this.cameras.main;

    this.nexusTotalNodesCollected += this.nexusRound;

    // ÎùºÏö¥Îìú ÌÅ¥Î¶¨Ïñ¥ ÌÖçÏä§Ìä∏
    const clearText = this.add.text(width / 2, height / 2, 'DECRYPTED!', {
      fontSize: '32px',
      fontFamily: 'monospace',
      color: '#00ff00',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(250);

    this.cameras.main.flash(200, 0, 255, 0);

    this.tweens.add({
      targets: clearText,
      scaleX: 1.3,
      scaleY: 1.3,
      alpha: 0,
      duration: 1500,
      onComplete: () => clearText.destroy()
    });

    // Î≥¥Ïä§ HIT Ï≤òÎ¶¨
    this.handleNexusHit();

    // Îã§Ïùå ÎùºÏö¥Îìú ÎòêÎäî ÏäπÎ¶¨
    this.time.delayedCall(2000, () => {
      if (this.nexusTotalNodesCollected >= 10) {
        // 10Í∞ú Î™®Îëê ÏàòÏßë = ÌÅ¥Î¶¨Ïñ¥!
        this.showNexusVictory();
      } else if (this.nexusRound < 4) {
        // Îã§Ïùå ÎùºÏö¥Îìú
        this.startNexusRound(this.nexusRound + 1);
      }
    });
  }

  startNexusRoundAttacks(roundNum) {
    if (!this.nexusMode) return;

    // NEXUS v2: Ïä§Ï∫î ÎπîÎßå ÏÇ¨Ïö© (Îã®ÏàúÌôî)
    // ÎùºÏö¥ÎìúÍ∞Ä Ïò¨ÎùºÍ∞àÏàòÎ°ù Í∞ÄÏä§Ï°¥Ïù¥ Îçî Îπ®Î¶¨ Ï∂ïÏÜå
    this.startScanBeamCycle();

    // ÎùºÏö¥Îìú 4ÏóêÏÑú Í∞ÄÏä§Ï°¥ Í∞ÄÏÜç (Îçî ÏôÑÌôîÎêú ÏÜçÎèÑ)
    if (roundNum === 4) {
      this.gasZoneExpandInterval = 7000; // 10Ï¥à ‚Üí 7Ï¥à (ÏôÑÌôî)
    }

  }

  // NEXUS v2: Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù ÎπÑ ÏãúÏûë (Í∏∞Ï°¥ spawnDataBlocks ÎûòÌçº)
  startDataBlockRain() {
    if (!this.nexusMode) return;

    // Î∞òÎ≥µ ÌÉÄÏù¥Î®∏Î°ú Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù Ïä§Ìè∞
    this.nexusDataStormTimer = this.time.addEvent({
      delay: 3000,
      callback: () => {
        if (this.nexusMode && this.nexusPhase !== 'victory') {
          this.spawnDataBlocks();
        }
      },
      loop: true
    });

    // Ï¶âÏãú Ìïú Î≤à Ïä§Ìè∞
    this.spawnDataBlocks();
  }

  // NEXUS v2: Ï∂îÏ†ÅÌÉÑ ÏãúÏûë (Í∏∞Ï°¥ fireTrackers ÎûòÌçº)
  startTrackerMissiles() {
    if (!this.nexusMode) return;

    // Î∞òÎ≥µ ÌÉÄÏù¥Î®∏Î°ú Ï∂îÏ†ÅÌÉÑ Î∞úÏÇ¨
    this.nexusTrackerFireTimer = this.time.addEvent({
      delay: 5000,
      callback: () => {
        if (this.nexusMode && this.nexusPhase !== 'victory') {
          this.fireTrackers();
        }
      },
      loop: true
    });

    // Ï¶âÏãú Ìïú Î≤à Î∞úÏÇ¨
    this.fireTrackers();
  }

  handleNexusHit() {
    this.nexusHitCount++;
    console.log(`[NEXUS] HIT ${this.nexusHitCount}/4`);

    const { width, height } = this.cameras.main;

    // HIT ÌÖçÏä§Ìä∏
    const hitText = this.add.text(width / 2, height / 2 + 50, `HIT ${this.nexusHitCount}/4!`, {
      fontSize: '28px',
      fontFamily: 'monospace',
      color: '#ffff00',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(250);

    this.tweens.add({
      targets: hitText,
      scaleX: 1.2,
      scaleY: 1.2,
      alpha: 0,
      duration: 1500,
      onComplete: () => hitText.destroy()
    });

    // HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    this.updateNexusHPBar();

    // Î≥¥Ïä§ ÌîºÍ≤© Ìö®Í≥º
    if (this.nexusElement) {
      this.tweens.add({
        targets: this.nexusElement,
        alpha: 0.3,
        duration: 100,
        yoyo: true,
        repeat: 3
      });
    }

    this.cameras.main.shake(300, 0.02);
  }

  updateNexusHPBar() {
    if (!this.nexusHPSegments) return;

    const remaining = 4 - this.nexusHitCount;
    for (let i = 0; i < 4; i++) {
      if (i < remaining) {
        this.nexusHPSegments[i].setFillStyle(0x00ffff, 1);
      } else {
        this.nexusHPSegments[i].setFillStyle(0x333333, 0.5);
      }
    }
  }

  setNexusVulnerable() {
    if (!this.nexusMode || this.nexusPhase === 'victory') return;

    console.log('[NEXUS] Vulnerable!');
    this.nexusVulnerable = true;

    // ÏΩîÏñ¥ ÏÉâÏÉÅ Î≥ÄÍ≤Ω (ÏãúÏïà ‚Üí Ï¥àÎ°ù)
    if (this.nexusCore) {
      this.nexusCore.clear();
      this.nexusCore.fillStyle(0x00ff00, 1);
      this.nexusCore.fillCircle(0, 0, 20);
      this.nexusCore.fillStyle(0x88ff88, 0.8);
      this.nexusCore.fillCircle(0, 0, 12);
      this.nexusCore.fillStyle(0xffffff, 0.9);
      this.nexusCore.fillCircle(0, 0, 5);
    }

    // "CORE EXPOSED!" ÌÖçÏä§Ìä∏
    const { width, height } = this.cameras.main;
    const exposedText = this.add.text(width / 2, height / 2 + 80, 'CORE EXPOSED!', {
      fontSize: '24px',
      fontFamily: 'monospace',
      color: '#00ff00'
    }).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: exposedText,
      scaleX: 1.1,
      scaleY: 1.1,
      duration: 300,
      yoyo: true,
      repeat: -1
    });

    // 2Ï¥à ÌõÑ vulnerable Ï¢ÖÎ£å
    this.time.delayedCall(2000, () => {
      exposedText.destroy();
      this.nexusVulnerable = false;
      this.restoreNexusCore();

      // Îã§Ïùå ÏÇ¨Ïù¥ÌÅ¥ ÎòêÎäî Phase Ï†ÑÌôò
      if (this.nexusPhase === 'phase1') {
        this.nexusScanCount = 0;
        this.startScanBeamCycle();
      } else if (this.nexusPhase === 'phase2') {
        this.nexusPhase2AttackCount = 0;
        this.startDataStormCycle();
      }
    });
  }

  restoreNexusCore() {
    if (this.nexusCore) {
      this.nexusCore.clear();
      this.nexusCore.fillStyle(0x4400aa, 1);
      this.nexusCore.fillCircle(0, 0, 20);
      this.nexusCore.fillStyle(0x00ffff, 0.8);
      this.nexusCore.fillCircle(0, 0, 12);
      this.nexusCore.fillStyle(0xffffff, 0.9);
      this.nexusCore.fillCircle(0, 0, 5);
    }
  }

  // ========== NEXUS Phase 2: Data Storm ==========

  startNexusPhase2() {
    console.log('[NEXUS] Phase 2: Data Storm');
    this.nexusPhase = 'phase2';
    this.nexusPhase2AttackCount = 0;

    // Phase ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    if (this.nexusPhaseLabel) {
      this.nexusPhaseLabel.setText('PHASE 2: DATA STORM');
    }
    this.showNexusPhaseText('PHASE 2: DATA STORM');

    // Îç∞Ïù¥ÌÑ∞ Ïä§ÌÜ∞ ÏÇ¨Ïù¥ÌÅ¥ ÏãúÏûë
    this.time.delayedCall(2000, () => {
      this.startDataStormCycle();
    });
  }

  startDataStormCycle() {
    if (this.nexusPhase !== 'phase2' || !this.nexusMode) return;

    // NEXUS v2: Phase 2ÎèÑ Ïä§Ï∫î ÎπîÎßå ÏÇ¨Ïö© (Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù/Ï∂îÏ†ÅÌÉÑ Ï†úÍ±∞)
    this.startScanBeamCycle();
  }

  spawnDataBlocks() {
    const { width, height } = this.cameras.main;

    // Í≤ΩÍ≥†
    const warnText = this.add.text(width / 2, 90, '‚ö† DATA INCOMING ‚ö†', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#ff00ff'
    }).setOrigin(0.5).setDepth(200);

    this.time.delayedCall(800, () => warnText.destroy());

    // 5~7Í∞ú Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù ÏÉùÏÑ±
    const count = Phaser.Math.Between(5, 7);
    for (let i = 0; i < count; i++) {
      const targetX = Phaser.Math.Between(2, this.cols - 3);
      const targetY = Phaser.Math.Between(2, this.rows - 3);

      // Í∑∏Î¶ºÏûê (Í≤ΩÍ≥†)
      const shadowX = targetX * this.gridSize + this.gridSize / 2;
      const shadowY = targetY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      const shadow = this.add.rectangle(shadowX, shadowY, this.gridSize - 4, this.gridSize - 4, 0xff00ff, 0.3);
      shadow.setDepth(80);

      this.tweens.add({
        targets: shadow,
        alpha: 0.1,
        duration: 150,
        yoyo: true,
        repeat: 2
      });

      // 0.8Ï¥à ÌõÑ Î∏îÎ°ù ÎÇôÌïò
      this.time.delayedCall(800, () => {
        shadow.destroy();

        const block = this.add.rectangle(shadowX, -20, this.gridSize - 4, this.gridSize - 4, 0xff00ff, 1);
        block.setStrokeStyle(2, 0xffffff);
        block.setDepth(90);

        this.nexusDataBlocks.push({ element: block, targetX, targetY, active: true });

        // ÎÇôÌïò Ïï†ÎãàÎ©îÏù¥ÏÖò
        this.tweens.add({
          targets: block,
          y: shadowY,
          duration: 400,
          ease: 'Bounce.easeOut',
          onComplete: () => {
            // Ï∞©ÏßÄ Ìö®Í≥º
            this.cameras.main.shake(100, 0.005);

            // 1.5Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê
            this.time.delayedCall(1500, () => {
              const idx = this.nexusDataBlocks.findIndex(b => b.element === block);
              if (idx >= 0) {
                this.nexusDataBlocks.splice(idx, 1);
              }
              this.tweens.add({
                targets: block,
                alpha: 0,
                duration: 300,
                onComplete: () => block.destroy()
              });
            });
          }
        });
      });
    }
  }

  fireTrackers() {
    const { width, height } = this.cameras.main;
    const centerX = this.nexusPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.nexusPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Í≤ΩÍ≥†
    const warnText = this.add.text(width / 2, 90, '‚ö† TRACKERS LOCKED ‚ö†', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#ff0000'
    }).setOrigin(0.5).setDepth(200);

    this.time.delayedCall(800, () => warnText.destroy());

    // 3Î∞ú Î∞úÏÇ¨
    this.time.delayedCall(800, () => {
      for (let i = 0; i < 3; i++) {
        this.time.delayedCall(i * 80, () => {
          this.spawnTracker(centerX, centerY);
        });
      }
    });
  }

  spawnTracker(startX, startY) {
    const tracker = this.add.circle(startX, startY, 6, 0xff0000);
    tracker.setStrokeStyle(2, 0xffff00);
    tracker.setDepth(90);

    const trackerObj = {
      element: tracker,
      x: startX,
      y: startY,
      speed: 2, // ÌîΩÏÖÄ/ÌîÑÎ†àÏûÑ
      lifespan: 180 // 3Ï¥à (60fps)
    };

    this.nexusTrackers.push(trackerObj);

    // Ï∂îÏ†Å ÏóÖÎç∞Ïù¥Ìä∏ (60fps ÌÉÄÏù¥Î®∏Í∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±)
    if (!this.nexusTrackerTimer) {
      this.nexusTrackerTimer = this.time.addEvent({
        delay: 16,
        callback: () => this.updateTrackers(),
        loop: true
      });
    }
  }

  updateTrackers() {
    if (!this.nexusMode) return;

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    for (let i = this.nexusTrackers.length - 1; i >= 0; i--) {
      const t = this.nexusTrackers[i];
      t.lifespan--;

      // ÏàòÎ™Ö Ï¢ÖÎ£å
      if (t.lifespan <= 0) {
        t.element.destroy();
        this.nexusTrackers.splice(i, 1);
        continue;
      }

      // Î±Ä Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô
      const dx = headX - t.x;
      const dy = headY - t.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 0) {
        t.x += (dx / dist) * t.speed;
        t.y += (dy / dist) * t.speed;
        t.element.setPosition(t.x, t.y);
      }

      // Î≤Ω Ï∂©Îèå Ï≤¥ÌÅ¨
      if (t.x < 0 || t.x > this.cameras.main.width || t.y < this.gameAreaY || t.y > this.cameras.main.height) {
        t.element.destroy();
        this.nexusTrackers.splice(i, 1);
      }
    }
  }

  fireEMPSurge() {
    const { width, height } = this.cameras.main;
    const centerX = this.nexusPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.nexusPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Í≤ΩÍ≥†
    const warnText = this.add.text(width / 2, 90, '‚ö† EMP SURGE ‚ö†', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0.5).setDepth(200);

    this.time.delayedCall(800, () => warnText.destroy());

    // Ï∂©Í≤©Ìåå ÏÉùÏÑ±
    this.time.delayedCall(800, () => {
      const wave = this.add.graphics();
      wave.setDepth(85);

      const waveObj = { graphics: wave, radius: 0, maxRadius: 300 };
      this.nexusEMPWaves.push(waveObj);

      // ÌôïÏû• Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: waveObj,
        radius: waveObj.maxRadius,
        duration: 1500,
        ease: 'Linear',
        onUpdate: () => {
          wave.clear();
          wave.lineStyle(8, 0x00ffff, 1 - waveObj.radius / waveObj.maxRadius);
          wave.strokeCircle(centerX, centerY, waveObj.radius);
        },
        onComplete: () => {
          const idx = this.nexusEMPWaves.indexOf(waveObj);
          if (idx >= 0) this.nexusEMPWaves.splice(idx, 1);
          wave.destroy();
        }
      });

      // Ï§ëÏïô ÌîåÎûòÏãú
      this.cameras.main.flash(100, 0, 255, 255);
    });
  }

  // ========== NEXUS Phase 3: Firewall Surge ==========

  startNexusPhase3() {
    console.log('[NEXUS] Phase 3: Firewall Surge');
    this.nexusPhase = 'phase3';

    // Phase ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    if (this.nexusPhaseLabel) {
      this.nexusPhaseLabel.setText('PHASE 3: FIREWALL SURGE');
    }
    this.showNexusPhaseText('PHASE 3: FIREWALL SURGE');

    // Í∞ÄÏä§Ï°¥ Í∞ÄÏÜç (5Ï¥à Í∞ÑÍ≤© - Í∏∞Ï°¥ 10Ï¥àÏóêÏÑú ÏôÑÌôî)
    if (this.gasZoneTimer) {
      this.gasZoneTimer.remove();
    }
    this.gasZoneTimer = this.time.addEvent({
      delay: 5000,
      callback: () => this.expandGasZone(),
      loop: true
    });

    // ÏΩîÏñ¥ ÌÖîÎ†àÌè¨Ìä∏ ÏãúÏûë
    this.nexusTeleportCount = 0;
    this.time.delayedCall(2000, () => {
      this.startNexusTeleportCycle();
    });
  }

  startNexusTeleportCycle() {
    if (this.nexusPhase !== 'phase3' || !this.nexusMode) return;

    this.nexusTeleportCount++;

    // ÌÖîÎ†àÌè¨Ìä∏ Ï†Ñ Í∏ÄÎ¶¨Ïπò
    this.showNexusTeleportWarning();

    this.time.delayedCall(500, () => {
      // Ïù¥Ï†Ñ ÏúÑÏπòÏóê ÏßÄÎ¢∞ ÏÉùÏÑ±
      this.spawnNexusMine(this.nexusPosition.x, this.nexusPosition.y);

      // ÏÉà ÏúÑÏπòÎ°ú ÌÖîÎ†àÌè¨Ìä∏
      this.teleportNexus();

      // vulnerable ÏÉÅÌÉú (1.5Ï¥à)
      this.time.delayedCall(500, () => {
        this.setNexusVulnerable();

        // 2Ï¥à ÌõÑ Îã§Ïùå ÌÖîÎ†àÌè¨Ìä∏
        this.time.delayedCall(2000, () => {
          if (this.nexusPhase === 'phase3' && this.nexusMode) {
            this.startNexusTeleportCycle();
          }
        });
      });
    });
  }

  showNexusTeleportWarning() {
    if (!this.nexusElement) return;

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º
    this.tweens.add({
      targets: this.nexusElement,
      alpha: 0.3,
      duration: 50,
      yoyo: true,
      repeat: 4
    });
  }

  teleportNexus() {
    // ÏïàÏ†ÑÌïú ÏúÑÏπò Ï∞æÍ∏∞ (Í∞ÄÏä§Ï°¥ Î∞ñ, Î±Ä ÏúÑÏπò ÏïÑÎãò)
    let newX, newY;
    let attempts = 0;

    do {
      newX = Phaser.Math.Between(3, this.cols - 4);
      newY = Phaser.Math.Between(3, this.rows - 4);
      attempts++;
    } while (
      (this.isInGasZone && this.isInGasZone(newX, newY)) ||
      this.snake.some(s => s.x === newX && s.y === newY) ||
      attempts < 20
    );

    // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    this.nexusPosition.x = newX;
    this.nexusPosition.y = newY;

    // ÏãúÍ∞ÅÏ†Å ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    if (this.nexusElement) {
      const pixelX = newX * this.gridSize + this.gridSize / 2;
      const pixelY = newY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      // ÌÖîÎ†àÌè¨Ìä∏ Ïù¥ÌéôÌä∏
      this.cameras.main.flash(100, 0, 255, 255);
      this.nexusElement.setPosition(pixelX, pixelY);
    }
  }

  spawnNexusMine(x, y) {
    const pixelX = x * this.gridSize + this.gridSize / 2;
    const pixelY = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÏßÄÎ¢∞ Í∑∏ÎûòÌîΩ
    const mine = this.add.container(pixelX, pixelY);
    mine.setDepth(85);

    const mineBody = this.add.circle(0, 0, 8, 0xff0000);
    mineBody.setStrokeStyle(2, 0xffff00);
    mine.add(mineBody);

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏
    const countText = this.add.text(0, 0, '5', {
      fontSize: '10px',
      fontFamily: 'monospace',
      color: '#ffffff'
    }).setOrigin(0.5);
    mine.add(countText);

    const mineObj = {
      element: mine,
      x: x,
      y: y,
      countdown: 5
    };
    this.nexusMines.push(mineObj);

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: mine,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 300,
      yoyo: true,
      repeat: -1
    });

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
    const countdownTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        // Í∞ùÏ≤¥Í∞Ä ÌååÍ¥¥ÎêòÏóàÎäîÏßÄ Ï≤¥ÌÅ¨
        if (!countText || !countText.active) {
          countdownTimer.destroy();
          return;
        }

        mineObj.countdown--;
        countText.setText(mineObj.countdown.toString());

        if (mineObj.countdown <= 0) {
          // Ìè≠Î∞ú
          this.explodeNexusMine(mineObj);
          countdownTimer.destroy();
        }
      },
      loop: true
    });

    // ÌÉÄÏù¥Î®∏ Ï∞∏Ï°∞ Ï†ÄÏû• (Ï†ïÎ¶¨Ïö©)
    mineObj.countdownTimer = countdownTimer;
  }

  explodeNexusMine(mineObj) {
    const pixelX = mineObj.x * this.gridSize + this.gridSize / 2;
    const pixelY = mineObj.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
    for (let i = 0; i < 8; i++) {
      const particle = this.add.circle(pixelX, pixelY, 4, 0xff0000);
      const angle = (i / 8) * Math.PI * 2;
      this.tweens.add({
        targets: particle,
        x: pixelX + Math.cos(angle) * 40,
        y: pixelY + Math.sin(angle) * 40,
        alpha: 0,
        duration: 400,
        onComplete: () => particle.destroy()
      });
    }

    this.cameras.main.shake(100, 0.01);

    // ÏßÄÎ¢∞ Ï†úÍ±∞
    const idx = this.nexusMines.indexOf(mineObj);
    if (idx >= 0) this.nexusMines.splice(idx, 1);

    if (mineObj.element) {
      this.tweens.killTweensOf(mineObj.element);
      mineObj.element.destroy();
    }
  }

  // ========== NEXUS ÎåÄÏãú ÏãúÏä§ÌÖú ==========

  startNexusDashCharge() {
    // Ïø®Îã§Ïö¥ Ï≤¥ÌÅ¨
    const now = Date.now();
    if (!this.nexusDashReady || now - this.nexusLastDashTime < this.nexusDashCooldown) {
      // Ïø®Îã§Ïö¥ Ï§ë ÌîºÎìúÎ∞±
      if (this.nexusDashUI && this.nexusDashUI.container) {
        this.tweens.add({
          targets: this.nexusDashUI.container,
          x: { from: this.nexusDashUI.container.x - 5, to: this.nexusDashUI.container.x + 5 },
          duration: 50,
          yoyo: true,
          repeat: 2
        });
      }
      return;
    }

    this.nexusDashCharging = true;
    this.nexusDashChargeStart = now;

    // Ï∞®ÏßÄ ÏãúÏûë Ìö®Í≥º
    if (this.nexusDashUI && this.nexusDashUI.gauge) {
      this.nexusDashUI.gauge.clear();
      this.nexusDashUI.gauge.fillStyle(0x00ffff, 0.8);
      this.nexusDashUI.gauge.fillRect(-25, -8, 1, 16);
    }

    // Ï∞®ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    if (this.nexusDashChargeTimer) {
      this.nexusDashChargeTimer.destroy();
    }
    this.nexusDashChargeTimer = this.time.addEvent({
      delay: 50,
      callback: () => this.updateNexusDashCharge(),
      loop: true
    });
  }

  updateNexusDashCharge() {
    if (!this.nexusDashCharging) {
      if (this.nexusDashChargeTimer) {
        this.nexusDashChargeTimer.destroy();
        this.nexusDashChargeTimer = null;
      }
      return;
    }

    const now = Date.now();
    const chargeTime = now - this.nexusDashChargeStart;
    const chargeRatio = Math.min(chargeTime / this.nexusMaxChargeTime, 1);

    // Í≤åÏù¥ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
    if (this.nexusDashUI && this.nexusDashUI.gauge) {
      this.nexusDashUI.gauge.clear();
      this.nexusDashUI.gauge.fillStyle(0x00ffff, 0.8);
      this.nexusDashUI.gauge.fillRect(-25, -8, 50 * chargeRatio, 16);
    }

    // Î±Ä Î®∏Î¶¨ Í∏ÄÎ°úÏö∞ Ìö®Í≥º
    if (this.snakeHeadGlow && chargeRatio > 0.3) {
      const glowIntensity = 0.3 + chargeRatio * 0.5;
      this.snakeHeadGlow.setAlpha(glowIntensity);
    }
  }

  executeNexusDash() {
    if (!this.nexusDashCharging) return;

    this.nexusDashCharging = false;
    if (this.nexusDashChargeTimer) {
      this.nexusDashChargeTimer.destroy();
      this.nexusDashChargeTimer = null;
    }

    const now = Date.now();
    const chargeTime = now - this.nexusDashChargeStart;

    // ÏµúÏÜå Ï∞®ÏßÄ ÏãúÍ∞Ñ (0.2Ï¥à)
    if (chargeTime < 200) {
      // Í≤åÏù¥ÏßÄ Î¶¨ÏÖã
      if (this.nexusDashUI && this.nexusDashUI.gauge) {
        this.nexusDashUI.gauge.clear();
        this.nexusDashUI.gauge.fillStyle(0x00ffff, 0.8);
        this.nexusDashUI.gauge.fillRect(-25, -8, 50, 16);
      }
      return;
    }

    // ÎåÄÏãú Í±∞Î¶¨ Í≥ÑÏÇ∞ (2~6Ïπ∏)
    const chargeRatio = Math.min(chargeTime / this.nexusMaxChargeTime, 1);
    const dashDistance = Math.floor(2 + chargeRatio * 4);

    // ÎåÄÏãú Ïã§Ìñâ
    this.performNexusDash(dashDistance);
  }

  performNexusDash(distance) {
    this.nexusDashing = true;
    this.nexusDashReady = false;
    this.nexusLastDashTime = Date.now();

    const head = this.snake[0];
    let dx = 0, dy = 0;

    // ÌòÑÏû¨ Î∞©Ìñ•Ïóê Îî∞Î•∏ Ïù¥Îèô
    switch (this.direction) {
      case 'UP': dy = -1; break;
      case 'DOWN': dy = 1; break;
      case 'LEFT': dx = -1; break;
      case 'RIGHT': dx = 1; break;
    }

    // Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞ (Î≤Ω Ï∂©Îèå Î∞©ÏßÄ)
    let targetX = head.x + dx * distance;
    let targetY = head.y + dy * distance;

    // Î≤Ω Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
    targetX = Math.max(0, Math.min(this.cols - 1, targetX));
    targetY = Math.max(0, Math.min(this.rows - 1, targetY));

    // ÏûîÏÉÅ Ìö®Í≥º ÏÉùÏÑ±
    const startX = head.x * this.gridSize + this.gridSize / 2;
    const startY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    const endX = targetX * this.gridSize + this.gridSize / 2;
    const endY = targetY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 4Í∞úÏùò ÏûîÏÉÅ
    for (let i = 0; i < 4; i++) {
      const ratio = i / 4;
      const ghostX = startX + (endX - startX) * ratio;
      const ghostY = startY + (endY - startY) * ratio;

      const ghost = this.add.circle(ghostX, ghostY, this.gridSize / 2 - 2, 0x00ffff, 0.6);
      ghost.setDepth(80);

      this.tweens.add({
        targets: ghost,
        alpha: 0,
        scaleX: 0.3,
        scaleY: 0.3,
        duration: 400,
        delay: i * 50,
        onComplete: () => ghost.destroy()
      });
    }

    // ÏãúÏïàÏÉâ Ìä∏Î†àÏùº
    const trail = this.add.graphics();
    trail.lineStyle(4, 0x00ffff, 0.8);
    trail.lineBetween(startX, startY, endX, endY);
    trail.setDepth(75);

    this.tweens.add({
      targets: trail,
      alpha: 0,
      duration: 500,
      onComplete: () => trail.destroy()
    });

    // Î±Ä ÏúÑÏπò ÏàúÍ∞ÑÏù¥Îèô
    const actualDistance = Math.abs(targetX - head.x) + Math.abs(targetY - head.y);
    for (let i = 0; i < actualDistance && i < this.snake.length; i++) {
      if (i === 0) {
        this.snake[0].x = targetX;
        this.snake[0].y = targetY;
      } else {
        // Íº¨Î¶¨ Î∂ÄÎ∂ÑÎèÑ ÎåÄÏãú Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô
        const segDist = Math.min(i, actualDistance);
        this.snake[i].x = targetX - dx * segDist;
        this.snake[i].y = targetY - dy * segDist;
      }
    }

    // "DASH!" ÌÖçÏä§Ìä∏
    const dashText = this.add.text(endX, endY - 30, 'DASH!', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0.5).setDepth(300);

    this.tweens.add({
      targets: dashText,
      y: endY - 60,
      alpha: 0,
      duration: 600,
      onComplete: () => dashText.destroy()
    });

    // Î†åÎçîÎßÅ ÏóÖÎç∞Ïù¥Ìä∏
    this.draw();

    // ÎåÄÏãú ÏÉÅÌÉú Ìï¥Ï†ú Î∞è Ïø®Îã§Ïö¥ ÏãúÏûë
    this.time.delayedCall(200, () => {
      this.nexusDashing = false;
    });

    // Ïø®Îã§Ïö¥ ÌõÑ ÎåÄÏãú Ï§ÄÎπÑ
    this.time.delayedCall(this.nexusDashCooldown, () => {
      this.nexusDashReady = true;
      // ÎåÄÏãú Í≤åÏù¥ÏßÄ Î¶¨ÏÖã
      if (this.nexusDashUI && this.nexusDashUI.gauge) {
        this.nexusDashUI.gauge.clear();
        this.nexusDashUI.gauge.fillStyle(0x00ffff, 0.8);
        this.nexusDashUI.gauge.fillRect(-25, -8, 50, 16);
      }
      // "READY!" ÌëúÏãú
      if (this.nexusDashUI && this.nexusDashUI.text) {
        this.nexusDashUI.text.setText('DASH READY');
        this.tweens.add({
          targets: this.nexusDashUI.text,
          scaleX: 1.2,
          scaleY: 1.2,
          duration: 200,
          yoyo: true
        });
      }
    });

    // Ïø®Îã§Ïö¥ UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updateNexusDashCooldownUI();
  }

  updateNexusDashCooldownUI() {
    if (!this.nexusDashUI) return;

    const startTime = Date.now();
    const updateCooldown = () => {
      const elapsed = Date.now() - startTime;
      const remaining = this.nexusDashCooldown - elapsed;

      if (remaining <= 0 || this.nexusDashReady) {
        if (this.nexusDashUI && this.nexusDashUI.text) {
          this.nexusDashUI.text.setText('DASH READY');
        }
        return;
      }

      if (this.nexusDashUI && this.nexusDashUI.text) {
        this.nexusDashUI.text.setText(`COOLDOWN ${(remaining / 1000).toFixed(1)}s`);
      }

      // Í≤åÏù¥ÏßÄ ÌöåÏÉâÏúºÎ°ú
      if (this.nexusDashUI && this.nexusDashUI.gauge) {
        const ratio = elapsed / this.nexusDashCooldown;
        this.nexusDashUI.gauge.clear();
        this.nexusDashUI.gauge.fillStyle(0x666666, 0.5);
        this.nexusDashUI.gauge.fillRect(-25, -8, 50, 16);
        this.nexusDashUI.gauge.fillStyle(0x00ffff, 0.8);
        this.nexusDashUI.gauge.fillRect(-25, -8, 50 * ratio, 16);
      }

      this.time.delayedCall(100, updateCooldown);
    };

    updateCooldown();
  }

  showNexusPhaseText(text) {
    const { width, height } = this.cameras.main;

    const phaseText = this.add.text(width / 2, height / 2, text, {
      fontSize: '32px',
      fontFamily: 'monospace',
      color: '#00ffff'
    }).setOrigin(0.5).setDepth(300);

    this.tweens.add({
      targets: phaseText,
      scaleX: 1.2,
      scaleY: 1.2,
      alpha: 0,
      duration: 2000,
      ease: 'Power2',
      onComplete: () => phaseText.destroy()
    });
  }

  // ========== NEXUS HIT ÏãúÏä§ÌÖú ==========

  handleNexusHit() {
    this.nexusHitCount++;
    this.nexusVulnerable = false;
    console.log(`[NEXUS] HIT ${this.nexusHitCount}/4`);

    const { width, height } = this.cameras.main;

    // HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    if (this.nexusHPSegments && this.nexusHPSegments[4 - this.nexusHitCount]) {
      const segment = this.nexusHPSegments[4 - this.nexusHitCount];
      this.tweens.add({
        targets: segment,
        fillColor: 0x444444,
        alpha: 0.3,
        duration: 300
      });
    }

    // HIT ÌëúÏãú
    const hitText = this.add.text(width / 2, height / 2 - 50, `HIT ${this.nexusHitCount}/4!`, {
      fontSize: '42px',
      fontFamily: 'monospace',
      color: '#00ff00'
    }).setOrigin(0.5).setDepth(300);

    this.tweens.add({
      targets: hitText,
      scaleX: 1.5,
      scaleY: 1.5,
      alpha: 0,
      duration: 1000,
      onComplete: () => hitText.destroy()
    });

    // Î≥¥Ïä§ ÌîºÍ≤© Ìö®Í≥º
    this.cameras.main.shake(400, 0.025);
    this.cameras.main.flash(200, 0, 255, 255);

    if (this.nexusElement) {
      this.tweens.add({
        targets: this.nexusElement,
        alpha: 0.2,
        duration: 80,
        yoyo: true,
        repeat: 4
      });
    }

    // ÏΩîÏñ¥ Î≥µÏõê
    this.restoreNexusCore();

    // Phase Ï†ÑÌôò ÎòêÎäî ÏäπÎ¶¨
    if (this.nexusHitCount === 1 && this.nexusPhase === 'phase1') {
      this.time.delayedCall(1500, () => {
        this.startNexusPhase2();
      });
    } else if (this.nexusHitCount === 3 && this.nexusPhase === 'phase2') {
      this.time.delayedCall(1500, () => {
        this.startNexusPhase3();
      });
    } else if (this.nexusHitCount >= 4) {
      this.showNexusVictory();
    }
  }

  // ========== NEXUS ÏäπÎ¶¨ Ïó∞Ï∂ú ==========
  showNexusVictory() {
    console.log('[NEXUS] Victory!');
    this.nexusPhase = 'victory';
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;
    const centerX = this.nexusPosition.x * this.gridSize + this.gridSize / 2;
    const centerY = this.nexusPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ïä¨Î°úÏö∞Î™®ÏÖò
    this.tweens.timeScale = 0.3;

    // Î≥¥Ïä§ ÎåÄÏÇ¨: "SYSTEM... FAILURE..."
    const failureText = this.add.text(centerX, centerY - 60, 'SYSTEM... FAILURE...', {
      fontSize: '20px',
      fontFamily: 'monospace',
      color: '#ff0000'
    }).setOrigin(0.5).setDepth(350);

    // ÌÖçÏä§Ìä∏ Îñ®Î¶º Ìö®Í≥º
    this.tweens.add({
      targets: failureText,
      x: { from: centerX - 3, to: centerX + 3 },
      duration: 50,
      yoyo: true,
      repeat: 20
    });

    // 1Ï¥à ÌõÑ Í∏ÄÎ¶¨Ïπò Ìè≠Î∞ú
    this.time.delayedCall(1000 / 0.3, () => {
      failureText.destroy();

      // Í∏ÄÎ¶¨Ïπò ÌååÌé∏ Ìè≠Î∞ú (50Í∞ú)
      for (let i = 0; i < 50; i++) {
        const size = Phaser.Math.Between(4, 12);
        const color = [0x00ffff, 0xff00ff, 0x00ff00, 0xffff00][i % 4];
        const fragment = this.add.rectangle(centerX, centerY, size, size, color);
        fragment.setDepth(300);

        const angle = (i / 50) * Math.PI * 2 + Math.random() * 0.5;
        const dist = Phaser.Math.Between(100, 250);
        const duration = Phaser.Math.Between(800, 1500);

        this.tweens.add({
          targets: fragment,
          x: centerX + Math.cos(angle) * dist,
          y: centerY + Math.sin(angle) * dist,
          rotation: Math.random() * Math.PI * 4,
          alpha: 0,
          scaleX: 0.1,
          scaleY: 0.1,
          duration: duration,
          ease: 'Power2',
          onComplete: () => fragment.destroy()
        });
      }

      // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
      this.cameras.main.shake(1000, 0.05);

      // Í∞ÄÏä§Ï°¥ ÏÜåÎ©∏ (Ïó≠Î∞©Ìñ• ÌôïÏû•)
      if (this.gasZoneEnabled) {
        this.gasZoneEnabled = false;
        if (this.gasZoneTimer) {
          this.gasZoneTimer.destroy();
          this.gasZoneTimer = null;
        }
        if (this.gasZoneGraphics) {
          this.tweens.add({
            targets: this.gasZoneGraphics,
            alpha: 0,
            duration: 500,
            onComplete: () => {
              this.gasZoneGraphics.clear();
            }
          });
        }
      }

      // Î≥¥Ïä§ ÎåÄÌè≠Î∞ú
      this.time.delayedCall(500, () => {
        // EMP ÎßÅ 3Ìöå
        for (let r = 0; r < 3; r++) {
          this.time.delayedCall(r * 200, () => {
            const ring = this.add.graphics();
            ring.lineStyle(4, 0x00ffff, 1);
            ring.strokeCircle(centerX, centerY, 10);
            ring.setDepth(280);

            this.tweens.add({
              targets: ring,
              scaleX: 15,
              scaleY: 15,
              alpha: 0,
              duration: 600,
              onComplete: () => ring.destroy()
            });
          });
        }

        // Î≥¥Ïä§ ÏöîÏÜå Ìè≠Î∞ú
        if (this.nexusElement) {
          this.tweens.add({
            targets: this.nexusElement,
            scaleX: 3,
            scaleY: 3,
            alpha: 0,
            duration: 800,
            onComplete: () => {
              if (this.nexusElement) {
                this.nexusElement.destroy();
                this.nexusElement = null;
              }
            }
          });
        }

        // ÌôîÎ©¥ ÌôîÏù¥Ìä∏ÏïÑÏõÉ
        this.time.delayedCall(500, () => {
          this.cameras.main.flash(800, 255, 255, 255);

          // Ïä¨Î°úÏö∞Î™®ÏÖò Ìï¥Ï†ú
          this.tweens.timeScale = 1;

          // "NEXUS TERMINATED" ÌÖçÏä§Ìä∏
          this.time.delayedCall(500, () => {
            const terminatedText = this.add.text(width / 2, height / 2 - 60, 'NEXUS TERMINATED', {
              fontSize: '36px',
              fontFamily: 'monospace',
              color: '#00ff00'
            }).setOrigin(0.5).setDepth(350);
            terminatedText.setAlpha(0);

            this.tweens.add({
              targets: terminatedText,
              alpha: 1,
              duration: 500
            });

            // "FIREWALL DISABLED"
            this.time.delayedCall(1000, () => {
              const firewallText = this.add.text(width / 2, height / 2 - 20, 'FIREWALL DISABLED', {
                fontSize: '24px',
                fontFamily: 'monospace',
                color: '#00ffff'
              }).setOrigin(0.5).setDepth(350);
              firewallText.setAlpha(0);

              this.tweens.add({
                targets: firewallText,
                alpha: 1,
                duration: 500
              });

              // "+1000 BONUS!"
              this.time.delayedCall(1000, () => {
                const bonusText = this.add.text(width / 2, height / 2 + 30, '+1000 BONUS!', {
                  fontSize: '32px',
                  fontFamily: 'monospace',
                  color: '#ffff00'
                }).setOrigin(0.5).setDepth(350);

                this.score += 1000;
                this.scoreText.setText(this.score.toString());

                // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
                this.tweens.add({
                  targets: bonusText,
                  scaleX: 1.3,
                  scaleY: 1.3,
                  duration: 300,
                  yoyo: true,
                  repeat: 2
                });

                // Ï†ïÎ¶¨ Î∞è ÏÉÅÏ†ê Ïò§Ìîà
                this.time.delayedCall(2000, () => {
                  terminatedText.destroy();
                  firewallText.destroy();
                  bonusText.destroy();

                  // 15ÌÉÑ Î≥¥Ïä§ BGM Ï†ïÏßÄ ÌõÑ Í∏∞Î≥∏ BGMÏúºÎ°ú ÏõêÎ≥µ
                  if (this.boss15Music && this.boss15Music.isPlaying) {
                    this.boss15Music.stop();
                  }
                  if (this.bgMusic && !this.bgMusic.isPlaying) {
                    this.bgMusic.play();
                  }

                  this.cleanupNexus();
                  this.nexusMode = false;
                  this.stageClear();
                });
              });
            });
          });
        });
      });
    });
  }

  // NEXUS Ï†ïÎ¶¨
  cleanupNexus() {
    console.log('[NEXUS] Cleanup');

    // Î™®Îì† NEXUS ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.nexusAnimTimer) {
      this.nexusAnimTimer.destroy();
      this.nexusAnimTimer = null;
    }

    if (this.nexusScanTimer) {
      this.nexusScanTimer.destroy();
      this.nexusScanTimer = null;
    }

    if (this.nexusDataStormTimer) {
      this.nexusDataStormTimer.destroy();
      this.nexusDataStormTimer = null;
    }

    if (this.nexusTeleportTimer) {
      this.nexusTeleportTimer.destroy();
      this.nexusTeleportTimer = null;
    }

    if (this.nexusTrackerTimer) {
      this.nexusTrackerTimer.destroy();
      this.nexusTrackerTimer = null;
    }

    // NEXUS v2: Ï∂îÍ∞Ä ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.nexusTrackerFireTimer) {
      this.nexusTrackerFireTimer.destroy();
      this.nexusTrackerFireTimer = null;
    }

    // Î≥¥Ïä§ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.nexusElement) {
      this.tweens.killTweensOf(this.nexusElement);
      this.nexusElement.destroy();
      this.nexusElement = null;
    }

    // HP Î∞î Ï†ïÎ¶¨
    if (this.nexusHPBar) {
      if (this.nexusHPBar.container) {
        this.nexusHPBar.container.destroy();
      }
      this.nexusHPBar = null;
    }

    // Phase ÌÖçÏä§Ìä∏ Ï†ïÎ¶¨
    if (this.nexusPhaseText) {
      this.nexusPhaseText.destroy();
      this.nexusPhaseText = null;
    }

    // ÎåÄÏãú UI Ï†ïÎ¶¨
    if (this.nexusDashUI) {
      if (this.nexusDashUI.container) {
        this.nexusDashUI.container.destroy();
      }
      this.nexusDashUI = null;
    }

    // Ïä§Ï∫î Îπî Ï†ïÎ¶¨
    if (this.nexusScanBeams) {
      this.nexusScanBeams.forEach(beam => {
        if (beam.warning) beam.warning.destroy();
        if (beam.laser) beam.laser.destroy();
      });
      this.nexusScanBeams = [];
    }

    // Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù Ï†ïÎ¶¨
    if (this.nexusDataBlocks) {
      this.nexusDataBlocks.forEach(block => {
        if (block.shadow) block.shadow.destroy();
        if (block.element) block.element.destroy();
      });
      this.nexusDataBlocks = [];
    }

    // Ï∂îÏ†ÅÌÉÑ Ï†ïÎ¶¨
    if (this.nexusTrackers) {
      this.nexusTrackers.forEach(tracker => {
        if (tracker.element) tracker.element.destroy();
      });
      this.nexusTrackers = [];
    }

    // ÏßÄÎ¢∞ Ï†ïÎ¶¨
    if (this.nexusMines) {
      this.nexusMines.forEach(mine => {
        if (mine.element) mine.element.destroy();
        if (mine.timer) mine.timer.destroy();
      });
      this.nexusMines = [];
    }

    // EMP ÏÑúÏßÄ Ï†ïÎ¶¨
    if (this.nexusEMPSurge) {
      if (this.nexusEMPSurge.element) {
        this.nexusEMPSurge.element.destroy();
      }
      this.nexusEMPSurge = null;
    }

    // NEXUS v2: Í≥†Ïä§Ìä∏ Î±Ä Ï†ïÎ¶¨
    if (this.nexusGhostSnakes) {
      this.nexusGhostSnakes.forEach(ghost => {
        if (ghost.container) {
          this.tweens.killTweensOf(ghost);
          ghost.container.destroy();
        }
      });
      this.nexusGhostSnakes = [];
    }

    // NEXUS v2: Î∞îÏù¥ÎÑàÎ¶¨ ÎÖ∏Îìú Ï†ïÎ¶¨
    if (this.nexusBinaryNodes) {
      this.nexusBinaryNodes.forEach(node => {
        if (node.element) node.element.destroy();
      });
      this.nexusBinaryNodes = [];
    }

    // NEXUS v2: ÏãúÌÄÄÏä§ UI Ï†ïÎ¶¨
    if (this.nexusSequenceUI) {
      if (this.nexusSequenceUI.container) {
        this.nexusSequenceUI.container.destroy();
      }
      this.nexusSequenceUI = null;
    }

    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.nexusMode = false;
    this.nexusPhase = 'none';
    this.nexusHitCount = 0;
    this.nexusVulnerable = false;
    this.nexusDashCharging = false;
    this.nexusDashReady = true;
    this.nexusPhase2AttackCount = 0;

    // NEXUS v2 ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.nexusRound = 0;
    this.nexusBinarySequence = [];
    this.nexusBinaryCollected = [];
    this.nexusTotalNodesCollected = 0;
  }

  // NEXUS Ï∂©Îèå Ï≤¥ÌÅ¨
  checkNexusHazardCollision(tileX, tileY) {
    if (!this.nexusMode) return false;

    const px = tileX * this.gridSize + this.gridSize / 2;
    const py = tileY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // NEXUS v2: Í≥†Ïä§Ìä∏ Î±Ä Ï∂©Îèå (Ïä§Ï∫îÏúºÎ°ú ÏÉùÏÑ±Îêú Îç∞ÎìúÏ°¥)
    if (this.nexusGhostSnakes && this.nexusGhostSnakes.length > 0) {
      for (const ghost of this.nexusGhostSnakes) {
        for (const seg of ghost.body) {
          if (seg.x === tileX && seg.y === tileY) {
            return true;
          }
        }
      }
    }

    // Îç∞Ïù¥ÌÑ∞ Î∏îÎ°ù Ï∂©Îèå
    if (this.nexusDataBlocks && this.nexusDataBlocks.length > 0) {
      for (const block of this.nexusDataBlocks) {
        if (block.landed && block.x === tileX && block.y === tileY) {
          return true;
        }
      }
    }

    // Ï∂îÏ†ÅÌÉÑ Ï∂©Îèå
    if (this.nexusTrackers && this.nexusTrackers.length > 0) {
      for (const tracker of this.nexusTrackers) {
        const dist = Math.sqrt(Math.pow(tileX - tracker.x, 2) + Math.pow(tileY - tracker.y, 2));
        if (dist < 1) return true;
      }
    }

    // EMP ÏÑúÏßÄ Ï∂©Îèå (ÎåÄÏãú Ï§ëÏù¥Î©¥ Î¨¥Ïãú)
    if (this.nexusEMPSurge && this.nexusEMPSurge.active && !this.nexusDashing) {
      const centerX = this.nexusPosition.x;
      const centerY = this.nexusPosition.y;
      const dist = Math.sqrt(Math.pow(tileX - centerX, 2) + Math.pow(tileY - centerY, 2));
      const surgeRadius = this.nexusEMPSurge.radius;
      if (Math.abs(dist - surgeRadius) < 1.5) return true;
    }

    // ÏßÄÎ¢∞ Ï∂©Îèå
    if (this.nexusMines && this.nexusMines.length > 0) {
      for (const mine of this.nexusMines) {
        if (mine.x === tileX && mine.y === tileY) {
          this.explodeNexusMine(mine);
          return true;
        }
      }
    }

    return false;
  }

  // NEXUS Î≥¥Ïä§ Ï∂©Îèå Ï≤¥ÌÅ¨ (HIT ÌåêÏ†ïÏö©)
  checkNexusBossCollision(tileX, tileY) {
    if (!this.nexusMode || !this.nexusVulnerable || !this.nexusPosition) return false;

    // Î≥¥Ïä§ ÏúÑÏπòÏôÄ ÎπÑÍµê (2x2 ÏòÅÏó≠)
    const bx = this.nexusPosition.x;
    const by = this.nexusPosition.y;

    if (tileX >= bx - 1 && tileX <= bx + 1 &&
        tileY >= by - 1 && tileY <= by + 1) {
      this.handleNexusHit();
      return true;
    }

    return false;
  }

  // ========== ÌÉÑÎßâ ÏäàÌåÖ Î≥¥Ïä§ ÏãúÏä§ÌÖú (Bullet Hell Boss) ==========

  // ÌöåÌîº ÏãúÏä§ÌÖú - Ïä§ÌéòÏù¥Ïä§Î∞îÎ°ú ÏÇ¨Ïù¥Îìú Î°§
  handleDodge() {
    // üÜï QTE Îã∑ÏßÄ Ï≤¥ÌÅ¨ (The Presence ÏãúÏä§ÌÖú)
    if (this.dodgeQTEActive) {
      this.handleDodgeQTEInput();
      return;
    }

    // Ïø®Îã§Ïö¥ Ï≤¥ÌÅ¨
    const now = Date.now();
    if (now - this.lastDodgeTime < this.dodgeCooldown) {
      // Ïø®Îã§Ïö¥ Ï§ë - Ïã§Ìå® ÌîºÎìúÎ∞±
      this.showDodgeCooldownFeedback();
      return;
    }

    // Í≤åÏûÑ ÏÉÅÌÉú Ï≤¥ÌÅ¨ - ÌÉÑÎßâ Î≥¥Ïä§ ÎòêÎäî ÏïàÍ∞ú Î≥¥Ïä§ Î™®ÎìúÏóêÏÑúÎßå
    if (this.gameOver) return;
    if (!this.bulletBossMode && !this.fogBossMode) return;

    // ÌöåÌîº Ïã§Ìñâ
    this.lastDodgeTime = now;
    this.canDodge = false;
    this.performSideRoll();

    // Ïø®Îã§Ïö¥ ÌõÑ ÌöåÌîº Í∞ÄÎä•
    this.time.delayedCall(this.dodgeCooldown, () => {
      this.canDodge = true;
      this.updateDodgeCooldownUI();
    });
  }

  performSideRoll() {
    // ÎåÄÏãú Ìö®Í≥ºÏùå
    this.sound.play('dash_effect', { volume: 0.3 });

    const head = this.snake[0];
    const direction = this.direction;
    let rollDx = 0;
    let rollDy = 0;
    const rollDistance = 3; // 3Ïπ∏ Ïù¥Îèô
    let rollAngle = 0; // Íµ¨Î•¥Í∏∞ Î∞©Ìñ• Í∞ÅÎèÑ

    // ÏßÑÌñâ Î∞©Ìñ•Ïóê ÏàòÏßÅÏù∏ Î∞©Ìñ•ÏúºÎ°ú Î°§
    if (direction === 'LEFT' || direction === 'RIGHT') {
      // ÏúÑ/ÏïÑÎûòÎ°ú Î≤àÍ∞àÏïÑÍ∞ÄÎ©∞ Î°§
      if (this.lastDodgeDirection === 'up') {
        rollDy = rollDistance;
        rollAngle = direction === 'RIGHT' ? Math.PI : -Math.PI;
        this.lastDodgeDirection = 'down';
      } else {
        rollDy = -rollDistance;
        rollAngle = direction === 'RIGHT' ? -Math.PI : Math.PI;
        this.lastDodgeDirection = 'up';
      }
    } else {
      // Ï¢å/Ïö∞Î°ú Î≤àÍ∞àÏïÑÍ∞ÄÎ©∞ Î°§
      if (this.lastDodgeDirection === 'left') {
        rollDx = rollDistance;
        rollAngle = direction === 'DOWN' ? -Math.PI : Math.PI;
        this.lastDodgeDirection = 'right';
      } else {
        rollDx = -rollDistance;
        rollAngle = direction === 'DOWN' ? Math.PI : -Math.PI;
        this.lastDodgeDirection = 'left';
      }
    }

    // ÏÉà ÏúÑÏπò Í≥ÑÏÇ∞ (Î≤Ω ÌÅ¥Îû®Ìïë)
    let newX = Math.max(0, Math.min(this.cols - 1, head.x + rollDx));
    let newY = Math.max(0, Math.min(this.rows - 1, head.y + rollDy));

    // ÏõêÎûò ÏúÑÏπò Ï†ÄÏû•
    const originalPositions = this.snake.map(s => ({ x: s.x, y: s.y }));

    // Î¨¥Ï†Å ÏÉÅÌÉú ÏãúÏûë
    this.isInvincible = true;

    // Î±Ä Ï†ÑÏ≤¥Î•º ÏÉà ÏúÑÏπòÎ°ú Ïù¥Îèô (ÏàúÍ∞ÑÏù¥Îèô)
    const offsetX = newX - head.x;
    const offsetY = newY - head.y;

    for (let i = 0; i < this.snake.length; i++) {
      this.snake[i].x += offsetX;
      this.snake[i].y += offsetY;

      // Î≤Ω ÌÅ¥Îû®Ìïë (Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏)
      this.snake[i].x = Math.max(0, Math.min(this.cols - 1, this.snake[i].x));
      this.snake[i].y = Math.max(0, Math.min(this.rows - 1, this.snake[i].y));
    }

    // === Í≥†Í∏â Íµ¨Î•¥Í∏∞ Ïù¥ÌéôÌä∏ ===
    this.createAdvancedRollEffect(originalPositions, offsetX, offsetY, rollAngle);

    // ÌöåÌîº Ïù¥ÌéôÌä∏ ÌëúÏãú
    this.showDodgeEffect(newX, newY);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(80, 0.008);

    // Î¨¥Ï†Å ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.startInvincibilityBlink();

    // Î≥¥Ìò∏Îßâ Ïù¥ÌéôÌä∏ ÏãúÏûë
    this.startPostDodgeShield();

    // Î¨¥Ï†Å Ìï¥Ï†ú (600ms ÌõÑ - Î∞òÏùë ÏãúÍ∞Ñ Í≥†Î†§)
    this.time.delayedCall(600, () => {
      this.isInvincible = false;
      this.stopInvincibilityBlink();
      this.stopPostDodgeShield();
    });

    // Îã§Ïãú Í∑∏Î¶¨Í∏∞
    this.draw();

    // Ïø®Îã§Ïö¥ UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updateDodgeCooldownUI();
  }

  // === Í≥†Í∏â Íµ¨Î•¥Í∏∞ Ïù¥ÌéôÌä∏ ÏãúÏä§ÌÖú ===
  createAdvancedRollEffect(originalPositions, offsetX, offsetY, rollAngle) {
    const gridSize = this.gridSize;
    const gameAreaY = this.gameAreaY;
    const rollDuration = 180; // Î°§ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏßÄÏÜçÏãúÍ∞Ñ
    const totalRotations = 1.5; // 1.5Î∞îÌÄ¥ ÌöåÏ†Ñ

    // 1. Î™®ÏÖò Î∏îÎü¨ Ìä∏Î†àÏùº (Ïù¥Ï†Ñ ‚Üí ÌòÑÏû¨ ÏúÑÏπò ÏÇ¨Ïù¥Ïóê Ïó¨Îü¨ Í∞ú)
    const trailCount = 8;
    for (let t = 0; t < trailCount; t++) {
      const progress = t / trailCount;
      const delayMs = t * 15;

      this.time.delayedCall(delayMs, () => {
        for (let i = 0; i < Math.min(originalPositions.length, 8); i++) {
          const orig = originalPositions[i];
          const interpX = orig.x + offsetX * progress;
          const interpY = orig.y + offsetY * progress;

          const pixelX = interpX * gridSize + gridSize / 2;
          const pixelY = interpY * gridSize + gridSize / 2 + gameAreaY;

          // Î™®ÏÖò Î∏îÎü¨ ÏÑ∏Í∑∏Î®ºÌä∏
          const blur = this.add.rectangle(
            pixelX, pixelY,
            gridSize - 2, gridSize - 2,
            i === 0 ? 0x00ffff : 0x00ff88,
            0.6 - progress * 0.5
          ).setDepth(95);

          // ÌöåÏ†Ñ Ìö®Í≥º (Íµ¨Î•¥Îäî ÎäêÎÇå)
          blur.setRotation(rollAngle * progress * totalRotations);

          // Ïä§ÏºÄÏùº ÏôúÍ≥° (Î™®ÏÖò Î∏îÎü¨ ÎäêÎÇå)
          const scaleX = 1 + Math.abs(Math.sin(progress * Math.PI)) * 0.3;
          const scaleY = 1 - Math.abs(Math.sin(progress * Math.PI)) * 0.2;
          blur.setScale(scaleX, scaleY);

          // Îπ†Î•∏ ÌéòÏù¥ÎìúÏïÑÏõÉ
          this.tweens.add({
            targets: blur,
            alpha: 0,
            scale: 0.3,
            duration: 120,
            ease: 'Power2.easeOut',
            onComplete: () => blur.destroy()
          });
        }
      });
    }

    // 2. ÏãúÏûëÏ†ê ÏóêÎÑàÏßÄ Î≤ÑÏä§Ìä∏
    const startX = originalPositions[0].x * gridSize + gridSize / 2;
    const startY = originalPositions[0].y * gridSize + gridSize / 2 + gameAreaY;

    // ÏóêÎÑàÏßÄ ÎßÅ (ÏãúÏûëÏ†ê)
    for (let r = 0; r < 3; r++) {
      const ring = this.add.circle(startX, startY, 8 + r * 5, 0x00ffff, 0).setDepth(96);
      ring.setStrokeStyle(3 - r, 0x00ffff, 0.8);

      this.tweens.add({
        targets: ring,
        radius: 30 + r * 15,
        alpha: 0,
        duration: 250 + r * 50,
        onUpdate: () => ring.setStrokeStyle(3 - r, 0x00ffff, ring.alpha),
        onComplete: () => ring.destroy()
      });
    }

    // ÏóêÎÑàÏßÄ Ïä§ÌååÌÅ¨ (ÏãúÏûëÏ†ê)
    for (let i = 0; i < 12; i++) {
      const angle = (Math.PI * 2 * i) / 12 + Math.random() * 0.3;
      const spark = this.add.rectangle(startX, startY, 8, 3, 0x00ffff, 1).setDepth(97);
      spark.setRotation(angle);

      this.tweens.add({
        targets: spark,
        x: startX + Math.cos(angle) * 40,
        y: startY + Math.sin(angle) * 40,
        alpha: 0,
        scaleX: 0.2,
        duration: 200,
        ease: 'Power2.easeOut',
        onComplete: () => spark.destroy()
      });
    }

    // 3. Íµ¨Î•¥Í∏∞ Ï§ëÏïô Í≤ΩÎ°úÏóê ÏóêÎÑàÏßÄ Ïõ®Ïù¥Î∏å
    const midX = (startX + (this.snake[0].x * gridSize + gridSize / 2)) / 2;
    const midY = (startY + (this.snake[0].y * gridSize + gridSize / 2 + gameAreaY)) / 2;

    const wave = this.add.ellipse(midX, midY, 60, 20, 0x00ff88, 0.6).setDepth(94);
    wave.setRotation(Math.atan2(offsetY, offsetX));

    this.tweens.add({
      targets: wave,
      scaleX: 2.5,
      scaleY: 0.5,
      alpha: 0,
      duration: 200,
      onComplete: () => wave.destroy()
    });

    // 4. ÎèÑÏ∞©Ï†ê Ï∞©ÏßÄ Ïù¥ÌéôÌä∏
    const endX = this.snake[0].x * gridSize + gridSize / 2;
    const endY = this.snake[0].y * gridSize + gridSize / 2 + gameAreaY;

    this.time.delayedCall(80, () => {
      // Ï∞©ÏßÄ Ï∂©Í≤©Ìåå
      const impact = this.add.circle(endX, endY, 5, 0xffff00, 0.8).setDepth(96);
      this.tweens.add({
        targets: impact,
        radius: 35,
        alpha: 0,
        duration: 200,
        onComplete: () => impact.destroy()
      });

      // Ï∞©ÏßÄ Î®ºÏßÄ ÌååÌã∞ÌÅ¥
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const dust = this.add.circle(
          endX + Math.cos(angle) * 10,
          endY + Math.sin(angle) * 10,
          3 + Math.random() * 2,
          0xffffaa, 0.7
        ).setDepth(95);

        this.tweens.add({
          targets: dust,
          x: endX + Math.cos(angle) * 25,
          y: endY + Math.sin(angle) * 25 + 5, // ÏïΩÍ∞Ñ ÏïÑÎûòÎ°ú
          alpha: 0,
          scale: 0.3,
          duration: 250,
          ease: 'Power2.easeOut',
          onComplete: () => dust.destroy()
        });
      }

      // Ï∞©ÏßÄ ÌîåÎûòÏãú
      const flash = this.add.rectangle(endX, endY, gridSize * 2, gridSize * 2, 0xffffff, 0.5).setDepth(94);
      this.tweens.add({
        targets: flash,
        alpha: 0,
        scale: 1.5,
        duration: 100,
        onComplete: () => flash.destroy()
      });
    });

    // 5. Ïã§Ï†ú Íµ¨Î•¥Îäî Î±Ä Ïï†ÎãàÎ©îÏù¥ÏÖò (ÏãúÍ∞ÅÏ†Å Ïò§Î≤ÑÎ†àÏù¥)
    this.createRollingSnakeAnimation(originalPositions, offsetX, offsetY, rollAngle, totalRotations, rollDuration);
  }

  createRollingSnakeAnimation(originalPositions, offsetX, offsetY, rollAngle, totalRotations, duration) {
    const gridSize = this.gridSize;
    const gameAreaY = this.gameAreaY;

    // Íµ¨Î•¥Îäî Î±Ä ÏÑ∏Í∑∏Î®ºÌä∏ Ïò§Î≤ÑÎ†àÏù¥
    const rollingSegments = [];

    for (let i = 0; i < Math.min(originalPositions.length, 6); i++) {
      const orig = originalPositions[i];
      const startPixelX = orig.x * gridSize + gridSize / 2;
      const startPixelY = orig.y * gridSize + gridSize / 2 + gameAreaY;

      // Íµ¨Î•¥Îäî ÏÑ∏Í∑∏Î®ºÌä∏ Ïª®ÌÖåÏù¥ÎÑà
      const container = this.add.container(startPixelX, startPixelY).setDepth(98);

      // Î©îÏù∏ ÏÑ∏Í∑∏Î®ºÌä∏
      const segment = this.add.rectangle(0, 0, gridSize - 2, gridSize - 2,
        i === 0 ? 0x00ff00 : 0x00cc00, 1);

      // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
      const glow = this.add.rectangle(0, 0, gridSize + 4, gridSize + 4,
        0x00ffff, 0.4);

      container.add([glow, segment]);
      rollingSegments.push(container);

      // Íµ¨Î•¥Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: container,
        x: (orig.x + offsetX) * gridSize + gridSize / 2,
        y: (orig.y + offsetY) * gridSize + gridSize / 2 + gameAreaY,
        rotation: rollAngle * totalRotations,
        duration: duration,
        ease: 'Power2.easeOut',
        delay: i * 15, // ÏÑ∏Í∑∏Î®ºÌä∏Î≥Ñ ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ (Î¨ºÍ≤∞ Ìö®Í≥º)
        onComplete: () => {
          // Ï∞©ÏßÄ Ïãú Ïä§ÏºÄÏùº Î∞îÏö¥Ïä§
          this.tweens.add({
            targets: container,
            scaleX: 1.2,
            scaleY: 0.8,
            duration: 50,
            yoyo: true,
            onComplete: () => {
              // ÌéòÏù¥ÎìúÏïÑÏõÉ
              this.tweens.add({
                targets: container,
                alpha: 0,
                duration: 80,
                onComplete: () => container.destroy()
              });
            }
          });
        }
      });

      // ÏÑ∏Í∑∏Î®ºÌä∏Î≥Ñ Ïä§ÏºÄÏùº ÏôúÍ≥° (Íµ¨Î•¥Îäî ÎäêÎÇå)
      this.tweens.add({
        targets: segment,
        scaleX: { from: 1, to: 1.3 },
        scaleY: { from: 1, to: 0.7 },
        duration: duration / 3,
        yoyo: true,
        repeat: 1
      });
    }
  }

  createDodgeGhostTrail() {
    // ÌòÑÏû¨ Î±Ä ÏúÑÏπòÏóê ÏûîÏÉÅ ÏÉùÏÑ±
    const ghostCount = 4;
    const snake = this.snake;

    for (let g = 0; g < ghostCount; g++) {
      this.time.delayedCall(g * 30, () => {
        for (let i = 0; i < Math.min(snake.length, 10); i++) {
          const segment = snake[i];
          const ghostAlpha = 0.6 - (g * 0.15);

          const ghost = this.add.rectangle(
            segment.x * this.gridSize + this.gridSize / 2,
            segment.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
            this.gridSize - 2,
            this.gridSize - 2,
            i === 0 ? 0x00ff00 : 0x00cc00,
            ghostAlpha
          ).setDepth(90);

          // ÏÇ¥Ïßù ÌöåÏ†Ñ Ìö®Í≥º
          ghost.setRotation((g - 2) * 0.1);

          // ÌéòÏù¥ÎìúÏïÑÏõÉ
          this.tweens.add({
            targets: ghost,
            alpha: 0,
            scale: 0.5,
            rotation: ghost.rotation + 0.5,
            duration: 200,
            ease: 'Power2.easeOut',
            onComplete: () => ghost.destroy()
          });
        }
      });
    }
  }

  showDodgeEffect(newX, newY) {
    const pixelX = newX * this.gridSize + this.gridSize / 2;
    const pixelY = newY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // === ÌôîÎ†§Ìïú "DODGE!" ÌÖçÏä§Ìä∏ ===
    // Í∑∏Î¶ºÏûê ÌÖçÏä§Ìä∏ (3D Ìö®Í≥º)
    const shadowText = this.add.text(pixelX + 3, pixelY - 27, 'DODGE!', {
      fontSize: '28px',
      fontStyle: 'bold',
      fill: '#000000'
    }).setOrigin(0.5).setDepth(1499).setAlpha(0);

    // Î©îÏù∏ ÌÖçÏä§Ìä∏
    const dodgeText = this.add.text(pixelX, pixelY - 30, 'DODGE!', {
      fontSize: '28px',
      fontStyle: 'bold',
      fill: '#00ffff',
      stroke: '#ffffff',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(1500).setAlpha(0);

    // Í∏ÄÎ°úÏö∞ ÌÖçÏä§Ìä∏ (Î∞∞Í≤Ω)
    const glowText = this.add.text(pixelX, pixelY - 30, 'DODGE!', {
      fontSize: '32px',
      fontStyle: 'bold',
      fill: '#00ffff'
    }).setOrigin(0.5).setDepth(1498).setAlpha(0);

    // ÌÖçÏä§Ìä∏ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: [shadowText, dodgeText, glowText],
      alpha: { value: 1, duration: 100 },
      y: pixelY - 60,
      scale: { from: 0.3, to: 1.3 },
      duration: 200,
      ease: 'Back.easeOut'
    });

    // Í∏ÄÎ°úÏö∞ ÌéÑÏä§ Ìö®Í≥º
    this.tweens.add({
      targets: glowText,
      scale: 1.5,
      alpha: 0.3,
      duration: 150,
      yoyo: true,
      repeat: 2
    });

    // ÌÖçÏä§Ìä∏ Ìá¥Ïû•
    this.time.delayedCall(350, () => {
      this.tweens.add({
        targets: [shadowText, dodgeText, glowText],
        alpha: 0,
        y: pixelY - 90,
        scale: 0.8,
        duration: 200,
        onComplete: () => {
          shadowText.destroy();
          dodgeText.destroy();
          glowText.destroy();
        }
      });
    });

    // === ÌôîÎ†§Ìïú Ï∞©ÏßÄ ÌååÌã∞ÌÅ¥ ===
    // Ïä§ÌîºÎìú ÎùºÏù∏ (Î∞©ÏÇ¨Ìòï)
    for (let i = 0; i < 16; i++) {
      const angle = (Math.PI * 2 * i) / 16;
      const lineLength = 20 + Math.random() * 15;

      const speedLine = this.add.rectangle(
        pixelX + Math.cos(angle) * 5,
        pixelY + Math.sin(angle) * 5,
        lineLength, 3,
        0x00ffff, 0.9
      ).setDepth(1500).setRotation(angle);

      this.tweens.add({
        targets: speedLine,
        x: pixelX + Math.cos(angle) * 50,
        y: pixelY + Math.sin(angle) * 50,
        alpha: 0,
        scaleX: 0.3,
        duration: 250,
        ease: 'Power3.easeOut',
        onComplete: () => speedLine.destroy()
      });
    }

    // Ïä§ÌååÌÅ¨ ÌååÌã∞ÌÅ¥ (Îã§ÏñëÌïú ÏÉâÏÉÅ)
    const sparkColors = [0x00ffff, 0xffff00, 0xffffff, 0x00ff00];
    for (let i = 0; i < 20; i++) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 20 + Math.random() * 30;
      const color = sparkColors[Math.floor(Math.random() * sparkColors.length)];

      const spark = this.add.circle(
        pixelX,
        pixelY,
        2 + Math.random() * 3,
        color, 1
      ).setDepth(1500);

      this.tweens.add({
        targets: spark,
        x: pixelX + Math.cos(angle) * dist,
        y: pixelY + Math.sin(angle) * dist,
        alpha: 0,
        scale: 0,
        duration: 350 + Math.random() * 150,
        ease: 'Power2.easeOut',
        onComplete: () => spark.destroy()
      });
    }

    // ÏóêÎÑàÏßÄ ÎßÅ (Ï∞©ÏßÄ Ï∂©Í≤©Ìåå)
    for (let r = 0; r < 2; r++) {
      const ring = this.add.circle(pixelX, pixelY, 10, 0x00ffff, 0).setDepth(1499);
      ring.setStrokeStyle(4 - r * 2, 0x00ffff, 0.8);

      this.tweens.add({
        targets: ring,
        radius: 40 + r * 20,
        duration: 300 + r * 100,
        onUpdate: () => ring.setStrokeStyle(4 - r * 2, 0x00ffff, ring.alpha || 0.8),
        onComplete: () => ring.destroy()
      });

      this.tweens.add({
        targets: ring,
        alpha: 0,
        duration: 300 + r * 100,
        delay: 100
      });
    }

    // ÏõêÌòï Ïõ®Ïù¥Î∏å Ïù¥ÌéôÌä∏
    const wave = this.add.circle(pixelX, pixelY, 5, 0xffff00, 0).setDepth(1499);
    wave.setStrokeStyle(2, 0xffff00, 0.8);

    this.tweens.add({
      targets: wave,
      radius: 40,
      alpha: 0,
      duration: 300,
      ease: 'Power2.easeOut',
      onUpdate: () => {
        wave.setStrokeStyle(2, 0xffff00, wave.alpha * 0.8);
      },
      onComplete: () => wave.destroy()
    });
  }

  startInvincibilityBlink() {
    // Îπ†Î•∏ ÍπúÎπ°ÏûÑ Ìö®Í≥ºÎ•º ÏúÑÌï¥ ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
    this.invincibilityBlinkActive = true;
    this.invincibilityBlinkCount = 0;

    // ÍπúÎπ°ÏûÑ ÌÉÄÏù¥Î®∏
    this.invincibilityBlinkTimer = this.time.addEvent({
      delay: 40,
      callback: () => {
        this.invincibilityBlinkCount++;
        // draw()ÏóêÏÑú Ï≤òÎ¶¨Ìï† Ïàò ÏûàÎèÑÎ°ù ÌîåÎûòÍ∑∏Îßå ÌÜ†Í∏Ä
        this.draw();
      },
      loop: true
    });
  }

  stopInvincibilityBlink() {
    this.invincibilityBlinkActive = false;
    if (this.invincibilityBlinkTimer) {
      this.invincibilityBlinkTimer.destroy();
      this.invincibilityBlinkTimer = null;
    }
    this.draw();
  }

  // === Îã∑ÏßÄ ÌõÑ Î≥¥Ìò∏Îßâ Ïù¥ÌéôÌä∏ ÏãúÏä§ÌÖú ===
  startPostDodgeShield() {
    // Í∏∞Ï°¥ Î≥¥Ìò∏Îßâ Ï†ïÎ¶¨
    this.stopPostDodgeShield();

    this.postDodgeShieldActive = true;
    this.postDodgeShieldElements = [];

    // Î±Ä Î®∏Î¶¨ Ï£ºÏúÑÏóê Î≥¥Ìò∏Îßâ ÏõêÌòï Ïù¥ÌéôÌä∏
    const head = this.snake[0];
    const pixelX = head.x * this.gridSize + this.gridSize / 2;
    const pixelY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 1. Ïô∏Î∂Ä Î≥¥Ìò∏Îßâ ÎßÅ (ÏãúÏïàÏÉâ)
    const shieldRing = this.add.circle(pixelX, pixelY, 25, 0x00ffff, 0).setDepth(150);
    shieldRing.setStrokeStyle(3, 0x00ffff, 0.8);
    this.postDodgeShieldElements.push(shieldRing);

    // 2. ÎÇ¥Î∂Ä Í∏ÄÎ°úÏö∞ ÌïÑÎìú
    const shieldGlow = this.add.circle(pixelX, pixelY, 20, 0x00ffff, 0.2).setDepth(149);
    this.postDodgeShieldElements.push(shieldGlow);

    // 3. ÌöåÏ†ÑÌïòÎäî Î≥¥Ìò∏Îßâ ÌååÌã∞ÌÅ¥Îì§
    this.shieldParticles = [];
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI * 2 * i) / 6;
      const particle = this.add.circle(
        pixelX + Math.cos(angle) * 22,
        pixelY + Math.sin(angle) * 22,
        3, 0x00ffff, 0.9
      ).setDepth(151);
      this.shieldParticles.push({ graphic: particle, angle: angle });
      this.postDodgeShieldElements.push(particle);
    }

    // Î≥¥Ìò∏Îßâ ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: shieldRing,
      scale: { from: 0.8, to: 1.2 },
      duration: 200,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    this.tweens.add({
      targets: shieldGlow,
      alpha: { from: 0.2, to: 0.4 },
      scale: { from: 1, to: 1.1 },
      duration: 150,
      yoyo: true,
      repeat: -1
    });

    // Î≥¥Ìò∏Îßâ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏ (Î±Ä ÏúÑÏπò Îî∞ÎùºÎã§ÎãàÍ∏∞ + ÌååÌã∞ÌÅ¥ ÌöåÏ†Ñ)
    this.postDodgeShieldTimer = this.time.addEvent({
      delay: 16, // 60fps
      callback: () => {
        if (!this.postDodgeShieldActive || !this.snake[0]) return;

        const head = this.snake[0];
        const newX = head.x * this.gridSize + this.gridSize / 2;
        const newY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

        // Î≥¥Ìò∏Îßâ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        if (shieldRing && shieldRing.active) {
          shieldRing.setPosition(newX, newY);
        }
        if (shieldGlow && shieldGlow.active) {
          shieldGlow.setPosition(newX, newY);
        }

        // ÌååÌã∞ÌÅ¥ ÌöåÏ†Ñ + ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
        if (this.shieldParticles) {
          for (const p of this.shieldParticles) {
            p.angle += 0.15; // ÌöåÏ†Ñ ÏÜçÎèÑ
            if (p.graphic && p.graphic.active) {
              p.graphic.setPosition(
                newX + Math.cos(p.angle) * 22,
                newY + Math.sin(p.angle) * 22
              );
            }
          }
        }
      },
      loop: true
    });

    // "PROTECTED" ÌÖçÏä§Ìä∏ ÌëúÏãú
    const protectedText = this.add.text(pixelX, pixelY - 40, 'PROTECTED', {
      fontFamily: 'Arial Black',
      fontSize: '12px',
      color: '#00ffff',
      stroke: '#003333',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(152).setAlpha(0);
    this.postDodgeShieldElements.push(protectedText);

    this.tweens.add({
      targets: protectedText,
      alpha: 1,
      y: pixelY - 50,
      duration: 200,
      ease: 'Power2.easeOut'
    });

    // ÌÖçÏä§Ìä∏ ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: protectedText,
      alpha: { from: 1, to: 0.5 },
      duration: 100,
      yoyo: true,
      repeat: -1,
      delay: 200
    });
  }

  stopPostDodgeShield() {
    this.postDodgeShieldActive = false;

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.postDodgeShieldTimer) {
      this.postDodgeShieldTimer.destroy();
      this.postDodgeShieldTimer = null;
    }

    // Î≥¥Ìò∏Îßâ ÏöîÏÜåÎì§ ÌéòÏù¥ÎìúÏïÑÏõÉ ÌõÑ Ï†úÍ±∞
    if (this.postDodgeShieldElements && this.postDodgeShieldElements.length > 0) {
      for (const element of this.postDodgeShieldElements) {
        if (element && element.active) {
          this.tweens.add({
            targets: element,
            alpha: 0,
            scale: 1.5,
            duration: 150,
            onComplete: () => {
              if (element && element.active) element.destroy();
            }
          });
        }
      }
      this.postDodgeShieldElements = [];
    }

    this.shieldParticles = null;
  }

  showDodgeCooldownFeedback() {
    // Ïø®Îã§Ïö¥ Ï§ëÏùº Îïå ÌîºÎìúÎ∞±
    if (this.dodgeCooldownUI) {
      // UI ÌùîÎì§Í∏∞
      this.tweens.add({
        targets: this.dodgeCooldownUI,
        x: this.dodgeCooldownUI.x - 5,
        duration: 50,
        yoyo: true,
        repeat: 3
      });
    }
  }

  createDodgeCooldownUI() {
    const { width, height } = this.cameras.main;
    const uiX = width - 80;
    const uiY = height - this.bottomUIHeight - 40;

    // Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
    this.dodgeCooldownUI = this.add.container(uiX, uiY).setDepth(2500);

    // Î∞∞Í≤Ω
    const bg = this.add.rectangle(0, 0, 60, 20, 0x000000, 0.7).setStrokeStyle(1, 0x00ff00);

    // Í≤åÏù¥ÏßÄ Î∞î
    this.dodgeCooldownBar = this.add.rectangle(-25, 0, 50, 14, 0x00ff00, 1).setOrigin(0, 0.5);

    // Î†àÏù¥Î∏î
    const label = this.add.text(0, -18, 'DODGE', {
      fontSize: '10px',
      fill: '#00ff00'
    }).setOrigin(0.5);

    // ÌÇ§ ÌëúÏãú
    const keyLabel = this.add.text(0, 18, '[SPACE]', {
      fontSize: '8px',
      fill: '#888888'
    }).setOrigin(0.5);

    this.dodgeCooldownUI.add([bg, this.dodgeCooldownBar, label, keyLabel]);
    this.dodgeCooldownUI.setVisible(false); // ÌÉÑÎßâ Î≥¥Ïä§Ï†ÑÏóêÏÑúÎßå ÌëúÏãú
  }

  updateDodgeCooldownUI() {
    if (!this.dodgeCooldownUI) return;

    const now = Date.now();
    const elapsed = now - this.lastDodgeTime;
    const progress = Math.min(1, elapsed / this.dodgeCooldown);

    if (this.dodgeCooldownBar) {
      this.dodgeCooldownBar.setScale(progress, 1);
      // ÏÉâÏÉÅ Î≥ÄÍ≤Ω (Îπ®Í∞ï ‚Üí Ï¥àÎ°ù)
      if (progress >= 1) {
        this.dodgeCooldownBar.setFillStyle(0x00ff00);
      } else {
        this.dodgeCooldownBar.setFillStyle(0xff3300);
      }
    }
  }

  showDodgeCooldownUIForBulletBoss() {
    if (!this.dodgeCooldownUI) {
      this.createDodgeCooldownUI();
    }
    this.dodgeCooldownUI.setVisible(true);

    // Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏
    if (this.dodgeCooldownUpdateTimer) {
      this.dodgeCooldownUpdateTimer.destroy();
    }
    this.dodgeCooldownUpdateTimer = this.time.addEvent({
      delay: 50,
      callback: () => this.updateDodgeCooldownUI(),
      loop: true
    });
  }

  hideDodgeCooldownUI() {
    if (this.dodgeCooldownUI) {
      this.dodgeCooldownUI.setVisible(false);
    }
    if (this.dodgeCooldownUpdateTimer) {
      this.dodgeCooldownUpdateTimer.destroy();
      this.dodgeCooldownUpdateTimer = null;
    }
  }

  // ========== ÌäúÌÜ†Î¶¨Ïñº ÏãúÏä§ÌÖú ==========

  showDodgeTutorial(callback) {
    const { width, height } = this.cameras.main;

    // ÌäúÌÜ†Î¶¨Ïñº Ï§ë Îã∑ÏßÄ ÎπÑÌôúÏÑ±Ìôî ÌîåÎûòÍ∑∏
    this.tutorialOpen = true;

    // ÌäúÌÜ†Î¶¨Ïñº Ï§ë Î±Ä Ïù¥Îèô Ï†ïÏßÄ
    if (this.moveTimer) {
      this.moveTimer.paused = true;
    }

    // Ïò§Î≤ÑÎ†àÏù¥
    const overlay = this.add.rectangle(0, 0, width, height, 0x000000, 0.85)
      .setOrigin(0, 0).setDepth(5000);

    // ÌäúÌÜ†Î¶¨Ïñº Ïª®ÌÖåÏù¥ÎÑà
    const container = this.add.container(width / 2, height / 2).setDepth(5001);

    // Î∞ïÏä§ Î∞∞Í≤Ω
    const boxBg = this.add.rectangle(0, 0, 400, 250, 0x1a1a2e, 1)
      .setStrokeStyle(3, 0x00ff00);

    // ÌÉÄÏù¥ÌãÄ
    const title = this.add.text(0, -90, 'DODGE TUTORIAL', {
      fontSize: '24px',
      fontStyle: 'bold',
      fill: '#00ff00'
    }).setOrigin(0.5);

    // Ïä§ÌéòÏù¥Ïä§Î∞î ÌÇ§ ÌëúÏãú
    const keyBox = this.add.rectangle(0, -30, 120, 40, 0x333333, 1)
      .setStrokeStyle(2, 0xffffff);
    const keyText = this.add.text(0, -30, 'SPACEBAR', {
      fontSize: '16px',
      fontStyle: 'bold',
      fill: '#ffffff'
    }).setOrigin(0.5);

    // ÏÑ§Î™Ö
    const desc = this.add.text(0, 20, '= SIDE ROLL DODGE', {
      fontSize: '18px',
      fill: '#ffff00'
    }).setOrigin(0.5);

    const desc2 = this.add.text(0, 50, 'Roll sideways to avoid bullets!', {
      fontSize: '14px',
      fill: '#aaaaaa'
    }).setOrigin(0.5);

    // ÎØ∏Îãà Î±Ä Îç∞Î™® Ïï†ÎãàÎ©îÏù¥ÏÖò
    const demoSnake = this.add.container(0, 90);
    for (let i = 0; i < 3; i++) {
      const segment = this.add.rectangle(-20 + i * 12, 0, 10, 10, i === 0 ? 0x00ff00 : 0x00cc00);
      demoSnake.add(segment);
    }

    // Î±ÄÏù¥ ÏòÜÏúºÎ°ú Íµ¨Î•¥Îäî Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: demoSnake,
      y: demoSnake.y - 30,
      duration: 300,
      ease: 'Power2.easeOut',
      yoyo: true,
      repeat: -1,
      repeatDelay: 1000
    });

    // Ïä§ÌÇµ ÏïàÎÇ¥
    const skipText = this.add.text(0, 110, 'Press any key to continue...', {
      fontSize: '12px',
      fill: '#666666'
    }).setOrigin(0.5);

    // ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: skipText,
      alpha: 0.3,
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    // ÌÇ§ ÎàÑÎ•¥Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: keyBox,
      scaleY: 0.9,
      duration: 150,
      yoyo: true,
      repeat: -1,
      repeatDelay: 800
    });

    container.add([boxBg, title, keyBox, keyText, desc, desc2, demoSnake, skipText]);

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    container.setScale(0.5).setAlpha(0);
    this.tweens.add({
      targets: container,
      scale: 1,
      alpha: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    // 3Ï¥à ÌõÑ ÏûêÎèô Ïä§ÌÇµ ÎòêÎäî ÏïÑÎ¨¥ ÌÇ§ ÏûÖÎ†•
    let tutorialClosed = false;

    const closeTutorial = () => {
      if (tutorialClosed) return;
      tutorialClosed = true;

      this.tweens.add({
        targets: [container, overlay],
        alpha: 0,
        scale: 0.8,
        duration: 200,
        onComplete: () => {
          container.destroy();
          overlay.destroy();
          // ÌäúÌÜ†Î¶¨Ïñº Ï¢ÖÎ£å - Îã∑ÏßÄ ÌôúÏÑ±Ìôî
          this.tutorialOpen = false;
          // Î±Ä Ïù¥Îèô Ïû¨Í∞ú
          if (this.moveTimer) {
            this.moveTimer.paused = false;
          }
          if (callback) callback();
        }
      });
    };

    // ÏïÑÎ¨¥ ÌÇ§ ÏûÖÎ†•ÏúºÎ°ú Ïä§ÌÇµ
    const skipListener = this.input.keyboard.once('keydown', closeTutorial);

    // 3Ï¥à ÌõÑ ÏûêÎèô Ïä§ÌÇµ
    this.time.delayedCall(3000, closeTutorial);
  }

  // ========== Ï¥ùÏïå ÏãúÏä§ÌÖú ==========

  createBullet(x, y, dx, dy, speed = 3, type = 'plasma') {
    const pixelX = x * this.gridSize + this.gridSize / 2;
    const pixelY = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // === ÌÉÄÏûÖÎ≥Ñ ÏÉâÏÉÅ ÌåîÎ†àÌä∏ ===
    const colorPalettes = {
      plasma: {
        outer: 0xff0066, mid: 0xff3388, inner: 0xff6699,
        glow: 0xff00ff, core: 0xffffff, ring: 0xff0066
      },
      energy: {
        outer: 0x00ccff, mid: 0x33ddff, inner: 0x66eeff,
        glow: 0x00ffff, core: 0xffffff, ring: 0x0099ff
      },
      spiral: {
        outer: 0x9900ff, mid: 0xaa33ff, inner: 0xcc66ff,
        glow: 0xff00ff, core: 0xffffff, ring: 0x6600cc
      },
      tracker: {
        outer: 0x00ff66, mid: 0x33ff88, inner: 0x66ffaa,
        glow: 0xffff00, core: 0xffffff, ring: 0x00cc44
      },
      wall: {
        outer: 0xff6600, mid: 0xff8833, inner: 0xffaa66,
        glow: 0xff3300, core: 0xffffff, ring: 0xff4400
      },
      shotgun: {
        outer: 0xffcc00, mid: 0xffdd33, inner: 0xffee66,
        glow: 0xffaa00, core: 0xffffff, ring: 0xff9900
      }
    };

    const colors = colorPalettes[type] || colorPalettes.plasma;

    // === Í≥†Í∏â Ï¥ùÏïå Í∑∏ÎûòÌîΩ (Î©ÄÌã∞ Î†àÏù¥Ïñ¥) ===
    const bulletContainer = this.add.container(pixelX, pixelY).setDepth(200);

    // ÌÉÄÏûÖÎ≥Ñ ÌäπÏàò ÎîîÏûêÏù∏
    if (type === 'spiral') {
      // ÎÇòÏÑ†Ìòï - ÌöåÏ†ÑÌïòÎäî ÎÇòÏÑ† Ìå®ÌÑ¥
      const spiralArms = [];
      for (let i = 0; i < 3; i++) {
        const arm = this.add.rectangle(0, 0, 20, 3, colors.mid, 0.7);
        arm.setRotation((Math.PI * 2 * i) / 3);
        spiralArms.push(arm);
        bulletContainer.add(arm);
      }

      // ÎÇòÏÑ† ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: spiralArms,
        rotation: `+=${Math.PI * 2}`,
        duration: 300,
        repeat: -1
      });

      const spiralCore = this.add.circle(0, 0, 6, colors.outer, 0.9);
      const spiralCenter = this.add.circle(0, 0, 3, colors.core, 1);
      bulletContainer.add([spiralCore, spiralCenter]);

      this.tweens.add({
        targets: spiralCore,
        scale: { from: 1, to: 1.4 },
        alpha: { from: 0.9, to: 0.5 },
        duration: 150,
        yoyo: true,
        repeat: -1
      });

    } else if (type === 'tracker') {
      // Ï∂îÏ†ÅÌÉÑ - ÌÉÄÍ≤üÌåÖ Ïã≠ÏûêÏÑ† Ïä§ÌÉÄÏùº
      const crosshairH = this.add.rectangle(0, 0, 22, 2, colors.glow, 0.8);
      const crosshairV = this.add.rectangle(0, 0, 2, 22, colors.glow, 0.8);
      const targetRing = this.add.circle(0, 0, 10, colors.outer, 0);
      targetRing.setStrokeStyle(2, colors.outer, 0.8);
      const innerDot = this.add.circle(0, 0, 4, colors.core, 1);

      bulletContainer.add([crosshairH, crosshairV, targetRing, innerDot]);

      // ÌöåÏ†Ñ Î∞è ÌéÑÏä§
      this.tweens.add({
        targets: [crosshairH, crosshairV],
        rotation: Math.PI / 4,
        duration: 400,
        yoyo: true,
        repeat: -1
      });

      this.tweens.add({
        targets: targetRing,
        scale: { from: 1, to: 1.5 },
        alpha: { from: 0.8, to: 0.2 },
        duration: 300,
        repeat: -1
      });

    } else if (type === 'shotgun') {
      // ÏÉ∑Í±¥ÌÉÑ - Î∂àÍ∑úÏπôÌïú Ìè≠Î∞ú ÌòïÌÉú
      const shards = [];
      for (let i = 0; i < 5; i++) {
        const angle = (Math.PI * 2 * i) / 5;
        const shard = this.add.triangle(
          Math.cos(angle) * 6, Math.sin(angle) * 6,
          0, -5, -3, 4, 3, 4,
          colors.mid, 0.8
        ).setRotation(angle);
        shards.push(shard);
        bulletContainer.add(shard);
      }

      const shotgunCore = this.add.circle(0, 0, 5, colors.outer, 1);
      const shotgunCenter = this.add.circle(0, 0, 2, colors.core, 1);
      bulletContainer.add([shotgunCore, shotgunCenter]);

      // ÏÉ§Îìú ÌéÑÏä§
      this.tweens.add({
        targets: shards,
        scale: { from: 1, to: 1.3 },
        duration: 120,
        yoyo: true,
        repeat: -1
      });

    } else if (type === 'wall') {
      // Î≤ΩÌÉÑ - ÏúÑÌóòÌïú Î∂àÌÉÄÎäî ÎäêÎÇå
      const flames = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 * i) / 6;
        const flame = this.add.ellipse(
          Math.cos(angle) * 8, Math.sin(angle) * 8,
          6, 10, colors.mid, 0.6
        ).setRotation(angle);
        flames.push(flame);
        bulletContainer.add(flame);
      }

      const wallCore = this.add.circle(0, 0, 7, colors.outer, 0.9);
      const wallCenter = this.add.circle(0, 0, 4, colors.core, 1);
      bulletContainer.add([wallCore, wallCenter]);

      // Î∂àÍΩÉ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: flames,
        scaleY: { from: 1, to: 1.5 },
        alpha: { from: 0.6, to: 0.2 },
        duration: 100,
        yoyo: true,
        repeat: -1
      });

    } else {
      // Í∏∞Î≥∏ (plasma, energy) - ÏõêÌòï Í∏ÄÎ°úÏö∞ Ïä§ÌÉÄÏùº
      // 1. Í∞ÄÏû• Î∞îÍπ• - Í±∞ÎåÄÌïú ÏóêÎÑàÏßÄ ÌïÑÎìú (ÎÇÆÏùÄ ÏïåÌåå)
      const outerField = this.add.circle(0, 0, 18, colors.outer, 0.15);

      // 2. Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞ ÎßÅ
      const glowRing = this.add.circle(0, 0, 14, colors.outer, 0);
      glowRing.setStrokeStyle(2, colors.outer, 0.6);

      // 3. Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
      const midGlow = this.add.circle(0, 0, 10, colors.mid, 0.4);

      // 4. ÎÇ¥Î∂Ä Í∏ÄÎ°úÏö∞
      const innerGlow = this.add.circle(0, 0, 7, colors.inner, 0.6);

      // 5. ÏΩîÏñ¥ (Î∞ùÏùÄ Ï§ëÏã¨)
      const core = this.add.circle(0, 0, 4, colors.core, 1);

      // 6. ÌïòÏù¥ÎùºÏù¥Ìä∏ (Î∞òÏßùÏù¥Îäî Ï†ê)
      const highlight = this.add.circle(-1, -1, 2, colors.core, 0.9);

      // 7. ÏóêÎÑàÏßÄ ÎßÅ ÌöåÏ†Ñ Ìö®Í≥º
      const energyRing = this.add.circle(0, 0, 12, colors.ring, 0);
      energyRing.setStrokeStyle(1, colors.glow, 0.5);

      bulletContainer.add([outerField, glowRing, midGlow, innerGlow, core, highlight, energyRing]);

      // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò (ÏóêÎÑàÏßÄ ÌïÑÎìú)
      this.tweens.add({
        targets: outerField,
        scale: { from: 1, to: 1.6 },
        alpha: { from: 0.15, to: 0.05 },
        duration: 150,
        yoyo: true,
        repeat: -1
      });

      // Í∏ÄÎ°úÏö∞ ÎßÅ ÌéÑÏä§
      this.tweens.add({
        targets: glowRing,
        scale: { from: 1, to: 1.3 },
        duration: 200,
        yoyo: true,
        repeat: -1
      });

      // ÏΩîÏñ¥ ÌéÑÏä§ (Ìò∏Ìù° Ìö®Í≥º)
      this.tweens.add({
        targets: [core, innerGlow],
        scale: { from: 1, to: 1.15 },
        duration: 100,
        yoyo: true,
        repeat: -1
      });

      // ÏóêÎÑàÏßÄ ÎßÅ ÌöåÏ†Ñ
      this.tweens.add({
        targets: energyRing,
        rotation: Math.PI * 2,
        duration: 500,
        repeat: -1
      });

      // ÌïòÏù¥ÎùºÏù¥Ìä∏ ÍπúÎπ°ÏûÑ
      this.tweens.add({
        targets: highlight,
        alpha: { from: 0.9, to: 0.3 },
        duration: 80,
        yoyo: true,
        repeat: -1
      });
    }

    const bullet = {
      x: pixelX,
      y: pixelY,
      dx: dx * speed,
      dy: dy * speed,
      speed: speed,
      type: type,
      graphics: bulletContainer,
      trail: [],
      trailCounter: 0 // Ìä∏Î†àÏùº ÏµúÏ†ÅÌôîÏö©
    };

    this.bullets.push(bullet);
    return bullet;
  }

  fireRadialBullets(count = 8, speed = 3, type = 'plasma', angleOffset = 0) {
    if (!this.bulletBossPosition) return;

    const bossX = this.bulletBossPosition.x;
    const bossY = this.bulletBossPosition.y;

    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + angleOffset;
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      this.createBullet(bossX, bossY, dx, dy, speed, type);
    }

    // Î∞úÏÇ¨ Ïù¥ÌéôÌä∏
    this.showBulletFireEffect(bossX, bossY);
  }

  fireRadialBulletsFromPosition(pos, count = 8, speed = 3, type = 'plasma', angleOffset = 0) {
    if (!pos) return;

    const bossX = pos.x;
    const bossY = pos.y;

    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + angleOffset;
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      this.createBullet(bossX, bossY, dx, dy, speed, type);
    }

    this.showBulletFireEffect(bossX, bossY);
  }

  fireSpiralBullets(bulletCount = 16, rotationOffset = 0, speed = 2.5, type = 'spiral') {
    if (!this.bulletBossPosition) return;

    // 6ÌÉÑ Î≥¥Ïä§ Ï¥ùÏïå Î∞úÏÇ¨ Ìö®Í≥ºÏùå
    this.sound.play('boss6_effect', { volume: 0.3 });

    const bossX = this.bulletBossPosition.x;
    const bossY = this.bulletBossPosition.y;

    for (let i = 0; i < bulletCount; i++) {
      const angle = (Math.PI * 2 * i) / bulletCount + rotationOffset;
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);

      // ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ÏùÑ ÎëêÍ≥† Î∞úÏÇ¨
      this.time.delayedCall(i * 50, () => {
        if (this.bulletBossMode) {
          this.createBullet(bossX, bossY, dx, dy, speed, type);
        }
      });
    }
  }

  fireAimedBullet(speed = 4, type = 'tracker') {
    if (!this.bulletBossPosition || !this.snake[0]) return;

    // 6ÌÉÑ Î≥¥Ïä§ Ï¥ùÏïå Î∞úÏÇ¨ Ìö®Í≥ºÏùå
    this.sound.play('boss6_effect', { volume: 0.3 });

    const bossX = this.bulletBossPosition.x;
    const bossY = this.bulletBossPosition.y;
    const head = this.snake[0];

    // Î±Ä Î∞©Ìñ•ÏúºÎ°ú Ï°∞Ï§Ä
    const dx = head.x - bossX;
    const dy = head.y - bossY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 0) {
      this.createBullet(bossX, bossY, dx / dist, dy / dist, speed, type);
    }
  }

  showBulletFireEffect(gridX, gridY) {
    const pixelX = gridX * this.gridSize + this.gridSize / 2;
    const pixelY = gridY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 6ÌÉÑ Î≥¥Ïä§ Ï¥ùÏïå Î∞úÏÇ¨ Ìö®Í≥ºÏùå
    this.sound.play('boss6_effect', { volume: 0.3 });

    // === ÌôîÎ†§Ìïú Î∞úÏÇ¨ Ïù¥ÌéôÌä∏ ===

    // 1. Ï§ëÏïô ÌîåÎûòÏãú (Î©ÄÌã∞ Î†àÏù¥Ïñ¥)
    const flashOuter = this.add.circle(pixelX, pixelY, 50, 0xff0066, 0.3).setDepth(198);
    const flashMid = this.add.circle(pixelX, pixelY, 35, 0xff3388, 0.5).setDepth(199);
    const flashCore = this.add.circle(pixelX, pixelY, 20, 0xffffff, 0.8).setDepth(200);

    this.tweens.add({
      targets: [flashOuter, flashMid, flashCore],
      scale: 2.5,
      alpha: 0,
      duration: 250,
      ease: 'Power2.easeOut',
      onComplete: () => {
        flashOuter.destroy();
        flashMid.destroy();
        flashCore.destroy();
      }
    });

    // 2. ÌôïÏû• ÎßÅ (Îã§Ï§ë)
    for (let r = 0; r < 3; r++) {
      const ring = this.add.circle(pixelX, pixelY, 15, 0xff0066, 0).setDepth(197);
      ring.setStrokeStyle(4 - r, r === 0 ? 0xff0066 : (r === 1 ? 0xff00ff : 0xffff00), 0.8);

      this.tweens.add({
        targets: ring,
        radius: 60 + r * 25,
        duration: 300 + r * 100,
        onUpdate: () => ring.setStrokeStyle(4 - r, ring.strokeColor, Math.max(0, 0.8 - ring.radius / 100)),
        onComplete: () => ring.destroy()
      });
    }

    // 3. Î∞©ÏÇ¨Ìòï ÏóêÎÑàÏßÄ ÎùºÏù∏
    for (let i = 0; i < 12; i++) {
      const angle = (Math.PI * 2 * i) / 12;
      const line = this.add.rectangle(
        pixelX, pixelY,
        25, 3,
        0xff0066, 0.9
      ).setDepth(199).setRotation(angle);

      this.tweens.add({
        targets: line,
        x: pixelX + Math.cos(angle) * 45,
        y: pixelY + Math.sin(angle) * 45,
        alpha: 0,
        scaleX: 0.3,
        duration: 200,
        ease: 'Power2.easeOut',
        onComplete: () => line.destroy()
      });
    }

    // 4. Ïä§ÌååÌÅ¨ ÌååÌã∞ÌÅ¥
    const sparkColors = [0xff0066, 0xff00ff, 0xffff00, 0xffffff];
    for (let i = 0; i < 16; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 30 + Math.random() * 40;
      const color = sparkColors[Math.floor(Math.random() * sparkColors.length)];

      const spark = this.add.circle(pixelX, pixelY, 2 + Math.random() * 2, color, 1).setDepth(200);

      this.tweens.add({
        targets: spark,
        x: pixelX + Math.cos(angle) * speed,
        y: pixelY + Math.sin(angle) * speed,
        alpha: 0,
        scale: 0,
        duration: 300 + Math.random() * 150,
        ease: 'Power2.easeOut',
        onComplete: () => spark.destroy()
      });
    }

    // 5. Ïπ¥Î©îÎùº ÏïΩÍ∞Ñ ÌùîÎì§Í∏∞
    this.cameras.main.shake(50, 0.003);
  }

  updateBullets() {
    const bulletsToRemove = [];

    for (let i = 0; i < this.bullets.length; i++) {
      const bullet = this.bullets[i];

      // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
      bullet.x += bullet.dx;
      bullet.y += bullet.dy;

      // Í∑∏ÎûòÌîΩ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
      if (bullet.graphics) {
        bullet.graphics.setPosition(bullet.x, bullet.y);
      }

      // Ìä∏Î†àÏùº Ìö®Í≥º
      this.updateBulletTrail(bullet);

      // Î≤Ω Ï∂©Îèå Ï≤¥ÌÅ¨
      if (bullet.x < 0 || bullet.x > this.cameras.main.width ||
          bullet.y < this.gameAreaY || bullet.y > this.cameras.main.height - this.bottomUIHeight) {
        bulletsToRemove.push(i);
        this.destroyBullet(bullet);
        continue;
      }

      // Î±Ä Ï∂©Îèå Ï≤¥ÌÅ¨ (Î¨¥Ï†Å ÏïÑÎãê ÎïåÎßå)
      if (!this.isInvincible) {
        const head = this.snake[0];
        const headPixelX = head.x * this.gridSize + this.gridSize / 2;
        const headPixelY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

        const dist = Math.sqrt(
          Math.pow(bullet.x - headPixelX, 2) +
          Math.pow(bullet.y - headPixelY, 2)
        );

        if (dist < this.gridSize * 0.7) {
          // Ï¥ùÏïåÏóê ÎßûÏùå!
          this.handleBulletHit();
          return;
        }
      }
    }

    // Ï†úÍ±∞Ìï† Ï¥ùÏïåÎì§ Ï≤òÎ¶¨
    for (let i = bulletsToRemove.length - 1; i >= 0; i--) {
      this.bullets.splice(bulletsToRemove[i], 1);
    }
  }

  updateBulletTrail(bullet) {
    // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Îß§ 2ÌîÑÎ†àÏûÑÎßàÎã§ Ìä∏Î†àÏùº ÏÉùÏÑ±
    bullet.trailCounter = (bullet.trailCounter || 0) + 1;
    if (bullet.trailCounter % 2 !== 0) return;

    // === ÌÉÄÏûÖÎ≥Ñ Ìä∏Î†àÏùº ÏÉâÏÉÅ ===
    const trailColors = {
      plasma: { outer: 0xff0066, mid: 0xff3388, spark: 0xffff00 },
      energy: { outer: 0x00ccff, mid: 0x33ddff, spark: 0x00ffff },
      spiral: { outer: 0x9900ff, mid: 0xaa33ff, spark: 0xff00ff },
      tracker: { outer: 0x00ff66, mid: 0x33ff88, spark: 0xffff00 },
      wall: { outer: 0xff6600, mid: 0xff8833, spark: 0xff3300 },
      shotgun: { outer: 0xffcc00, mid: 0xffdd33, spark: 0xffaa00 }
    };

    const colors = trailColors[bullet.type] || trailColors.plasma;

    // === ÌôîÎ†§Ìïú Î©ÄÌã∞ Î†àÏù¥Ïñ¥ Ìä∏Î†àÏùº ===

    // 1. Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞ Ìä∏Î†àÏùº (ÌÅ∞, Ìà¨Î™Ö)
    const outerTrail = this.add.circle(bullet.x, bullet.y, 12, colors.outer, 0.2).setDepth(197);
    this.tweens.add({
      targets: outerTrail,
      alpha: 0,
      scale: 0.3,
      duration: 200,
      onComplete: () => outerTrail.destroy()
    });

    // 2. Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞ Ìä∏Î†àÏùº
    const midTrail = this.add.circle(bullet.x, bullet.y, 7, colors.mid, 0.4).setDepth(198);
    this.tweens.add({
      targets: midTrail,
      alpha: 0,
      scale: 0.2,
      duration: 180,
      onComplete: () => midTrail.destroy()
    });

    // 3. ÏΩîÏñ¥ Ìä∏Î†àÏùº (Î∞ùÏùÄ)
    const coreTrail = this.add.circle(bullet.x, bullet.y, 4, 0xffffff, 0.6).setDepth(199);
    this.tweens.add({
      targets: coreTrail,
      alpha: 0,
      scale: 0.1,
      duration: 150,
      onComplete: () => coreTrail.destroy()
    });

    // 4. Í∞ÄÎÅî Ïä§ÌååÌÅ¨ Ï∂îÍ∞Ä (10% ÌôïÎ•†)
    if (Math.random() < 0.1) {
      const sparkAngle = Math.random() * Math.PI * 2;
      const spark = this.add.circle(
        bullet.x + Math.cos(sparkAngle) * 5,
        bullet.y + Math.sin(sparkAngle) * 5,
        2, colors.spark, 0.8
      ).setDepth(199);

      this.tweens.add({
        targets: spark,
        x: bullet.x + Math.cos(sparkAngle) * 15,
        y: bullet.y + Math.sin(sparkAngle) * 15,
        alpha: 0,
        duration: 150,
        onComplete: () => spark.destroy()
      });
    }
  }

  destroyBullet(bullet) {
    if (bullet.graphics) {
      // Î¨¥Ìïú Î∞òÎ≥µ Ìä∏Ïúà(Í∏ÄÎ°úÏö∞/ÌéÑÏä§ Îì±) Ï†ïÎ¶¨ - ÌååÍ¥¥ ÌõÑ TweenData Ïò§Î•ò Î∞©ÏßÄ
      if (bullet.graphics.list && bullet.graphics.list.length > 0) {
        this.tweens.killTweensOf(bullet.graphics.list);
      }
      this.tweens.killTweensOf(bullet.graphics);

      // === ÌÉÄÏûÖÎ≥Ñ Ìè≠Î∞ú ÏÉâÏÉÅ ===
      const explosionColors = {
        plasma: { flash: 0xff0066, core: 0xffff00, ring: 0xff0066, sparks: [0xff0066, 0xff00ff, 0xffff00, 0xffffff] },
        energy: { flash: 0x00ccff, core: 0xffffff, ring: 0x00ccff, sparks: [0x00ccff, 0x00ffff, 0x66eeff, 0xffffff] },
        spiral: { flash: 0x9900ff, core: 0xffffff, ring: 0x9900ff, sparks: [0x9900ff, 0xff00ff, 0xcc66ff, 0xffffff] },
        tracker: { flash: 0x00ff66, core: 0xffff00, ring: 0x00ff66, sparks: [0x00ff66, 0xffff00, 0x66ffaa, 0xffffff] },
        wall: { flash: 0xff6600, core: 0xffff00, ring: 0xff6600, sparks: [0xff6600, 0xff3300, 0xffaa66, 0xffffff] },
        shotgun: { flash: 0xffcc00, core: 0xffffff, ring: 0xffcc00, sparks: [0xffcc00, 0xffaa00, 0xffee66, 0xffffff] }
      };

      const colors = explosionColors[bullet.type] || explosionColors.plasma;

      // === ÌôîÎ†§Ìïú ÌååÍ¥¥ Ïù¥ÌéôÌä∏ ===
      const x = bullet.graphics.x;
      const y = bullet.graphics.y;

      // 1. Ìè≠Î∞ú ÌîåÎûòÏãú (Î©ÄÌã∞ Î†àÏù¥Ïñ¥)
      const flashOuter = this.add.circle(x, y, 20, colors.flash, 0.4).setDepth(200);
      const flashCore = this.add.circle(x, y, 10, colors.core, 0.8).setDepth(201);

      this.tweens.add({
        targets: [flashOuter, flashCore],
        scale: 2,
        alpha: 0,
        duration: 150,
        onComplete: () => {
          flashOuter.destroy();
          flashCore.destroy();
        }
      });

      // 2. ÌôïÏû• ÎßÅ
      const ring = this.add.circle(x, y, 5, colors.ring, 0).setDepth(199);
      ring.setStrokeStyle(2, colors.ring, 0.8);
      this.tweens.add({
        targets: ring,
        radius: 25,
        duration: 200,
        onUpdate: () => ring.setStrokeStyle(2, colors.ring, Math.max(0, 0.8 - ring.radius / 30)),
        onComplete: () => ring.destroy()
      });

      // 3. Ïä§ÌååÌÅ¨ ÌååÌã∞ÌÅ¥ (Îçî ÎßéÏù¥, Îã§ÏñëÌïú ÏÉâÏÉÅ)
      const sparkColors = colors.sparks;
      for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 * i) / 12 + Math.random() * 0.3;
        const dist = 20 + Math.random() * 15;
        const color = sparkColors[Math.floor(Math.random() * sparkColors.length)];

        const spark = this.add.circle(x, y, 2 + Math.random() * 2, color, 1).setDepth(200);

        this.tweens.add({
          targets: spark,
          x: x + Math.cos(angle) * dist,
          y: y + Math.sin(angle) * dist,
          alpha: 0,
          scale: 0.2,
          duration: 250 + Math.random() * 100,
          ease: 'Power2.easeOut',
          onComplete: () => spark.destroy()
        });
      }

      // 4. ÏûëÏùÄ ÌååÌé∏ (Îπ†Î•¥Í≤å ÏÇ¨ÎùºÏßÄÎäî ÏÑ†)
      for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        const fragment = this.add.rectangle(x, y, 8, 2, colors.flash, 0.9).setDepth(200);
        fragment.setRotation(angle);

        this.tweens.add({
          targets: fragment,
          x: x + Math.cos(angle) * 18,
          y: y + Math.sin(angle) * 18,
          alpha: 0,
          scaleX: 0.2,
          rotation: angle + Math.PI * 0.5,
          duration: 180,
          ease: 'Power2.easeOut',
          onComplete: () => fragment.destroy()
        });
      }

      bullet.graphics.destroy();
    }
  }

  clearAllBullets() {
    for (const bullet of this.bullets) {
      if (bullet.graphics) {
        if (bullet.graphics.list && bullet.graphics.list.length > 0) {
          this.tweens.killTweensOf(bullet.graphics.list);
        }
        this.tweens.killTweensOf(bullet.graphics);
        bullet.graphics.destroy();
      }
    }
    this.bullets = [];
  }

  handleBulletHit() {
    // Ï¥ùÏïåÏóê ÎßûÏùå - Í≤åÏûÑ Ïò§Î≤Ñ
    this.clearAllBullets();
    this.cleanupBulletBoss();
    this.endGame();
  }

  startBulletUpdateTimer() {
    if (this.bulletUpdateTimer) {
      this.bulletUpdateTimer.destroy();
    }

    // 60fpsÎ°ú Ï¥ùÏïå ÏóÖÎç∞Ïù¥Ìä∏
    this.bulletUpdateTimer = this.time.addEvent({
      delay: 16, // ~60fps
      callback: () => this.updateBullets(),
      loop: true
    });
  }

  stopBulletUpdateTimer() {
    if (this.bulletUpdateTimer) {
      this.bulletUpdateTimer.destroy();
      this.bulletUpdateTimer = null;
    }
  }

  // ========== ÌÉÑÎßâ Î≥¥Ïä§ Î©îÏù∏ Î°úÏßÅ ==========

  startBulletBoss() {
    if (!this.isBossStage) {
      this.enterBossStage();
    }

    this.bulletBossMode = true;
    this.bulletBossPhase = 'intro';
    this.bulletBossHitCount = 0;
    this.bulletBossWaveCount = 0;
    this.bullets = [];

    // Í∏∞Ï°¥ Îç∞ÎìúÏ°¥ Ïó∞Ï∂ú Ìè≠Ìåå
    this.destroyAllDeadZonesWithAnimation();

    // ÏùåÏãù Ïà®ÍπÄ Ï≤òÎ¶¨
    this.food = { x: -100, y: -100 };
    this.hideFoodGraphics();

    // ÌöåÌîº ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.canDodge = true;
    this.lastDodgeTime = 0;
    this.isInvincible = false;
    this.lastDodgeDirection = 'up';

    // 6ÌÉÑ Î≥¥Ïä§ BGMÏúºÎ°ú Î≥ÄÍ≤Ω
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.bgMusic.stop();
    }
    if (this.boss6Music) {
      this.boss6Music.play();
    }

    // Ïù∏Ìä∏Î°ú Ïó∞Ï∂ú ÏãúÏûë
    this.showBulletBossIntro();
  }

  hideFoodGraphics(options = {}) {
    const skipRedraw = options.skipRedraw || this.isStageClearingAnimation;
    // foodGraphicsÍ∞Ä ÏûàÏúºÎ©¥ Ïà®Í∏∞Í∏∞
    if (this.foodGraphics) {
      this.foodGraphics.setVisible(false);
    }
    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥/ÌÅ¥Î¶¨Ïñ¥ ÏÉÅÌÉúÏóêÏÑúÎäî Í∑∏ÎûòÌîΩÏùÑ Îã§Ïãú Î≥¥Ïù¥Í≤å ÎßåÎì§ÏßÄ ÏïäÏùå
    if (skipRedraw) {
      if (this.graphics && !this.graphics.visible) {
        this.graphics.clear();
      }
      return;
    }
    // Îã§Ïãú Í∑∏Î¶¨Í∏∞ (Î®πÏù¥Í∞Ä ÌôîÎ©¥ Î∞ñÏù¥ÎØÄÎ°ú Ïïà Î≥¥ÏûÑ)
    this.draw();
  }

  hideSnakeGraphics() {
    // graphics Ïà®Í∏∞Í∏∞ (draw()ÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî Í∞ùÏ≤¥)
    if (this.graphics) {
      this.graphics.clear();
      this.graphics.setVisible(false);
    }
    // Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑÎèÑ Ïà®Í∏∞Í∏∞
    if (this.speedBoostOrbitals) {
      this.speedBoostOrbitals.forEach(o => {
        if (o && o.setVisible) o.setVisible(false);
      });
    }
  }

  showSnakeGraphics() {
    // graphics Îã§Ïãú Î≥¥Ïù¥Í∏∞
    if (this.graphics) {
      this.graphics.setVisible(true);
    }
    // Ïä§ÌîºÎìú Î∂ÄÏä§Ìä∏ Í∂§ÎèÑÎèÑ Î≥¥Ïù¥Í∏∞
    if (this.hasSpeedBoost && this.speedBoostOrbitals) {
      this.speedBoostOrbitals.forEach(o => {
        if (o && o.setVisible) o.setVisible(true);
      });
    }
    this.draw();
  }

  showBulletBossIntro() {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãú Ï†ïÏßÄ
    this.moveTimer.paused = true;
    this.bossInputBlocked = true;

    // 1. ÌôîÎ©¥ Ïñ¥Îë°Í≤å
    const darkOverlay = this.add.rectangle(0, 0, width, height, 0x000000, 0)
      .setOrigin(0, 0).setDepth(4000);

    this.tweens.add({
      targets: darkOverlay,
      alpha: 0.7,
      duration: 1000
    });

    // 2. Í≤ΩÍ≥† ÏÇ¨Ïù¥Î†å Ìö®Í≥º
    this.time.delayedCall(500, () => {
      this.showBulletBossWarning();
    });

    // 3. Î≥¥Ïä§ Îì±Ïû• (2Ï¥à ÌõÑ)
    this.time.delayedCall(2000, () => {
      this.showBulletBossAppear(darkOverlay);
    });
  }

  showBulletBossWarning() {
    const { width, height } = this.cameras.main;

    // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Îπ®Í∞Ñ Í∏ÄÎ°úÏö∞ ÍπúÎπ°ÏûÑ
    const warningGlow = this.add.rectangle(0, 0, width, height, 0xff0000, 0)
      .setOrigin(0, 0).setDepth(4001);
    warningGlow.setStrokeStyle(20, 0xff0000, 0);

    // ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    let blinkCount = 0;
    const blinkTimer = this.time.addEvent({
      delay: 150,
      callback: () => {
        blinkCount++;
        const alpha = blinkCount % 2 === 0 ? 0 : 0.3;
        warningGlow.setFillStyle(0xff0000, alpha);
        warningGlow.setStrokeStyle(20, 0xff0000, alpha * 2);

        if (blinkCount >= 10) {
          blinkTimer.destroy();
          warningGlow.destroy();
        }
      },
      loop: true
    });

    // "WARNING" ÌÖçÏä§Ìä∏
    const warningText = this.add.text(width / 2, height / 2, 'WARNING!', {
      fontSize: '48px',
      fontStyle: 'bold',
      fill: '#ff0000',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(4002).setAlpha(0);

    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scale: { from: 0.5, to: 1.5 },
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: warningText,
          alpha: 0,
          duration: 500,
          delay: 500,
          onComplete: () => warningText.destroy()
        });
      }
    });

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(500, 0.01);
  }

  showBulletBossAppear(darkOverlay) {
    const { width, height } = this.cameras.main;

    // Î≥¥Ïä§ ÏµúÏ¥à ÏúÑÏπò: Stage 3 ÎèÖÍ∞úÍµ¨Î¶¨ ÎèÖÏÑ± ÏúÑÏπòÏôÄ ÎèôÏùº
    const spawnPos = this.getPoisonFrogSpawnPosition ? this.getPoisonFrogSpawnPosition() : { x: this.cols - 9, y: 15 };
    this.bulletBossPosition = { x: spawnPos.x, y: spawnPos.y };

    // ÌîåÎûòÏãú Ìö®Í≥º
    const flash = this.add.rectangle(0, 0, width, height, 0xff00ff, 0)
      .setOrigin(0, 0).setDepth(4003);

    this.tweens.add({
      targets: flash,
      alpha: 0.8,
      duration: 100,
      yoyo: true,
      repeat: 2,
      onComplete: () => flash.destroy()
    });

    // Ïπ¥Î©îÎùº Í∞ïÌïòÍ≤å ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(500, 0.03);

    // Î≥¥Ïä§ Í∑∏Î¶¨Í∏∞
    this.time.delayedCall(300, () => {
      this.drawBulletBoss();

      // Î≥¥Ïä§ ÎåÄÏÇ¨ ‚Üí Î±Ä ÏùëÎãµ ‚Üí Î≥¥Ïä§ ÎåÄÏÇ¨ ‚Üí Í≤åÏûÑ ÏãúÏûë
      this.time.delayedCall(500, () => {
        this.showBulletBossDialogue("Hey, trash snake!", () => {
          // Î±ÄÏùò Í∑ÄÏ∞ÆÎã§Îäî ÎìØÌïú ÏùëÎãµ
          this.showSnakeBubbleDialogue("Ugh... not you again.", () => {
            // Î≥¥Ïä§Ïùò Ïú†Î®∏ÏûàÎäî Í∞ïÌï¥Ïßê ÏÑ†Ïñ∏
            this.showBulletBossDialogue("I hit the gym! Prepare to get rekt!", () => {
              // "BULLET HELL!" ÌÖçÏä§Ìä∏
              this.showBulletHellTitle(() => {
                // Ïñ¥ÎëêÏö¥ Ïò§Î≤ÑÎ†àÏù¥ Ï†úÍ±∞
                this.tweens.add({
                  targets: darkOverlay,
                  alpha: 0,
                  duration: 300,
                  onComplete: () => darkOverlay.destroy()
                });

                // Î≥¥Ïä§Ï†Ñ ÏÜçÎèÑ 90msÎ°ú ÏÑ§Ï†ï
                this.moveTimer.delay = 90;

                // Í≤åÏûÑ Ïû¨Í∞ú Ï§ÄÎπÑ
                this.bulletBossPhase = 'shooting';
                this.bossInputBlocked = false;
                this.moveTimer.paused = false;

                // Ï¥ùÏïå ÏóÖÎç∞Ïù¥Ìä∏ ÌÉÄÏù¥Î®∏ ÏãúÏûë
                this.startBulletUpdateTimer();

                // ÌöåÌîº Ïø®Îã§Ïö¥ UI ÌëúÏãú
                this.showDodgeCooldownUIForBulletBoss();

                // ÎØ∏ÏÇ¨Ïùº Í≤ΩÍ≥† ‚Üí ÌäúÌÜ†Î¶¨Ïñº ‚Üí Ï≤´ Ïõ®Ïù¥Î∏å ÏãúÏûë
                this.showMissileWarning(() => {
                  this.showDodgeTutorial(() => {
                    // ÌäúÌÜ†Î¶¨Ïñº ÎÅùÎÇòÎ©¥ Ï≤´ Ïõ®Ïù¥Î∏å ÏãúÏûë
                    this.startBulletWave();
                  });
                });
              });
            });
          });
        });
      });
    });
  }

  // Î±Ä ÎßêÌíçÏÑ† ÎåÄÏÇ¨ ÌëúÏãú
  showSnakeBubbleDialogue(text, callback) {
    const head = this.snake[0];
    const pixelX = head.x * this.gridSize + this.gridSize / 2;
    const pixelY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubbleBg = this.add.rectangle(pixelX, pixelY - 45, 180, 35, 0xffffff, 0.95)
      .setStrokeStyle(2, 0x00ff00).setDepth(4010);

    // ÎßêÌíçÏÑ† Íº¨Î¶¨
    const tail = this.add.triangle(pixelX, pixelY - 25, 0, 0, 10, 10, -10, 10, 0xffffff)
      .setDepth(4010);

    // ÎåÄÏÇ¨ ÌÖçÏä§Ìä∏
    const dialogueText = this.add.text(pixelX, pixelY - 45, text, {
      fontSize: '14px',
      fontStyle: 'bold',
      fill: '#00aa00'
    }).setOrigin(0.5).setDepth(4011).setAlpha(0);

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    bubbleBg.setScale(0).setAlpha(0);
    tail.setScale(0).setAlpha(0);

    this.tweens.add({
      targets: [bubbleBg, tail],
      scale: 1,
      alpha: 1,
      duration: 200,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 40,
      callback: () => {
        charIndex++;
        dialogueText.setText(text.substring(0, charIndex));
        dialogueText.setAlpha(1);
        if (charIndex >= text.length) {
          typeTimer.destroy();
        }
      },
      repeat: text.length - 1
    });

    // 1.5Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê
    this.time.delayedCall(1500, () => {
      this.tweens.add({
        targets: [bubbleBg, tail, dialogueText],
        alpha: 0,
        scale: 0.8,
        duration: 200,
        onComplete: () => {
          bubbleBg.destroy();
          tail.destroy();
          dialogueText.destroy();
          if (callback) callback();
        }
      });
    });
  }

  // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Ï†Ñ Í≤ΩÍ≥† ÌëúÏãú
  showMissileWarning(callback) {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãú Ï†ïÏßÄ (Í≤ΩÍ≥† Ï§ë)
    this.moveTimer.paused = true;

    // Î≥¥Ïä§ ÏúÑÏπòÏóêÏÑú ÎäêÎÇåÌëú ÌëúÏãú
    if (this.bulletBossPosition) {
      const bossPixelX = this.bulletBossPosition.x * this.gridSize + this.gridSize / 2;
      const bossPixelY = this.bulletBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      // ÎäêÎÇåÌëúÎì§Ïù¥ ÏÇ¨Î∞©ÏúºÎ°ú ÍπúÎπ°Ïù¥Î©∞ Í≤ΩÍ≥†
      const warningContainer = this.add.container(bossPixelX, bossPixelY).setDepth(3500);

      // Ï§ëÏïô ÌÅ∞ ÎäêÎÇåÌëú
      const centerWarning = this.add.text(0, -50, '‚ö†', {
        fontSize: '48px'
      }).setOrigin(0.5);

      // 8Î∞©Ìñ• ÏûëÏùÄ ÎäêÎÇåÌëú
      const smallWarnings = [];
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const dist = 60;
        const warning = this.add.text(
          Math.cos(angle) * dist,
          Math.sin(angle) * dist,
          '!',
          {
            fontSize: '32px',
            fontStyle: 'bold',
            fill: '#ff0000',
            stroke: '#ffff00',
            strokeThickness: 4
          }
        ).setOrigin(0.5).setAlpha(0);
        smallWarnings.push(warning);
        warningContainer.add(warning);
      }

      warningContainer.add(centerWarning);

      // Ï§ëÏïô ÎäêÎÇåÌëú ÌéÑÏä§
      this.tweens.add({
        targets: centerWarning,
        scale: { from: 1, to: 1.5 },
        duration: 200,
        yoyo: true,
        repeat: 4
      });

      // 8Î∞©Ìñ• ÎäêÎÇåÌëú ÏàúÏ∞® Îì±Ïû•
      smallWarnings.forEach((w, i) => {
        this.tweens.add({
          targets: w,
          alpha: 1,
          scale: { from: 0.5, to: 1.2 },
          duration: 150,
          delay: i * 80,
          yoyo: true,
          repeat: 2
        });
      });

      // "INCOMING!" ÌÖçÏä§Ìä∏
      const incomingText = this.add.text(width / 2, height / 2 - 80, 'INCOMING!', {
        fontSize: '36px',
        fontStyle: 'bold',
        fill: '#ff0000',
        stroke: '#ffff00',
        strokeThickness: 5
      }).setOrigin(0.5).setDepth(3501).setAlpha(0);

      this.tweens.add({
        targets: incomingText,
        alpha: 1,
        scale: { from: 0.5, to: 1.2 },
        duration: 300,
        ease: 'Back.easeOut'
      });

      // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Îπ®Í∞Ñ Í≤ΩÍ≥†
      const edgeWarning = this.add.rectangle(0, 0, width, height, 0xff0000, 0)
        .setOrigin(0, 0).setDepth(3499);

      this.tweens.add({
        targets: edgeWarning,
        alpha: 0.3,
        duration: 150,
        yoyo: true,
        repeat: 5
      });

      // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
      this.cameras.main.shake(800, 0.008);

      // Í≤ΩÍ≥† ÎÅùÎÇòÎ©¥ Ï†ïÎ¶¨ ÌõÑ ÏΩúÎ∞±
      this.time.delayedCall(1500, () => {
        this.tweens.add({
          targets: [warningContainer, incomingText, edgeWarning],
          alpha: 0,
          duration: 200,
          onComplete: () => {
            warningContainer.destroy();
            incomingText.destroy();
            edgeWarning.destroy();
            // Í≤åÏûÑ Ïû¨Í∞ú
            this.moveTimer.paused = false;
            if (callback) callback();
          }
        });
      });
    } else {
      // Í≤åÏûÑ Ïû¨Í∞ú
      this.moveTimer.paused = false;
      if (callback) callback();
    }
  }

  isPositionOccupied(x, y) {
    // Î±ÄÍ≥º Í≤πÏπòÎäîÏßÄ Ï≤¥ÌÅ¨
    for (const segment of this.snake) {
      if (segment.x === x && segment.y === y) return true;
    }
    // Îç∞ÎìúÏ°¥Í≥º Í≤πÏπòÎäîÏßÄ Ï≤¥ÌÅ¨
    for (const dz of this.deadZones) {
      if (dz.x === x && dz.y === y) return true;
    }
    return false;
  }

  drawBulletBoss() {
    if (this.bulletBossElement) {
      this.bulletBossElement.destroy();
    }

    const { x, y } = this.bulletBossPosition;
    const pixelX = x * this.gridSize + this.gridSize / 2;
    const pixelY = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const container = this.add.container(pixelX, pixelY).setDepth(150);

    // ÏúÑÌóò ÎßÅ (ÌöåÏ†Ñ)
    const dangerRing = this.add.circle(0, 0, 25, 0xff0000, 0).setStrokeStyle(3, 0xff0000, 0.5);

    // Î≥¥Ïä§ Î™∏Ï≤¥ (ÎßàÏ††ÌÉÄ)
    const body = this.add.circle(0, 0, 15, 0xff00ff, 1);

    // ÎÇ¥Î∂Ä ÏΩîÏñ¥ (Ïñ¥ÎëêÏö¥ ÏÉâ)
    const core = this.add.circle(0, 0, 8, 0x990099, 1);

    // Îàà (ÏúÑÌòëÏ†Å)
    const eye1 = this.add.circle(-5, -3, 3, 0xffffff, 1);
    const eye2 = this.add.circle(5, -3, 3, 0xffffff, 1);
    const pupil1 = this.add.circle(-5, -3, 1.5, 0x000000, 1);
    const pupil2 = this.add.circle(5, -3, 1.5, 0x000000, 1);

    container.add([dangerRing, body, core, eye1, eye2, pupil1, pupil2]);

    // ÏúÑÌóò ÎßÅ ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: dangerRing,
      rotation: Math.PI * 2,
      duration: 2000,
      repeat: -1
    });

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: body,
      scale: { from: 1, to: 1.1 },
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    container.setScale(0).setAlpha(0);
    this.tweens.add({
      targets: container,
      scale: 1,
      alpha: 1,
      duration: 500,
      ease: 'Back.easeOut'
    });

    this.bulletBossElement = container;
    this.bulletBossDangerRing = dangerRing;
    this.bulletBossBody = body;
  }

  showBulletBossDialogue(text, callback) {
    const { width, height } = this.cameras.main;

    const dialogueText = this.add.text(width / 2, height / 2 - 80, '', {
      fontSize: '28px',
      fontStyle: 'bold',
      fill: '#ff00ff',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(4500);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        charIndex++;
        dialogueText.setText(text.substring(0, charIndex));

        if (charIndex >= text.length) {
          typeTimer.destroy();

          // 1Ï¥à ÌõÑ ÌéòÏù¥ÎìúÏïÑÏõÉ
          this.time.delayedCall(1000, () => {
            this.tweens.add({
              targets: dialogueText,
              alpha: 0,
              y: dialogueText.y - 30,
              duration: 300,
              onComplete: () => {
                dialogueText.destroy();
                if (callback) callback();
              }
            });
          });
        }
      },
      loop: true
    });
  }

  showBulletHellTitle(callback) {
    const { width, height } = this.cameras.main;

    const titleText = this.add.text(width / 2, height / 2, 'BULLET HELL!', {
      fontSize: '64px',
      fontStyle: 'bold',
      fill: '#ff0000',
      stroke: '#ffff00',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(4600).setScale(0).setAlpha(0);

    // Ìè≠Î∞úÏ†Å Îì±Ïû•
    this.tweens.add({
      targets: titleText,
      scale: 1.2,
      alpha: 1,
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
        this.cameras.main.shake(300, 0.02);

        // ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 50 + Math.random() * 100;
          const particle = this.add.circle(
            width / 2,
            height / 2,
            5 + Math.random() * 5,
            [0xff0000, 0xff00ff, 0xffff00][Math.floor(Math.random() * 3)]
          ).setDepth(4599);

          this.tweens.add({
            targets: particle,
            x: width / 2 + Math.cos(angle) * dist,
            y: height / 2 + Math.sin(angle) * dist,
            alpha: 0,
            duration: 500,
            onComplete: () => particle.destroy()
          });
        }

        // ÌéòÏù¥ÎìúÏïÑÏõÉ
        this.time.delayedCall(800, () => {
          this.tweens.add({
            targets: titleText,
            alpha: 0,
            scale: 0.5,
            duration: 300,
            onComplete: () => {
              titleText.destroy();
              if (callback) callback();
            }
          });
        });
      }
    });
  }

  // ========== Ïõ®Ïù¥Î∏å ÏãúÏä§ÌÖú ==========

  startBulletWave() {
    if (!this.bulletBossMode || this.bulletBossPhase !== 'shooting') return;

    this.bulletBossWaveCount++;

    // Ïõ®Ïù¥Î∏åÏóê Îî∞Îùº Ìå®ÌÑ¥ Î≥µÏû°ÎèÑ Ï¶ùÍ∞Ä
    const wave = this.bulletBossWaveCount;

    // Î™®Îì† Ïõ®Ïù¥Î∏å: Î∞îÎ°ú Î∞úÏÇ¨ (Í≤ΩÍ≥†Îäî Ï≤´ Ïõ®Ïù¥Î∏å Ïù∏Ìä∏Î°úÏóêÏÑúÎßå)
    this.showWaveStartText(wave);
    this.executeBulletPattern(wave);
  }

  // Í≤åÏûÑ Î©àÏ∂îÏßÄ ÏïäÎäî Îπ†Î•∏ Í≤ΩÍ≥† ÌëúÏãú
  showQuickMissileWarning() {
    // Í∏∞Ï°¥ Í≤ΩÍ≥† Ï†ïÎ¶¨
    this.clearQuickMissileWarnings();

    if (!this.bulletBossPosition) return;

    // Í≤ΩÍ≥† ÏöîÏÜå Ï†ÄÏû• Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî
    this.quickWarningElements = [];

    const bossPixelX = this.bulletBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossPixelY = this.bulletBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 8Î∞©Ìñ• ÎäêÎÇåÌëú (Í≤åÏûÑ Î©àÏ∂îÏßÄ ÏïäÏùå)
    for (let i = 0; i < 8; i++) {
      const angle = (Math.PI * 2 * i) / 8;
      const dist = 50;
      const warning = this.add.text(
        bossPixelX + Math.cos(angle) * dist,
        bossPixelY + Math.sin(angle) * dist,
        '!',
        {
          fontSize: '28px',
          fontStyle: 'bold',
          fill: '#ff0000',
          stroke: '#ffff00',
          strokeThickness: 3
        }
      ).setOrigin(0.5).setDepth(3500).setAlpha(0);

      this.quickWarningElements.push(warning);

      // ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÎÇòÌÉÄÎÇ¨Îã§ ÏÇ¨ÎùºÏßÄÍ∏∞
      this.tweens.add({
        targets: warning,
        alpha: 1,
        scale: { from: 0.5, to: 1.3 },
        duration: 100,
        delay: i * 50,
        yoyo: true,
        hold: 200,
        onComplete: () => {
          if (warning && warning.active) warning.destroy();
        }
      });
    }

    // Ï§ëÏïô Í≤ΩÍ≥† ÏïÑÏù¥ÏΩò
    const centerWarning = this.add.text(bossPixelX, bossPixelY - 40, '‚ö†', {
      fontSize: '36px'
    }).setOrigin(0.5).setDepth(3501).setAlpha(0);

    this.quickWarningElements.push(centerWarning);

    this.tweens.add({
      targets: centerWarning,
      alpha: 1,
      scale: { from: 0.8, to: 1.4 },
      duration: 150,
      yoyo: true,
      hold: 300,
      onComplete: () => {
        if (centerWarning && centerWarning.active) centerWarning.destroy();
      }
    });

    // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Îπ®Í∞Ñ ÌîåÎûòÏãú (ÏßßÍ≤å)
    const { width, height } = this.cameras.main;
    const edgeFlash = this.add.rectangle(0, 0, width, height, 0xff0000, 0)
      .setOrigin(0, 0).setDepth(3499);

    this.quickWarningElements.push(edgeFlash);

    this.tweens.add({
      targets: edgeFlash,
      alpha: 0.2,
      duration: 100,
      yoyo: true,
      repeat: 2,
      onComplete: () => {
        if (edgeFlash && edgeFlash.active) edgeFlash.destroy();
      }
    });
  }

  // Í≤ΩÍ≥† ÏöîÏÜåÎì§ Ï¶âÏãú Ï†ïÎ¶¨
  clearQuickMissileWarnings() {
    if (this.quickWarningElements && this.quickWarningElements.length > 0) {
      for (const element of this.quickWarningElements) {
        if (element && element.active) {
          this.tweens.killTweensOf(element);
          element.destroy();
        }
      }
      this.quickWarningElements = [];
    }
  }

  showWaveStartText(wave) {
    const { width } = this.cameras.main;

    const waveText = this.add.text(width / 2, this.gameAreaY + 30, `WAVE ${wave}`, {
      fontSize: '20px',
      fontStyle: 'bold',
      fill: '#ff6600',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(3000).setAlpha(0);

    this.tweens.add({
      targets: waveText,
      alpha: 1,
      scale: { from: 0.5, to: 1 },
      duration: 200,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: waveText,
          alpha: 0,
          duration: 500,
          delay: 500,
          onComplete: () => waveText.destroy()
        });
      }
    });
  }

  executeBulletPattern(wave) {
    // === Îçî Ïñ¥Î†§Ïö¥ Ïõ®Ïù¥Î∏åÎ≥Ñ Ìå®ÌÑ¥ ===
    const patterns = [];
    const baseSpeed = 3.5 + wave * 0.3; // Ïõ®Ïù¥Î∏åÎßàÎã§ Îπ®ÎùºÏßê

    // Ïõ®Ïù¥Î∏å 1: 12Î∞©Ìñ• + Îπ†Î•∏ ÏÜçÎèÑ
    patterns.push(() => this.fireRadialBullets(12, baseSpeed, 'plasma'));

    // ÏßÄÏó∞Îêú Ï∂îÍ∞Ä Î∞©ÏÇ¨ (Ï≤´ Ïõ®Ïù¥Î∏åÎ∂ÄÌÑ∞)
    patterns.push(() => {
      this.time.delayedCall(400, () => {
        this.fireRadialBullets(12, baseSpeed, 'energy', Math.PI / 12); // Ïò§ÌîÑÏÖãÏúºÎ°ú ÏóáÍ∞àÎ¶¨Í≤å
      });
    });

    // Ïõ®Ïù¥Î∏å 2+: ÎÇòÏÑ†Ìòï 2Í∞ú (Î∞òÎåÄ Î∞©Ìñ•)
    if (wave >= 2) {
      patterns.push(() => {
        this.time.delayedCall(300, () => this.fireSpiralBullets(16, 0, baseSpeed - 0.5, 'spiral'));
        this.time.delayedCall(600, () => this.fireSpiralBullets(16, Math.PI, baseSpeed - 0.5, 'spiral'));
      });
    }

    // Ïõ®Ïù¥Î∏å 3+: Ïó∞ÏÜç Ï°∞Ï§ÄÌÉÑ 5Î∞ú
    if (wave >= 3) {
      patterns.push(() => {
        for (let i = 0; i < 5; i++) {
          this.time.delayedCall(200 + i * 180, () => this.fireAimedBullet(baseSpeed + 1, 'tracker'));
        }
      });
    }

    // Ïõ®Ïù¥Î∏å 4+: ÏõêÌòï Î≤Ω Ìå®ÌÑ¥ (ÌîºÌïòÍ∏∞ Ïñ¥Î†§ÏõÄ)
    if (wave >= 4) {
      patterns.push(() => {
        this.time.delayedCall(1000, () => {
          this.fireRadialBullets(24, baseSpeed - 1, 'wall');
          this.time.delayedCall(200, () => this.fireRadialBullets(24, baseSpeed - 1, 'wall', Math.PI / 24));
        });
      });
    }

    // Ïõ®Ïù¥Î∏å 5+: ÏÇ∞ÌÉÑ Ìå®ÌÑ¥
    if (wave >= 5) {
      patterns.push(() => {
        this.time.delayedCall(800, () => this.fireShotgunBullets(7, baseSpeed + 0.5));
      });
    }

    // Î™®Îì† Ìå®ÌÑ¥ Ïã§Ìñâ
    for (const pattern of patterns) {
      pattern();
    }

    // Ïõ®Ïù¥Î∏å Ï¢ÖÎ£å ÌõÑ vulnerable ÏÉÅÌÉúÎ°ú Ï†ÑÌôò
    const waveEndDelay = 2500 + wave * 400;
    this.time.delayedCall(waveEndDelay, () => {
      if (this.bulletBossMode && this.bulletBossPhase === 'shooting') {
        this.setBossVulnerable();
      }
    });
  }

  // ÏÇ∞ÌÉÑ Ìå®ÌÑ¥ (Î±Ä Î∞©Ìñ•ÏúºÎ°ú ÌçºÏßÄÎäî Ï¥ùÏïå)
  fireShotgunBullets(count, speed) {
    if (!this.bulletBossPosition || !this.snake[0]) return;

    const bossX = this.bulletBossPosition.x;
    const bossY = this.bulletBossPosition.y;
    const head = this.snake[0];

    const baseAngle = Math.atan2(head.y - bossY, head.x - bossX);
    const spread = Math.PI / 6; // 30ÎèÑ ÌçºÏßê

    for (let i = 0; i < count; i++) {
      const angle = baseAngle + spread * ((i / (count - 1)) - 0.5) * 2;
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      this.createBullet(bossX, bossY, dx, dy, speed, 'shotgun');
    }

    this.showBulletFireEffect(bossX, bossY);
  }

  // ========== Vulnerable ÏÉÅÌÉú ==========

  setBossVulnerable() {
    if (!this.bulletBossMode) return;

    this.bulletBossPhase = 'vulnerable';

    // Î≥¥Ïä§ ÏÉâÏÉÅÏùÑ Ï¥àÎ°ùÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
    if (this.bulletBossBody) {
      this.tweens.add({
        targets: this.bulletBossBody,
        fillColor: { from: 0xff00ff, to: 0x00ff00 },
        duration: 300
      });
      this.bulletBossBody.setFillStyle(0x00ff00);
    }

    // "HIT ME!" ÌëúÏãú
    this.showHitMeIndicator();

    // 2Ï¥à ÌõÑ Îã§Ïãú shooting ÏÉÅÌÉúÎ°ú (ÎßûÏßÄ ÏïäÏïòÎã§Î©¥)
    this.bulletBossVulnerableTimer = this.time.delayedCall(2000, () => {
      if (this.bulletBossPhase === 'vulnerable') {
        this.bulletBossPhase = 'shooting';
        this.hideHitMeIndicator();

        // Î≥¥Ïä§ ÏÉâÏÉÅ Î≥µÏõê
        if (this.bulletBossBody) {
          this.bulletBossBody.setFillStyle(0xff00ff);
        }

        // Îã§Ïùå Ïõ®Ïù¥Î∏å
        this.startBulletWave();
      }
    });
  }

  showHitMeIndicator() {
    if (!this.bulletBossPosition) return;

    const { x, y } = this.bulletBossPosition;
    const pixelX = x * this.gridSize + this.gridSize / 2;
    const pixelY = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    this.hitMeText = this.add.text(pixelX, pixelY - 40, 'HIT', {
      fontSize: '20px',
      fontStyle: 'bold',
      fill: '#00ff00',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(160);

    // ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: this.hitMeText,
      alpha: { from: 1, to: 0.3 },
      scale: { from: 1, to: 1.2 },
      duration: 200,
      yoyo: true,
      repeat: -1
    });
  }

  hideHitMeIndicator() {
    if (this.hitMeText) {
      this.hitMeText.destroy();
      this.hitMeText = null;
    }
  }

  // ========== HIT Ï≤òÎ¶¨ ==========

  handleBulletBossHit() {
    if (this.bulletBossPhase !== 'vulnerable') return;

    this.bulletBossHitCount++;
    this.bulletBossPhase = 'teleporting';

    // ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
    if (this.bulletBossVulnerableTimer) {
      this.bulletBossVulnerableTimer.destroy();
    }

    // HIT ME ÌëúÏãú Ï†úÍ±∞
    this.hideHitMeIndicator();

    // Î™®Îì† Ï¥ùÏïå Ï†úÍ±∞
    this.clearAllBullets();

    // 4Î≤à HITÎ©¥ Ïö∏Ìä∏Îùº Ïä¨Î°úÏö∞Î™®ÏÖò ÌååÏù¥ÎÑê ÌûàÌä∏!
    if (this.bulletBossHitCount >= 4) {
      this.handleBulletBossFinalHit();
    } else {
      // HIT Ïù¥ÌéôÌä∏
      this.showBulletBossHitEffect();

      // HIT ÌÖçÏä§Ìä∏
      const hitText = `HIT ${this.bulletBossHitCount}/4!`;
      this.showHitText(hitText);

      // HIT ÌõÑ Ï¶âÏãú ÏÇ¨ÎùºÏ°åÎã§Í∞Ä ÎûúÎç§ ÏúÑÏπòÎ°ú ÏÉùÏÑ±
      this.teleportBulletBoss({
        onComplete: () => {
          // ÏÉà ÏúÑÏπòÏóêÏÑú ÎäêÎÇåÌëú Í≤ΩÍ≥† ÌõÑ Í≥µÍ≤© ÏãúÏûë
          this.time.delayedCall(400, () => {
            this.showBossWarningBeforeAttack(() => {
              this.bulletBossPhase = 'shooting';
              this.startBulletWave();
            });
          });
        }
      });
    }
  }

  // Î≥¥Ïä§Í∞Ä ÏÉà ÏúÑÏπòÏóêÏÑú Í≥µÍ≤© Ï†Ñ ÎäêÎÇåÌëú Í≤ΩÍ≥† ÌëúÏãú
  showBossWarningBeforeAttack(onComplete) {
    if (!this.bulletBossPosition) {
      onComplete();
      return;
    }

    const { x, y } = this.bulletBossPosition;
    const pixelX = x * this.gridSize + this.gridSize / 2;
    const pixelY = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎäêÎÇåÌëú ÌëúÏãú
    const warningText = this.add.text(pixelX, pixelY - 35, '!', {
      fontSize: '28px',
      fontStyle: 'bold',
      fill: '#ff0000',
      stroke: '#ffff00',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(160).setAlpha(0);

    // Îπ†Î•¥Í≤å ÎÇòÌÉÄÎÇ¨Îã§ ÏÇ¨ÎùºÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scale: { from: 0.5, to: 1.3 },
      duration: 150,
      ease: 'Back.easeOut',
      onComplete: () => {
        // Ïû†Ïãú Ïú†ÏßÄ ÌõÑ ÏÇ¨ÎùºÏßê
        this.tweens.add({
          targets: warningText,
          alpha: { from: 1, to: 0.5 },
          scale: { from: 1.3, to: 1.1 },
          duration: 100,
          yoyo: true,
          repeat: 1,
          onComplete: () => {
            this.tweens.add({
              targets: warningText,
              alpha: 0,
              scale: 0.3,
              duration: 100,
              onComplete: () => {
                warningText.destroy();
                onComplete();
              }
            });
          }
        });
      }
    });
  }

  showTeleportStrikeWarning(originPos) {
    if (!originPos) return;
    if (!this.bulletBossMode || this.bulletBossPhase === 'victory') return;

    const pixelX = originPos.x * this.gridSize + this.gridSize / 2;
    const pixelY = originPos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const warningText = this.add.text(pixelX, pixelY - 35, '!', {
      fontSize: '30px',
      fontStyle: 'bold',
      fill: '#ff0000',
      stroke: '#ffff00',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(160).setAlpha(0);

    if (this.bulletBossTeleportStrikeEffects) {
      this.bulletBossTeleportStrikeEffects.push(warningText);
    }

    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scale: { from: 0.6, to: 1.4 },
      duration: 140,
      yoyo: true,
      repeat: 2,
      onComplete: () => {
        if (warningText && warningText.active) {
          warningText.destroy();
        }
        if (this.bulletBossTeleportStrikeEffects) {
          this.bulletBossTeleportStrikeEffects = this.bulletBossTeleportStrikeEffects.filter(el => el !== warningText);
        }
      }
    });
  }

  // ÌÉÑÎßâ Î≥¥Ïä§ ÌååÏù¥ÎÑê ÌûàÌä∏ - Ïö∏Ìä∏Îùº Ïä¨Î°úÏö∞Î™®ÏÖò Í∑πÏ†Å Ïó∞Ï∂ú (ÏßßÍ≤å)
  handleBulletBossFinalHit() {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏôÑÏ†Ñ Ï†ïÏßÄ
    this.moveTimer.paused = true;
    this.bulletBossPhase = 'victory';

    // Î≥¥Ïä§ ÏúÑÏπò
    const bossX = this.bulletBossElement ? this.bulletBossElement.x : width / 2;
    const bossY = this.bulletBossElement ? this.bulletBossElement.y : height / 2;

    // === PHASE 1: Ïä¨Î°úÏö∞Î™®ÏÖò + ÌôîÎ©¥ Ïñ¥Îë°Í≤å ===
    this.time.timeScale = 0.3;

    const darkOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0)
      .setDepth(5000).setScrollFactor(0); // ÌôîÎ©¥ Í≥†Ï†ï
    this.tweens.add({
      targets: darkOverlay,
      alpha: 0.5,
      duration: 200
    });

    // Ïπ¥Î©îÎùº Ï§å (Îπ†Î•¥Í≤å)
    this.cameras.main.zoomTo(1.8, 300, 'Power2', false, (cam, zoomProgress) => {
      if (zoomProgress === 1) {
        this.cameras.main.shake(400, 0.04);

        // === PHASE 2: "FINAL HIT!" ÌÖçÏä§Ìä∏ (ÌôîÎ©¥ Ï§ëÏïô Í≥†Ï†ï) ===
        const finalHitText = this.add.text(width / 2, height / 2 - 60, 'FINAL HIT!!', {
          fontSize: '56px',
          fontStyle: 'bold',
          fill: '#ff0000',
          stroke: '#ffff00',
          strokeThickness: 8
        }).setOrigin(0.5).setDepth(6000).setScale(0).setScrollFactor(0);

        this.tweens.add({
          targets: finalHitText,
          scale: 1.2,
          duration: 250,
          ease: 'Back.easeOut'
        });

        // Î≥¥Ïä§ ÎπÑÎ™Ö (ÏõîÎìú Ï¢åÌëú)
        const scream = this.add.text(bossX, bossY - 40, "NOOOOO!!!", {
          fontSize: '28px',
          fontStyle: 'bold',
          fill: '#ff00ff',
          stroke: '#ffffff',
          strokeThickness: 3
        }).setOrigin(0.5).setDepth(6001).setAlpha(0);

        this.tweens.add({
          targets: scream,
          alpha: 1,
          y: bossY - 70,
          scale: { from: 0.5, to: 1.5 },
          duration: 400
        });

        // Î≥¥Ïä§ ÌåΩÏ∞Ω
        if (this.bulletBossElement) {
          this.tweens.add({
            targets: this.bulletBossElement,
            scale: 2,
            duration: 400,
            ease: 'Quad.easeIn'
          });
        }

        // === PHASE 3: ÎåÄÌè≠Î∞ú (400ms ÌõÑ) ===
        this.time.delayedCall(400, () => {
          // ÌôîÎ©¥ ÌîåÎûòÏãú
          const flash = this.add.rectangle(width / 2, height / 2, width * 2, height * 2, 0xffffff, 0)
            .setDepth(6500).setScrollFactor(0);
          this.tweens.add({
            targets: flash,
            alpha: 0.9,
            duration: 100,
            yoyo: true,
            hold: 50,
            onComplete: () => flash.destroy()
          });

          // Î≥¥Ïä§ Ìè≠Î∞ú
          if (this.bulletBossElement) {
            const bx = this.bulletBossElement.x;
            const by = this.bulletBossElement.y;

            // Ìè≠Î∞ú ÎßÅ
            for (let ring = 0; ring < 2; ring++) {
              const explosionRing = this.add.circle(bx, by, 10, 0xffffff, 0).setDepth(6200);
              explosionRing.setStrokeStyle(4, [0xff00ff, 0xffff00][ring]);
              this.tweens.add({
                targets: explosionRing,
                radius: 100 + ring * 40,
                alpha: 0,
                duration: 400,
                delay: ring * 50,
                onComplete: () => explosionRing.destroy()
              });
            }

            // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
            for (let i = 0; i < 25; i++) {
              const angle = (i / 25) * Math.PI * 2;
              const dist = 40 + Math.random() * 80;
              const colors = [0xff00ff, 0xffff00, 0x00ffff, 0xffffff];
              const particle = this.add.star(bx, by, 5, 3, 6,
                colors[Math.floor(Math.random() * colors.length)]
              ).setDepth(6100);

              this.tweens.add({
                targets: particle,
                x: bx + Math.cos(angle) * dist,
                y: by + Math.sin(angle) * dist,
                rotation: Math.random() * 6,
                scale: 0,
                alpha: 0,
                duration: 500,
                onComplete: () => particle.destroy()
              });
            }

            this.bulletBossElement.destroy();
            this.bulletBossElement = null;
          }

          // ÌÖçÏä§Ìä∏ ÌéòÏù¥ÎìúÏïÑÏõÉ
          this.tweens.add({
            targets: [finalHitText, scream],
            alpha: 0,
            duration: 300,
            delay: 200,
            onComplete: () => {
              if (finalHitText && finalHitText.active) finalHitText.destroy();
              if (scream && scream.active) scream.destroy();
            }
          });

          // === PHASE 4: Ï§å ÏïÑÏõÉ & ÏäπÎ¶¨ (600ms ÌõÑ) ===
          this.time.delayedCall(600, () => {
            this.time.timeScale = 1;

            this.tweens.add({
              targets: darkOverlay,
              alpha: 0,
              duration: 200,
              onComplete: () => darkOverlay.destroy()
            });

            this.cameras.main.zoomTo(1, 300, 'Power2', false, () => {
              this.showBulletBossVictory();
            });
          });
        });
      }
    });
  }

  showBulletBossHitEffect() {
    if (!this.bulletBossElement) return;

    const x = this.bulletBossElement.x;
    const y = this.bulletBossElement.y;

    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 30 + Math.random() * 30;
      const particle = this.add.circle(
        x, y,
        4 + Math.random() * 4,
        [0x00ff00, 0xffff00, 0xffffff][Math.floor(Math.random() * 3)]
      ).setDepth(200);

      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * dist,
        y: y + Math.sin(angle) * dist,
        alpha: 0,
        duration: 400,
        onComplete: () => particle.destroy()
      });
    }

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(200, 0.02);

    // Î≥¥Ïä§ ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: this.bulletBossElement,
      alpha: 0,
      duration: 100,
      yoyo: true,
      repeat: 3
    });
  }

  showHitText(text) {
    const { width, height } = this.cameras.main;

    const hitText = this.add.text(width / 2, height / 2, text, {
      fontSize: '48px',
      fontStyle: 'bold',
      fill: '#ffff00',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000).setScale(0);

    this.tweens.add({
      targets: hitText,
      scale: 1.2,
      duration: 200,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: hitText,
          alpha: 0,
          y: hitText.y - 50,
          duration: 500,
          delay: 300,
          onComplete: () => hitText.destroy()
        });
      }
    });
  }

  teleportBulletBoss(options = {}) {
    const onComplete = typeof options.onComplete === 'function' ? options.onComplete : null;
    const originPos = this.bulletBossPosition ? { x: this.bulletBossPosition.x, y: this.bulletBossPosition.y } : null;

    // ÏÉà ÏúÑÏπò Í≤∞Ï†ï
    let newX, newY;
    let attempts = 0;
    do {
      newX = 5 + Math.floor(Math.random() * (this.cols - 10));
      newY = 5 + Math.floor(Math.random() * (this.rows - 10));
      attempts++;
    } while ((this.isPositionOccupied(newX, newY) ||
             (originPos && newX === originPos.x && newY === originPos.y)) &&
             attempts < 50);

    const finalizeTeleport = () => {
      this.bulletBossPosition = { x: newX, y: newY };
      this.drawBulletBoss();

      // ÏÇ¨ÎùºÏßÑ ÏúÑÏπòÏóêÏÑú 1Ï¥à ÌõÑ Í∏∞Ï°¥ Î≥¥Ïä§ Í≥µÍ≤© 1Ìöå (ÎÇúÏù¥ÎèÑ ÏóÖ)
      if (originPos) {
        this.scheduleBulletBossTeleportStrike(originPos);
      }

      if (onComplete) onComplete();
    };

    // ÏÇ¨ÎùºÏßÄÎäî Ïù¥ÌéôÌä∏
    if (this.bulletBossElement) {
      this.tweens.add({
        targets: this.bulletBossElement,
        alpha: 0,
        scale: 0,
        duration: 200,
        onComplete: () => {
          this.bulletBossElement.destroy();
          this.bulletBossElement = null;
          finalizeTeleport();
        }
      });
    } else {
      finalizeTeleport();
    }
  }

  scheduleBulletBossTeleportStrike(originPos) {
    if (!originPos) return;
    if (!this.bulletBossMode || this.bulletBossPhase === 'victory') return;

    const strikeDelay = 1000;
    const warningLead = 350;

    const warningTimer = this.time.delayedCall(Math.max(0, strikeDelay - warningLead), () => {
      if (!this.bulletBossMode || this.bulletBossPhase === 'victory') return;
      if (this.gameOver) return;
      this.showTeleportStrikeWarning(originPos);
    });

    const strikeTimer = this.time.delayedCall(strikeDelay, () => {
      if (!this.bulletBossMode || this.bulletBossPhase === 'victory') return;
      if (this.gameOver) return;
      this.spawnBulletBossTeleportStrike(originPos);
    });

    if (!this.bulletBossTeleportStrikeTimers) this.bulletBossTeleportStrikeTimers = [];
    this.bulletBossTeleportStrikeTimers.push(warningTimer, strikeTimer);
  }

  spawnBulletBossTeleportStrike(originPos) {
    if (!originPos) return;
    if (!this.bulletBossMode || this.bulletBossPhase === 'victory') return;
    if (this.gameOver) return;

    // Í∏∞Ï°¥ Î≥¥Ïä§Í∞Ä ÏèòÎçò Ìå®ÌÑ¥ÏùÑ "ÏÇ¨ÎùºÏßÑ ÏúÑÏπò"ÏóêÏÑú 1Ìöå Îçî Î∞úÏÇ¨
    const wave = Math.max(1, this.bulletBossWaveCount || 1);
    const baseSpeed = 3.5 + wave * 0.3;
    this.fireRadialBulletsFromPosition(originPos, 12, baseSpeed, 'plasma');
  }

  // ========== ÏäπÎ¶¨ Ï≤òÎ¶¨ ==========

  showBulletBossVictory() {
    // Ïù¥ÎØ∏ ÌååÏù¥ÎÑê ÌûàÌä∏ÏóêÏÑú phaseÎ•º victoryÎ°ú ÏÑ§Ï†ïÌñàÏúºÎØÄÎ°ú Îã§Ïãú ÌôïÏù∏
    this.bulletBossPhase = 'victory';
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;
    const victoryElements = [];

    // Í≤åÏûÑ ÏôÑÏ†Ñ Ï†ïÏßÄ (Î±ÄÏù¥ ÏõÄÏßÅÏù¥ÏßÄ ÏïäÎèÑÎ°ù)
    this.moveTimer.paused = true;
    this.stopBulletUpdateTimer();
    this.clearQuickMissileWarnings();

    // Í≤åÏûÑ ÏòÅÏó≠ ÌÅ¥Î¶¨Ïñ¥ (Î±Ä, Î®πÏù¥ Ïà®Í∏∞Í∏∞)
    this.clearGameAreaForVictory();

    // Î≥¥Ïä§Îäî ÌååÏù¥ÎÑê ÌûàÌä∏ÏóêÏÑú Ïù¥ÎØ∏ ÌååÍ¥¥Îê® - Î∞îÎ°ú Ï∂ïÌïò Ïó∞Ï∂úÎ°ú
    // === "BULLET HELL CLEAR!" ÌÖçÏä§Ìä∏ Î∞îÎ°ú ÏãúÏûë ===

    // ÌôîÎ©¥ ÌîåÎûòÏãú (ÎÖ∏ÎûÄÏÉâ)
    const flash2 = this.add.rectangle(centerX, centerY, width, height, 0xffff00, 0.6)
      .setDepth(6000).setScrollFactor(0);
    victoryElements.push(flash2);
    this.tweens.add({
      targets: flash2,
      alpha: 0,
      duration: 300,
      onComplete: () => flash2.destroy()
    });

    // "BULLET HELL" ÌÖçÏä§Ìä∏ (ÏúÑÏóêÏÑú Îñ®Ïñ¥Ïßê)
    const bulletHellText = this.add.text(centerX, -100, 'BULLET HELL', {
      fontSize: '64px',
      fontStyle: 'bold',
      fill: '#ff00ff',
      stroke: '#ffffff',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(6500).setScrollFactor(0);
    victoryElements.push(bulletHellText);

    this.tweens.add({
      targets: bulletHellText,
      y: centerY - 50,
      duration: 400,
      ease: 'Bounce.easeOut'
    });

    // "CLEAR!!" ÌÖçÏä§Ìä∏ (ÏïÑÎûòÏóêÏÑú Ïò¨ÎùºÏò¥)
    const clearText = this.add.text(centerX, height + 100, 'CLEAR!!', {
      fontSize: '80px',
      fontStyle: 'bold',
      fill: '#ffff00',
      stroke: '#ff6600',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(6500).setScrollFactor(0);
    victoryElements.push(clearText);

    this.tweens.add({
      targets: clearText,
      y: centerY + 40,
      duration: 400,
      ease: 'Bounce.easeOut',
      delay: 200
    });

    // ÌÖçÏä§Ìä∏ ÌéÑÏä§ Ìö®Í≥º
    this.time.delayedCall(700, () => {
      this.tweens.add({
        targets: [bulletHellText, clearText],
        scale: { from: 1, to: 1.1 },
        duration: 300,
        yoyo: true,
        repeat: 3,
        ease: 'Sine.easeInOut'
      });

      // Î†àÏù∏Î≥¥Ïö∞ Í∏ÄÎ°úÏö∞ Ìö®Í≥º
      let glowTime = 0;
      const glowInterval = this.time.addEvent({
        delay: 50,
        callback: () => {
          glowTime += 0.2;
          const hue = (Math.sin(glowTime) + 1) / 2;
          bulletHellText.setTint(Phaser.Display.Color.HSLToColor(hue, 1, 0.5).color);
        },
        repeat: 40
      });
    });

    // === PHASE 3: Ïª®ÌéòÌã∞ & Î∂àÍΩÉÎÜÄÏù¥ (1Ï¥à ÌõÑ) ===
    this.time.delayedCall(1000, () => {
      // Ïª®ÌéòÌã∞ ÎπÑ
      for (let i = 0; i < 100; i++) {
        const confetti = this.add.rectangle(
          Math.random() * width,
          -20 - Math.random() * 200,
          8 + Math.random() * 8,
          4 + Math.random() * 4,
          [0xff00ff, 0xffff00, 0x00ffff, 0xff0000, 0x00ff00, 0xff6600][Math.floor(Math.random() * 6)]
        ).setDepth(5800).setRotation(Math.random() * Math.PI);
        victoryElements.push(confetti);

        this.tweens.add({
          targets: confetti,
          y: height + 50,
          x: confetti.x + (Math.random() - 0.5) * 200,
          rotation: confetti.rotation + Math.random() * 10,
          duration: 2000 + Math.random() * 1500,
          delay: Math.random() * 1000,
          onComplete: () => confetti.destroy()
        });
      }

      // Î∂àÍΩÉÎÜÄÏù¥ (ÌôîÎ©¥ Ïó¨Îü¨ Í≥≥ÏóêÏÑú)
      for (let fw = 0; fw < 5; fw++) {
        this.time.delayedCall(fw * 400, () => {
          const fwX = 100 + Math.random() * (width - 200);
          const fwY = 100 + Math.random() * (height - 250);
          const fwColor = [0xff00ff, 0xffff00, 0x00ffff, 0xff6600, 0x00ff00][fw];

          // Î∂àÍΩÉ Î∞úÏÇ¨
          const rocket = this.add.circle(fwX, height, 5, fwColor).setDepth(5900);
          victoryElements.push(rocket);

          this.tweens.add({
            targets: rocket,
            y: fwY,
            duration: 400,
            ease: 'Quad.easeOut',
            onComplete: () => {
              rocket.destroy();

              // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
              for (let p = 0; p < 24; p++) {
                const angle = (p / 24) * Math.PI * 2;
                const dist = 40 + Math.random() * 60;
                const spark = this.add.circle(fwX, fwY, 3 + Math.random() * 4, fwColor).setDepth(5900);
                victoryElements.push(spark);

                this.tweens.add({
                  targets: spark,
                  x: fwX + Math.cos(angle) * dist,
                  y: fwY + Math.sin(angle) * dist + 30,
                  alpha: 0,
                  scale: 0,
                  duration: 800,
                  ease: 'Quad.easeOut',
                  onComplete: () => spark.destroy()
                });
              }

              // Ìè≠Î∞úÏùå ÎåÄÏã† ÏãúÍ∞ÅÏ†Å ÌîåÎûòÏãú
              const miniFlash = this.add.circle(fwX, fwY, 30, fwColor, 0.5).setDepth(5890);
              victoryElements.push(miniFlash);
              this.tweens.add({
                targets: miniFlash,
                scale: 2,
                alpha: 0,
                duration: 200,
                onComplete: () => miniFlash.destroy()
              });
            }
          });
        });
      }
    });

    // === PHASE 4: Î≥¥ÎÑàÏä§ Ï†êÏàò (1.8Ï¥à ÌõÑ) ===
    this.time.delayedCall(1800, () => {
      // "+1000 BONUS!"
      const bonusText = this.add.text(centerX, centerY + 100, '+1000 BONUS!', {
        fontSize: '40px',
        fontStyle: 'bold',
        fill: '#00ff00',
        stroke: '#004400',
        strokeThickness: 5
      }).setOrigin(0.5).setDepth(6500).setScale(0).setScrollFactor(0);
      victoryElements.push(bonusText);

      this.tweens.add({
        targets: bonusText,
        scale: 1.3,
        duration: 300,
        ease: 'Back.easeOut',
        onComplete: () => {
          this.tweens.add({
            targets: bonusText,
            scale: 1,
            duration: 200
          });
        }
      });

      // Ï†êÏàò Ïπ¥Ïö¥Ìä∏ÏóÖ Ìö®Í≥º
      this.score = 0;
      const scoreCountUp = this.time.addEvent({
        delay: 20,
        callback: () => {
          this.score += 50;
          if (this.score >= 1000) {
            this.score = 1000;
            scoreCountUp.remove();
          }
          this.scoreText.setText(this.score.toString());
        },
        repeat: 20
      });

      // ÏΩîÏù∏ ÌååÌã∞ÌÅ¥
      for (let c = 0; c < 20; c++) {
        const coin = this.add.circle(
          bonusText.x + (Math.random() - 0.5) * 200,
          bonusText.y,
          6, 0xffd700
        ).setDepth(6400);
        victoryElements.push(coin);

        this.tweens.add({
          targets: coin,
          y: coin.y - 50 - Math.random() * 50,
          alpha: 0,
          duration: 600,
          delay: c * 30,
          ease: 'Quad.easeOut',
          onComplete: () => coin.destroy()
        });
      }
    });

    // === PHASE 5: ÏäπÎ¶¨ ÎßÅ Ïù¥ÌéôÌä∏ (2.5Ï¥à ÌõÑ) ===
    this.time.delayedCall(2500, () => {
      // ÌôîÎ©¥ Ï§ëÏïôÏóêÏÑú ÌçºÏßÄÎäî ÏäπÎ¶¨ ÎßÅ
      for (let i = 0; i < 3; i++) {
        this.time.delayedCall(i * 200, () => {
          const victoryRing = this.add.circle(centerX, centerY, 20, 0xffffff, 0).setDepth(6000);
          victoryRing.setStrokeStyle(4, 0xffd700);
          victoryElements.push(victoryRing);

          this.tweens.add({
            targets: victoryRing,
            radius: 400,
            alpha: 0,
            duration: 800,
            onComplete: () => victoryRing.destroy()
          });
        });
      }
    });

    // === PHASE 6: ÎßàÎ¨¥Î¶¨ Î∞è ÏÉÅÏ†ê Ï†ÑÌôò (4Ï¥à ÌõÑ) ===
    this.time.delayedCall(4000, () => {
      // Î™®Îì† ÌÖçÏä§Ìä∏ ÌéòÏù¥Îìú ÏïÑÏõÉ
      victoryElements.forEach(el => {
        if (el && el.active) {
          this.tweens.add({
            targets: el,
            alpha: 0,
            duration: 500,
            onComplete: () => el.destroy()
          });
        }
      });

      // ÎßàÏßÄÎßâ ÌôîÎ©¥ ÌîåÎûòÏãú
      const finalFlash = this.add.rectangle(centerX, centerY, width, height, 0xffffff, 0.4).setDepth(7000);
      this.tweens.add({
        targets: finalFlash,
        alpha: 0,
        duration: 500,
        onComplete: () => finalFlash.destroy()
      });

      this.time.delayedCall(800, () => {
        // 6ÌÉÑ Î≥¥Ïä§ BGM Ï†ïÏßÄ ÌõÑ Í∏∞Î≥∏ BGMÏúºÎ°ú ÏõêÎ≥µ
        if (this.boss6Music && this.boss6Music.isPlaying) {
          this.boss6Music.stop();
        }
        if (this.bgMusic && !this.bgMusic.isPlaying) {
          this.bgMusic.play();
        }

        this.cleanupBulletBoss();

        // ÏÉÅÏ†ê Ïò§Ìîà ÎòêÎäî Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ
        if (this.currentStage >= 3) {
          this.openShop();
        } else {
          this.showStageClearText();
        }
      });
    });
  }

  cleanupBulletBoss() {
    this.bulletBossMode = false;
    this.bulletBossPhase = 'none';
    this.bulletBossPosition = null;

    // ÌÖîÎ†àÌè¨Ìä∏ ÎØ∏ÏÇ¨Ïùº ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.bulletBossTeleportStrikeTimers && this.bulletBossTeleportStrikeTimers.length > 0) {
      for (const t of this.bulletBossTeleportStrikeTimers) {
        if (!t) continue;
        if (t.destroy) t.destroy();
        else if (t.remove) t.remove();
      }
      this.bulletBossTeleportStrikeTimers = [];
    }

    // ÌÖîÎ†àÌè¨Ìä∏ ÎØ∏ÏÇ¨Ïùº Ïó∞Ï∂ú ÏöîÏÜå Ï†ïÎ¶¨
    if (this.bulletBossTeleportStrikeEffects && this.bulletBossTeleportStrikeEffects.length > 0) {
      for (const el of this.bulletBossTeleportStrikeEffects) {
        if (!el || !el.active) continue;
        this.tweens.killTweensOf(el);
        el.destroy();
      }
      this.bulletBossTeleportStrikeEffects = [];
    }

    // Ï¥ùÏïå Ï†ïÎ¶¨
    this.clearAllBullets();
    this.stopBulletUpdateTimer();

    // UI Ï†ïÎ¶¨
    this.hideDodgeCooldownUI();
    this.hideHitMeIndicator();

    // Î≥¥Ìò∏Îßâ Ï†ïÎ¶¨
    this.stopPostDodgeShield();
    this.isInvincible = false;

    // Î≥¥Ïä§ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.bulletBossElement) {
      this.bulletBossElement.destroy();
      this.bulletBossElement = null;
    }

    // ÏΩ§Î≥¥ Î≥µÏõê
    this.combo = this.savedCombo;
    this.comboShieldCount = this.savedComboShieldCount;
    if (this.combo > 0) {
      this.comboText.setText(`x${this.combo}`);
    }

    // Í≤åÏûÑ Ïû¨Í∞úÎäî ÏÉÅÏ†ê Îã´Ìûå ÌõÑ ÎòêÎäî Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑú Ï≤òÎ¶¨
    // this.moveTimer.paused = false; // Ïó¨Í∏∞ÏÑú Ïû¨Í∞úÌïòÏßÄ ÏïäÏùå!
  }

  // ÏäπÎ¶¨ Ïó∞Ï∂úÏö© Í≤åÏûÑ ÏòÅÏó≠ ÌÅ¥Î¶¨Ïñ¥
  clearGameAreaForVictory() {
    // Î±Ä/Í≤©Ïûê Í∑∏ÎûòÌîΩ Ïà®Í∏∞Í∏∞
    this.hideSnakeGraphics();
    if (this.gridGraphics) {
      this.gridGraphics.setVisible(false);
    }
    if (this.snakeGraphics) {
      this.snakeGraphics.clear();
      this.snakeGraphics.setVisible(false);
    }

    // Î®πÏù¥ Í∑∏ÎûòÌîΩ Ïà®Í∏∞Í∏∞
    if (this.foodGraphics) {
      this.foodGraphics.clear();
    }

    // Îç∞ÎìúÏ°¥ Ïà®Í∏∞Í∏∞
    if (this.deadZones) {
      this.deadZones.forEach(dz => {
        if (dz.rect) dz.rect.setVisible(false);
      });
    }
    if (this.deadZoneGraphics) {
      this.deadZoneGraphics.clear();
    }

    // ÌÜ±Îãà Ïà®Í∏∞Í∏∞
    if (this.saws) {
      this.saws.forEach(saw => {
        if (saw.container) saw.container.setVisible(false);
      });
    }

    // ÏûêÍ∏∞Ïû• Ïà®Í∏∞Í∏∞
    if (this.gasZoneGraphics) {
      this.gasZoneGraphics.clear();
    }
  }

  // ÌÉÑÎßâ Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (showNextStageÏóêÏÑú Ìò∏Ï∂ú)
  isBulletBossStage() {
    return this.currentStage === this.testBulletBossStage;
  }

  // ÏïàÍ∞ú Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨
  isFogBossStage() {
    return this.currentStage === this.testFogBossStage;
  }

  // ÎèÖÍ∞úÍµ¨Î¶¨ Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 3)
  isPoisonFrogBossStage() {
    const stage = this.currentStage;
    if (this.isBulletBossStage()) return false;
    if (this.isFogBossStage()) return false;
    if (this.isGearTitanStage()) return false;
    if (isMagnetarStage(stage)) return false;
    if (isMultiverseCollapseStage(stage)) return false;

    return stage === this.testBossStage ||
      (stage > this.testBossStage && stage % this.bossStageInterval === 0);
  }

  // ÎèÖÍ∞úÍµ¨Î¶¨ Î≥¥Ïä§ Îì±Ïû• ÏúÑÏπò (Stage 3 Í∏∞Ï§Ä)
  getPoisonFrogSpawnPosition() {
    let bossX = this.cols - 9;
    let bossY = 15;

    bossX = Phaser.Math.Clamp(bossX, 0, Math.max(0, this.cols - 1));
    bossY = Phaser.Math.Clamp(bossY, 0, Math.max(0, this.rows - 1));

    // Îç∞ÎìúÏ°¥Í≥º Í≤πÏπòÎ©¥ Ïù∏Ï†ë ÌÉÄÏùºÎ°ú Ïù¥Îèô
    const isOnDeadZone = this.deadZones.some(dz => dz.x === bossX && dz.y === bossY);
    if (isOnDeadZone) {
      const offsets = [
        { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }
      ];
      for (const offset of offsets) {
        const newX = bossX + offset.x;
        const newY = bossY + offset.y;
        if (newX >= 0 && newX < this.cols && newY >= 0 && newY < this.rows) {
          const alsoOnDeadZone = this.deadZones.some(dz => dz.x === newX && dz.y === newY);
          if (!alsoOnDeadZone) {
            bossX = newX;
            bossY = newY;
            break;
          }
        }
      }
    }

    // Î±Ä/Îç∞ÎìúÏ°¥Í≥º Í≤πÏπòÎ©¥ Ï£ºÎ≥ÄÏóêÏÑú ÏïàÏ†ÑÌïú ÌÉÄÏùº ÌÉêÏÉâ
    if (this.isPositionOccupied && this.isPositionOccupied(bossX, bossY)) {
      let found = false;
      const maxRadius = 6;
      for (let r = 1; r <= maxRadius && !found; r++) {
        for (let dx = -r; dx <= r && !found; dx++) {
          for (let dy = -r; dy <= r && !found; dy++) {
            if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
            const nx = bossX + dx;
            const ny = bossY + dy;
            if (nx < 0 || nx >= this.cols || ny < 0 || ny >= this.rows) continue;
            if (!this.isPositionOccupied(nx, ny)) {
              bossX = nx;
              bossY = ny;
              found = true;
            }
          }
        }
      }
    }

    return { x: bossX, y: bossY };
  }

  // ========== ÏïàÍ∞ú Î≥¥Ïä§ (Nocturn) ÏãúÏä§ÌÖú ==========

  // ÏïàÍ∞ú Î≥¥Ïä§ ÏãúÏûë
  startFogBoss() {
    const previousCombo = this.isBossStage ? this.savedCombo : this.combo;
    const previousShield = this.isBossStage ? this.savedComboShieldCount : this.comboShieldCount;

    if (!this.isBossStage) {
      this.enterBossStage();
      this.savedCombo = previousCombo;
      this.savedComboShieldCount = previousShield;
    }

    this.fogBossMode = true;
    this.fogBossPhase = 'intro';
    this.fogBossHitCount = 0;
    this.fogBossVisible = false;
    this.flareCount = 0;
    this.flares = [];
    this.hallucinationFoods = [];
    this.fogBossFirstDodgeGraceUsed = false;
    this.dodgeAttemptCount = 0;

    if (this.moveTimer) {
      this.moveTimer.delay = 90;
      this.speedText.setText('90ms');
    }

    this.savedFogBossCombo = previousCombo;
    this.savedFogBossShieldCount = previousShield;
    this.combo = 0;
    this.comboShieldCount = 0;
    this.updateItemStatusUI();

    this.fogTestForceEnable = true;
    this.originalFogVisibleTiles = this.fogVisibleTiles;
    this.fogVisibleTiles = 2.5;
    this.fogEnabled = true;
    this.ensureFogAssets();

    this.draw();
    this.updateFogOfWar();

    this.food = { x: -100, y: -100 };

    this.moveTimer.paused = true;

    // BGMÏùÄ showFogBossIntroÏóêÏÑú Í≤ÄÏùÄ Î∞∞Í≤ΩÏù¥ ÎêòÎäî ÏàúÍ∞ÑÏóê Î≥ÄÍ≤ΩÎê®

    this.showFogBossIntro();
  }

  showFogBossIntro() {
    const { width, height } = this.cameras.main;
    this.fogBossInputBlocked = true;
    this.fogBossElements = [];

    // 1. ÌôîÎ©¥ Ïñ¥Îë°Í≤å
    const darkOverlay = this.add.rectangle(0, 0, width, height, 0x000000, 0)
      .setOrigin(0, 0)
      .setDepth(5000);
    this.fogBossElements.push(darkOverlay);

    this.tweens.add({
      targets: darkOverlay,
      alpha: 0.85,
      duration: 800,
      ease: 'Power2'
    });

    // 2. ÏÜçÏÇ≠ÏûÑ ÌÖçÏä§Ìä∏
    this.time.delayedCall(1000, () => {
      const whisperText = this.add.text(width / 2, height / 2 - 50, '', {
        fontSize: '28px',
        fill: '#666666',
        fontStyle: 'italic'
      }).setOrigin(0.5).setDepth(5001).setAlpha(0);
      this.fogBossElements.push(whisperText);

      this.tweens.add({
        targets: whisperText,
        alpha: 1,
        duration: 300
      });

      // ÌÉÄÏù¥Ìïë Ìö®Í≥º
      const whisperMessage = '...';
      let charIndex = 0;
      const typeTimer = this.time.addEvent({
        delay: 200,
        callback: () => {
          charIndex++;
          whisperText.setText(whisperMessage.substring(0, charIndex));
          if (charIndex >= whisperMessage.length) {
            typeTimer.destroy();
          }
        },
        loop: true
      });

      // 3. Îπ®Í∞Ñ Îàà Îì±Ïû• (1.5Ï¥à ÌõÑ)
      this.time.delayedCall(1500, () => {
        // ÏÜçÏÇ≠ÏûÑ ÌéòÏù¥ÎìúÏïÑÏõÉ
        this.tweens.add({
          targets: whisperText,
          alpha: 0,
          duration: 300
        });

        // üÜï DOM(Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤Ω)ÎèÑ Ìï®Íªò Ïñ¥ÎëêÏõåÏßÄÎäî Í≥µÌè¨ Ïó∞Ï∂ú!
        this.createBrowserDarkness();

        // 9ÌÉÑ Î≥¥Ïä§ BGMÏúºÎ°ú Î≥ÄÍ≤Ω (Îßµ Î∞îÍπ•Ïù¥ Í≤ÄÏ†ïÏÉâÏù¥ ÎêòÎäî ÏàúÍ∞Ñ)
        if (this.bgMusic && this.bgMusic.isPlaying) {
          this.bgMusic.stop();
        }
        if (this.boss9Music) {
          this.boss9Music.play();
        }

        // Ï∂îÍ∞Ä Í≥µÌè¨ Ïó∞Ï∂ú: Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏ≤¥ Îπ®Í∞Ñ ÌîåÎûòÏãú
        this.flashBrowserRed();

        this.showFogBossEyesAppear();
      });
    });
  }

  // Îπ®Í∞Ñ Îàà Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
  showFogBossEyesAppear() {
    const { width, height } = this.cameras.main;

    // Î≥¥Ïä§ Ï¥àÍ∏∞ ÏúÑÏπò (ÌôîÎ©¥ Ï§ëÏïô Ïö∞Ï∏°)
    const bossX = Math.floor(this.cols * 0.7);
    const bossY = Math.floor(this.rows * 0.5);
    this.fogBossPosition = { x: bossX, y: bossY };

    const pixelX = bossX * this.gridSize + this.gridSize / 2;
    const pixelY = bossY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Îπ®Í∞Ñ Îàà Ïª®ÌÖåÏù¥ÎÑà
    const eyesContainer = this.add.container(pixelX, pixelY).setDepth(5002);
    this.fogBossElements.push(eyesContainer);

    // Îàà Í∏ÄÎ°úÏö∞ (Î∞∞Í≤Ω)
    const leftGlow = this.add.circle(-10, 0, 12, 0xff0000, 0.3);
    const rightGlow = this.add.circle(10, 0, 12, 0xff0000, 0.3);
    eyesContainer.add([leftGlow, rightGlow]);

    // Îàà (ÌïµÏã¨)
    const leftEye = this.add.circle(-10, 0, 5, 0xff0000, 0);
    const rightEye = this.add.circle(10, 0, 5, 0xff0000, 0);
    eyesContainer.add([leftEye, rightEye]);

    // ÎààÎèôÏûê
    const leftPupil = this.add.circle(-10, 0, 2, 0x000000, 0);
    const rightPupil = this.add.circle(10, 0, 2, 0x000000, 0);
    eyesContainer.add([leftPupil, rightPupil]);

    // Îàà ÌéòÏù¥ÎìúÏù∏ + Ïä§ÏºÄÏùº
    eyesContainer.setScale(0.5);
    this.tweens.add({
      targets: [leftEye, rightEye],
      alpha: 1,
      duration: 500,
      ease: 'Power2'
    });
    this.tweens.add({
      targets: [leftPupil, rightPupil],
      alpha: 1,
      duration: 500,
      delay: 200,
      ease: 'Power2'
    });
    this.tweens.add({
      targets: [leftGlow, rightGlow],
      alpha: 0.5,
      duration: 600,
      ease: 'Power2'
    });
    this.tweens.add({
      targets: eyesContainer,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 600,
      ease: 'Back.easeOut'
    });

    // Îàà ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: eyesContainer,
      scaleX: { from: 1.1, to: 1.3 },
      scaleY: { from: 1.1, to: 1.3 },
      duration: 800,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // Ïπ¥Î©îÎùº ÏÇ¥Ïßù ÌùîÎì§Í∏∞
    this.cameras.main.shake(300, 0.005);

    // 4. Î≥¥Ïä§ ÎåÄÏÇ¨ (1Ï¥à ÌõÑ)
    this.time.delayedCall(1000, () => {
      this.showFogBossDialogue('You dare enter MY domain...', 0xff0000, () => {
        // 5. Î≥¥Ïä§ Ï†ÑÏ≤¥ Î™®Ïäµ Í≥µÍ∞ú
        this.time.delayedCall(500, () => {
          this.revealFogBoss(eyesContainer);
        });
      });
    });
  }

  // Î≥¥Ïä§ ÎåÄÏÇ¨ ÌëúÏãú (ÌÉÄÏù¥Ìïë Ìö®Í≥º)
  showFogBossDialogue(text, color = 0xff0000, callback = null) {
    const { width, height } = this.cameras.main;

    const dialogueText = this.add.text(width / 2, height / 2 + 80, '', {
      fontSize: '24px',
      fill: `#${color.toString(16).padStart(6, '0')}`,
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5003);
    this.fogBossElements.push(dialogueText);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        charIndex++;
        dialogueText.setText(text.substring(0, charIndex));
        if (charIndex >= text.length) {
          typeTimer.destroy();
          // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ ÏΩúÎ∞±
          if (callback) {
            this.time.delayedCall(800, callback);
          }
        }
      },
      loop: true
    });

    // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Îπ®Í∞Ñ Í∏ÄÎ°úÏö∞
    const edgeGlow = this.add.rectangle(0, 0, width, height, color, 0)
      .setOrigin(0, 0)
      .setDepth(4999);
    this.fogBossElements.push(edgeGlow);

    this.tweens.add({
      targets: edgeGlow,
      alpha: 0.15,
      duration: 300,
      yoyo: true,
      repeat: 2
    });
  }

  // Î≥¥Ïä§ Ï†ÑÏ≤¥ Î™®Ïäµ Í≥µÍ∞ú
  revealFogBoss(eyesContainer) {
    const { width, height } = this.cameras.main;

    // ÏóêÎÑàÏßÄ ÏàòÎ†¥ ÌååÌã∞ÌÅ¥
    for (let i = 0; i < 30; i++) {
      const angle = (i / 30) * Math.PI * 2;
      const startDist = 100 + Math.random() * 50;
      const particle = this.add.circle(
        eyesContainer.x + Math.cos(angle) * startDist,
        eyesContainer.y + Math.sin(angle) * startDist,
        4 + Math.random() * 3,
        0x330033,
        0.8
      ).setDepth(5001);
      this.fogBossElements.push(particle);

      this.tweens.add({
        targets: particle,
        x: eyesContainer.x,
        y: eyesContainer.y,
        scale: 0.2,
        alpha: 0,
        duration: 600 + Math.random() * 300,
        ease: 'Power2.easeIn',
        onComplete: () => particle.destroy()
      });
    }

    // Ìè≠Î∞ú ÌîåÎûòÏãú
    this.time.delayedCall(700, () => {
      const flash = this.add.circle(eyesContainer.x, eyesContainer.y, 10, 0x660066, 1)
        .setDepth(5004);
      this.fogBossElements.push(flash);

      this.tweens.add({
        targets: flash,
        scaleX: 8,
        scaleY: 8,
        alpha: 0,
        duration: 400,
        ease: 'Power2',
        onComplete: () => flash.destroy()
      });

      // Î≥¥Ïä§ Î≥∏Ï≤¥ Í∑∏Î¶¨Í∏∞
      this.drawFogBoss();

      // Í∏∞Ï°¥ Îàà Ïª®ÌÖåÏù¥ÎÑà Ï†úÍ±∞
      eyesContainer.destroy();

      // Î≥¥Ïä§ Ïù¥Î¶Ñ Îì±Ïû•
      this.time.delayedCall(300, () => {
        this.showFogBossTitle();
      });
    });
  }

  // Î≥¥Ïä§ Ïù¥Î¶Ñ ÌÉÄÏù¥ÌãÄ Ïï†ÎãàÎ©îÏù¥ÏÖò
  showFogBossTitle() {
    const { width, height } = this.cameras.main;

    // Ïù¥Î¶Ñ Î∞∞Í≤Ω
    const titleBg = this.add.rectangle(width / 2, height / 2 - 120, 300, 50, 0x000000, 0.8)
      .setOrigin(0.5)
      .setDepth(5005)
      .setScale(0);
    this.fogBossElements.push(titleBg);

    // Î≥¥Ïä§ Ïù¥Î¶Ñ
    const titleText = this.add.text(width / 2, height / 2 - 120, 'NOCTURN', {
      fontSize: '36px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5006).setScale(0);
    this.fogBossElements.push(titleText);

    // Î∂ÄÏ†ú
    const subtitleText = this.add.text(width / 2, height / 2 - 85, 'Shadow of the Abyss', {
      fontSize: '16px',
      fill: '#aa0000',
      fontStyle: 'italic'
    }).setOrigin(0.5).setDepth(5006).setAlpha(0);
    this.fogBossElements.push(subtitleText);

    // Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: [titleBg, titleText],
      scaleX: 1,
      scaleY: 1,
      duration: 400,
      ease: 'Back.easeOut'
    });

    this.tweens.add({
      targets: subtitleText,
      alpha: 1,
      duration: 300,
      delay: 300
    });

    // Ï†úÎ™© ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: titleText,
      alpha: { from: 1, to: 0.7 },
      duration: 500,
      yoyo: true,
      repeat: 3,
      delay: 500
    });

    // Î±Ä Î∞òÏùë
    this.time.delayedCall(1500, () => {
      this.showSnakeReactionToFogBoss();
    });
  }

  // Î±Ä Î∞òÏùë
  showSnakeReactionToFogBoss() {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Î±Ä ÎßêÌíçÏÑ†
    const bubbleBg = this.add.ellipse(headX + 50, headY - 30, 160, 40, 0xffffff, 0.9)
      .setDepth(5007)
      .setScale(0);
    this.fogBossElements.push(bubbleBg);

    const bubbleText = this.add.text(headX + 50, headY - 30, 'What is this thing?!', {
      fontSize: '12px',
      fill: '#000000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5008).setAlpha(0);
    this.fogBossElements.push(bubbleText);

    this.tweens.add({
      targets: bubbleBg,
      scaleX: 1,
      scaleY: 1,
      duration: 200,
      ease: 'Back.easeOut'
    });

    this.tweens.add({
      targets: bubbleText,
      alpha: 1,
      duration: 200,
      delay: 100
    });

    // ÌäúÌÜ†Î¶¨Ïñº ÌûåÌä∏
    this.time.delayedCall(1500, () => {
      this.showFogBossTutorial();
    });
  }

  // ÌäúÌÜ†Î¶¨Ïñº ÌûåÌä∏
  showFogBossTutorial() {
    const { width, height } = this.cameras.main;

    // ÌûåÌä∏ Î∞∞Í≤Ω
    const hintBg = this.add.rectangle(width / 2, height - 100, 400, 60, 0x333300, 0.9)
      .setOrigin(0.5)
      .setDepth(5007)
      .setAlpha(0);
    this.fogBossElements.push(hintBg);

    // Ï°∞Î™ÖÌÉÑ ÏïÑÏù¥ÏΩò (ÏõêÏúºÎ°ú ÌëúÌòÑ)
    const flareIcon = this.add.circle(width / 2 - 150, height - 100, 15, 0xffff00, 0)
      .setDepth(5008);
    this.fogBossElements.push(flareIcon);

    // ÌûåÌä∏ ÌÖçÏä§Ìä∏
    const hintText = this.add.text(width / 2 + 10, height - 100, 'Find FLARES to expose the shadow!', {
      fontSize: '18px',
      fill: '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5008).setAlpha(0);
    this.fogBossElements.push(hintText);

    // ÌéòÏù¥ÎìúÏù∏
    this.tweens.add({
      targets: [hintBg, flareIcon, hintText],
      alpha: 1,
      duration: 400
    });

    // Ï°∞Î™ÖÌÉÑ ÏïÑÏù¥ÏΩò ÌéÑÏä§
    this.tweens.add({
      targets: flareIcon,
      scaleX: { from: 1, to: 1.3 },
      scaleY: { from: 1, to: 1.3 },
      duration: 500,
      yoyo: true,
      repeat: 3
    });

    // Ïù∏Ìä∏Î°ú Ï¢ÖÎ£å Î∞è Í≤åÏûÑ ÏãúÏûë
    this.time.delayedCall(2500, () => {
      this.endFogBossIntro();
    });
  }

  // Ïù∏Ìä∏Î°ú Ï¢ÖÎ£å
  endFogBossIntro() {
    // Î™®Îì† Ïù∏Ìä∏Î°ú ÏöîÏÜå ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.fogBossElements.forEach(element => {
      if (element && element.active) {
        this.tweens.add({
          targets: element,
          alpha: 0,
          duration: 400,
          onComplete: () => {
            if (element && element.destroy) {
              element.destroy();
            }
          }
        });
      }
    });
    this.fogBossElements = [];

    // Î≥¥Ïä§ Îã§Ïãú Í∑∏Î¶¨Í∏∞ (Ïù∏Í≤åÏûÑÏö©)
    this.time.delayedCall(500, () => {
      this.drawFogBoss();

      // ÌéòÏù¥Ï¶à Ï†ÑÌôò
      this.fogBossPhase = 'shadow';
      this.fogBossInputBlocked = false;

      // Í≤åÏûÑ Ïû¨Í∞ú
      this.moveTimer.paused = false;

      // Ï°∞Î™ÖÌÉÑ(ÎπõÏùò Ï°∞Í∞Å)ÏùÄ Ï≤´ ÌöåÌîº ÏÑ±Í≥µ ÌõÑ ÏÉùÏÑ±Îê® (handlePresenceDodgeSuccessÏóêÏÑú Ìò∏Ï∂ú)

      // Shadow Strike ÏãúÏûë
      this.startShadowStrikePhase();
    });
  }

  // Î≥¥Ïä§ Í∑∏Î¶¨Í∏∞ (ÏßïÍ∑∏Îü¨Ïö¥ ÎîîÏûêÏù∏)
  drawFogBoss() {
    // Í∏∞Ï°¥ Î≥¥Ïä§ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.fogBossElement) {
      this.fogBossElement.destroy();
    }

    const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Î≥¥Ïä§ Ïª®ÌÖåÏù¥ÎÑà
    this.fogBossElement = this.add.container(bossX, bossY).setDepth(150);

    // Ï¥âÏàòÎì§ (8Í∞ú) - Î∂àÍ∑úÏπôÌïòÍ≤å ÏõÄÏßÅÏûÑ
    this.bossTentacles = [];
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const tentacle = this.add.rectangle(
        Math.cos(angle) * 20,
        Math.sin(angle) * 20,
        6,
        25,
        0x1a0011,
        0.8
      ).setRotation(angle + Math.PI / 2);
      this.fogBossElement.add(tentacle);
      this.bossTentacles.push(tentacle);

      // Ï¥âÏàò ÍøàÌãÄÍ±∞Î¶º
      this.tweens.add({
        targets: tentacle,
        scaleY: { from: 1, to: 1.4 },
        scaleX: { from: 1, to: 0.7 },
        duration: 400 + i * 100,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut',
        delay: i * 50
      });
    }

    // Ïñ¥ÎëêÏö¥ ÏïÑÏö∞Îùº (Îß•Îèô)
    const darkAura = this.add.circle(0, 0, 35, 0x0a0005, 0.4);
    this.fogBossElement.add(darkAura);
    this.tweens.add({
      targets: darkAura,
      scaleX: { from: 1, to: 1.3 },
      scaleY: { from: 1, to: 1.3 },
      alpha: { from: 0.4, to: 0.1 },
      duration: 1000,
      yoyo: true,
      repeat: -1
    });

    // Î™∏ÌÜµ - Î∂àÍ∑úÏπôÌïú ÌòïÌÉú (Ïó¨Îü¨ ÏõêÏúºÎ°ú Íµ¨ÏÑ±)
    const bodyParts = [];
    for (let i = 0; i < 5; i++) {
      const offsetX = Phaser.Math.Between(-5, 5);
      const offsetY = Phaser.Math.Between(-5, 5);
      const size = 12 + Phaser.Math.Between(0, 8);
      const body = this.add.circle(offsetX, offsetY, size, 0x0d0008, 0.9);
      this.fogBossElement.add(body);
      bodyParts.push(body);
    }

    // Ï§ëÏã¨ Ìïµ (Îß•ÎèôÌïòÎäî Ïã¨Ïû•Ï≤òÎüº)
    const core = this.add.circle(0, 0, 10, 0x220011, 1);
    this.fogBossElement.add(core);
    this.tweens.add({
      targets: core,
      scaleX: { from: 1, to: 1.2 },
      scaleY: { from: 1, to: 1.2 },
      duration: 300,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });

    // Îàà 3Í∞ú (ÎπÑÎåÄÏπ≠, ÌÅ¨Í∏∞ Îã§Î¶Ñ)
    const eyes = [
      { x: -10, y: -5, size: 6, pupilSize: 3 },
      { x: 8, y: -3, size: 5, pupilSize: 2.5 },
      { x: 0, y: 5, size: 4, pupilSize: 2 }  // Ï†ú3Ïùò Îàà
    ];

    this.bossEyes = [];
    eyes.forEach((eyeData, idx) => {
      // Îàà Í∏ÄÎ°úÏö∞ (ÌïèÏ§ÑÍ∞ôÏùÄ ÎäêÎÇå)
      const eyeGlow = this.add.circle(eyeData.x, eyeData.y, eyeData.size + 3, 0x660000, 0.4);
      this.fogBossElement.add(eyeGlow);

      // ÎààÏïå (ÎÖ∏ÎûÄÎπõ + ÌïèÏ§Ñ)
      const eyeball = this.add.circle(eyeData.x, eyeData.y, eyeData.size, 0xaaaa00, 1);
      this.fogBossElement.add(eyeball);

      // ÌôçÏ±Ñ
      const iris = this.add.circle(eyeData.x, eyeData.y, eyeData.size * 0.7, 0x990000, 1);
      this.fogBossElement.add(iris);

      // ÎèôÍ≥µ (ÏÑ∏Î°úÎ°ú Í∏¥ Í≥†ÏñëÏù¥ Îàà)
      const pupil = this.add.ellipse(eyeData.x, eyeData.y, eyeData.pupilSize * 0.5, eyeData.pupilSize * 1.5, 0x000000, 1);
      this.fogBossElement.add(pupil);

      this.bossEyes.push({ eyeball, iris, pupil, eyeGlow });

      // Îàà ÍπúÎπ°ÏûÑ (Î∂àÍ∑úÏπô)
      this.time.addEvent({
        delay: 2000 + idx * 1000,
        callback: () => {
          if (!this.fogBossElement || !this.fogBossElement.active) return;
          this.tweens.add({
            targets: [eyeball, iris, pupil, eyeGlow],
            scaleY: 0.1,
            duration: 80,
            yoyo: true,
            onComplete: () => {
              // Îã§Ïùå ÍπúÎπ°ÏûÑ ÏòàÏïΩ
              if (this.fogBossMode) {
                this.time.delayedCall(3000 + Math.random() * 2000, () => {
                  if (this.fogBossElement && this.fogBossElement.active) {
                    this.tweens.add({
                      targets: [eyeball, iris, pupil, eyeGlow],
                      scaleY: 0.1,
                      duration: 80,
                      yoyo: true
                    });
                  }
                });
              }
            }
          });
        },
        loop: false
      });
    });

    // ÏûÖ (Ïù¥Îπ®Ïù¥ Î≥¥Ïù¥Îäî Ï∞¢Ïñ¥ÏßÑ ÏûÖ)
    const mouthBg = this.add.ellipse(0, 12, 14, 6, 0x000000, 1);
    this.fogBossElement.add(mouthBg);

    // Ïù¥Îπ®Îì§
    for (let i = 0; i < 5; i++) {
      const toothX = -5 + i * 2.5;
      const toothHeight = 3 + Math.random() * 2;
      const tooth = this.add.triangle(
        toothX, 10,
        0, 0,
        1.5, toothHeight,
        -1.5, toothHeight,
        0xccccaa, 1
      );
      this.fogBossElement.add(tooth);
    }

    // Ïπ® Îñ®Ïñ¥ÏßÄÎäî Ìö®Í≥º
    this.bossSlimeTimer = this.time.addEvent({
      delay: 800,
      callback: () => this.createBossSlime(),
      loop: true
    });

    // Ï†ÑÏ≤¥ Î≥¥Ïä§ Î∂àÍ∑úÏπôÌïú Îñ®Î¶º
    this.tweens.add({
      targets: this.fogBossElement,
      x: bossX + Phaser.Math.Between(-2, 2),
      y: bossY + Phaser.Math.Between(-2, 2),
      duration: 100,
      yoyo: true,
      repeat: -1
    });

    // Ïó∞Í∏∞ ÌååÌã∞ÌÅ¥ (ÏúÑÎ°ú Ïò¨ÎùºÍ∞ê)
    this.createBossSmokeParticles();

    // Î≥¥Ïä§Í∞Ä Î≥¥Ïù¥ÏßÄ ÏïäÎäî ÏÉÅÌÉúÎ©¥ Ïà®Í∏∞Í∏∞
    if (!this.fogBossVisible) {
      this.fogBossElement.setAlpha(0);
    }
  }

  // Î≥¥Ïä§ Ïó∞Í∏∞ ÌååÌã∞ÌÅ¥
  createBossSmokeParticles() {
    if (!this.fogBossElement || !this.fogBossPosition) return;

    const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 2Í∞úÏùò Ïó∞Í∏∞ ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    for (let i = 0; i < 2; i++) {
      const offsetX = Phaser.Math.Between(-15, 15);
      const particle = this.add.circle(bossX + offsetX, bossY - 10, 4 + Math.random() * 3, 0x220022, 0.4)
        .setDepth(149);

      this.tweens.add({
        targets: particle,
        y: bossY - 60 - Math.random() * 30,
        x: bossX + offsetX + Phaser.Math.Between(-20, 20),
        alpha: 0,
        scale: 0.3,
        duration: 1500 + Math.random() * 500,
        onComplete: () => particle.destroy()
      });
    }

    // Î≥¥Ïä§Í∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎ©¥ Í≥ÑÏÜç ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
    if (this.fogBossMode && this.fogBossPhase !== 'victory') {
      this.time.delayedCall(400, () => this.createBossSmokeParticles());
    }
  }

  // Î≥¥Ïä§ Ïπ® Îñ®Ïñ¥ÏßÄÎäî Ìö®Í≥º
  createBossSlime() {
    if (!this.fogBossElement || !this.fogBossElement.active || !this.fogBossPosition) return;

    const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ïπ® Î¨ºÎ∞©Ïö∏
    const slime = this.add.ellipse(
      bossX + Phaser.Math.Between(-5, 5),
      bossY + 15,
      3 + Math.random() * 2,
      5 + Math.random() * 3,
      0x00ff00,
      0.7
    ).setDepth(148);

    // Îñ®Ïñ¥ÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: slime,
      y: bossY + 60 + Math.random() * 30,
      scaleX: 0.5,
      scaleY: 1.5,
      alpha: 0,
      duration: 800 + Math.random() * 400,
      ease: 'Quad.easeIn',
      onComplete: () => slime.destroy()
    });

    // Ïπ®Ïù¥ Î∞îÎã•Ïóê ÎãøÏúºÎ©¥ ÌäÄÎäî Ìö®Í≥º
    this.time.delayedCall(700, () => {
      if (!this.fogBossMode) return;

      const splash = this.add.circle(slime.x, bossY + 60, 4, 0x00ff00, 0.4).setDepth(147);
      this.tweens.add({
        targets: splash,
        scaleX: 2,
        scaleY: 0.5,
        alpha: 0,
        duration: 300,
        onComplete: () => splash.destroy()
      });
    });
  }

  // Ï°∞Î™ÖÌÉÑ ÏÉùÏÑ± ÏãúÏûë
  startFlareSpawning() {
    // Ï≤´ Ï°∞Î™ÖÌÉÑ Ï¶âÏãú ÏÉùÏÑ±
    this.spawnFlare();

    // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Ï°∞Î™ÖÌÉÑ ÏÉùÏÑ±
    this.flareSpawnTimer = this.time.addEvent({
      delay: this.flareSpawnInterval,
      callback: () => this.spawnFlare(),
      loop: true
    });
  }

  // Ï°∞Î™ÖÌÉÑ ÏÉùÏÑ±
  spawnFlare() {
    if (!this.fogBossMode || this.fogBossPhase === 'victory') return;
    if (this.flares.length >= 2) return; // ÏµúÎåÄ 2Í∞úÍπåÏßÄÎßå

    // ÏïàÏ†ÑÌïú ÏúÑÏπò Ï∞æÍ∏∞
    let flarePos;
    let validPosition = false;
    let attempts = 0;

    while (!validPosition && attempts < 50) {
      flarePos = {
        x: Phaser.Math.Between(3, this.cols - 4),
        y: Phaser.Math.Between(3, this.rows - 4)
      };

      // Î±Ä, Î≥¥Ïä§, Í∏∞Ï°¥ Ï°∞Î™ÖÌÉÑÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ ÌôïÏù∏
      validPosition = true;

      // Î±ÄÍ≥º Í±∞Î¶¨ Ï≤¥ÌÅ¨
      for (const segment of this.snake) {
        if (Math.abs(segment.x - flarePos.x) < 3 && Math.abs(segment.y - flarePos.y) < 3) {
          validPosition = false;
          break;
        }
      }

      // Î≥¥Ïä§ÏôÄ Í±∞Î¶¨ Ï≤¥ÌÅ¨
      if (this.fogBossPosition) {
        if (Math.abs(this.fogBossPosition.x - flarePos.x) < 4 &&
            Math.abs(this.fogBossPosition.y - flarePos.y) < 4) {
          validPosition = false;
        }
      }

      // Í∏∞Ï°¥ Ï°∞Î™ÖÌÉÑÍ≥º Í±∞Î¶¨ Ï≤¥ÌÅ¨
      for (const flare of this.flares) {
        if (Math.abs(flare.x - flarePos.x) < 5 && Math.abs(flare.y - flarePos.y) < 5) {
          validPosition = false;
          break;
        }
      }

      attempts++;
    }

    if (!validPosition) return;

    const pixelX = flarePos.x * this.gridSize + this.gridSize / 2;
    const pixelY = flarePos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ï°∞Î™ÖÌÉÑ Ïª®ÌÖåÏù¥ÎÑà
    const container = this.add.container(pixelX, pixelY).setDepth(120);

    // Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞
    const outerGlow = this.add.circle(0, 0, 15, 0xffff00, 0.2);
    // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
    const midGlow = this.add.circle(0, 0, 10, 0xffa500, 0.4);
    // ÏΩîÏñ¥
    const core = this.add.circle(0, 0, 5, 0xffffff, 1);

    container.add([outerGlow, midGlow, core]);

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: outerGlow,
      scaleX: { from: 1, to: 1.5 },
      scaleY: { from: 1, to: 1.5 },
      alpha: { from: 0.3, to: 0.1 },
      duration: 800,
      yoyo: true,
      repeat: -1
    });

    this.tweens.add({
      targets: midGlow,
      scaleX: { from: 1, to: 1.2 },
      scaleY: { from: 1, to: 1.2 },
      duration: 600,
      yoyo: true,
      repeat: -1
    });

    // Ïä§ÌååÌÅ¥ ÌååÌã∞ÌÅ¥
    this.createFlareSparkles(container, pixelX, pixelY);

    // Ï°∞Î™ÖÌÉÑ Îì±Î°ù
    const flare = {
      x: flarePos.x,
      y: flarePos.y,
      container: container,
      outerGlow: outerGlow,
      midGlow: midGlow,
      core: core
    };
    this.flares.push(flare);

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    container.setScale(0);
    this.tweens.add({
      targets: container,
      scaleX: 1,
      scaleY: 1,
      duration: 400,
      ease: 'Back.easeOut'
    });
  }

  // Ï°∞Î™ÖÌÉÑ Ïä§ÌååÌÅ¥ Ìö®Í≥º
  createFlareSparkles(container, pixelX, pixelY) {
    const createSparkle = () => {
      if (!container || !container.active) return;

      const angle = Math.random() * Math.PI * 2;
      const dist = 8 + Math.random() * 10;
      const sparkle = this.add.circle(
        Math.cos(angle) * dist,
        Math.sin(angle) * dist,
        1 + Math.random(),
        0xffff00,
        0.8
      );
      container.add(sparkle);

      this.tweens.add({
        targets: sparkle,
        alpha: 0,
        scale: 0,
        x: Math.cos(angle) * (dist + 10),
        y: Math.sin(angle) * (dist + 10),
        duration: 400 + Math.random() * 200,
        onComplete: () => {
          sparkle.destroy();
          if (container && container.active) {
            createSparkle();
          }
        }
      });
    };

    // 3Í∞úÏùò Ïä§ÌååÌÅ¥ ÏãúÏûë
    for (let i = 0; i < 3; i++) {
      this.time.delayedCall(i * 200, createSparkle);
    }
  }

  // Ï°∞Î™ÖÌÉÑ ÏàòÏßë
  collectFlare(flare) {
    // ÎπõÏùòÏ°∞Í∞Å ÏàòÏßë Ìö®Í≥ºÏùå
    this.sound.play('flare_collect', { volume: 0.3 });

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ï°∞Î™ÖÌÉÑÏù¥ Î±Ä Î®∏Î¶¨Î°ú ÎÇ†ÏïÑÍ∞ê
    this.tweens.add({
      targets: flare.container,
      x: headX,
      y: headY,
      scaleX: 0.5,
      scaleY: 0.5,
      duration: 200,
      ease: 'Power2',
      onComplete: () => {
        flare.container.destroy();
      }
    });

    // Î∞∞Ïó¥ÏóêÏÑú Ï†úÍ±∞
    const index = this.flares.indexOf(flare);
    if (index > -1) {
      this.flares.splice(index, 1);
    }

    // Ï°∞Î™ÖÌÉÑ Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
    this.flareCount++;

    // üÜï ÌöåÌîº ÏãúÎèÑ Ïπ¥Ïö¥Ìä∏ Î¶¨ÏÖã (ÎπõÏùò Ï°∞Í∞ÅÏúºÎ°ú ÌöåÎ≥µ!)
    if (this.dodgeAttemptCount > 0) {
      this.dodgeAttemptCount = 0;
      // Î¶¨ÏÖã ÌîºÎìúÎ∞±
      const resetText = this.add.text(headX, headY - 40, 'DODGE RESET!', {
        fontSize: '14px',
        fill: '#00ffff',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 2
      }).setOrigin(0.5).setDepth(200);

      this.tweens.add({
        targets: resetText,
        alpha: 0,
        y: headY - 70,
        duration: 800,
        onComplete: () => resetText.destroy()
      });
    }

    // ÏàòÏßë Ìö®Í≥º
    this.showFlareCollectEffect(headX, headY);

    // Ï°∞Î™ÖÌÉÑ Ìè≠Î∞ú Ìï≠ÏÉÅ Ìä∏Î¶¨Í±∞
    this.time.delayedCall(100, () => {
      this.triggerFlareExplosion();
    });
  }

  // Ï°∞Î™ÖÌÉÑ ÏàòÏßë Ìö®Í≥º
  showFlareCollectEffect(x, y) {
    // "+1 FLARE" ÌÖçÏä§Ìä∏
    const text = this.add.text(x, y - 20, '+1 FLARE', {
      fontSize: '16px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: text,
      y: y - 50,
      alpha: 0,
      duration: 800,
      onComplete: () => text.destroy()
    });

    // ÌîåÎûòÏãú Ìö®Í≥º
    const flash = this.add.circle(x, y, 20, 0xffff00, 0.6).setDepth(199);
    this.tweens.add({
      targets: flash,
      scaleX: 2,
      scaleY: 2,
      alpha: 0,
      duration: 300,
      onComplete: () => flash.destroy()
    });
  }

  // Î≥¥Ïä§ Í∑ºÏ≤òÏù∏ÏßÄ Ï≤¥ÌÅ¨
  isNearFogBoss() {
    if (!this.fogBossPosition) return false;
    const head = this.snake[0];
    const dist = Math.abs(head.x - this.fogBossPosition.x) + Math.abs(head.y - this.fogBossPosition.y);
    return dist <= 8;
  }

  // Ï°∞Î™ÖÌÉÑ Ìè≠Î∞ú (Î≥¥Ïä§ ÎÖ∏Ï∂ú)
  triggerFlareExplosion() {
    if (this.flareCount <= 0) return;
    if (this.flareActive) return;

    this.flareCount--;
    this.flareActive = true;

    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÌôîÎ©¥ ÌîåÎûòÏãú
    const { width, height } = this.cameras.main;
    const flash = this.add.rectangle(0, 0, width, height, 0xffffaa, 0.7)
      .setOrigin(0, 0)
      .setDepth(4000);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 500,
      onComplete: () => flash.destroy()
    });

    // Îπõ ÌååÎèô Ìö®Í≥º
    this.createLightWave(headX, headY);

    // ÏãúÏïº ÏùºÏãúÏ†Å ÌôïÎåÄ
    const originalVisibility = this.fogVisibleTiles;
    this.fogVisibleTiles = this.flareLightRadius;

    // Î≥¥Ïä§ ÎÖ∏Ï∂ú
    this.fogBossVisible = true;
    if (this.fogBossElement) {
      this.tweens.add({
        targets: this.fogBossElement,
        alpha: 1,
        duration: 200
      });
    }

    // Î≥¥Ïä§Í∞Ä Í≥µÍ≤© Ï§ëÏù¥Î©¥ (Ï†êÌîÑ Ïä§ÏºÄÏñ¥ Ï§ë, Í≤ΩÍ≥† ÏÉÅÌÉú, ÎòêÎäî Î≥¥Ïù¥Îäî ÏÉÅÌÉú) HIT!
    if (this.jumpScareActive || this.shadowStrikeWarningActive || this.fogBossVisible) {
      // üÜï HIT Îì±Î°ù ÎåÄÍ∏∞ ÏÉÅÌÉú (ÌöåÌîº Ïã§Ìå®Î≥¥Îã§ Ïö∞ÏÑ†!)
      this.fogBossHitPending = true;
      if (this.fogBossHitCount >= 3) {
        if (this.moveTimer) this.moveTimer.paused = true;
        this.fogBossInputBlocked = true;
      }

      // üÜï QTEÍ∞Ä ÌôúÏÑ±Ìôî Ï§ëÏù¥Î©¥ Ï¶âÏãú Ï∑®ÏÜå (HIT Ïö∞ÏÑ†!)
      if (this.dodgeQTEActive) {
        this.dodgeQTEActive = false;
        this.cleanupQTEElements();
      }

      // Î≥¥Ïä§ Í≥µÍ≤© Ï∑®ÏÜå
      if (this.shadowStrikeTimer) {
        this.shadowStrikeTimer.destroy();
        this.shadowStrikeTimer = null;
      }
      this.shadowStrikeWarningActive = false;
      this.jumpScareActive = false;

      // Ïä§ÌÜ†ÌÇπ ÏãúÏä§ÌÖú Ï†ïÎ¶¨
      this.cleanupStalkingSystem();

      // Î≥¥Ïä§ ÎπÑÎ™Ö + Í≥†ÌÜµ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.showFogBossPain();

      // HIT Ï≤òÎ¶¨
      this.time.delayedCall(500, () => {
        this.fogBossHitPending = false;
        this.handleFogBossHit();
      });
    } else {
      // Î≥¥Ïä§ ÎπÑÎ™Ö
      this.showFogBossScream('ARGH! THE LIGHT!');
    }

    // 2Ï¥à ÌõÑ Îã§Ïãú Ïà®Í∏∞Í∏∞
    this.time.delayedCall(2000, () => {
      this.flareActive = false;
      this.fogVisibleTiles = originalVisibility;

      // ÏïÑÏßÅ ÌÅ¥Î¶¨Ïñ¥ Ï†ÑÏù¥Î©¥ Ïà®ÍπÄ
        if (this.fogBossPhase === 'shadow' && this.fogBossHitCount < 4) {
          this.fogBossVisible = false;
          if (this.fogBossElement) {
            this.tweens.add({
              targets: this.fogBossElement,
              alpha: 0,
              duration: 300
            });
          }

          // Îã§Ïùå Í≥µÍ≤© ÏòàÏïΩ
          const delay = this.getShadowStrikeDelay();
          this.shadowStrikeTimer = this.time.delayedCall(delay, () => {
            this.showShadowStrikeWarning();
          });
        }
      });
  }

  // Îπõ ÌååÎèô Ìö®Í≥º
  createLightWave(x, y) {
    // Ïó¨Îü¨ ÎßÅ ÏÉùÏÑ±
    for (let i = 0; i < 4; i++) {
      const ring = this.add.circle(x, y, 20, 0xffff00, 0)
        .setDepth(3999)
        .setStrokeStyle(3, 0xffff00, 0.8);

      this.tweens.add({
        targets: ring,
        scaleX: 10 + i * 2,
        scaleY: 10 + i * 2,
        alpha: 0,
        duration: 600,
        delay: i * 100,
        ease: 'Power2',
        onComplete: () => ring.destroy()
      });
    }

    // Î∞©ÏÇ¨Ìòï ÎπõÏ§ÑÍ∏∞
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      const beam = this.add.rectangle(x, y, 200, 4, 0xffffaa, 0.6)
        .setOrigin(0, 0.5)
        .setRotation(angle)
        .setDepth(3998);

      this.tweens.add({
        targets: beam,
        scaleX: 2,
        alpha: 0,
        duration: 500,
        delay: 100,
        onComplete: () => beam.destroy()
      });
    }
  }

  // Î≥¥Ïä§ ÎπÑÎ™Ö
  showFogBossScream(text) {
    if (!this.fogBossPosition) return;

    const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const screamText = this.add.text(bossX, bossY - 40, text, {
      fontSize: '18px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: screamText,
      y: bossY - 70,
      alpha: 0,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 1000,
      onComplete: () => screamText.destroy()
    });

    // Ïπ¥Î©îÎùº ÌùîÎì§Í∏∞
    this.cameras.main.shake(200, 0.01);
  }

  // Î≥¥Ïä§ Í≥†ÌÜµ Ïï†ÎãàÎ©îÏù¥ÏÖò
  showFogBossPain() {
    if (!this.fogBossElement || !this.fogBossPosition) return;

    const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎπÑÎ™Ö ÌÖçÏä§Ìä∏
    const screamText = this.add.text(bossX, bossY - 50, 'AAAARGH!!!', {
      fontSize: '24px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: screamText,
      y: bossY - 100,
      alpha: 0,
      scaleX: 1.5,
      scaleY: 1.5,
      duration: 1200,
      onComplete: () => screamText.destroy()
    });

    // Î≥¥Ïä§ Î™∏Ï≤¥ Îπ®Í∞ÑÏÉâÏúºÎ°ú ÍπúÎπ°ÏûÑ
    const originalTint = 0xffffff;
    let flashCount = 0;
    const flashTimer = this.time.addEvent({
      delay: 80,
      callback: () => {
        if (this.fogBossElement && this.fogBossElement.active) {
          // Îπ®Í∞ÑÏÉâ/ÏõêÎûòÏÉâ Î≤àÍ∞àÏïÑÍ∞ÄÎ©∞ ÌîåÎûòÏãú
          const tint = flashCount % 2 === 0 ? 0xff0000 : 0xffffff;
          this.fogBossElement.list.forEach(child => {
            if (child.setTint) child.setTint(tint);
          });
        }
        flashCount++;
        if (flashCount >= 8) {
          flashTimer.destroy();
          // ÏõêÎûò ÏÉâÏúºÎ°ú Î≥µÏõê
          if (this.fogBossElement && this.fogBossElement.active) {
            this.fogBossElement.list.forEach(child => {
              if (child.clearTint) child.clearTint();
            });
          }
        }
      },
      loop: true
    });

    // Î≥¥Ïä§ Î™∏Ï≤¥ ÌùîÎì§Î¶º
    this.tweens.add({
      targets: this.fogBossElement,
      x: bossX + 5,
      duration: 50,
      yoyo: true,
      repeat: 6
    });

    // Í≥†ÌÜµ ÌååÌã∞ÌÅ¥ (Î≥¥Ïä§ÏóêÏÑú ÎøúÏñ¥Ï†∏ ÎÇòÏò¥)
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      const particle = this.add.circle(
        bossX,
        bossY,
        4 + Math.random() * 4,
        0xff0000,
        0.8
      ).setDepth(155);

      this.tweens.add({
        targets: particle,
        x: bossX + Math.cos(angle) * (60 + Math.random() * 40),
        y: bossY + Math.sin(angle) * (60 + Math.random() * 40),
        alpha: 0,
        scale: 0.3,
        duration: 600 + Math.random() * 300,
        ease: 'Power2',
        onComplete: () => particle.destroy()
      });
    }

    // Í∞ïÌïú Ïπ¥Î©îÎùº ÌùîÎì§Í∏∞
    this.cameras.main.shake(400, 0.03);

    // ÌôîÎ©¥ Îπ®Í∞Ñ ÌîåÎûòÏãú
    const { width, height } = this.cameras.main;
    const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.3)
      .setOrigin(0, 0)
      .setDepth(3500);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 400,
      onComplete: () => flash.destroy()
    });
  }

  // Shadow Strike ÌéòÏù¥Ï¶à ÏãúÏûë ‚Üí ÏÉàÎ°úÏö¥ "The Presence" ÏãúÏä§ÌÖú
  startShadowStrikePhase() {
    this.fogBossPhase = 'shadow';

    // Î≥¥Ïä§ Ïà®Í∏∞Í∏∞
    this.fogBossVisible = false;
    if (this.fogBossElement) {
      this.fogBossElement.setAlpha(0);
    }

    // üÜï The Presence ÏãúÏä§ÌÖú ÏãúÏûë
    this.startPresenceSystem();
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üÜï THE PRESENCE SYSTEM - Í∑πÌïúÏùò Í≥µÌè¨ (Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏ≤¥ Ïñ¥Îë†)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // The Presence ÏãúÏûë
  startPresenceSystem() {
    this.presenceActive = true;
    this.presenceLevel = 0;
    this.stalkingActive = true;
    this.presenceAttackCount = 0; // Í≥µÍ≤© ÌöüÏàò Î¶¨ÏÖã (Ï≤´ Í≥µÍ≤© ÌöåÌîº ÏãúÍ∞Ñ 10Ï¥à)
    const hitCount = this.fogBossHitCount;

    // 1. Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤Ω Ïñ¥Îë† Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ± (DOM)
    this.createBrowserDarkness();

    // 2. Ïù∏Í≤åÏûÑ ÎπÑÎÑ§Ìä∏ ÏÉùÏÑ±
    this.createVignetteOverlay();

    // 3. HIT ÏàòÏóê Îî∞Î•∏ Ïù∏Ìä∏Î°ú Ïó∞Ï∂ú (ÎåÄÏÇ¨ ÎÅùÎÇòÎ©¥ Í≥µÍ≤© ÏãúÏûë)
    // üÜï ÎåÄÏÇ¨ Ï§ëÏóêÎäî Í≥µÍ≤© Ï∞®Îã®
    this.presenceDialogueActive = true;
    this.showPresenceIntro();

    // 4. Ï°¥Ïû¨Í∞ê Ï†êÏßÑÏ†Å Ï¶ùÍ∞Ä ÌÉÄÏù¥Î®∏
    const presenceSpeed = Math.max(800 - hitCount * 100, 400);
    this.presenceTimer = this.time.addEvent({
      delay: presenceSpeed,
      callback: () => this.updatePresenceLevel(),
      loop: true
    });

    // üÜï Í≥µÍ≤©/Ïä§Ìè∞ÏùÄ ÎåÄÏÇ¨ ÎÅùÎÇú ÌõÑ showPresenceIntroÏóêÏÑú Ìò∏Ï∂úÎê®
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üÜï Î¨¥ÏÑúÏö¥ ÏÉùÎ¨º ÏãúÏä§ÌÖú - ÌöÉÎ∂à ÏòÅÏó≠Ïóê Ìù†Ïπ´ ÎÜÄÎùºÍ≤å ÌïòÎäî Ï°¥Ïû¨Îì§
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // Î¨¥ÏÑúÏö¥ ÏÉùÎ¨º Ïä§Ìè∞ ÏãúÏûë
  startCreatureSpawning() {
    // 3~6Ï¥àÎßàÎã§ ÏÉùÎ¨º Ïä§Ìè∞
    this.creatureSpawnTimer = this.time.addEvent({
      delay: Phaser.Math.Between(3000, 6000),
      callback: () => {
        if (!this.presenceActive || this.gameOver) return;
        this.spawnCreepyCreature();
        // Îã§Ïùå Ïä§Ìè∞ Í∞ÑÍ≤© ÎûúÎç§Ìôî
        if (this.creatureSpawnTimer) {
          this.creatureSpawnTimer.delay = Phaser.Math.Between(4000, 8000);
        }
      },
      loop: true
    });
  }

  // Î¨¥ÏÑúÏö¥ ÏÉùÎ¨º Ïä§Ìè∞
  spawnCreepyCreature() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÏÉùÎ¨º Ï¢ÖÎ•ò (Îã§ÏñëÌïú ÎîîÏûêÏù∏)
    const creatureTypes = [
      'ghost',      // Ïú†Î†π - ÌïòÏñÄ Î∞òÌà¨Î™Ö
      'crawler',    // Í∏∞Ïñ¥Îã§ÎãàÎäî Í≤É - Ïó¨Îü¨ Îã§Î¶¨
      'eyeball',    // ÎààÏïå - ÌÅ∞ Îàà
      'shadow',     // Í∑∏Î¶ºÏûê Ïù∏Í∞Ñ - Í∏∏Ï≠âÌïú ÌòïÌÉú
      'hands',      // ÏÜê - Î∞îÎã•ÏóêÏÑú ÎÇòÏò§Îäî ÏÜêÎì§
      'face'        // ÏùºÍ∑∏Îü¨ÏßÑ ÏñºÍµ¥
    ];
    const type = Phaser.Math.RND.pick(creatureTypes);

    // ÏãúÏïº Í∞ÄÏû•ÏûêÎ¶¨ÏóêÏÑú Ïä§Ìè∞ (ÌöÉÎ∂à Îπõ ÏòÅÏó≠ ÎÅù)
    const spawnAngle = Math.random() * Math.PI * 2;
    const spawnDistance = this.fogVisibleTiles * this.gridSize * 0.8;
    const spawnX = headX + Math.cos(spawnAngle) * spawnDistance;
    const spawnY = headY + Math.sin(spawnAngle) * spawnDistance;

    // Î∞òÎåÄÏ™ΩÏúºÎ°ú Ïù¥ÎèôÌï† Î™©Ìëú
    const targetAngle = spawnAngle + Math.PI + Phaser.Math.FloatBetween(-0.5, 0.5);
    const targetDistance = spawnDistance * 2;
    const targetX = headX + Math.cos(targetAngle) * targetDistance;
    const targetY = headY + Math.sin(targetAngle) * targetDistance;

    // ÏÉùÎ¨º ÏÉùÏÑ±
    const creature = this.createCreature(type, spawnX, spawnY);
    this.creepyCreatures.push(creature);

    // Ïù¥Îèô Ïï†ÎãàÎ©îÏù¥ÏÖò (Ï≤úÏ≤úÌûà Ïä§Ï≥êÏßÄÎÇòÍ∞ê)
    const moveDuration = Phaser.Math.Between(1500, 3000);

    this.tweens.add({
      targets: creature,
      x: targetX,
      y: targetY,
      duration: moveDuration,
      ease: 'Linear',
      onComplete: () => {
        this.destroyCreature(creature);
      }
    });

    // 50% ÌôïÎ•†Î°ú ÍπúÏßù Ìö®Í≥º
    if (Math.random() < 0.5) {
      this.time.delayedCall(moveDuration * 0.3, () => {
        this.creatureJumpScare(creature);
      });
    }
  }

  // ÏÉùÎ¨º ÏÉùÏÑ± (ÌÉÄÏûÖÎ≥Ñ ÎîîÏûêÏù∏)
  createCreature(type, x, y) {
    const container = this.add.container(x, y).setDepth(155).setAlpha(0);

    switch (type) {
      case 'ghost':
        // Ïú†Î†π - Ìù∞ÏÉâ Î∞òÌà¨Î™Ö ÌòïÌÉú
        const ghostBody = this.add.ellipse(0, 0, 25, 35, 0xffffff, 0.3);
        const ghostEye1 = this.add.circle(-5, -5, 4, 0x000000, 0.8);
        const ghostEye2 = this.add.circle(5, -5, 4, 0x000000, 0.8);
        const ghostMouth = this.add.ellipse(0, 8, 8, 12, 0x000000, 0.6);
        container.add([ghostBody, ghostEye1, ghostEye2, ghostMouth]);
        // ÌùîÎì§Î¶º
        this.tweens.add({
          targets: container,
          y: container.y + 5,
          duration: 500,
          yoyo: true,
          repeat: -1
        });
        break;

      case 'crawler':
        // Í∏∞Ïñ¥Îã§ÎãàÎäî Í≤É - Ïó¨Îü¨ Îã§Î¶¨
        const crawlerBody = this.add.ellipse(0, 0, 30, 15, 0x1a0a0a, 0.6);
        for (let i = 0; i < 6; i++) {
          const legX = -12 + i * 5;
          const leg = this.add.rectangle(legX, 10, 2, 12, 0x1a0a0a, 0.5)
            .setAngle(Phaser.Math.Between(-20, 20));
          container.add(leg);
        }
        container.add(crawlerBody);
        // Îã§Î¶¨ ÏõÄÏßÅÏûÑ
        container.list.forEach((child, i) => {
          if (i > 0) {
            this.tweens.add({
              targets: child,
              angle: child.angle + Phaser.Math.Between(-10, 10),
              duration: 100,
              yoyo: true,
              repeat: -1,
              delay: i * 30
            });
          }
        });
        break;

      case 'eyeball':
        // ÌÅ∞ ÎààÏïå
        const eyeWhite = this.add.circle(0, 0, 20, 0xffffee, 0.5);
        const eyeIris = this.add.circle(0, 0, 12, 0x880000, 0.7);
        const eyePupil = this.add.circle(0, 0, 6, 0x000000, 0.9);
        const veins = [];
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2;
          const vein = this.add.line(0, 0,
            Math.cos(angle) * 10, Math.sin(angle) * 10,
            Math.cos(angle) * 18, Math.sin(angle) * 18,
            0xff0000, 0.3
          ).setLineWidth(1);
          veins.push(vein);
        }
        container.add([eyeWhite, ...veins, eyeIris, eyePupil]);
        // ÎààÏïå Íµ¥Îü¨Í∞ê
        this.tweens.add({
          targets: container,
          angle: 360,
          duration: 2000,
          repeat: -1
        });
        break;

      case 'shadow':
        // Í∑∏Î¶ºÏûê Ïù∏Í∞Ñ - Í∏∏Ï≠âÌïú Í≤ÄÏùÄ ÌòïÌÉú
        const shadowBody = this.add.ellipse(0, 0, 15, 50, 0x0a0005, 0.4);
        const shadowHead = this.add.circle(0, -30, 10, 0x0a0005, 0.5);
        const shadowEye1 = this.add.circle(-3, -32, 2, 0xff0000, 0.8);
        const shadowEye2 = this.add.circle(3, -32, 2, 0xff0000, 0.8);
        container.add([shadowBody, shadowHead, shadowEye1, shadowEye2]);
        // ÌùîÎì§Î¶º
        this.tweens.add({
          targets: container,
          scaleX: { from: 0.8, to: 1.2 },
          duration: 300,
          yoyo: true,
          repeat: -1
        });
        break;

      case 'hands':
        // Î∞îÎã•ÏóêÏÑú ÎÇòÏò§Îäî ÏÜêÎì§
        for (let i = 0; i < 3; i++) {
          const handX = -15 + i * 15;
          const hand = this.add.container(handX, 0);
          const palm = this.add.ellipse(0, 0, 10, 15, 0x2a1a1a, 0.5);
          for (let f = 0; f < 5; f++) {
            const finger = this.add.rectangle(-6 + f * 3, -12, 3, 10, 0x2a1a1a, 0.5);
            hand.add(finger);
          }
          hand.add(palm);
          container.add(hand);
          // ÏÜêÍ∞ÄÎùΩ ÏõÄÏßÅÏûÑ
          this.tweens.add({
            targets: hand,
            y: hand.y - 5,
            angle: Phaser.Math.Between(-10, 10),
            duration: 200 + i * 100,
            yoyo: true,
            repeat: -1
          });
        }
        break;

      case 'face':
        // ÏùºÍ∑∏Îü¨ÏßÑ ÏñºÍµ¥
        const faceBase = this.add.circle(0, 0, 25, 0x1a0a0a, 0.4);
        const faceEye1 = this.add.circle(-8, -5, 6, 0xffffaa, 0.6);
        const faceEye2 = this.add.circle(10, -8, 4, 0xffffaa, 0.6);
        const facePupil1 = this.add.circle(-8, -5, 3, 0x000000, 0.8);
        const facePupil2 = this.add.circle(10, -8, 2, 0x000000, 0.8);
        const faceMouth = this.add.ellipse(2, 12, 20, 10, 0x000000, 0.7);
        container.add([faceBase, faceEye1, faceEye2, facePupil1, facePupil2, faceMouth]);
        // ÏûÖ Î≤åÎ¶º
        this.tweens.add({
          targets: faceMouth,
          scaleY: { from: 1, to: 2 },
          duration: 500,
          yoyo: true,
          repeat: -1
        });
        break;
    }

    // ÌéòÏù¥ÎìúÏù∏
    this.tweens.add({
      targets: container,
      alpha: 0.6,
      duration: 300
    });

    return container;
  }

  // ÏÉùÎ¨º ÍπúÏßù Ìö®Í≥º
  creatureJumpScare(creature) {
    if (!creature || !creature.active) return;

    // Í∞ëÏûêÍ∏∞ ÏÑ†Î™ÖÌï¥Ï°åÎã§ ÏÇ¨ÎùºÏßê
    this.tweens.add({
      targets: creature,
      alpha: 1,
      scaleX: 1.5,
      scaleY: 1.5,
      duration: 100,
      yoyo: true,
      onComplete: () => {
        if (creature && creature.active) {
          creature.setAlpha(0.4);
        }
      }
    });

    // Ïπ¥Î©îÎùº ÎØ∏ÏÑ∏ ÌùîÎì§Î¶º
    this.cameras.main.shake(100, 0.01);

    // Î∏åÎùºÏö∞Ï†Ä ÎØ∏ÏÑ∏ ÌîåÎûòÏãú
    const flash = document.createElement('div');
    flash.style.cssText = `
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(50, 0, 0, 0.2);
      pointer-events: none;
      z-index: 9997;
    `;
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 100);
  }

  // ÏÉùÎ¨º Ï†úÍ±∞
  destroyCreature(creature) {
    const index = this.creepyCreatures.indexOf(creature);
    if (index > -1) {
      this.creepyCreatures.splice(index, 1);
    }

    if (creature && creature.active) {
      this.tweens.add({
        targets: creature,
        alpha: 0,
        duration: 200,
        onComplete: () => {
          creature.destroy();
        }
      });
    }
  }

  // Î™®Îì† ÏÉùÎ¨º Ï†ïÎ¶¨
  cleanupCreatures() {
    if (this.creatureSpawnTimer) {
      this.creatureSpawnTimer.destroy();
      this.creatureSpawnTimer = null;
    }

    this.creepyCreatures.forEach(creature => {
      if (creature && creature.destroy) creature.destroy();
    });
    this.creepyCreatures = [];
  }

  // Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤Ω Ïñ¥Îë† Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ± (DOM Ï°∞Ïûë)
  createBrowserDarkness() {
    // Í∏∞Ï°¥ Ïò§Î≤ÑÎ†àÏù¥ Ï†úÍ±∞
    this.removeBrowserDarkness();

    // Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏ≤¥Î•º ÎçÆÎäî Ïñ¥Îë† Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ±
    const overlay = document.createElement('div');
    overlay.id = 'presence-darkness';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(ellipse at center, transparent 30%, rgba(10, 0, 5, 0) 100%);
      pointer-events: none;
      z-index: 9999;
      transition: background 0.5s ease;
      opacity: 0;
    `;
    document.body.appendChild(overlay);
    this.browserDarkOverlay = overlay;

    // ÏÑúÏÑúÌûà Ïñ¥Îë† Îì±Ïû•
    setTimeout(() => {
      if (this.browserDarkOverlay) {
        this.browserDarkOverlay.style.opacity = '1';
      }
    }, 100);

    // Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤ΩÏÉâÎèÑ Î≥ÄÍ≤Ω
    document.body.style.transition = 'background 2s ease';
    document.body.style.background = 'linear-gradient(135deg, #0a0005 0%, #1a0510 100%)';
  }

  // Î∏åÎùºÏö∞Ï†Ä Ïñ¥Îë† Í∞ïÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
  updateBrowserDarkness(level) {
    if (!this.browserDarkOverlay) return;

    // level: 0-100
    const darkness = Math.min(level / 100, 1);
    const innerRadius = Math.max(30 - darkness * 25, 5); // 30% ‚Üí 5%
    const outerAlpha = Math.min(darkness * 0.9, 0.85);

    this.browserDarkOverlay.style.background = `
      radial-gradient(ellipse at center,
        transparent ${innerRadius}%,
        rgba(10, 0, 5, ${outerAlpha * 0.3}) ${innerRadius + 20}%,
        rgba(10, 0, 5, ${outerAlpha * 0.6}) ${innerRadius + 40}%,
        rgba(10, 0, 5, ${outerAlpha}) 100%)
    `;
  }

  // Î∏åÎùºÏö∞Ï†Ä ÌéÑÏä§ Ìö®Í≥º (Ïã¨Ïû•Î∞ïÎèô)
  browserPulse() {
    if (!this.browserDarkOverlay || !this.presenceActive) return;

    // Îπ®Í∞Ñ ÌîåÎûòÏãú
    const pulse = document.createElement('div');
    pulse.id = 'presence-pulse';
    pulse.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(ellipse at center, transparent 20%, rgba(80, 0, 0, 0.3) 100%);
      pointer-events: none;
      z-index: 9998;
      animation: presencePulse 0.3s ease-out;
    `;
    document.body.appendChild(pulse);

    // CSS Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
    if (!document.getElementById('presence-pulse-style')) {
      const style = document.createElement('style');
      style.id = 'presence-pulse-style';
      style.textContent = `
        @keyframes presencePulse {
          0% { opacity: 0; }
          30% { opacity: 1; }
          100% { opacity: 0; }
        }
        @keyframes browserShake {
          0%, 100% { transform: translate(0, 0); }
          10% { transform: translate(-5px, -3px); }
          20% { transform: translate(5px, 3px); }
          30% { transform: translate(-3px, 5px); }
          40% { transform: translate(3px, -5px); }
          50% { transform: translate(-5px, 3px); }
          60% { transform: translate(5px, -3px); }
          70% { transform: translate(-3px, -5px); }
          80% { transform: translate(3px, 5px); }
          90% { transform: translate(-5px, -3px); }
        }
        @keyframes attackFlash {
          0% { opacity: 0; background: rgba(255, 0, 0, 0.8); }
          20% { opacity: 1; }
          100% { opacity: 0; background: rgba(0, 0, 0, 0); }
        }
      `;
      document.head.appendChild(style);
    }

    // ÌéÑÏä§ Ï†úÍ±∞
    setTimeout(() => pulse.remove(), 300);
  }

  // Î∏åÎùºÏö∞Ï†Ä ÌùîÎì§Î¶º Ìö®Í≥º
  browserShake(duration = 500, intensity = 'medium') {
    const gameContainer = document.getElementById('game-container');
    if (!gameContainer) return;

    const intensityMap = {
      light: '3px',
      medium: '8px',
      heavy: '15px',
      extreme: '25px'
    };

    gameContainer.style.animation = `browserShake ${duration}ms ease-in-out`;
    gameContainer.style.setProperty('--shake-amount', intensityMap[intensity] || '8px');

    setTimeout(() => {
      gameContainer.style.animation = '';
    }, duration);
  }

  // Î∏åÎùºÏö∞Ï†Ä ÌîåÎûòÏãú Ìö®Í≥º
  browserFlash(color = 'red', duration = 200) {
    const flash = document.createElement('div');
    flash.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: ${color === 'red' ? 'rgba(255, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.8)'};
      pointer-events: none;
      z-index: 10000;
      animation: attackFlash ${duration}ms ease-out;
    `;
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), duration);
  }

  // üÜï Ïù∏Ìä∏Î°úÏö© Í∑πÏ†ÅÏù∏ Îπ®Í∞Ñ ÌîåÎûòÏãú (Îπ®Í∞Ñ Îàà Îì±Ïû• Ïãú)
  flashBrowserRed() {
    // Ï≤´ Î≤àÏß∏ ÌîåÎûòÏãú - Í∞ïÎ†¨ÌïòÍ≤å
    this.browserFlash('red', 150);
    this.browserShake(300, 'medium');

    // Îëê Î≤àÏß∏ ÌîåÎûòÏãú - Ïó¨Ïö¥
    setTimeout(() => {
      const afterFlash = document.createElement('div');
      afterFlash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(ellipse at center, rgba(100, 0, 0, 0.3) 0%, transparent 70%);
        pointer-events: none;
        z-index: 10000;
        animation: introFlashFade 1s ease-out forwards;
      `;
      document.body.appendChild(afterFlash);

      // CSS Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
      if (!document.getElementById('intro-flash-style')) {
        const style = document.createElement('style');
        style.id = 'intro-flash-style';
        style.textContent = `
          @keyframes introFlashFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
          }
        `;
        document.head.appendChild(style);
      }

      setTimeout(() => afterFlash.remove(), 1000);
    }, 100);

    // Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤Ω Ï¶âÏãú Ïñ¥Îë°Í≤å Ï†ÑÌôò
    document.body.style.transition = 'background 0.5s ease';
    document.body.style.background = 'linear-gradient(135deg, #0a0005 0%, #150010 100%)';
  }

  // Î∏åÎùºÏö∞Ï†Ä Ïñ¥Îë† Ï†úÍ±∞
  removeBrowserDarkness() {
    // Ïò§Î≤ÑÎ†àÏù¥ Ï†úÍ±∞
    const existing = document.getElementById('presence-darkness');
    if (existing) existing.remove();

    // ÌéÑÏä§ Ï†úÍ±∞
    const pulse = document.getElementById('presence-pulse');
    if (pulse) pulse.remove();

    // Î∞∞Í≤ΩÏÉâ Î≥µÏõê
    document.body.style.transition = 'background 1s ease';
    document.body.style.background = 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)';

    this.browserDarkOverlay = null;
  }

  // The Presence Ïù∏Ìä∏Î°ú Ïó∞Ï∂ú
  showPresenceIntro() {
    const { width, height } = this.cameras.main;
    const hitCount = this.fogBossHitCount;

    // HIT ÏàòÏóê Îî∞Î•∏ ÎåÄÏÇ¨
    const dialogues = [
      { text: "I am everywhere...", subtext: "You cannot hide." },
      { text: "Did you think you escaped?", subtext: "I am always watching." },
      { text: "Your fear feeds me...", subtext: "RUN." },
      { text: "THIS ENDS NOW.", subtext: "" }
    ];
    const dialogue = dialogues[Math.min(hitCount, 3)];

    // Î©îÏù∏ ÌÖçÏä§Ìä∏
    const mainText = this.add.text(width / 2, height / 2 - 20, '', {
      fontSize: `${28 + hitCount * 4}px`,
      fill: '#880000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 60,
      callback: () => {
        if (charIndex < dialogue.text.length) {
          mainText.setText(dialogue.text.substring(0, charIndex + 1));
          charIndex++;
          // Î∏åÎùºÏö∞Ï†Ä ÎØ∏ÏÑ∏ ÌùîÎì§Î¶º
          if (hitCount >= 2) this.browserShake(50, 'light');
        }
      },
      repeat: dialogue.text.length - 1
    });

    // ÏÑúÎ∏å ÌÖçÏä§Ìä∏
    if (dialogue.subtext) {
      this.time.delayedCall(dialogue.text.length * 60 + 500, () => {
        const subText = this.add.text(width / 2, height / 2 + 30, dialogue.subtext, {
          fontSize: '20px',
          fill: '#ff0000',
          fontStyle: 'italic'
        }).setOrigin(0.5).setDepth(5000).setAlpha(0);

        this.tweens.add({
          targets: subText,
          alpha: 1,
          duration: 300,
          onComplete: () => {
            this.time.delayedCall(1500, () => {
              this.tweens.add({
                targets: [mainText, subText],
                alpha: 0,
                duration: 500,
                onComplete: () => {
                  mainText.destroy();
                  subText.destroy();
                  // üÜï ÎåÄÏÇ¨ ÎÅù ‚Üí Í≥µÍ≤© ÏãúÏûë!
                  this.onPresenceDialogueEnd();
                }
              });
            });
          }
        });
      });
    } else {
      // HIT 3: Î∞îÎ°ú ÏÇ¨ÎùºÏßÄÍ≥† Í≥µÍ≤© ÏãúÏûë
      this.time.delayedCall(1500, () => {
        this.tweens.add({
          targets: mainText,
          alpha: 0,
          duration: 300,
          onComplete: () => {
            mainText.destroy();
            // üÜï ÎåÄÏÇ¨ ÎÅù ‚Üí Í≥µÍ≤© ÏãúÏûë!
            this.onPresenceDialogueEnd();
          }
        });
      });
    }

    // Î∏åÎùºÏö∞Ï†Ä ÌéÑÏä§ ÏãúÏûë
    this.browserPulse();
  }

  // üÜï ÎåÄÏÇ¨ Ï¢ÖÎ£å ÌõÑ Ìò∏Ï∂ú - Í≥µÍ≤© ÏãúÏûë
  onPresenceDialogueEnd() {
    this.presenceDialogueActive = false;

    // ÎπõÏùò Ï°∞Í∞ÅÏùÄ Ï≤´ Í≥µÍ≤© ÏôÑÎ£å ÌõÑ Ïä§Ìè∞Îê®
    this.firstAttackCompleted = false;

    // Í≥µÍ≤© Ïä§ÏºÄÏ§ÑÎßÅ ÏãúÏûë
    this.schedulePresenceAttack();

    // Ïä§ÌÜ†ÌÇπ Îàà ÏãúÏûë
    this.scheduleStalkingEyes();

    // Î¨¥ÏÑúÏö¥ ÏÉùÎ¨ºÎì§ Ïä§Ìè∞ ÏãúÏûë
    this.startCreatureSpawning();
  }

  // Ï°¥Ïû¨Í∞ê Î†àÎ≤® ÏóÖÎç∞Ïù¥Ìä∏
  updatePresenceLevel() {
    if (!this.fogBossMode || !this.presenceActive || this.gameOver) return;

    const hitCount = this.fogBossHitCount;

    // Ï°¥Ïû¨Í∞ê Ï†êÏßÑÏ†Å Ï¶ùÍ∞Ä
    const increaseRate = 3 + hitCount * 2;
    this.presenceLevel = Math.min(this.presenceLevel + increaseRate, 100);

    // Î∏åÎùºÏö∞Ï†Ä Ïñ¥Îë† ÏóÖÎç∞Ïù¥Ìä∏
    this.updateBrowserDarkness(this.presenceLevel);

    // Ïù∏Í≤åÏûÑ ÎπÑÎÑ§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
    this.updateVignetteIntensity(this.presenceLevel);

    // Ï°¥Ïû¨Í∞ê 50 Ïù¥ÏÉÅ: Ïã¨Ïû•Î∞ïÎèô Ìö®Í≥º
    if (this.presenceLevel >= 50 && !this.presencePulseTimer) {
      this.startPresenceHeartbeat();
    }

    // Ï°¥Ïû¨Í∞ê 70 Ïù¥ÏÉÅ: ÏïàÍ∞ú ÏßôÏñ¥Ïßê
    if (this.presenceLevel >= 70) {
      this.fogVisibleTiles = Math.max(2.5, this.originalFogVisibleTiles - this.presenceLevel * 0.02);
    }
  }

  // Ïã¨Ïû•Î∞ïÎèô Ìö®Í≥º (Î∏åÎùºÏö∞Ï†Ä Ìè¨Ìï®)
  startPresenceHeartbeat() {
    if (this.presencePulseTimer) return;

    this.presencePulseTimer = this.time.addEvent({
      delay: 1000 - this.presenceLevel * 3,
      callback: () => {
        // üÜï Î≥¥Ïä§ Î™®Îìú Ï¢ÖÎ£å ÏãúÏóêÎèÑ Ï†ïÏßÄ
        if (!this.fogBossMode || !this.presenceActive || this.gameOver) {
          if (this.presencePulseTimer) {
            this.presencePulseTimer.destroy();
            this.presencePulseTimer = null;
          }
          return;
        }

        // Î∏åÎùºÏö∞Ï†Ä ÌéÑÏä§
        this.browserPulse();

        // Ïπ¥Î©îÎùº Ï§å ÌéÑÏä§
        this.tweens.add({
          targets: this.cameras.main,
          zoom: 1.02,
          duration: 100,
          yoyo: true
        });

        // ÎîúÎ†àÏù¥ ÏóÖÎç∞Ïù¥Ìä∏
        if (this.presencePulseTimer) {
          this.presencePulseTimer.delay = Math.max(600, 1000 - this.presenceLevel * 4);
        }
      },
      loop: true
    });
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üÜï Í≥µÍ≤© ÏãúÏä§ÌÖú - Î™ÖÌôïÌïú Î∞©Ìñ• Í≤ΩÍ≥† + ÌöåÌîº
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // Í≥µÍ≤© Ïä§ÏºÄÏ§ÑÎßÅ
  schedulePresenceAttack() {
    if (!this.fogBossMode || !this.presenceActive || this.gameOver) return;

    const hitCount = this.fogBossHitCount;
    const attemptCount = Math.min(this.dodgeAttemptCount || 0, 10);
    // HIT ÎßéÏùÑÏàòÎ°ù Í≥µÍ≤© Í∞ÑÍ≤© ÏßßÏïÑÏßê
    const cooldown = Math.max(2500, this.attackCooldown - hitCount * 1200 - attemptCount * 150);

    this.time.delayedCall(cooldown, () => {
      if (this.fogBossMode && this.presenceActive && !this.gameOver) {
        this.initiatePresenceAttack();
      }
    });
  }

  // Í≥µÍ≤© ÏãúÏûë - Î™ÖÌôïÌïú Î∞©Ìñ• Í≤ΩÍ≥†
  initiatePresenceAttack() {
    if (!this.fogBossMode || !this.presenceActive || this.gameOver) return;

    const { width, height } = this.cameras.main;
    const hitCount = this.fogBossHitCount;

    // 1. Í≥µÍ≤© Î∞©Ìñ• Í≤∞Ï†ï (Î±ÄÏùò Ïïû, ÏòÜ, Îí§ Ï§ë ÌïòÎÇò)
    const directions = ['front', 'left', 'right', 'behind'];
    // HIT ÎÜíÏùÑÏàòÎ°ù Îí§ÏóêÏÑú Í≥µÍ≤© ÌôïÎ•† Ï¶ùÍ∞Ä
    const weights = hitCount >= 2 ? [30, 25, 25, 20] : [50, 25, 25, 0];
    this.attackDirection = this.weightedRandom(directions, weights);

    // Ïã§Ï†ú Î∞©Ìñ• Í≥ÑÏÇ∞ (Î±ÄÏùò ÌòÑÏû¨ Î∞©Ìñ• Í∏∞Ï§Ä)
    const actualDirection = this.getActualAttackDirection(this.attackDirection);

    // ÌöåÌîºÌï¥Ïïº Ìï† Î∞©Ìñ• (Í≥µÍ≤© Î∞òÎåÄ Î∞©Ìñ•)
    this.correctDodgeDirection = this.getOppositDirection(actualDirection);

    // 2. Í≤ΩÍ≥† Îã®Í≥Ñ ÏãúÏûë
    this.showAttackWarning(actualDirection);
  }

  // Í∞ÄÏ§ëÏπò ÎûúÎç§ ÏÑ†ÌÉù
  weightedRandom(items, weights) {
    const total = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * total;
    for (let i = 0; i < items.length; i++) {
      random -= weights[i];
      if (random <= 0) return items[i];
    }
    return items[0];
  }

  // Î±Ä Î∞©Ìñ• Í∏∞Ï§ÄÏúºÎ°ú Ïã§Ï†ú Í≥µÍ≤© Î∞©Ìñ• Í≥ÑÏÇ∞
  getActualAttackDirection(relativeDir) {
    const snakeDir = this.direction;
    const dirMap = {
      'RIGHT': { front: 'left', behind: 'right', left: 'up', right: 'down' },
      'LEFT': { front: 'right', behind: 'left', left: 'down', right: 'up' },
      'UP': { front: 'down', behind: 'up', left: 'left', right: 'right' },
      'DOWN': { front: 'up', behind: 'down', left: 'right', right: 'left' }
    };
    return dirMap[snakeDir][relativeDir];
  }

  // Î∞òÎåÄ Î∞©Ìñ• Íµ¨ÌïòÍ∏∞
  getOppositDirection(dir) {
    const opposite = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
    return opposite[dir];
  }

  // Í≥µÍ≤© Í≤ΩÍ≥† ÌëúÏãú (Î™ÖÌôïÌïú Î∞©Ìñ• ÌôîÏÇ¥Ìëú)
  showAttackWarning(attackFrom) {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 1. Î∏åÎùºÏö∞Ï†Ä Ï†ÑÏ≤¥ Îπ®Í∞Ñ ÌÖåÎëêÎ¶¨ ÍπúÎπ°ÏûÑ
    this.showBrowserWarningBorder(attackFrom);

    // 2. Î∞©Ìñ• ÌôîÏÇ¥Ìëú Í≤ΩÍ≥† (Ïñ¥ÎîîÏÑú Í≥µÍ≤©Ïù¥ Ïò§ÎäîÏßÄ)
    const arrowConfig = {
      'up': { x: headX, y: 60, rotation: Math.PI / 2, text: '‚Üì FROM ABOVE!' },
      'down': { x: headX, y: height - 30, rotation: -Math.PI / 2, text: '‚Üë FROM BELOW!' },
      'left': { x: 30, y: headY, rotation: 0, text: '‚Üí FROM LEFT!' },
      'right': { x: width - 30, y: headY, rotation: Math.PI, text: '‚Üê FROM RIGHT!' }
    };
    const config = arrowConfig[attackFrom];

    // Í≤ΩÍ≥† ÌôîÏÇ¥Ìëú
    const warningArrow = this.add.text(config.x, config.y, '‚ö†Ô∏è', {
      fontSize: '40px'
    }).setOrigin(0.5).setDepth(6000);

    // Î∞©Ìñ• ÌÖçÏä§Ìä∏
    const dirText = this.add.text(width / 2, height / 2 - 80, config.text, {
      fontSize: '32px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4,
      backgroundColor: '#000000aa',
      padding: { x: 15, y: 8 }
    }).setOrigin(0.5).setDepth(6000);

    // ÌöåÌîº ÏïàÎÇ¥
    const dodgeHint = this.add.text(width / 2, height / 2 + 50, `DODGE ${this.correctDodgeDirection.toUpperCase()}! [SPACE]`, {
      fontSize: '28px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(6000);

    // ÍπúÎπ°ÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: [warningArrow, dirText, dodgeHint],
      alpha: { from: 1, to: 0.3 },
      duration: 150,
      yoyo: true,
      repeat: 5
    });

    // Î∏åÎùºÏö∞Ï†Ä ÌùîÎì§Î¶º
    this.browserShake(1500, 'medium');

    // Ïπ¥Î©îÎùº ÌùîÎì§Î¶º
    this.cameras.main.shake(1500, 0.03);

    // Í≤ΩÍ≥† ÏãúÍ∞Ñ ÌõÑ Í≥µÍ≤© Ïã§Ìñâ (2Ï¥à - ÌöåÌîº Ï§ÄÎπÑ ÏãúÍ∞Ñ)
    const isFirstAttack = this.presenceAttackCount === 0;
    const warningTime = Math.max(1500, 2000 - this.fogBossHitCount * 200);
    this.presenceAttackCount++;

    this.time.delayedCall(warningTime, () => {
      warningArrow.destroy();
      dirText.destroy();
      dodgeHint.destroy();
      this.executePresenceAttack(attackFrom);
    });

    // ÌöåÌîº Ï∞Ω ÌôúÏÑ±Ìôî (Ï≤´ Í≥µÍ≤©Îßå 10Ï¥àÎ°ú Ï∂©Î∂ÑÌûà Í∏∏Í≤å - Í≤åÏûÑ Î∞©Ïãù ÌïôÏäµÏö©)
    this.dodgeWindowActive = true;
    const dodgeWindow = isFirstAttack ? 10000 : warningTime + 500;
    this.dodgeWindowTimer = this.time.delayedCall(dodgeWindow, () => {
      this.dodgeWindowActive = false;
    });
  }

  // Î∏åÎùºÏö∞Ï†Ä Í≤ΩÍ≥† ÌÖåÎëêÎ¶¨
  showBrowserWarningBorder(direction) {
    const border = document.createElement('div');
    border.id = 'presence-warning-border';

    // Î∞©Ìñ•Ïóê Îî∞Î•∏ ÌÖåÎëêÎ¶¨
    const borderStyles = {
      'up': 'border-top: 8px solid #ff0000;',
      'down': 'border-bottom: 8px solid #ff0000;',
      'left': 'border-left: 8px solid #ff0000;',
      'right': 'border-right: 8px solid #ff0000;'
    };

    border.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      ${borderStyles[direction]}
      pointer-events: none;
      z-index: 10001;
      box-sizing: border-box;
      animation: presencePulse 0.3s ease-in-out infinite;
    `;
    document.body.appendChild(border);

    // 2Ï¥à ÌõÑ Ï†úÍ±∞
    setTimeout(() => border.remove(), 2000);
  }

  // Í≥µÍ≤© Ïã§Ìñâ
  executePresenceAttack(attackFrom) {
    if (!this.fogBossMode || !this.presenceActive || this.gameOver) return;
    if (!this.snake || this.snake.length === 0) return;

    const { width, height } = this.cameras.main;
    const head = this.snake[0];

    // 1. Î∏åÎùºÏö∞Ï†Ä Í∞ïÎ†•Ìïú ÌîåÎûòÏãú + ÌùîÎì§Î¶º
    this.browserFlash('white', 150);
    this.browserShake(500, 'heavy');

    // 2. Î≥¥Ïä§ Îì±Ïû• ÏúÑÏπò Í≥ÑÏÇ∞
    const offsetTiles = 3;
    let bossX = head.x;
    let bossY = head.y;

    switch (attackFrom) {
      case 'up': bossY = head.y - offsetTiles; break;
      case 'down': bossY = head.y + offsetTiles; break;
      case 'left': bossX = head.x - offsetTiles; break;
      case 'right': bossX = head.x + offsetTiles; break;
    }

    // Î≥¥Ïä§ ÏúÑÏπò ÏÑ§Ï†ï
    this.fogBossPosition = { x: bossX, y: bossY };
    const bossPixelX = bossX * this.gridSize + this.gridSize / 2;
    const bossPixelY = bossY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 3. Î≥¥Ïä§ Îì±Ïû•
    this.fogBossVisible = true;
    if (this.fogBossElement) {
      this.fogBossElement.setPosition(bossPixelX, bossPixelY);
      this.fogBossElement.setAlpha(1);
      this.fogBossElement.setScale(2);

      // ÌôïÎåÄ ÌõÑ ÎèåÏßÑ
      this.tweens.add({
        targets: this.fogBossElement,
        scaleX: 1,
        scaleY: 1,
        duration: 100
      });
    }

    // 4. "RAAAGH!" ÎπÑÎ™Ö
    const scream = this.add.text(width / 2, height / 2, 'RAAAGH!!!', {
      fontSize: '72px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(6000).setAlpha(0);

    this.tweens.add({
      targets: scream,
      alpha: 1,
      scaleX: { from: 0.5, to: 1.3 },
      scaleY: { from: 0.5, to: 1.3 },
      duration: 150,
      onComplete: () => {
        this.time.delayedCall(200, () => {
          scream.destroy();
        });
      }
    });

    // 5. ÎèåÏßÑ Ïã§Ìñâ
    this.time.delayedCall(200, () => {
      this.executePresenceDash(attackFrom);
    });
  }

  // ÎèåÏßÑ Ïã§Ìñâ - QTE Ïä§ÌÉÄÏùº (SPACE ÎàåÎü¨Ïïº ÌöåÌîº)
  executePresenceDash(attackFrom) {
    // üÜï Ïù¥ÎØ∏ QTE ÏßÑÌñâ Ï§ëÏù¥Î©¥ Ï§ëÎ≥µ Í≥µÍ≤© Î∞©ÏßÄ
    if (this.dodgeQTEActive) {
      return;
    }

    // üÜï Î≥¥Ïä§ Î™®Îìú Ï¢ÖÎ£å, Í≤åÏûÑÏò§Î≤Ñ ÏÉÅÌÉú, snakeÍ∞Ä ÏóÜÏúºÎ©¥ Ïã§Ìñâ ÏïàÌï®
    if (!this.fogBossMode || !this.presenceActive || this.gameOver) {
      return;
    }
    if (!this.snake || this.snake.length === 0) {
      return;
    }

    const head = this.snake[0];
    const targetX = head.x * this.gridSize + this.gridSize / 2;
    const targetY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // QTE ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.playerDodged = false;
    this.dodgeQTEActive = true;

    // üÜï ÌöåÌîº ÏãúÎèÑ Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
    this.dodgeAttemptCount = (this.dodgeAttemptCount || 0) + 1;

    // ÎèåÏßÑ ÏÜçÎèÑ (HIT ÎßéÏùÑÏàòÎ°ù + ÏãúÎèÑ ÌöüÏàò ÎßéÏùÑÏàòÎ°ù Îπ®ÎùºÏßê!)
    // Ï¥àÎ∞ò: 700ms (Ïó¨Ïú†) ‚Üí ÌõÑÎ∞ò: 250ms (Í∑πÌïú)
    const baseTime = 700;
    const hitPenalty = this.fogBossHitCount * 90;  // HITÎãπ 90ms Í∞êÏÜå
    const attemptPenalty = Math.max(0, this.dodgeAttemptCount - 1) * 60;  // ÏãúÎèÑÎãπ 60ms Í∞êÏÜå
    const dashDuration = Math.max(300, baseTime - hitPenalty - attemptPenalty);

    // QTE ÌîÑÎ°¨ÌîÑÌä∏ ÌëúÏãú (Ï≤´ Í≥µÍ≤©ÏùÄ 10Ï¥àÎ°ú Ï∂©Î∂ÑÌûà Í∏∏Í≤å - Í≤åÏûÑ Î∞©Ïãù ÌïôÏäµÏö©)
    const useGraceWindow = !this.fogBossFirstDodgeGraceUsed;
    if (useGraceWindow) {
      this.fogBossFirstDodgeGraceUsed = true;
    }
    const qteDuration = useGraceWindow ? 10000 : dashDuration;
    this.showDodgeQTE(qteDuration);

    // QTE ÏãúÍ∞Ñ (Ï≤´ Í≥µÍ≤©ÏùÄ 10Ï¥àÎ°ú Ï∂©Î∂ÑÌûà Í∏∏Í≤å)
    const qteWindow = useGraceWindow ? 10000 : dashDuration + 80;
    const actualDashDuration = useGraceWindow ? 10000 : dashDuration;

    this.tweens.add({
      targets: this.fogBossElement,
      x: targetX,
      y: targetY,
      duration: actualDashDuration,
      ease: 'Power2.easeIn',
      onUpdate: () => {
        // ÎèåÏßÑ Ï§ë ÏûîÏÉÅ Ìö®Í≥º
        if (Math.random() < 0.3 && this.fogBossElement) {
          const trail = this.add.circle(
            this.fogBossElement.x + Phaser.Math.Between(-10, 10),
            this.fogBossElement.y + Phaser.Math.Between(-10, 10),
            8, 0x660033, 0.5
          ).setDepth(140);
          this.tweens.add({
            targets: trail,
            alpha: 0,
            scale: 0.3,
            duration: 200,
            onComplete: () => trail.destroy()
          });
        }
      },
      onComplete: () => {
        // 9ÌÉÑ Î≥¥Ïä§ Í≥µÍ≤© Ìö®Í≥ºÏùå (Î±Ä ÏúÑÎ•º ÏßÄÎÇòÍ∞à Îïå)
        this.sound.play('boss9_effect', { volume: 0.3 });

        // QTE Ï∞Ω Ï¢ÖÎ£å
        this.dodgeQTEActive = false;

        // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä SPACEÎ•º ÎàåÎ†ÄÎäîÏßÄ ÌôïÏù∏
        if (this.playerDodged) {
          // ÌöåÌîº ÏÑ±Í≥µ!
          this.handlePresenceDodgeSuccess();
        } else {
          // ÌöåÌîº Ïã§Ìå® - Ï£ΩÏùå!
          this.handlePresenceKill();
        }
      }
    });

    // Î≥¥Ïä§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    this.fogBossPosition = { x: head.x, y: head.y };
  }

  // QTE Îã∑ÏßÄ ÌîÑÎ°¨ÌîÑÌä∏ ÌëúÏãú
  showDodgeQTE(duration = 600) {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // üÜï Í∏∞Ï°¥ QTE ÏöîÏÜåÍ∞Ä ÏûàÏúºÎ©¥ Î®ºÏ†Ä Ï†ïÎ¶¨ (Ï§ëÎ≥µ Î∞©ÏßÄ!)
    this.cleanupQTEElements();

    // üÜï QTE ÏÑ∏ÏÖò ID ÏÉùÏÑ± (ÎÇòÏ§ëÏóê Ï†ïÎ¶¨ Ïãú ÌôïÏù∏Ïö©)
    this.currentQTESessionId = Date.now();
    const sessionId = this.currentQTESessionId;

    // üÜï ÎÇúÏù¥ÎèÑ ÌëúÏãú (ÏãúÍ∞ÑÏù¥ ÏßßÏùÑÏàòÎ°ù Îπ®Í∞ÑÏÉâ)
    const difficultyRatio = Math.max(0, (duration - 250) / 450); // 0(Í∑πÌïú) ~ 1(Ïó¨Ïú†)
    const timerColor = Phaser.Display.Color.Interpolate.ColorWithColor(
      { r: 255, g: 0, b: 0 },    // Îπ®Í∞ï (ÏúÑÌóò)
      { r: 0, g: 255, b: 0 },    // Ï¥àÎ°ù (ÏïàÏ†Ñ)
      100,
      Math.floor(difficultyRatio * 100)
    );
    const timerHexColor = Phaser.Display.Color.GetColor(timerColor.r, timerColor.g, timerColor.b);

    // ÌÅ∞ SPACE ÌîÑÎ°¨ÌîÑÌä∏
    const qtePrompt = this.add.container(width / 2, height / 2 + 80).setDepth(7000);

    // Î∞∞Í≤Ω (ÎÇúÏù¥ÎèÑÏóê Îî∞Îùº ÌÖåÎëêÎ¶¨ ÏÉâ Î≥ÄÍ≤Ω)
    const borderColor = duration < 400 ? 0xff0000 : 0xffff00;
    const bg = this.add.rectangle(0, 0, 280, 70, 0x000000, 0.8)
      .setStrokeStyle(4, borderColor);
    qtePrompt.add(bg);

    // SPACE ÌÇ§ ÏïÑÏù¥ÏΩò
    const keyBg = this.add.rectangle(-60, 0, 80, 40, 0x333333)
      .setStrokeStyle(2, 0xffffff);
    const keyText = this.add.text(-60, 0, 'SPACE', {
      fontSize: '16px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    qtePrompt.add([keyBg, keyText]);

    // "TO DODGE!" ÌÖçÏä§Ìä∏ (ÏãúÍ∞Ñ ÏßßÏúºÎ©¥ QUICK! Ï∂îÍ∞Ä)
    const urgency = duration < 400 ? 'QUICK!' : 'TO DODGE!';
    const dodgeText = this.add.text(40, 0, urgency, {
      fontSize: '24px',
      fill: duration < 400 ? '#ff6666' : '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    qtePrompt.add(dodgeText);

    // ÌÉÄÏù¥Î®∏ Î∞î (Ï†êÏ†ê Ï§ÑÏñ¥Îì¶) - ÏÉâÏÉÅÏù¥ ÎÇúÏù¥ÎèÑ Î∞òÏòÅ
    const timerBarBg = this.add.rectangle(0, 45, 260, 12, 0x333333);
    const timerBar = this.add.rectangle(-130, 45, 260, 10, timerHexColor).setOrigin(0, 0.5);
    qtePrompt.add([timerBarBg, timerBar]);

    // ÌÉÄÏù¥Î®∏ Î∞î Ïï†ÎãàÎ©îÏù¥ÏÖò (Ïã§Ï†ú ÏßÄÏÜçÏãúÍ∞ÑÏóê ÎßûÏ∂§!)
    this.tweens.add({
      targets: timerBar,
      scaleX: 0,
      duration: duration,
      ease: 'Linear',
      onUpdate: () => {
        // ÏãúÍ∞ÑÏù¥ Í±∞Ïùò ÏóÜÏùÑ Îïå Îπ®Í∞ÑÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
        if (timerBar.scaleX < 0.3) {
          timerBar.setFillStyle(0xff0000);
        }
      }
    });

    // ÍπúÎπ°ÏûÑ Ìö®Í≥º (ÏãúÍ∞Ñ ÏßßÏúºÎ©¥ Îçî Îπ†Î•¥Í≤å)
    const blinkSpeed = duration < 400 ? 60 : 100;
    this.tweens.add({
      targets: [bg, keyBg],
      alpha: { from: 1, to: 0.5 },
      duration: blinkSpeed,
      yoyo: true,
      repeat: -1
    });

    // Î±Ä Î®∏Î¶¨ ÏúÑÏóêÎèÑ ÌëúÏãú
    const headPrompt = this.add.text(headX, headY - 40, '‚ö° SPACE! ‚ö°', {
      fontSize: '20px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(7000);

    this.tweens.add({
      targets: headPrompt,
      scaleX: { from: 1, to: 1.3 },
      scaleY: { from: 1, to: 1.3 },
      duration: 100,
      yoyo: true,
      repeat: -1
    });

    // Ï†ÄÏû• (ÎÇòÏ§ëÏóê Ï†ïÎ¶¨Ïö©)
    this.qteElements = [qtePrompt, headPrompt];

    // QTE ÎÅùÎÇòÎ©¥ ÏûêÎèô Ï†úÍ±∞ (ÏÑ∏ÏÖò ID Ï≤¥ÌÅ¨Î°ú Ï§ëÎ≥µ Ï†ïÎ¶¨ Î∞©ÏßÄ!)
    this.time.delayedCall(duration + 200, () => {
      // üÜï Í∞ôÏùÄ ÏÑ∏ÏÖòÏùò QTEÎßå Ï†ïÎ¶¨ (Ïù¥ÎØ∏ ÏÉà QTEÍ∞Ä ÏãúÏûëÎêêÏúºÎ©¥ Ïä§ÌÇµ)
      if (this.currentQTESessionId === sessionId) {
        this.cleanupQTEElements();
      }
    });
  }

  // üÜï QTE ÏöîÏÜå Ï†ïÎ¶¨ Ìï®Ïàò
  cleanupQTEElements() {
    if (this.qteElements) {
      this.qteElements.forEach(el => {
        if (el && el.destroy) {
          // tweens Î®ºÏ†Ä Ï§ëÏßÄ
          this.tweens.killTweensOf(el);
          el.destroy();
        }
      });
      this.qteElements = null;
    }
  }

  // QTE Îã∑ÏßÄ ÏûÖÎ†• Ï≤òÎ¶¨ (ÌÇ§Î≥¥Îìú Ìï∏Îì§Îü¨ÏóêÏÑú Ìò∏Ï∂ú)
  handleDodgeQTEInput() {
    if (!this.dodgeQTEActive) return false;

    // Îã∑ÏßÄ ÏÑ±Í≥µ!
    this.playerDodged = true;
    this.dodgeQTEActive = false;

    // üÜï QTE ÌîÑÎ°¨ÌîÑÌä∏ Ï¶âÏãú Ï†úÍ±∞ (Ï†ïÎ¶¨ Ìï®Ïàò ÏÇ¨Ïö©)
    this.cleanupQTEElements();

    // Ï¶âÏãú "PERFECT!" ÌëúÏãú
    this.showPerfectDodge();

    return true;
  }

  // ÌçºÌéôÌä∏ Îã∑ÏßÄ Ïó∞Ï∂ú
  showPerfectDodge() {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ïä¨Î°úÏö∞Î™®ÏÖò Ìö®Í≥º
    this.time.timeScale = 0.3;
    this.tweens.timeScale = 0.3;

    // üÜï Î≥¥Ïä§Í∞Ä ÏòÜÏúºÎ°ú Îπ†Î•¥Í≤å ÏßÄÎÇòÍ∞ÄÎäî Ìö®Í≥º (Ïã§Ï†úÎ°ú ÌîºÌïú ÎäêÎÇå!)
    this.showBossPassingEffect(headX, headY);

    // Î±ÄÏù¥ ÏòÜÏúºÎ°ú Íµ¥Îü¨Í∞ÄÎäî Ïó∞Ï∂ú (ÏûîÏÉÅ)
    for (let i = 0; i < 4; i++) {
      const ghost = this.add.circle(
        headX + i * 15,
        headY,
        this.gridSize / 2 - 2,
        0x00ff00,
        0.6 - i * 0.15
      ).setDepth(150);

      this.tweens.add({
        targets: ghost,
        alpha: 0,
        x: ghost.x + 30,
        duration: 300,
        delay: i * 50,
        onComplete: () => ghost.destroy()
      });
    }

    // "PERFECT!" ÌÖçÏä§Ìä∏
    const perfectText = this.add.text(width / 2, height / 2 - 50, 'PERFECT!', {
      fontSize: '48px',
      fill: '#00ffff',
      fontStyle: 'bold',
      stroke: '#003333',
      strokeThickness: 5
    }).setOrigin(0.5).setDepth(7000);

    this.tweens.add({
      targets: perfectText,
      scaleX: { from: 0.5, to: 1.2 },
      scaleY: { from: 0.5, to: 1.2 },
      duration: 200,
      onComplete: () => {
        this.tweens.add({
          targets: perfectText,
          alpha: 0,
          y: height / 2 - 100,
          duration: 500,
          onComplete: () => perfectText.destroy()
        });
      }
    });

    // 0.5Ï¥à ÌõÑ ÏãúÍ∞Ñ Î≥µÍµ¨
    this.time.delayedCall(500, () => {
      this.time.timeScale = 1;
      this.tweens.timeScale = 1;
    });

    // Î¨¥Ï†Å ÌîÑÎ†àÏûÑ
    this.isInvincible = true;
    this.time.delayedCall(800, () => {
      this.isInvincible = false;
    });
  }

  // üÜï Î≥¥Ïä§Í∞Ä ÏòÜÏúºÎ°ú ÏßÄÎÇòÍ∞ÄÎäî Ìö®Í≥º (Ïä¨Î°úÏö∞Î™®ÏÖò Ï§ë)
  showBossPassingEffect(headX, headY) {
    // Î≥¥Ïä§Í∞Ä ÏßÄÎÇòÍ∞ÄÎäî Î∞©Ìñ• Í≤∞Ï†ï (Î±Ä Î∞©Ìñ•Ïùò Î∞òÎåÄÏ™ΩÏóêÏÑú Ï∂úÎ∞ú)
    const directions = ['left', 'right', 'top', 'bottom'];
    const passDir = directions[Math.floor(Math.random() * directions.length)];

    let startX, startY, endX, endY;
    const offset = 150; // ÌôîÎ©¥ Î∞ñÏóêÏÑú ÏãúÏûë

    switch (passDir) {
      case 'left':
        startX = headX - offset;
        startY = headY;
        endX = headX + offset;
        endY = headY + Phaser.Math.Between(-30, 30);
        break;
      case 'right':
        startX = headX + offset;
        startY = headY;
        endX = headX - offset;
        endY = headY + Phaser.Math.Between(-30, 30);
        break;
      case 'top':
        startX = headX + Phaser.Math.Between(-50, 50);
        startY = headY - offset;
        endX = headX + Phaser.Math.Between(-50, 50);
        endY = headY + offset;
        break;
      case 'bottom':
        startX = headX + Phaser.Math.Between(-50, 50);
        startY = headY + offset;
        endX = headX + Phaser.Math.Between(-50, 50);
        endY = headY - offset;
        break;
    }

    // Î≥¥Ïä§ Í∑∏Î¶ºÏûê (ÏßÄÎÇòÍ∞ÄÎäî ÌòïÏ≤¥)
    const passingBoss = this.add.container(startX, startY).setDepth(6500);

    // Ïñ¥ÎëêÏö¥ ÌòïÏ≤¥ (Î∏îÎü¨ ÎäêÎÇå)
    const shadowBody = this.add.ellipse(0, 0, 60, 80, 0x220022, 0.7);
    passingBoss.add(shadowBody);

    // Îπ®Í∞Ñ Îàà (Ìä∏Î†àÏùº Ìö®Í≥º)
    const leftEye = this.add.circle(-8, -10, 5, 0xff0000, 1);
    const rightEye = this.add.circle(8, -10, 5, 0xff0000, 1);
    leftEye.setBlendMode(Phaser.BlendModes.ADD);
    rightEye.setBlendMode(Phaser.BlendModes.ADD);
    passingBoss.add([leftEye, rightEye]);

    // ÏûîÏÉÅ Ìä∏Î†àÏùº ÏÉùÏÑ±
    const trailCount = 8;
    for (let i = 0; i < trailCount; i++) {
      const trailProgress = i / trailCount;
      const trailX = startX + (endX - startX) * trailProgress * 0.3;
      const trailY = startY + (endY - startY) * trailProgress * 0.3;

      const trail = this.add.ellipse(trailX, trailY, 50, 70, 0x330033, 0.3 - i * 0.03)
        .setDepth(6400);

      this.tweens.add({
        targets: trail,
        alpha: 0,
        scaleX: 0.5,
        scaleY: 0.5,
        duration: 400,
        delay: i * 30,
        onComplete: () => trail.destroy()
      });
    }

    // Î≥¥Ïä§ Îπ†Î•¥Í≤å ÏßÄÎÇòÍ∞ê (Ïä¨Î°úÏö∞Î™®ÏÖò ÏÉÅÌÉúÏóêÏÑúÎèÑ Îπ†Î•¥Í≤å!)
    this.tweens.add({
      targets: passingBoss,
      x: endX,
      y: endY,
      duration: 200, // Ïä¨Î°úÏö∞Î™®ÏÖòÏù¥Îùº Ïã§Ï†úÎ°úÎäî Îçî Í∏∏Í≤å ÎäêÍª¥Ïßê
      ease: 'Power2.easeIn',
      onUpdate: () => {
        // ÏßÄÎÇòÍ∞ÄÎ©¥ÏÑú Îàà Ìä∏Î†àÏùº
        if (Math.random() < 0.5) {
          const eyeTrail = this.add.circle(
            passingBoss.x + Phaser.Math.Between(-15, 15),
            passingBoss.y - 10,
            3, 0xff0000, 0.6
          ).setDepth(6400).setBlendMode(Phaser.BlendModes.ADD);

          this.tweens.add({
            targets: eyeTrail,
            alpha: 0,
            scaleX: 0.3,
            scaleY: 0.3,
            duration: 150,
            onComplete: () => eyeTrail.destroy()
          });
        }
      },
      onComplete: () => {
        passingBoss.destroy();
      }
    });

    // Ïä§ÏúΩ ÌïòÎäî Î∞îÎûå Ìö®Í≥º (ÏãúÍ∞ÅÏ†Å)
    const windLines = [];
    for (let i = 0; i < 5; i++) {
      const lineY = headY + Phaser.Math.Between(-40, 40);
      const line = this.add.rectangle(
        passDir === 'left' ? headX - 30 : headX + 30,
        lineY,
        80, 2, 0x666699, 0.5
      ).setDepth(6300);
      windLines.push(line);

      this.tweens.add({
        targets: line,
        x: passDir === 'left' ? headX + 100 : headX - 100,
        alpha: 0,
        scaleX: 2,
        duration: 250,
        delay: i * 30,
        onComplete: () => line.destroy()
      });
    }
  }

  // ÌöåÌîº ÏÑ±Í≥µ Ï≤òÎ¶¨
  handlePresenceDodgeSuccess() {
    const { width, height } = this.cameras.main;

    // Ï≤´ Í≥µÍ≤© ÏôÑÎ£å ÌõÑ ÎπõÏùò Ï°∞Í∞Å Ïä§Ìè∞ ÏãúÏûë
    if (!this.firstAttackCompleted) {
      this.firstAttackCompleted = true;
      this.startFlareSpawning();
    }

    // "SURVIVED!" ÌëúÏãú
    const survivedText = this.add.text(width / 2, height / 2, 'SURVIVED!', {
      fontSize: '36px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#003300',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: survivedText,
      alpha: 0,
      y: height / 2 - 50,
      duration: 800,
      onComplete: () => survivedText.destroy()
    });

    // Î≥¥Ïä§ Ïà®Í∏∞Í∏∞ (Ï¢åÏ†àÌïòÎ©∞ ÏÇ¨ÎùºÏßê)
    this.time.delayedCall(300, () => {
      // Î≥¥Ïä§ Ï¢åÏ†à ÎπÑÎ™Ö
      const frustration = this.add.text(
        this.fogBossElement?.x || width / 2,
        (this.fogBossElement?.y || height / 2) - 30,
        'MISSED!',
        {
          fontSize: '20px',
          fill: '#ff6666',
          fontStyle: 'bold'
        }
      ).setOrigin(0.5).setDepth(160);

      this.tweens.add({
        targets: frustration,
        alpha: 0,
        y: frustration.y - 30,
        duration: 600,
        onComplete: () => frustration.destroy()
      });

      if (this.fogBossElement) {
        // Î≥¥Ïä§Í∞Ä ÏïàÍ∞ú ÏÜçÏúºÎ°ú ÎÖπÏïÑÎìúÎäî Ìö®Í≥º
        this.tweens.add({
          targets: this.fogBossElement,
          alpha: 0,
          scaleX: 0.5,
          scaleY: 0.5,
          duration: 500,
          ease: 'Power2.easeIn'
        });
      }
      this.fogBossVisible = false;

      // Ï°¥Ïû¨Í∞ê ÏïΩÍ∞Ñ Í∞êÏÜå (ÏïàÏã¨ Ìö®Í≥º)
      if (this.presenceActive) {
        this.presenceLevel = Math.max(this.presenceLevel - 20, 30);
        this.updateBrowserDarkness(this.presenceLevel);
      }

      // Îã§Ïùå Í≥µÍ≤© Ïä§ÏºÄÏ§Ñ (ÌéòÏù¥Ï¶àÏóê Îî∞Îùº Îã§Î•¥Í≤å)
      this.time.delayedCall(500, () => {
        if (this.fogBossPhase === 'shadow') {
          // Shadow ÌéòÏù¥Ï¶àÎ©¥ shadowStrike Í≥ÑÏÜç
          const delay = this.getShadowStrikeDelay();
          this.shadowStrikeTimer = this.time.delayedCall(delay, () => {
            this.showShadowStrikeWarning();
          });
        } else if (this.presenceActive) {
          // Presence ÏãúÏä§ÌÖúÏù¥Î©¥ presenceAttack Ïä§ÏºÄÏ§Ñ
          this.schedulePresenceAttack();
        }
      });
    });
  }

  // ÌöåÌîº Ïã§Ìå® - ÏÇ¨Îßù (Î≥¥Ïä§ÏóêÍ≤å Ïû°ÏïÑÎ®πÌûò!)
  handlePresenceKill() {
    // üÜï HIT ÎåÄÍ∏∞ Ï§ëÏù¥Î©¥ ÏÇ¨Îßù Î¨¥Ïãú (ÌÅ¥Î¶¨Ïñ¥ Ïö∞ÏÑ†!)
    if (this.fogBossHitPending) {
      return;
    }

    this.gameOver = true;
    if (this.moveTimer) this.moveTimer.paused = true;

    // üÜï Ïû°ÏïÑÎ®πÌûàÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò!
    this.showBossEatingAnimation();
  }

  // üÜï Î≥¥Ïä§Í∞Ä Î±ÄÏùÑ Ïû°ÏïÑÎ®πÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò (ÌöåÌîº ÏÑ±Í≥µÍ≥º ÎèôÏùºÌïú Îß§Ïª§ÎãàÏ¶ò, Î±ÄÎßå ÎÅåÎ†§Í∞ê)
  showBossEatingAnimation() {
    const { width, height } = this.cameras.main;
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // 1. ÌöåÌîº ÏÑ±Í≥µÍ≥º ÎèôÏùºÌïòÍ≤å Ïä¨Î°úÏö∞Î™®ÏÖò ÏãúÏûë
    this.time.timeScale = 0.3;
    this.tweens.timeScale = 0.3;

    // 2. Î≥¥Ïä§Í∞Ä ÏßÄÎÇòÍ∞ÄÎäî Î∞©Ìñ• Í≤∞Ï†ï (showBossPassingEffectÏôÄ ÎèôÏùº!)
    const directions = ['left', 'right', 'top', 'bottom'];
    const passDir = directions[Math.floor(Math.random() * directions.length)];

    let startX, startY, endX, endY;
    const offset = 150;

    switch (passDir) {
      case 'left':
        startX = headX - offset;
        startY = headY;
        endX = headX + offset;
        endY = headY + Phaser.Math.Between(-30, 30);
        break;
      case 'right':
        startX = headX + offset;
        startY = headY;
        endX = headX - offset;
        endY = headY + Phaser.Math.Between(-30, 30);
        break;
      case 'top':
        startX = headX + Phaser.Math.Between(-50, 50);
        startY = headY - offset;
        endX = headX + Phaser.Math.Between(-50, 50);
        endY = headY + offset;
        break;
      case 'bottom':
        startX = headX + Phaser.Math.Between(-50, 50);
        startY = headY + offset;
        endX = headX + Phaser.Math.Between(-50, 50);
        endY = headY - offset;
        break;
    }

    // 3. Î≥¥Ïä§ Í∑∏Î¶ºÏûê ÏÉùÏÑ± (showBossPassingEffectÏôÄ ÎèôÏùºÌïú ÎîîÏûêÏù∏!)
    const passingBoss = this.add.container(startX, startY).setDepth(6500);

    // Ïñ¥ÎëêÏö¥ ÌòïÏ≤¥ (Î∏îÎü¨ ÎäêÎÇå) - ÎèôÏùºÌïú ÌÅ¨Í∏∞
    const shadowBody = this.add.ellipse(0, 0, 60, 80, 0x220022, 0.7);
    passingBoss.add(shadowBody);

    // Îπ®Í∞Ñ Îàà 2Í∞ú (ÎèôÏùº)
    const leftEye = this.add.circle(-8, -10, 5, 0xff0000, 1);
    const rightEye = this.add.circle(8, -10, 5, 0xff0000, 1);
    leftEye.setBlendMode(Phaser.BlendModes.ADD);
    rightEye.setBlendMode(Phaser.BlendModes.ADD);
    passingBoss.add([leftEye, rightEye]);

    // 4. ÏûîÏÉÅ Ìä∏Î†àÏùº ÏÉùÏÑ± (ÎèôÏùº)
    const trailCount = 8;
    for (let i = 0; i < trailCount; i++) {
      const trailProgress = i / trailCount;
      const trailX = startX + (headX - startX) * trailProgress * 0.3;
      const trailY = startY + (headY - startY) * trailProgress * 0.3;

      const trail = this.add.ellipse(trailX, trailY, 50, 70, 0x330033, 0.3 - i * 0.03)
        .setDepth(6400);

      this.tweens.add({
        targets: trail,
        alpha: 0,
        scaleX: 0.5,
        scaleY: 0.5,
        duration: 400,
        delay: i * 30,
        onComplete: () => trail.destroy()
      });
    }

    // 5. Î±Ä Î≥µÏ†úÎ≥∏ ÏÉùÏÑ± (ÎÅåÎ†§Í∞à Ïö©ÎèÑ)
    const snakeCopy = [];
    this.snake.forEach((segment, index) => {
      const segX = segment.x * this.gridSize + this.gridSize / 2;
      const segY = segment.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
      const isHead = index === 0;

      const copy = this.add.circle(segX, segY, this.gridSize / 2 - 2, isHead ? 0x00aa00 : 0x00ff00, 1)
        .setDepth(6400);
      snakeCopy.push({ element: copy, startX: segX, startY: segY });
    });

    // ÏõêÎ≥∏ Î±Ä Ïà®Í∏∞Í∏∞ (graphics Í∞ùÏ≤¥Î°ú Í∑∏Î†§Ïßê!)
    if (this.graphics) {
      this.graphics.clear();
      this.graphics.setAlpha(0);
    }

    // 6. Î≥¥Ïä§ Îπ†Î•¥Í≤å ÏßÄÎÇòÍ∞ê (Î±Ä ÏúÑÏπòÍπåÏßÄ) - Í∑∏Î¶¨Í≥† Î±ÄÏùÑ ÎÇöÏïÑÏ±ÑÎ©∞ Í≥ÑÏÜç Ïù¥Îèô
    let snakeCaught = false;

    this.tweens.add({
      targets: passingBoss,
      x: endX,
      y: endY,
      duration: 200,
      ease: 'Power2.easeIn',
      onUpdate: () => {
        // ÏßÄÎÇòÍ∞ÄÎ©¥ÏÑú Îàà Ìä∏Î†àÏùº (ÎèôÏùº)
        if (Math.random() < 0.5) {
          const eyeTrail = this.add.circle(
            passingBoss.x + Phaser.Math.Between(-15, 15),
            passingBoss.y - 10,
            3, 0xff0000, 0.6
          ).setDepth(6400).setBlendMode(Phaser.BlendModes.ADD);

          this.tweens.add({
            targets: eyeTrail,
            alpha: 0,
            scaleX: 0.3,
            scaleY: 0.3,
            duration: 150,
            onComplete: () => eyeTrail.destroy()
          });
        }

        // Î≥¥Ïä§Í∞Ä Î±Ä ÏúÑÏπòÏóê ÎèÑÎã¨ÌïòÎ©¥ Î±ÄÏùÑ ÎÇöÏïÑÏ±î!
        const distToSnake = Math.sqrt(
          Math.pow(passingBoss.x - headX, 2) + Math.pow(passingBoss.y - headY, 2)
        );

        if (!snakeCaught && distToSnake < 30) {
          snakeCaught = true;

          // Î±ÄÏù¥ Î≥¥Ïä§Ïóê Î∂ôÏñ¥ÏÑú Ìï®Íªò ÎÅåÎ†§Í∞ê
          snakeCopy.forEach((copyData, idx) => {
            const offsetX = copyData.startX - headX;
            const offsetY = copyData.startY - headY;

            // Î≥¥Ïä§ÏôÄ Ìï®Íªò Ïñ¥Îë† ÏÜçÏúºÎ°ú ÎÅåÎ†§Í∞ê
            this.tweens.add({
              targets: copyData.element,
              x: endX + offsetX * 0.3,
              y: endY + offsetY * 0.3,
              alpha: 0,
              scaleX: 0.1,
              scaleY: 0.1,
              duration: 150,
              delay: idx * 10,
              ease: 'Power2.easeIn',
              onComplete: () => copyData.element.destroy()
            });
          });
        }
      },
      onComplete: () => {
        passingBoss.destroy();
      }
    });

    // 7. Ïä¨Î°úÏö∞Î™®ÏÖò ÎÅùÎÇòÍ≥† "Delicious..." ÌëúÏãú (ÏïàÍ∞úÎäî Í∑∏ÎåÄÎ°ú!)
    this.time.delayedCall(400, () => {
      // ÏãúÍ∞Ñ Î≥µÍµ¨
      this.time.timeScale = 1;
      this.tweens.timeScale = 1;

      // Ïû†Ïãú ÌõÑ "Delicious..." (ÏïàÍ∞ú ÏúÑÏóê ÌëúÏãú - depth 5000)
      this.time.delayedCall(800, () => {
        const deliciousText = this.add.text(width / 2, height / 2, 'Delicious...', {
          fontSize: '32px',
          fill: '#cc3333',
          fontStyle: 'italic',
          stroke: '#000000',
          strokeThickness: 3
        }).setOrigin(0.5).setDepth(5000).setAlpha(0);

        this.tweens.add({
          targets: deliciousText,
          alpha: 1,
          duration: 400
        });

        // 1Ï¥à ÌõÑ Í≤åÏûÑ Ïò§Î≤Ñ
        this.time.delayedCall(1200, () => {
          this.tweens.add({
            targets: deliciousText,
            alpha: 0,
            duration: 300,
            onComplete: () => {
              deliciousText.destroy();
              this.cleanupPresenceSystem();
              this.showGameOverScreen();
            }
          });
        });
      });
    });
  }

  // Presence ÏãúÏä§ÌÖú Ï†ïÎ¶¨
  cleanupPresenceSystem() {
    this.presenceActive = false;
    this.stalkingActive = false;
    this.presenceLevel = 0;
    this.dodgeWindowActive = false;

    if (this.presenceTimer) {
      this.presenceTimer.destroy();
      this.presenceTimer = null;
    }
    if (this.presencePulseTimer) {
      this.presencePulseTimer.destroy();
      this.presencePulseTimer = null;
    }
    if (this.dodgeWindowTimer) {
      this.dodgeWindowTimer.destroy();
      this.dodgeWindowTimer = null;
    }

    // Î∏åÎùºÏö∞Ï†Ä Ïñ¥Îë† Ï†úÍ±∞
    this.removeBrowserDarkness();

    // Í∏∞Ï°¥ Ïä§ÌÜ†ÌÇπ ÏãúÏä§ÌÖúÎèÑ Ï†ïÎ¶¨
    this.cleanupStalkingSystem();
  }

  // üÜï Ïä§ÌÜ†ÌÇπ ÌéòÏù¥Ï¶à ÏãúÏûë (Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ - The Presence ÏãúÏä§ÌÖúÏóêÏÑú Ìò∏Ï∂ú)
  startStalkingPhase() {
    // The PresenceÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨ÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Îàà Ïä§ÏºÄÏ§ÑÎßå
    this.stalkingActive = true;
  }

  // üÜï Rage Mode ÏãúÏûë (HIT 3 Î∂ÑÎÖ∏ Î™®Îìú)
  startRageMode() {
    this.rageModeActive = true;

    const { width, height } = this.cameras.main;

    // Rage ÏãúÏûë Ïó∞Ï∂ú
    this.showRageModeIntro();

    // ÌôîÎ©¥ ÍπúÎπ°ÏûÑ Ìö®Í≥º (ÏßÄÏÜçÏ†Å)
    this.rageFlickerTimer = this.time.addEvent({
      delay: Phaser.Math.Between(400, 800),
      callback: () => {
        if (!this.rageModeActive || this.gameOver) return;

        // ÎûúÎç§ÌïòÍ≤å ÌôîÎ©¥ ÍπúÎπ°ÏûÑ
        const flicker = this.add.rectangle(0, 0, width, height, 0xff0000, 0.15)
          .setOrigin(0, 0).setDepth(2998);

        this.tweens.add({
          targets: flicker,
          alpha: 0,
          duration: 100,
          onComplete: () => flicker.destroy()
        });

        // Îã§Ïùå ÍπúÎπ°ÏûÑ Ïä§ÏºÄÏ§Ñ (Î∂àÍ∑úÏπôÌïòÍ≤å)
        if (this.rageFlickerTimer) {
          this.rageFlickerTimer.delay = Phaser.Math.Between(300, 700);
        }
      },
      loop: true
    });

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º ÌÉÄÏù¥Î®∏
    this.rageGlitchTimer = this.time.addEvent({
      delay: Phaser.Math.Between(2000, 4000),
      callback: () => {
        if (!this.rageModeActive || this.gameOver) return;
        this.showRageGlitch();
      },
      loop: true
    });
  }

  // üÜï Rage Mode Ïù∏Ìä∏Î°ú Ïó∞Ï∂ú
  showRageModeIntro() {
    const { width, height } = this.cameras.main;

    // Í∞ïÎ†•Ìïú ÌôîÎ©¥ ÌîåÎûòÏãú
    const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.6)
      .setOrigin(0, 0).setDepth(5000);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 500,
      onComplete: () => flash.destroy()
    });

    // "RAGE MODE" ÌÖçÏä§Ìä∏
    const rageText = this.add.text(width / 2, height / 2, 'RAGE MODE', {
      fontSize: '48px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#ffff00',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5001).setAlpha(0);

    // ÌÖçÏä§Ìä∏ ÌùîÎì§Î¶º Ìö®Í≥º
    this.tweens.add({
      targets: rageText,
      alpha: 1,
      scaleX: { from: 0.5, to: 1.2 },
      scaleY: { from: 0.5, to: 1.2 },
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÌùîÎì§Î¶º
        this.tweens.add({
          targets: rageText,
          x: width / 2 + Phaser.Math.Between(-10, 10),
          y: height / 2 + Phaser.Math.Between(-5, 5),
          duration: 50,
          repeat: 10,
          yoyo: true
        });

        // ÌéòÏù¥ÎìúÏïÑÏõÉ
        this.time.delayedCall(800, () => {
          this.tweens.add({
            targets: rageText,
            alpha: 0,
            scaleX: 1.5,
            scaleY: 1.5,
            duration: 300,
            onComplete: () => rageText.destroy()
          });
        });
      }
    });

    // Ïπ¥Î©îÎùº Í∞ïÌïú ÌùîÎì§Î¶º
    this.cameras.main.shake(800, 0.05);
  }

  // üÜï Rage Í∏ÄÎ¶¨Ïπò Ìö®Í≥º
  showRageGlitch() {
    const { width, height } = this.cameras.main;

    // ÌôîÎ©¥ ÏùºÎ∂Ä ÏûòÎ†§ÏÑú Ïù¥ÎèôÌïòÎäî Ìö®Í≥º
    const numSlices = Phaser.Math.Between(3, 6);
    for (let i = 0; i < numSlices; i++) {
      const sliceY = Phaser.Math.Between(0, height);
      const sliceHeight = Phaser.Math.Between(5, 30);
      const sliceOffset = Phaser.Math.Between(-20, 20);

      const slice = this.add.rectangle(sliceOffset, sliceY, width, sliceHeight, 0xff0000, 0.3)
        .setOrigin(0, 0).setDepth(2997);

      this.tweens.add({
        targets: slice,
        x: Phaser.Math.Between(-30, 30),
        alpha: 0,
        duration: 150,
        delay: i * 30,
        onComplete: () => slice.destroy()
      });
    }

    // ÎûúÎç§ ÏÜçÏÇ≠ÏûÑ (Î∂ÑÎÖ∏ Î≤ÑÏ†Ñ)
    if (Math.random() < 0.5) {
      const whisper = Phaser.Math.RND.pick(this.rageWhisperTexts);
      const whisperText = this.add.text(
        Phaser.Math.Between(50, width - 50),
        Phaser.Math.Between(100, height - 100),
        whisper,
        {
          fontSize: '24px',
          fill: '#ff0000',
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 3
        }
      ).setOrigin(0.5).setDepth(3002).setAlpha(0);

      this.tweens.add({
        targets: whisperText,
        alpha: 0.8,
        duration: 100,
        onComplete: () => {
          this.tweens.add({
            targets: whisperText,
            alpha: 0,
            y: whisperText.y - 20,
            duration: 400,
            onComplete: () => whisperText.destroy()
          });
        }
      });
    }

    // Îã§Ïùå Í∏ÄÎ¶¨Ïπò Ïä§ÏºÄÏ§Ñ (Î∂àÍ∑úÏπô)
    if (this.rageGlitchTimer) {
      this.rageGlitchTimer.delay = Phaser.Math.Between(1500, 3500);
    }
  }

  // üÜï Rage Mode Ï†ïÎ¶¨
  cleanupRageMode() {
    this.rageModeActive = false;

    if (this.rageFlickerTimer) {
      this.rageFlickerTimer.destroy();
      this.rageFlickerTimer = null;
    }
    if (this.rageGlitchTimer) {
      this.rageGlitchTimer.destroy();
      this.rageGlitchTimer = null;
    }
  }

  // üÜï ÌéòÏù¥Ï¶à Ïù∏Ìä∏Î°ú Ïó∞Ï∂ú (HIT ÏàòÏóê Îî∞Îùº Îã§Î•∏ Ïó∞Ï∂ú)
  showPhaseIntro() {
    const { width, height } = this.cameras.main;
    const hitCount = this.fogBossHitCount;

    // HIT ÏàòÏóê Îî∞Î•∏ Î≥¥Ïä§ ÎåÄÏÇ¨
    const dialogues = [
      { text: "I see you...", color: '#880000' },                    // 0 HIT
      { text: "You got lucky... NOT AGAIN!", color: '#aa0000' },     // 1 HIT
      { text: "NOW I'M ANGRY!", color: '#cc0000' },                  // 2 HIT
      { text: "YOU WILL NOT ESCAPE!!!", color: '#ff0000' }           // 3 HIT
    ];

    const dialogue = dialogues[Math.min(hitCount, 3)];

    // Î≥¥Ïä§ ÎåÄÏÇ¨ ÌëúÏãú
    const text = this.add.text(width / 2, height / 2, dialogue.text, {
      fontSize: `${24 + hitCount * 6}px`,
      fill: dialogue.color,
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    const fullText = dialogue.text;
    text.setText('');
    let charIndex = 0;

    this.time.addEvent({
      delay: 50 - hitCount * 10,
      callback: () => {
        if (charIndex < fullText.length) {
          text.setText(fullText.substring(0, charIndex + 1));
          charIndex++;
          // Ïπ¥Î©îÎùº ÏÇ¥Ïßù ÌùîÎì§Í∏∞
          if (hitCount >= 2) {
            this.cameras.main.shake(50, 0.005);
          }
        }
      },
      repeat: fullText.length - 1
    });

    this.tweens.add({
      targets: text,
      alpha: 1,
      duration: 200
    });

    // HIT 2+ : ÌôîÎ©¥ Îπ®Í∞Ñ ÌîåÎûòÏãú
    if (hitCount >= 2) {
      const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.3)
        .setOrigin(0, 0).setDepth(4999);
      this.tweens.add({
        targets: flash,
        alpha: 0,
        duration: 500,
        onComplete: () => flash.destroy()
      });
    }

    // HIT 3 : Î≥¥Ïä§ Î∂ÑÎÖ∏ Ìö®Í≥º - ÌôîÎ©¥ Îñ®Î¶º + Í≤ÄÏùÄ ÏÑ† Ìö®Í≥º
    if (hitCount >= 3) {
      this.cameras.main.shake(800, 0.02);

      // ÌôîÎ©¥Ïóê Îπ†Î•¥Í≤å Ïä§Ï≥êÍ∞ÄÎäî Í≤ÄÏùÄ ÏÑ†Îì§
      for (let i = 0; i < 5; i++) {
        this.time.delayedCall(i * 100, () => {
          const line = this.add.rectangle(
            Phaser.Math.Between(0, width),
            0, 3, height, 0x000000, 0.7
          ).setOrigin(0, 0).setDepth(5001);

          this.tweens.add({
            targets: line,
            x: line.x + Phaser.Math.Between(-100, 100),
            alpha: 0,
            duration: 200,
            onComplete: () => line.destroy()
          });
        });
      }
    }

    // ÎåÄÏÇ¨ ÏÇ¨ÎùºÏßê
    this.time.delayedCall(1500, () => {
      this.tweens.add({
        targets: text,
        alpha: 0,
        y: height / 2 - 30,
        duration: 300,
        onComplete: () => text.destroy()
      });
    });
  }

  // üÜï Îπ®Í∞Ñ ÎπÑÎÑ§Ìä∏ Ïò§Î≤ÑÎ†àÏù¥ ÏÉùÏÑ±
  createVignetteOverlay() {
    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ ÎπÑÎÑ§Ìä∏ Ï†úÍ±∞
    if (this.vignetteOverlay) {
      this.vignetteOverlay.destroy();
    }

    // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎπÑÎÑ§Ìä∏ Ìö®Í≥º (Í∞ÄÏû•ÏûêÎ¶¨Í∞Ä Îπ®Í∞ÑÏÉâ)
    this.vignetteOverlay = this.add.graphics().setDepth(3000);
    this.updateVignetteIntensity(0);
  }

  // üÜï ÎπÑÎÑ§Ìä∏ Í∞ïÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ (ÏïÑÏ£º ÎØ∏ÏÑ∏ÌïòÍ≤å)
  updateVignetteIntensity(intensity) {
    if (!this.vignetteOverlay) return;

    const { width, height } = this.cameras.main;
    this.vignetteOverlay.clear();

    // Í∏¥Ïû•ÎèÑÏóê Îî∞Îùº ÎπÑÎÑ§Ìä∏ Í∞ïÎèÑ Ï°∞Ï†à (Îß§Ïö∞ ÏïΩÌïòÍ≤å)
    // ÏµúÎåÄ alphaÎ•º 0.15Î°ú Ï†úÌïú (Í∏∞Ï°¥ 0.4ÏóêÏÑú ÎåÄÌè≠ Í∞êÏÜå)
    const alpha = Math.min(intensity / 100 * 0.15, 0.15);

    // ÌÖåÎëêÎ¶¨Îßå ÏÇ¥Ïßù Îπ®Í∞õÍ≤å (ÎëêÍªòÎèÑ Ï§ÑÏûÑ)
    const borderWidth = 5 + intensity * 0.1;
    this.vignetteOverlay.lineStyle(borderWidth, 0xff0000, alpha);
    this.vignetteOverlay.strokeRect(0, 0, width, height);

    // Í∏¥Ïû•ÎèÑ ÎÜíÏùÑ ÎïåÎßå Îëê Î≤àÏß∏ ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä
    if (intensity > 50) {
      const innerAlpha = alpha * 0.5;
      this.vignetteOverlay.lineStyle(borderWidth * 0.5, 0xff0000, innerAlpha);
      this.vignetteOverlay.strokeRect(borderWidth, borderWidth, width - borderWidth * 2, height - borderWidth * 2);
    }
  }

  // üÜï Ïä§ÌÜ†ÌÇπ Îàà Ïä§ÏºÄÏ§ÑÎßÅ (HIT ÏàòÏóê Îî∞Îùº Îçî ÎπàÎ≤àÌïòÍ≤å)
  scheduleStalkingEyes() {
    if (!this.stalkingActive || this.gameOver) return;

    const hitCount = this.fogBossHitCount;

    // HIT ÏàòÏóê Îî∞Îùº Í∏∞Î≥∏ ÎîúÎ†àÏù¥ Í∞êÏÜå (Îçî Îπ†Î•¥Í≤å ÎÇòÌÉÄÎÇ®)
    // 0 HIT: 3000ms Í∏∞Ï§Ä, 3 HIT: 1500ms Í∏∞Ï§Ä
    const hitBonus = hitCount * 500;
    const baseDelay = Math.max(1500, 3000 - hitBonus - this.stalkingIntensity * 20);
    const minDelay = Math.max(600, 800 - hitCount * 100);
    const delay = Math.max(Phaser.Math.Between(baseDelay - 500, baseDelay + 500), minDelay);

    this.stalkingTimer = this.time.delayedCall(delay, () => {
      if (this.stalkingActive && !this.gameOver) {
        this.showStalkingEyes();
      }
    });
  }

  // üÜï Ïä§ÌÜ†ÌÇπ Îàà ÌëúÏãú (ÏïàÍ∞ú ÏÜçÏóêÏÑú Î≤àÏ©çÏù¥Îäî Îπ®Í∞Ñ Îàà - HIT ÏàòÏóê Îî∞Îùº Îàà Í∞úÏàò Ï¶ùÍ∞Ä)
  showStalkingEyes() {
    if (!this.stalkingActive || this.gameOver) return;

    const head = this.snake[0];
    const hitCount = this.fogBossHitCount;

    // HIT ÏàòÏóê Îî∞Îùº Îàà Í∞úÏàò Ï¶ùÍ∞Ä (0 HIT: 1Í∞ú, 1 HIT: 2Í∞ú, 2 HIT: 3Í∞ú, 3 HIT: 4Í∞ú)
    const eyeCount = 1 + hitCount;

    // HIT ÏàòÏóê Îî∞Îùº ÎààÏù¥ Îçî Í∞ÄÍπùÍ≤å ÎÇòÌÉÄÎÇ®
    const minDistance = Math.max(4, 6 - hitCount);
    const maxDistance = Math.max(6, 10 - hitCount);

    const allEyeContainers = [];

    for (let i = 0; i < eyeCount; i++) {
      // Îàà ÏúÑÏπò Í≥ÑÏÇ∞ (ÏÑúÎ°ú Í≤πÏπòÏßÄ ÏïäÍ≤å Î∂ÑÏÇ∞)
      const angleOffset = (Math.PI * 2 / eyeCount) * i + Math.random() * 0.5;
      const distance = Phaser.Math.Between(minDistance, maxDistance);
      let eyeX = head.x + Math.cos(angleOffset) * distance;
      let eyeY = head.y + Math.sin(angleOffset) * distance;

      // Îßµ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
      eyeX = Phaser.Math.Clamp(eyeX, 2, this.cols - 3);
      eyeY = Phaser.Math.Clamp(eyeY, 2, this.rows - 3);

      if (i === 0) {
        this.lastStalkingEyePos = { x: eyeX, y: eyeY };
      }

      const pixelX = eyeX * this.gridSize + this.gridSize / 2;
      const pixelY = eyeY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      // HIT ÏàòÏóê Îî∞Îùº Îàà ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
      const eyeScale = 1 + hitCount * 0.15;

      // Îàà Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
      const eyeContainer = this.add.container(pixelX, pixelY).setDepth(160).setAlpha(0).setScale(eyeScale);

      // Îàà Í∏ÄÎ°úÏö∞ (HIT ÏàòÏóê Îî∞Îùº Îçî Î∞ùÏïÑÏßê)
      const glowAlpha = 0.3 + hitCount * 0.1;
      const eyeGlow = this.add.circle(0, 0, 15, 0xff0000, glowAlpha);
      const leftEye = this.add.circle(-8, 0, 5, 0xff0000, 1);
      const rightEye = this.add.circle(8, 0, 5, 0xff0000, 1);

      // ÎèôÍ≥µ (ÏÑ∏Î°úÎ°ú Í∏¥ Í≥†ÏñëÏù¥ Îàà)
      const leftPupil = this.add.ellipse(-8, 0, 2, 5, 0x000000, 1);
      const rightPupil = this.add.ellipse(8, 0, 2, 5, 0x000000, 1);

      eyeContainer.add([eyeGlow, leftEye, rightEye, leftPupil, rightPupil]);

      // Î±Ä Î∞©Ìñ• Ï≥êÎã§Î≥¥Í∏∞
      const lookAngle = Phaser.Math.Angle.Between(eyeX, eyeY, head.x, head.y);
      const lookOffset = 2;
      leftPupil.x = -8 + Math.cos(lookAngle) * lookOffset;
      leftPupil.y = Math.sin(lookAngle) * lookOffset;
      rightPupil.x = 8 + Math.cos(lookAngle) * lookOffset;
      rightPupil.y = Math.sin(lookAngle) * lookOffset;

      allEyeContainers.push({ container: eyeContainer, leftPupil, rightPupil, eyeX, eyeY });

      // ÌéòÏù¥ÎìúÏù∏ (ÏãúÍ∞ÑÏ∞® Ï†ÅÏö©)
      this.tweens.add({
        targets: eyeContainer,
        alpha: 1,
        duration: 150,
        delay: i * 80  // ÏãúÍ∞ÑÏ∞®Î°ú ÌïòÎÇòÏî© ÎÇòÌÉÄÎÇ®
      });
    }

    // Î™®Îì† ÎààÏù¥ ÎÇòÌÉÄÎÇú ÌõÑ Ìö®Í≥º
    this.time.delayedCall(eyeCount * 80 + 200, () => {
      // ÎààÎì§Ïù¥ Î±ÄÏùÑ Îî∞ÎùºÍ∞ÄÎäî Ìö®Í≥º
      allEyeContainers.forEach(({ leftPupil, rightPupil, eyeX, eyeY }) => {
        this.tweens.add({
          targets: [leftPupil, rightPupil],
          x: (target) => {
            const baseX = target === leftPupil ? -8 : 8;
            const newAngle = Phaser.Math.Angle.Between(eyeX, eyeY, this.snake[0].x, this.snake[0].y);
            return baseX + Math.cos(newAngle) * 2;
          },
          y: () => {
            const newAngle = Phaser.Math.Angle.Between(eyeX, eyeY, this.snake[0].x, this.snake[0].y);
            return Math.sin(newAngle) * 2;
          },
          duration: 400
        });
      });

      // Í∏¥Ïû•ÎèÑ ÎÜíÏúºÎ©¥ ÏÜçÏÇ≠ÏûÑ ÌÖçÏä§Ìä∏ Ï∂îÍ∞Ä (HIT ÎÜíÏùÑÏàòÎ°ù ÌôïÎ•† Ï¶ùÍ∞Ä)
      const whisperChance = 0.3 + hitCount * 0.15;
      if (this.stalkingIntensity > 30 && Math.random() < whisperChance) {
        this.showWhisperText();
      }

      // HIT 3+ : ÎààÎì§Ïù¥ Îπ†Î•¥Í≤å ÍπúÎπ°Ïù¥Îäî Ìö®Í≥º
      if (hitCount >= 3) {
        allEyeContainers.forEach(({ container }, idx) => {
          this.tweens.add({
            targets: container,
            alpha: { from: 1, to: 0.3 },
            duration: 80,
            yoyo: true,
            repeat: 3,
            delay: idx * 50
          });
        });
      }

      // ÌéòÏù¥ÎìúÏïÑÏõÉ (HIT ÎÜíÏùÑÏàòÎ°ù Ïò§Îûò Ïú†ÏßÄ)
      const displayTime = 600 + hitCount * 150;
      this.time.delayedCall(displayTime, () => {
        let destroyedCount = 0;
        allEyeContainers.forEach(({ container }, idx) => {
          this.tweens.add({
            targets: container,
            alpha: 0,
            duration: 200,
            delay: idx * 50,
            onComplete: () => {
              container.destroy();
              destroyedCount++;

              // Î™®Îì† ÎààÏù¥ ÏÇ¨ÎùºÏßÑ ÌõÑ Îã§Ïùå Îã®Í≥Ñ
              if (destroyedCount === allEyeContainers.length) {
                // Í∏¥Ïû•ÎèÑÍ∞Ä Ï∂©Î∂ÑÌûà ÎÜíÏúºÎ©¥ Ï†êÌîÑ Ïä§ÏºÄÏñ¥ ÌôïÎ•† Ï≤¥ÌÅ¨
                // HIT ÏàòÏóê Îî∞Îùº ÌïÑÏöîÌïú Í∏¥Ïû•ÎèÑ Í∞êÏÜå (Îçî Îπ®Î¶¨ Í≥µÍ≤©)
                const requiredTension = Math.max(50, 70 - hitCount * 10);
                if (this.stalkingIntensity >= requiredTension) {
                  this.checkJumpScareOrContinue();
                } else {
                  this.scheduleStalkingEyes();
                }
              }
            }
          });
        });
      });
    });

    // Ïπ¥Î©îÎùº ÎØ∏ÏÑ∏ ÌùîÎì§Î¶º (HIT ÏàòÏóê ÎπÑÎ°ÄÌï¥ÏÑú Îçî Í∞ïÌïòÍ≤å)
    const shakeIntensity = 0.002 + this.stalkingIntensity * 0.0001 + hitCount * 0.003;
    if (this.stalkingIntensity > 40 || hitCount >= 2) {
      this.cameras.main.shake(100 + hitCount * 50, shakeIntensity);
    }
  }

  // üÜï ÏÜçÏÇ≠ÏûÑ ÌÖçÏä§Ìä∏ ÌëúÏãú
  showWhisperText() {
    const { width, height } = this.cameras.main;

    const text = this.whisperTexts[this.currentWhisperIndex];
    this.currentWhisperIndex = (this.currentWhisperIndex + 1) % this.whisperTexts.length;

    // ÎûúÎç§ ÏúÑÏπò (ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨)
    const positions = [
      { x: Phaser.Math.Between(50, 150), y: Phaser.Math.Between(100, height - 100) },
      { x: Phaser.Math.Between(width - 150, width - 50), y: Phaser.Math.Between(100, height - 100) },
      { x: Phaser.Math.Between(100, width - 100), y: Phaser.Math.Between(70, 120) },
      { x: Phaser.Math.Between(100, width - 100), y: Phaser.Math.Between(height - 120, height - 70) }
    ];
    const pos = Phaser.Math.RND.pick(positions);

    const whisper = this.add.text(pos.x, pos.y, text, {
      fontSize: '16px',
      fill: '#880000',
      fontStyle: 'italic',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(3001).setAlpha(0);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    whisper.setText('');
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 80,
      callback: () => {
        if (charIndex < text.length) {
          whisper.setText(text.substring(0, charIndex + 1));
          charIndex++;
        }
      },
      repeat: text.length - 1
    });

    // ÌéòÏù¥ÎìúÏù∏
    this.tweens.add({
      targets: whisper,
      alpha: 0.7,
      duration: 300
    });

    // ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.time.delayedCall(2000, () => {
      this.tweens.add({
        targets: whisper,
        alpha: 0,
        duration: 500,
        onComplete: () => whisper.destroy()
      });
    });
  }

  // üÜï Í∏¥Ïû•ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
  updateStalkingIntensity() {
    if (!this.stalkingActive || this.gameOver) return;

    // Í∏¥Ïû•ÎèÑ Ï†êÏßÑÏ†Å Ï¶ùÍ∞Ä
    this.stalkingIntensity = Math.min(this.stalkingIntensity + 5, 100);

    // ÎπÑÎÑ§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
    this.updateVignetteIntensity(this.stalkingIntensity);

    // Í∏¥Ïû•ÎèÑ 50 Ïù¥ÏÉÅÏù¥Î©¥ Ïã¨Ïû•Î∞ïÎèô Ìö®Í≥º ÏãúÏûë
    if (this.stalkingIntensity >= 50 && !this.heartbeatTimer) {
      this.startHeartbeatEffect();
    }

    // Í∏¥Ïû•ÎèÑ ÎÜíÏùÑÏàòÎ°ù ÏïàÍ∞ú ÏßôÏñ¥Ïßê
    if (this.stalkingIntensity >= 60) {
      this.fogVisibleTiles = Math.max(2.0, this.originalFogVisibleTiles - this.stalkingIntensity * 0.02);
    }
  }

  // üÜï Ïã¨Ïû•Î∞ïÎèô Ìö®Í≥º
  startHeartbeatEffect() {
    if (this.heartbeatTimer) return;

    const { width, height } = this.cameras.main;

    this.heartbeatTimer = this.time.addEvent({
      delay: 800 - this.stalkingIntensity * 3, // Í∏¥Ïû•ÎèÑ ÎÜíÏùÑÏàòÎ°ù Îπ†Î¶Ñ
      callback: () => {
        if (!this.stalkingActive || this.gameOver) {
          this.heartbeatTimer.destroy();
          this.heartbeatTimer = null;
          return;
        }

        // ÌôîÎ©¥ ÌéÑÏä§ Ìö®Í≥º
        const pulse = this.add.rectangle(0, 0, width, height, 0x330000, 0)
          .setOrigin(0, 0)
          .setDepth(2999);

        this.tweens.add({
          targets: pulse,
          alpha: { from: 0, to: 0.15 },
          duration: 100,
          yoyo: true,
          onComplete: () => pulse.destroy()
        });

        // Ïπ¥Î©îÎùº ÏÇ¥Ïßù Ï§å
        this.tweens.add({
          targets: this.cameras.main,
          zoom: 1.02,
          duration: 100,
          yoyo: true
        });
      },
      loop: true
    });
  }

  // üÜï Ï†êÌîÑ Ïä§ÏºÄÏñ¥ ÎòêÎäî Í≥ÑÏÜç Ïä§ÌÜ†ÌÇπ Í≤∞Ï†ï (HIT ÏàòÏóê Îî∞Îùº Îã§Î•∏ ÌñâÎèô)
  checkJumpScareOrContinue() {
    if (!this.stalkingActive || this.gameOver) return;

    const hitCount = this.fogBossHitCount;

    // HIT ÏàòÏóê Îî∞Îùº Í∞ÄÏßú Îì±Ïû• ÌôïÎ•† Í∞êÏÜå (Îçî Í≥µÍ≤©Ï†ÅÏúºÎ°ú)
    const adjustedFakeOutChance = Math.max(0.1, this.fakeOutChance - hitCount * 0.1);

    // Í∞ÄÏßú Îì±Ïû• ÌôïÎ•† Ï≤¥ÌÅ¨
    if (Math.random() < adjustedFakeOutChance) {
      this.executeFakeOut();
    } else {
      // HIT 2+ : ÏΩ§Î≥¥ Í≥µÍ≤© ÏãúÏûë (Ïó∞ÏÜç Í≥µÍ≤©)
      if (hitCount >= 2 && !this.comboAttackActive) {
        this.startComboAttack();
      } else {
        // ÏßÑÏßú Ï†êÌîÑ Ïä§ÏºÄÏñ¥!
        this.executeJumpScare();
      }
    }
  }

  // üÜï ÏΩ§Î≥¥ Í≥µÍ≤© ÏãúÏûë (HIT 2+ Ïó∞ÏÜç Í≥µÍ≤©)
  startComboAttack() {
    const hitCount = this.fogBossHitCount;
    this.comboAttackActive = true;
    this.comboAttackCount = 0;

    // HIT ÏàòÏóê Îî∞Îùº ÏΩ§Î≥¥ ÌöüÏàò Í≤∞Ï†ï (2 HIT: 2Ïó∞ÏÜç, 3 HIT: 3Ïó∞ÏÜç)
    this.maxComboAttacks = Math.min(hitCount, 3);

    // ÏΩ§Î≥¥ Í≤ΩÍ≥† ÌëúÏãú
    this.showComboWarning();
  }

  // üÜï ÏΩ§Î≥¥ Í≤ΩÍ≥† ÌëúÏãú
  showComboWarning() {
    const { width, height } = this.cameras.main;
    const hitCount = this.fogBossHitCount;

    // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const warningTexts = [
      '', '',
      'DOUBLE STRIKE!', // 2 HIT
      'TRIPLE FURY!!'   // 3 HIT
    ];
    const warningText = this.add.text(width / 2, height / 2, warningTexts[hitCount] || 'COMBO!', {
      fontSize: '36px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 5
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    // Ï§åÏù∏ Ìö®Í≥º
    warningText.setScale(0.5);
    this.tweens.add({
      targets: warningText,
      alpha: 1,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 200,
      onComplete: () => {
        this.tweens.add({
          targets: warningText,
          alpha: 0,
          y: height / 2 - 50,
          duration: 300,
          delay: 300,
          onComplete: () => {
            warningText.destroy();
            // Ï≤´ Î≤àÏß∏ ÏΩ§Î≥¥ Í≥µÍ≤© Ïã§Ìñâ
            this.executeComboAttack();
          }
        });
      }
    });

    // ÌôîÎ©¥ Î∂âÏùÄ ÌîåÎûòÏãú
    const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.3)
      .setOrigin(0, 0).setDepth(4999);
    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 400,
      onComplete: () => flash.destroy()
    });

    // Í∞ïÌïú Ïπ¥Î©îÎùº ÌùîÎì§Í∏∞
    this.cameras.main.shake(400, 0.04);
  }

  // üÜï ÏΩ§Î≥¥ Í≥µÍ≤© Ïã§Ìñâ (Ïó∞ÏÜç Ï†êÌîÑ Ïä§ÏºÄÏñ¥)
  executeComboAttack() {
    if (this.gameOver) {
      this.comboAttackActive = false;
      return;
    }

    this.comboAttackCount++;

    // ÏΩ§Î≥¥ Ïπ¥Ïö¥Ìä∏ ÌëúÏãú
    const { width, height } = this.cameras.main;
    const countText = this.add.text(width / 2, 80, `COMBO ${this.comboAttackCount}/${this.maxComboAttacks}`, {
      fontSize: '24px',
      fill: '#ffaa00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(5000);

    this.tweens.add({
      targets: countText,
      alpha: 0,
      y: 60,
      duration: 500,
      delay: 500,
      onComplete: () => countText.destroy()
    });

    // Ï†êÌîÑ Ïä§ÏºÄÏñ¥ Ïã§Ìñâ (ÏΩ§Î≥¥ Î™®Îìú)
    this.executeJumpScare(true);
  }

  // üÜï ÏΩ§Î≥¥ Í≥µÍ≤© Îã§Ïùå Îã®Í≥Ñ
  continueComboOrEnd() {
    if (this.comboAttackCount < this.maxComboAttacks) {
      // Îã§Ïùå ÏΩ§Î≥¥ÍπåÏßÄ ÏßßÏùÄ ÎåÄÍ∏∞
      this.time.delayedCall(400, () => {
        if (!this.gameOver) {
          this.executeComboAttack();
        }
      });
    } else {
      // ÏΩ§Î≥¥ ÏôÑÎ£å - Ïä§ÌÜ†ÌÇπÏúºÎ°ú Î≥µÍ∑Ä
      this.comboAttackActive = false;
      this.comboAttackCount = 0;

      // ÏΩ§Î≥¥ ÏôÑÎ£å Ìö®Í≥º
      this.showComboEndEffect();

      this.time.delayedCall(800, () => {
        if (!this.gameOver) {
          this.stalkingIntensity = 30;
          this.startStalkingPhase();
        }
      });
    }
  }

  // üÜï ÏΩ§Î≥¥ ÏôÑÎ£å Ìö®Í≥º
  showComboEndEffect() {
    const { width, height } = this.cameras.main;

    const endText = this.add.text(width / 2, height / 2, 'SURVIVED!', {
      fontSize: '28px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#003300',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    this.tweens.add({
      targets: endText,
      alpha: 1,
      scaleX: { from: 0.5, to: 1 },
      scaleY: { from: 0.5, to: 1 },
      duration: 200,
      onComplete: () => {
        this.tweens.add({
          targets: endText,
          alpha: 0,
          duration: 400,
          delay: 500,
          onComplete: () => endText.destroy()
        });
      }
    });
  }

  // üÜï Í∞ÄÏßú Îì±Ïû• (ÎÜÄÎûòÌÇ§Í≥† ÏÇ¨ÎùºÏßê)
  executeFakeOut() {
    const head = this.snake[0];
    const { width, height } = this.cameras.main;

    // Î±Ä Î∞îÎ°ú ÏïûÏóê Í∞ëÏûêÍ∏∞ Î≥¥Ïä§ ÏñºÍµ¥ Îì±Ïû•
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Î∞©Ìñ•Ïóê Îî∞Îùº ÏïûÏ™Ω ÏúÑÏπò Í≥ÑÏÇ∞
    let fakeX = headX;
    let fakeY = headY;
    const offset = this.gridSize * 3;

    switch (this.direction) {
      case 'UP': fakeY -= offset; break;
      case 'DOWN': fakeY += offset; break;
      case 'LEFT': fakeX -= offset; break;
      case 'RIGHT': fakeX += offset; break;
    }

    // Í∞ëÏûêÍ∏∞ ÎÇòÌÉÄÎÇòÎäî Î≥¥Ïä§ ÏñºÍµ¥
    const fakeFace = this.createScaryFace(fakeX, fakeY);

    // ÌôîÎ©¥ ÌîåÎûòÏãú
    const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.4)
      .setOrigin(0, 0)
      .setDepth(4000);

    // Ïπ¥Î©îÎùº ÌùîÎì§Í∏∞
    this.cameras.main.shake(200, 0.03);

    // Îπ†Î•¥Í≤å ÏÇ¨ÎùºÏßê
    this.time.delayedCall(200, () => {
      this.tweens.add({
        targets: [fakeFace, flash],
        alpha: 0,
        duration: 150,
        onComplete: () => {
          fakeFace.destroy();
          flash.destroy();

          // Í∏¥Ïû•ÎèÑ ÏïΩÍ∞Ñ ÎÇÆÏ∂îÍ∏∞ (ÏïàÏã¨ Ìö®Í≥º)
          this.stalkingIntensity = Math.max(this.stalkingIntensity - 15, 50);

          // Îã§Ïãú Ïä§ÌÜ†ÌÇπ
          this.scheduleStalkingEyes();
        }
      });
    });
  }

  // üÜï ÏßÑÏßú Ï†êÌîÑ Ïä§ÏºÄÏñ¥ Í≥µÍ≤©! (HIT ÏàòÏóê Îî∞Îùº Îçî Îπ†Î•¥Í≥† Í≥µÍ≤©Ï†Å)
  executeJumpScare(isCombo = false) {
    if (this.jumpScareActive || this.gameOver) return;

    this.jumpScareActive = true;
    this.stalkingActive = false;

    const head = this.snake[0];
    const { width, height } = this.cameras.main;
    const hitCount = this.fogBossHitCount;

    // Î±Ä Î∞îÎ°ú ÏïûÏóê Î≥¥Ïä§ Îì±Ïû•
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // HIT ÏàòÏóê Îî∞Îùº Îçî Í∞ÄÍπåÏù¥ ÎÇòÌÉÄÎÇ® (Îçî Îπ†Î•∏ Î∞òÏùë ÌïÑÏöî)
    const offsetMultiplier = Math.max(1.5, 2.5 - hitCount * 0.3);
    const offset = this.gridSize * offsetMultiplier;

    // Î∞©Ìñ•Ïóê Îî∞Îùº ÏïûÏ™Ω ÏúÑÏπò
    let jumpX = headX;
    let jumpY = headY;

    switch (this.direction) {
      case 'UP': jumpY -= offset; break;
      case 'DOWN': jumpY += offset; break;
      case 'LEFT': jumpX -= offset; break;
      case 'RIGHT': jumpX += offset; break;
    }

    // HIT 3 (Rage Mode): Í∞ÄÎÅî ÏòÜÏóêÏÑú Îì±Ïû• (ÏòàÏ∏° Î∂àÍ∞Ä)
    if (hitCount >= 3 && Math.random() < 0.4) {
      const sideDirection = Math.random() < 0.5 ? 'left' : 'right';
      if (this.direction === 'UP' || this.direction === 'DOWN') {
        jumpX = headX + (sideDirection === 'left' ? -offset : offset);
        jumpY = headY;
      } else {
        jumpX = headX;
        jumpY = headY + (sideDirection === 'left' ? -offset : offset);
      }
    }

    // Î¨¥ÏÑúÏö¥ ÏñºÍµ¥ ÏÉùÏÑ± (HIT ÏàòÏóê Îî∞Îùº Îçî ÌÅ¨Í≤å)
    const scaryFace = this.createScaryFace(jumpX, jumpY);
    const initialScale = 0.4 + hitCount * 0.15;
    scaryFace.setScale(initialScale);

    // ÏΩ§Î≥¥ Î™®ÎìúÏóêÏÑúÎäî Îçî Îπ†Î•∏ Ïó∞Ï∂ú
    const freezeTime = isCombo ? 150 : 300;
    const flashDuration = isCombo ? 100 : 200;

    // ÌôîÎ©¥ Ï†ïÏßÄ Ìö®Í≥ºÎ•º ÏúÑÌï¥ Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // Í∞ïÎ†•Ìïú ÌôîÎ©¥ ÌîåÎûòÏãú (HIT ÏàòÏóê Îî∞Îùº ÏÉâÏÉÅ Î≥ÄÌôî)
    const flashColor = hitCount >= 3 ? 0xff0000 : 0xffffff;
    const flashAlpha = 0.6 + hitCount * 0.1;
    const flash = this.add.rectangle(0, 0, width, height, flashColor, flashAlpha)
      .setOrigin(0, 0)
      .setDepth(4500);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: flashDuration,
      onComplete: () => flash.destroy()
    });

    // Î≥¥Ïä§ ÌôïÎåÄ + ÎπÑÎ™Ö (HIT ÏàòÏóê Îî∞Îùº Îçî Îπ†Î•¥Í≤å)
    const scaleUpDuration = Math.max(80, 150 - hitCount * 20);
    const finalScale = 1.8 + hitCount * 0.3;
    this.tweens.add({
      targets: scaryFace,
      scaleX: finalScale,
      scaleY: finalScale,
      duration: scaleUpDuration,
      ease: 'Back.easeOut'
    });

    // HIT ÏàòÏóê Îî∞Î•∏ ÎπÑÎ™Ö ÌÖçÏä§Ìä∏ Î≥ÄÌôî
    const screams = ['RAAAGH!!!', 'RAAAGHH!!!!', 'DIE!!!!', 'NO ESCAPE!!!'];
    const screamText = this.add.text(width / 2, height / 2 - 100, screams[hitCount] || screams[0], {
      fontSize: `${56 + hitCount * 8}px`,
      fill: hitCount >= 3 ? '#ffff00' : '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(5000).setScale(0);

    this.tweens.add({
      targets: screamText,
      scaleX: 1.2 + hitCount * 0.1,
      scaleY: 1.2 + hitCount * 0.1,
      duration: 100
    });

    // Ïπ¥Î©îÎùº ÌùîÎì§Î¶º (HIT ÏàòÏóê Îî∞Îùº Îçî Í∞ïÌïòÍ≤å)
    const shakeIntensity = 0.04 + hitCount * 0.015;
    this.cameras.main.shake(400 + hitCount * 50, shakeIntensity);

    // HIT 3 : Ï∂îÍ∞Ä Ìö®Í≥º - ÌôîÎ©¥ ÏôúÍ≥°
    if (hitCount >= 3) {
      this.tweens.add({
        targets: this.cameras.main,
        zoom: { from: 1.1, to: 1 },
        duration: 200
      });
    }

    // ÌôîÎ©¥ Ï†ïÏßÄ ÌõÑ ÎèåÏßÑ (HIT ÎßéÏùÑÏàòÎ°ù Îπ®Î¶¨)
    this.time.delayedCall(freezeTime, () => {
      // ÌôîÎ©¥ Ï†ïÏßÄ Ìï¥Ï†ú
      this.moveTimer.paused = false;

      // Î±ÄÏùò ÌòÑÏû¨ ÏúÑÏπòÎ•º ÌÉÄÍ≤üÏúºÎ°ú Ï†ÄÏû•
      this.shadowStrikeTargetPos = { x: this.snake[0].x, y: this.snake[0].y };

      // Î≥¥Ïä§ Ïã§Ï†ú ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
      const jumpTileX = Math.floor(jumpX / this.gridSize);
      const jumpTileY = Math.floor((jumpY - this.gameAreaY) / this.gridSize);
      this.fogBossPosition = { x: jumpTileX, y: jumpTileY };

      // Î¨¥ÏÑúÏö¥ ÏñºÍµ¥ Ï†úÍ±∞ÌïòÍ≥† Ïã§Ï†ú Î≥¥Ïä§Î°ú ÍµêÏ≤¥
      scaryFace.destroy();
      screamText.destroy();

      // Î≥¥Ïä§ Î≥¥Ïù¥Í≤å
      this.fogBossVisible = true;
      if (this.fogBossElement) {
        this.fogBossElement.setPosition(jumpX, jumpY);
        this.fogBossElement.setAlpha(1);
      }

      // üÜï "DODGE NOW!" Í≤ΩÍ≥† ÌëúÏãú (Î™ÖÌôïÌïú ÌöåÌîº ÌÉÄÏù¥Î∞ç)
      this.showDodgeWarning();

      // ÎèåÏßÑ Ïã§Ìñâ (ÏΩ§Î≥¥ Î™®Îìú Ï†ÑÎã¨)
      this.executeShadowStrikeDash(isCombo);
    });
  }

  // üÜï Î¨¥ÏÑúÏö¥ ÏñºÍµ¥ ÏÉùÏÑ±
  createScaryFace(x, y) {
    const face = this.add.container(x, y).setDepth(4000).setAlpha(1);

    // Ïñ¥ÎëêÏö¥ ÏñºÍµ¥ Î≤†Ïù¥Ïä§
    const faceBase = this.add.circle(0, 0, 40, 0x0a0005, 0.9);
    face.add(faceBase);

    // ÌÅ¨Í≥† Î¨¥ÏÑúÏö¥ Îàà 3Í∞ú
    const eyes = [
      { x: -20, y: -10, size: 12 },
      { x: 20, y: -10, size: 12 },
      { x: 0, y: 5, size: 8 }
    ];

    eyes.forEach(eyeData => {
      const eyeGlow = this.add.circle(eyeData.x, eyeData.y, eyeData.size + 5, 0xff0000, 0.5);
      const eyeball = this.add.circle(eyeData.x, eyeData.y, eyeData.size, 0xffff00, 1);
      const iris = this.add.circle(eyeData.x, eyeData.y, eyeData.size * 0.6, 0xff0000, 1);
      const pupil = this.add.ellipse(eyeData.x, eyeData.y, eyeData.size * 0.3, eyeData.size * 0.8, 0x000000, 1);
      face.add([eyeGlow, eyeball, iris, pupil]);
    });

    // Ï∞¢Ïñ¥ÏßÑ ÏûÖ
    const mouth = this.add.ellipse(0, 25, 30, 15, 0x000000, 1);
    face.add(mouth);

    // Ïù¥Îπ®
    for (let i = 0; i < 7; i++) {
      const toothX = -12 + i * 4;
      const tooth = this.add.triangle(toothX, 20, 0, 0, 3, 10, -3, 10, 0xccccaa, 1);
      face.add(tooth);
    }

    return face;
  }

  // üÜï "DODGE NOW!" Í≤ΩÍ≥† ÌëúÏãú
  showDodgeWarning() {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Î±Ä ÏúÑÏóê ÌÅ∞ Í≤ΩÍ≥† ÌÖçÏä§Ìä∏
    const dodgeText = this.add.text(headX, headY - 50, '‚ö†Ô∏è DODGE! [SPACE] ‚ö†Ô∏è', {
      fontSize: '28px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff0000',
      strokeThickness: 4,
      backgroundColor: '#000000aa',
      padding: { x: 10, y: 5 }
    }).setOrigin(0.5).setDepth(6000);

    // ÍπúÎπ°ÏûÑ Ìö®Í≥º
    this.tweens.add({
      targets: dodgeText,
      alpha: { from: 1, to: 0.3 },
      scaleX: { from: 1, to: 1.1 },
      scaleY: { from: 1, to: 1.1 },
      duration: 100,
      yoyo: true,
      repeat: 3,
      onComplete: () => dodgeText.destroy()
    });

    // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ ÎÖ∏ÎûÄ ÌîåÎûòÏãú (ÏúÑÌóò ÌëúÏãú)
    const { width, height } = this.cameras.main;
    const warningBorder = this.add.graphics().setDepth(5500);
    warningBorder.lineStyle(8, 0xffff00, 0.8);
    warningBorder.strokeRect(0, 0, width, height);

    this.tweens.add({
      targets: warningBorder,
      alpha: 0,
      duration: 500,
      onComplete: () => warningBorder.destroy()
    });
  }

  // üÜï Shadow Strike ÎèåÏßÑ (Ï†êÌîÑ Ïä§ÏºÄÏñ¥ ÌõÑ - HIT ÏàòÏóê Îî∞Îùº Îçî Îπ†Î¶Ñ)
  executeShadowStrikeDash(isCombo = false) {
    if (!this.shadowStrikeTargetPos) {
      this.jumpScareActive = false;
      if (isCombo) {
        this.continueComboOrEnd();
      } else {
        this.startStalkingPhase();
      }
      return;
    }

    const targetX = this.shadowStrikeTargetPos.x * this.gridSize + this.gridSize / 2;
    const targetY = this.shadowStrikeTargetPos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    const hitCount = this.fogBossHitCount;

    // ÌöåÌîº Í∞ÄÎä• ÏúàÎèÑÏö∞ ÏãúÏûë
    this.canDodgeBoss = true;

    // HIT ÏàòÏóê Îî∞Îùº ÎèåÏßÑ ÏÜçÎèÑ Ï¶ùÍ∞Ä (Îçî Îπ†Î•¥Í≤å)
    const dashDuration = Math.max(100, 200 - hitCount * 30);

    // Î≥¥Ïä§ ÎèåÏßÑ
    this.tweens.add({
      targets: this.fogBossElement,
      x: targetX,
      y: targetY,
      duration: dashDuration,
      ease: 'Power3.easeIn',
      onComplete: () => {
        this.canDodgeBoss = false;

        // Ï∂©Îèå Ï≤¥ÌÅ¨
        const head = this.snake[0];
        const dist = Math.abs(head.x - this.shadowStrikeTargetPos.x) + Math.abs(head.y - this.shadowStrikeTargetPos.y);

        if (dist <= 1 && !this.isInvincible) {
          // ÌöåÌîº Ïã§Ìå® - Í≤åÏûÑ Ïò§Î≤Ñ
          this.comboAttackActive = false;
          this.handleFogBossKill();
        } else {
          // ÌöåÌîº ÏÑ±Í≥µ
          const recoveryTime = isCombo ? 300 : 500;
          this.time.delayedCall(recoveryTime, () => {
            this.fogBossVisible = false;
            this.jumpScareActive = false;

            if (this.fogBossElement) {
              this.tweens.add({
                targets: this.fogBossElement,
                alpha: 0,
                duration: 200
              });
            }

            // ÏΩ§Î≥¥ Î™®ÎìúÎ©¥ Îã§Ïùå ÏΩ§Î≥¥ ÎòêÎäî Ï¢ÖÎ£å
            if (isCombo) {
              this.continueComboOrEnd();
            } else {
              // Í∏¥Ïû•ÎèÑ Î¶¨ÏÖãÌïòÍ≥† Îã§Ïãú Ïä§ÌÜ†ÌÇπ
              this.stalkingIntensity = 30;
              this.startStalkingPhase();
            }
          });
        }
      }
    });

    // Î≥¥Ïä§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    this.fogBossPosition = { ...this.shadowStrikeTargetPos };
  }

  // üÜï Ïä§ÌÜ†ÌÇπ ÏãúÏä§ÌÖú Ï†ïÎ¶¨
  cleanupStalkingSystem() {
    this.stalkingActive = false;
    this.jumpScareActive = false;
    this.stalkingIntensity = 0;
    this.comboAttackActive = false;
    this.comboAttackCount = 0;

    if (this.stalkingTimer) {
      this.stalkingTimer.destroy();
      this.stalkingTimer = null;
    }
    if (this.tensionBuildupTimer) {
      this.tensionBuildupTimer.destroy();
      this.tensionBuildupTimer = null;
    }
    if (this.heartbeatTimer) {
      this.heartbeatTimer.destroy();
      this.heartbeatTimer = null;
    }
    if (this.rageFlickerTimer) {
      this.rageFlickerTimer.destroy();
      this.rageFlickerTimer = null;
    }
    if (this.rageGlitchTimer) {
      this.rageGlitchTimer.destroy();
      this.rageGlitchTimer = null;
    }
    if (this.vignetteOverlay) {
      this.vignetteOverlay.destroy();
      this.vignetteOverlay = null;
    }
    if (this.stalkingEyes) {
      this.stalkingEyes.destroy();
      this.stalkingEyes = null;
    }

    // Rage Mode Ï†ïÎ¶¨
    this.rageModeActive = false;
  }

  getShadowStrikeDelay() {
    const hitCount = this.fogBossHitCount;
    const attemptCount = Math.min(this.dodgeAttemptCount || 0, 8);
    const minBase = this.shadowStrikeInterval[0];
    const maxBase = this.shadowStrikeInterval[1];
    const hitDrop = hitCount * 350;
    const attemptDrop = attemptCount * 120;
    const minDelay = Math.max(900, minBase - hitDrop - attemptDrop);
    const maxDelay = Math.max(minDelay + 200, maxBase - hitDrop - attemptDrop);

    return Phaser.Math.Between(minDelay, maxDelay);
  }

  // Shadow Strike Í≤ΩÍ≥†
  showShadowStrikeWarning() {
    if (this.fogBossPhase !== 'shadow') return;
    if (this.gameOver) return;

    this.shadowStrikeWarningActive = true;

    // Î±ÄÏùò ÌòÑÏû¨ ÏúÑÏπòÎ•º ÌÉÄÍ≤üÏúºÎ°ú Ï†ÄÏû•
    const head = this.snake[0];
    this.shadowStrikeTargetPos = { x: head.x, y: head.y };

    // Î≥¥Ïä§Î•º ÌÉÄÍ≤ü Í∑ºÏ≤òÎ°ú Ïù¥Îèô
    this.teleportFogBoss(head.x + Phaser.Math.Between(-5, 5), head.y + Phaser.Math.Between(-5, 5));

    // Îπ®Í∞Ñ Îàà Í≤ΩÍ≥†
    const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
    const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Í≤ΩÍ≥† Îàà
    const warningEyes = this.add.container(bossX, bossY).setDepth(160);
    const leftEye = this.add.circle(-10, 0, 6, 0xff0000, 0);
    const rightEye = this.add.circle(10, 0, 6, 0xff0000, 0);
    warningEyes.add([leftEye, rightEye]);

    // Îàà ÌéòÏù¥ÎìúÏù∏ + Îπ†Î•∏ ÌéÑÏä§
    this.tweens.add({
      targets: [leftEye, rightEye],
      alpha: 1,
      duration: 200
    });

    this.tweens.add({
      targets: warningEyes,
      scaleX: { from: 1, to: 1.5 },
      scaleY: { from: 1, to: 1.5 },
      duration: 150,
      yoyo: true,
      repeat: 5
    });

    // Î±Ä Î®∏Î¶¨ ÏúÑÏóê "!" ÌëúÏãú
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    const warningIcon = this.add.text(headX, headY - 25, '!', {
      fontSize: '24px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(200);

    this.tweens.add({
      targets: warningIcon,
      scaleX: { from: 1, to: 1.3 },
      scaleY: { from: 1, to: 1.3 },
      duration: 100,
      yoyo: true,
      repeat: 5
    });

    // Í≤ΩÍ≥† ÏãúÍ∞Ñ ÌõÑ Í≥µÍ≤©
    this.time.delayedCall(this.shadowStrikeWarningTime, () => {
      warningEyes.destroy();
      warningIcon.destroy();
      this.executeShadowStrike();
    });
  }

  // Shadow Strike Ïã§Ìñâ - üÜï QTE ÏãúÏä§ÌÖúÏúºÎ°ú Î≥ÄÍ≤Ω (GOT YOU! Ï†úÍ±∞)
  executeShadowStrike() {
    if (this.fogBossPhase !== 'shadow') return;
    if (!this.shadowStrikeTargetPos) return;

    // üÜï QTE ÏãúÏä§ÌÖúÏúºÎ°ú Ïó∞Í≤∞ (ÏúÑÏπò Í∏∞Î∞ò Ï¶âÏÇ¨ Ï†úÍ±∞!)
    // The Presence ÏãúÏä§ÌÖúÏùò QTE Îã∑ÏßÄ ÏÇ¨Ïö©
    this.executePresenceDash('shadow');
  }

  // Î≥¥Ïä§ÏóêÍ≤å Ï£ΩÏùå
  handleFogBossKill() {
    this.gameOver = true;
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;

    // ÌôîÎ©¥ Îπ®Í∞Ñ ÌîåÎûòÏãú
    const flash = this.add.rectangle(0, 0, width, height, 0xff0000, 0.5)
      .setOrigin(0, 0)
      .setDepth(5000);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 500
    });

    // Î≥¥Ïä§ ÏõÉÏùå
    this.showFogBossScream('GOT YOU!');

    // Í≤åÏûÑ Ïò§Î≤Ñ Ï≤òÎ¶¨
    this.time.delayedCall(1500, () => {
      this.cleanupFogBoss();
      this.showGameOverScreen();
    });
  }

  // Î≥¥Ïä§ ÌÖîÎ†àÌè¨Ìä∏
  teleportFogBoss(targetX, targetY) {
    // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
    targetX = Phaser.Math.Clamp(targetX, 2, this.cols - 3);
    targetY = Phaser.Math.Clamp(targetY, 2, this.rows - 3);

    this.fogBossPosition = { x: targetX, y: targetY };

    // Î≥¥Ïä§ ÏöîÏÜå ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    if (this.fogBossElement) {
      this.fogBossElement.x = targetX * this.gridSize + this.gridSize / 2;
      this.fogBossElement.y = targetY * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    }
  }

  // Î≥¥Ïä§ ÌûàÌä∏ Ï≤òÎ¶¨
  handleFogBossHit() {
    this.fogBossHitCount++;

    const { width, height } = this.cameras.main;

    // ÌûàÌä∏ Ìö®Í≥º
    const hitText = this.add.text(width / 2, height / 2, `HIT ${this.fogBossHitCount}/4!`, {
      fontSize: '48px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff0000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setScale(0);

    this.tweens.add({
      targets: hitText,
      scaleX: 1,
      scaleY: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    this.tweens.add({
      targets: hitText,
      alpha: 0,
      y: height / 2 - 50,
      duration: 600,
      delay: 600,
      onComplete: () => hitText.destroy()
    });

    // Ïπ¥Î©îÎùº Ìö®Í≥º
    this.cameras.main.shake(300, 0.02);

    // Îã§Ïùå ÌéòÏù¥Ï¶à Ï≤¥ÌÅ¨ (4 HIT ÌÅ¥Î¶¨Ïñ¥)
    if (this.fogBossHitCount >= 4) {
      this.handleFogBossFinalHit();
    } else {
      // Î≥¥Ïä§ ÌÖîÎ†àÌè¨Ìä∏ ÌõÑ Í≥ÑÏÜç Shadow Strike
      this.time.delayedCall(1500, () => {
        // ÏÉà ÏúÑÏπòÎ°ú ÌÖîÎ†àÌè¨Ìä∏
        const newX = Phaser.Math.Between(5, this.cols - 6);
        const newY = Phaser.Math.Between(5, this.rows - 6);
        this.teleportFogBoss(newX, newY);

        // Î≥¥Ïä§ Ïà®Í∏∞Í∏∞
        this.fogBossVisible = false;
        if (this.fogBossElement) {
          this.tweens.add({
            targets: this.fogBossElement,
            alpha: 0,
            duration: 300
          });
        }

        // Îã§Ïùå Í≥µÍ≤© ÏòàÏïΩ (Îçî Îπ†Î•¥Í≤å)
        const delay = this.getShadowStrikeDelay();
        this.shadowStrikeTimer = this.time.delayedCall(Math.max(delay, 1500), () => {
          this.showShadowStrikeWarning();
        });
      });
    }
  }

  // Hallucination ÌéòÏù¥Ï¶à ÏãúÏûë
  startHallucinationPhase() {
    this.fogBossPhase = 'hallucination';

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.shadowStrikeTimer) {
      this.shadowStrikeTimer.destroy();
    }

    // Î≥¥Ïä§ ÎåÄÏÇ¨
    const { width, height } = this.cameras.main;
    const dialogue = this.add.text(width / 2, height / 2, 'Can you find the truth in darkness?', {
      fontSize: '24px',
      fill: '#9900ff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    this.tweens.add({
      targets: dialogue,
      alpha: 1,
      duration: 300
    });

    this.tweens.add({
      targets: dialogue,
      alpha: 0,
      duration: 300,
      delay: 2000,
      onComplete: () => dialogue.destroy()
    });

    // ÌôîÎ©¥ ÏôúÍ≥° Ìö®Í≥º
    this.cameras.main.shake(500, 0.008);

    // ÌôòÍ∞Å Î®πÏù¥ ÏÉùÏÑ±
    this.time.delayedCall(2500, () => {
      this.spawnHallucinationFood();
    });
  }

  // ÌôòÍ∞Å Î®πÏù¥ ÏÉùÏÑ±
  spawnHallucinationFood() {
    this.hallucinationFoods = [];

    // 5Í∞ú ÏúÑÏπò ÏÉùÏÑ±
    const positions = [];
    for (let i = 0; i < 5; i++) {
      let pos;
      let valid = false;
      let attempts = 0;

      while (!valid && attempts < 50) {
        pos = {
          x: Phaser.Math.Between(5, this.cols - 6),
          y: Phaser.Math.Between(5, this.rows - 6)
        };

        valid = true;
        // Î±ÄÍ≥º Í±∞Î¶¨ Ï≤¥ÌÅ¨
        for (const segment of this.snake) {
          if (Math.abs(segment.x - pos.x) < 3 && Math.abs(segment.y - pos.y) < 3) {
            valid = false;
            break;
          }
        }
        // Îã§Î•∏ ÏúÑÏπòÏôÄ Í±∞Î¶¨ Ï≤¥ÌÅ¨
        for (const p of positions) {
          if (Math.abs(p.x - pos.x) < 4 && Math.abs(p.y - pos.y) < 4) {
            valid = false;
            break;
          }
        }
        attempts++;
      }

      if (valid) {
        positions.push(pos);
      }
    }

    // ÏßÑÏßú Î®πÏù¥ Ïù∏Îç±Ïä§ (ÎûúÎç§)
    this.realFoodIndex = Phaser.Math.Between(0, positions.length - 1);

    // Î®πÏù¥ ÏÉùÏÑ±
    positions.forEach((pos, index) => {
      const isReal = index === this.realFoodIndex;
      const pixelX = pos.x * this.gridSize + this.gridSize / 2;
      const pixelY = pos.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      const container = this.add.container(pixelX, pixelY).setDepth(110);

      // Î®πÏù¥ Í∏∞Î≥∏ Î™®Ïñë (Îπ®Í∞Ñ ÏÇ¨Í∞ÅÌòï)
      const food = this.add.rectangle(0, 0, this.gridSize - 2, this.gridSize - 2, 0xff0000)
        .setStrokeStyle(1, 0xff6666);
      container.add(food);

      // ÏßÑÏßú Î®πÏù¥Îäî ÎØ∏Î¨òÌïú Îî∞ÎúªÌïú ÌååÌã∞ÌÅ¥ (Ï°∞Î™ÖÌÉÑ ÏÇ¨Ïö© Ïãú ÎÖ∏Ï∂ú)
      if (isReal) {
        const warmGlow = this.add.circle(0, 0, 12, 0xffaa00, 0);
        container.add(warmGlow);

        // Ï°∞Î™ÖÌÉÑ ÌôúÏÑ±Ìôî Ïãú ÎÖ∏Ï∂ú
        this.time.addEvent({
          delay: 100,
          callback: () => {
            if (this.flareActive) {
              warmGlow.setAlpha(0.4);
              food.setFillStyle(0xff6600); // Îçî Îî∞ÎúªÌïú ÏÉâ
            } else {
              warmGlow.setAlpha(0);
              food.setFillStyle(0xff0000);
            }
          },
          loop: true
        });
      } else {
        // Í∞ÄÏßú Î®πÏù¥Îäî ÎØ∏Î¨òÌïú Ïâ¨Î®∏ (Ï°∞Î™ÖÌÉÑ ÏÇ¨Ïö© Ïãú Î≥¥ÎùºÏÉâ Ìã¥Ìä∏)
        this.time.addEvent({
          delay: 100,
          callback: () => {
            if (this.flareActive) {
              food.setFillStyle(0x9900ff); // Î≥¥ÎùºÏÉâ Ìã¥Ìä∏
            } else {
              food.setFillStyle(0xff0000);
            }
          },
          loop: true
        });
      }

      // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: container,
        scaleX: { from: 1, to: 1.1 },
        scaleY: { from: 1, to: 1.1 },
        duration: 500,
        yoyo: true,
        repeat: -1
      });

      this.hallucinationFoods.push({
        x: pos.x,
        y: pos.y,
        container: container,
        isReal: isReal
      });
    });
  }

  // ÌôòÍ∞Å Î®πÏù¥ Î®πÍ∏∞ Ï≤òÎ¶¨
  handleHallucinationFood(food) {
    if (food.isReal) {
      // ÏßÑÏßú Î®πÏù¥ - Î≥¥Ïä§ ÌûàÌä∏
      food.container.destroy();
      const index = this.hallucinationFoods.indexOf(food);
      if (index > -1) {
        this.hallucinationFoods.splice(index, 1);
      }

      // ÎÇòÎ®∏ÏßÄ Í∞ÄÏßú Î®πÏù¥ Ìè≠Î∞ú
      this.hallucinationFoods.forEach(fake => {
        const explosionX = fake.x * this.gridSize + this.gridSize / 2;
        const explosionY = fake.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

        // Ìè≠Î∞ú Ìö®Í≥º
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const particle = this.add.circle(explosionX, explosionY, 4, 0x9900ff, 1).setDepth(200);

          this.tweens.add({
            targets: particle,
            x: explosionX + Math.cos(angle) * 40,
            y: explosionY + Math.sin(angle) * 40,
            alpha: 0,
            duration: 400,
            onComplete: () => particle.destroy()
          });
        }

        fake.container.destroy();
      });
      this.hallucinationFoods = [];

      // ÌûàÌä∏ Ï≤òÎ¶¨
      this.handleFogBossHit();
    } else {
      // Í∞ÄÏßú Î®πÏù¥ - Í≤åÏûÑ Ïò§Î≤Ñ
      const { width, height } = this.cameras.main;

      // "IT WAS A TRAP!" Î©îÏãúÏßÄ
      const trapText = this.add.text(width / 2, height / 2, 'IT WAS A TRAP!', {
        fontSize: '36px',
        fill: '#ff0000',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5).setDepth(5000).setScale(0);

      this.tweens.add({
        targets: trapText,
        scaleX: 1.2,
        scaleY: 1.2,
        duration: 300,
        ease: 'Back.easeOut'
      });

      // Î≥¥Ïä§ ÏõÉÏùå
      this.showFogBossScream('FOOLISH SNAKE!');

      // Í≤åÏûÑ Ïò§Î≤Ñ
      this.handleFogBossKill();
    }
  }

  // Eclipse ÌéòÏù¥Ï¶à ÏãúÏûë
  startEclipsePhase() {
    this.fogBossPhase = 'eclipse';
    this.eclipseActive = true;

    const { width, height } = this.cameras.main;

    // Î≥¥Ïä§ ÎåÄÏÇ¨
    const dialogue = this.add.text(width / 2, height / 2, 'EMBRACE THE VOID!', {
      fontSize: '32px',
      fill: '#9900ff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setAlpha(0);

    this.tweens.add({
      targets: dialogue,
      alpha: 1,
      scaleX: { from: 0.5, to: 1.2 },
      scaleY: { from: 0.5, to: 1.2 },
      duration: 500,
      ease: 'Power2'
    });

    this.tweens.add({
      targets: dialogue,
      alpha: 0,
      duration: 300,
      delay: 1500,
      onComplete: () => dialogue.destroy()
    });

    // ÏãúÏïº Í∑πÎèÑÎ°ú Ï∂ïÏÜå
    this.time.delayedCall(2000, () => {
      this.fogVisibleTiles = this.eclipseVisibility;

      // Îπõ Ïò§Î∏å ÏÉùÏÑ±
      this.spawnLightOrb();

      // Shadow Strike Í≥ÑÏÜç (Îçî ÎπàÎ≤àÌïòÍ≤å)
      this.shadowStrikeInterval = [2000, 3500];
      this.startShadowStrikePhase();
    });
  }

  // Îπõ Ïò§Î∏å ÏÉùÏÑ±
  spawnLightOrb() {
    // Îßµ Ï§ëÏïô Í∑ºÏ≤òÏóê ÏÉùÏÑ±
    const orbX = Math.floor(this.cols / 2) + Phaser.Math.Between(-3, 3);
    const orbY = Math.floor(this.rows / 2) + Phaser.Math.Between(-3, 3);

    const pixelX = orbX * this.gridSize + this.gridSize / 2;
    const pixelY = orbY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // Ïò§Î∏å Ïª®ÌÖåÏù¥ÎÑà
    const container = this.add.container(pixelX, pixelY).setDepth(130);

    // Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞ (Ìù¨ÎØ∏ÌïòÍ≤å)
    const outerGlow = this.add.circle(0, 0, 20, 0xffffff, 0.1);
    // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
    const midGlow = this.add.circle(0, 0, 12, 0xffffaa, 0.2);
    // ÏΩîÏñ¥
    const core = this.add.circle(0, 0, 6, 0xffffff, 0.6);

    container.add([outerGlow, midGlow, core]);

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: outerGlow,
      alpha: { from: 0.1, to: 0.3 },
      scaleX: { from: 1, to: 1.5 },
      scaleY: { from: 1, to: 1.5 },
      duration: 1000,
      yoyo: true,
      repeat: -1
    });

    this.tweens.add({
      targets: core,
      alpha: { from: 0.6, to: 1 },
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    this.lightOrb = {
      x: orbX,
      y: orbY,
      container: container
    };
  }

  // Îπõ Ïò§Î∏å ÏàòÏßë
  collectLightOrb() {
    if (!this.lightOrb) return;

    const { width, height } = this.cameras.main;

    // Ïò§Î∏å ÌååÍ¥¥
    this.lightOrb.container.destroy();

    // Í±∞ÎåÄÌïú Îπõ Ìè≠Î∞ú
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÌôîÎ©¥ ÌîåÎûòÏãú
    const flash = this.add.rectangle(0, 0, width, height, 0xffffff, 1)
      .setOrigin(0, 0)
      .setDepth(5000);

    this.tweens.add({
      targets: flash,
      alpha: 0,
      duration: 1000,
      onComplete: () => flash.destroy()
    });

    // ÏãúÏïº ÏôÑÏ†Ñ Î≥µÏõê
    this.fogVisibleTiles = 6;
    this.eclipseActive = false;

    // Îπõ ÌååÎèô
    this.createLightWave(headX, headY);

    // "NOW! STRIKE!" ÌîÑÎ°¨ÌîÑÌä∏
    const strikeText = this.add.text(width / 2, height / 2 - 100, 'NOW! STRIKE!', {
      fontSize: '36px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5001);

    this.tweens.add({
      targets: strikeText,
      scaleX: { from: 0.5, to: 1.2 },
      scaleY: { from: 0.5, to: 1.2 },
      duration: 300,
      ease: 'Back.easeOut'
    });

    this.tweens.add({
      targets: strikeText,
      alpha: 0,
      duration: 300,
      delay: 1500,
      onComplete: () => strikeText.destroy()
    });

    // Î≥¥Ïä§ ÏôÑÏ†Ñ ÎÖ∏Ï∂ú
    this.fogBossVisible = true;
    if (this.fogBossElement) {
      this.fogBossElement.setAlpha(1);
    }

    // Shadow Strike ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ
    if (this.shadowStrikeTimer) {
      this.shadowStrikeTimer.destroy();
    }

    // Î≥¥Ïä§ vulnerable ÏÉÅÌÉú
    this.fogBossPhase = 'vulnerable';
    this.lightOrb = null;
  }

  // ÏµúÏ¢Ö ÌûàÌä∏ Ï≤òÎ¶¨
  handleFogBossFinalHit() {
    this.fogBossPhase = 'victory';
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;

    // Ïä¨Î°úÏö∞ Î™®ÏÖò
    this.time.timeScale = 0.3;

    // Ïπ¥Î©îÎùº Ï§å
    this.cameras.main.zoomTo(1.5, 500);

    // Î≥¥Ïä§ ÎπÑÎ™Ö
    const screamText = this.add.text(width / 2, height / 2, 'NO! THE LIGHT... IT BURNS!', {
      fontSize: '28px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000).setScale(0);

    this.tweens.add({
      targets: screamText,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 500,
      ease: 'Back.easeOut'
    });

    // Î≥¥Ïä§ Î∂ÑÌï¥ Ìö®Í≥º
    this.time.delayedCall(1500, () => {
      this.time.timeScale = 1;
      this.cameras.main.zoomTo(1, 500);

      // Î≥¥Ïä§ ÌååÌã∞ÌÅ¥ Î∂ÑÌï¥
      if (this.fogBossElement) {
        const bossX = this.fogBossElement.x;
        const bossY = this.fogBossElement.y;

        for (let i = 0; i < 40; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 50 + Math.random() * 100;
          const particle = this.add.circle(bossX, bossY, 3 + Math.random() * 4, 0x330033, 1)
            .setDepth(200);

          this.tweens.add({
            targets: particle,
            x: bossX + Math.cos(angle) * speed,
            y: bossY + Math.sin(angle) * speed,
            alpha: 0,
            scale: 0,
            duration: 800 + Math.random() * 400,
            onComplete: () => particle.destroy()
          });
        }

        this.fogBossElement.destroy();
        this.fogBossElement = null;
      }

      screamText.destroy();

      // ÏäπÎ¶¨ ÏãúÌÄÄÏä§
      this.time.delayedCall(1000, () => {
        this.showFogBossVictory();
      });
    });
  }

  // ÏäπÎ¶¨ ÏãúÌÄÄÏä§ (Dawn Breaking) - ÎìúÎùºÎßàÌã± Î≤ÑÏ†Ñ
  showFogBossVictory() {
    const { width, height } = this.cameras.main;
    const victoryElements = [];

    // ====== PHASE 1: Î≥¥Ïä§Ïùò Í≥†ÌÜµÏä§Îü¨Ïö¥ Ï£ΩÏùå ======

    // 1-1. ÌôîÎ©¥ Îñ®Î¶º ÏãúÏûë
    this.cameras.main.shake(1500, 0.02);

    // 1-2. Î≥¥Ïä§ ÎπÑÎ™Ö (Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Ïä§ÌÇµ)
    const bossScream = this.add.text(width / 2, height / 2 - 80, 'NOOOO...!', {
      fontSize: '32px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5100).setAlpha(0);
    victoryElements.push(bossScream);

    this.tweens.add({
      targets: bossScream,
      alpha: 1,
      scaleX: { from: 0.5, to: 1.3 },
      scaleY: { from: 0.5, to: 1.3 },
      duration: 300,
      onComplete: () => {
        this.tweens.add({
          targets: bossScream,
          alpha: 0,
          y: height / 2 - 120,
          duration: 800
        });
      }
    });

    // 1-3. Î≥¥Ïä§ Î∂ÑÌï¥ ÌååÌã∞ÌÅ¥ (Î≥¥Ïä§Í∞Ä Î∂ÄÏÑúÏßÄÎäî Ìö®Í≥º)
    if (this.fogBossElement && this.fogBossPosition) {
      const bossX = this.fogBossPosition.x * this.gridSize + this.gridSize / 2;
      const bossY = this.fogBossPosition.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      // Î≥¥Ïä§ Ï°∞Í∞ÅÎì§Ïù¥ Ìù©Ïñ¥Ïßê
      for (let i = 0; i < 30; i++) {
        const shard = this.add.polygon(
          bossX + Phaser.Math.Between(-20, 20),
          bossY + Phaser.Math.Between(-20, 20),
          [0, 0, 8, 3, 6, 10, -2, 8],
          0x220011,
          0.9
        ).setDepth(5050);

        this.tweens.add({
          targets: shard,
          x: shard.x + Phaser.Math.Between(-200, 200),
          y: shard.y + Phaser.Math.Between(-200, 200),
          angle: Phaser.Math.Between(-360, 360),
          alpha: 0,
          scaleX: 0.1,
          scaleY: 0.1,
          duration: 1500,
          delay: i * 30,
          ease: 'Power2.easeOut',
          onComplete: () => shard.destroy()
        });
      }

      // Î≥¥Ïä§ Îàà ÌäÄÏñ¥ÎÇòÍ∞ÄÎäî Ìö®Í≥º (3Í∞ú)
      for (let i = 0; i < 3; i++) {
        const eyeShard = this.add.circle(
          bossX + Phaser.Math.Between(-15, 15),
          bossY + Phaser.Math.Between(-10, 10),
          6 - i,
          0xcccc00,
          1
        ).setDepth(5060);

        this.tweens.add({
          targets: eyeShard,
          x: eyeShard.x + Phaser.Math.Between(-300, 300),
          y: eyeShard.y + Phaser.Math.Between(-300, 300),
          alpha: 0,
          duration: 1200,
          delay: 200 + i * 100,
          ease: 'Power3.easeOut',
          onComplete: () => eyeShard.destroy()
        });
      }
    }

    // ====== PHASE 2: ÏïàÍ∞ú ÏÇ∞ÏÇ∞Ïù¥ Î∂ÄÏÑúÏßê ======
    this.time.delayedCall(800, () => {
      // 2-1. ÏïàÍ∞ú ÎπÑÌôúÏÑ±Ìôî
      this.fogEnabled = false;
      this.fogTestForceEnable = false;

      // 2-2. ÏïàÍ∞ú ÌååÌé∏ ÏÉùÏÑ± (ÏïàÍ∞úÍ∞Ä Ïú†Î¶¨Ï≤òÎüº Íπ®ÏßÄÎäî Ìö®Í≥º)
      const shardCount = 50;
      for (let i = 0; i < shardCount; i++) {
        const shardX = Phaser.Math.Between(0, width);
        const shardY = Phaser.Math.Between(this.gameAreaY, height);
        const shardSize = Phaser.Math.Between(15, 40);

        // Î∂àÍ∑úÏπôÌïú Îã§Í∞ÅÌòï ÌååÌé∏
        const points = [];
        const sides = Phaser.Math.Between(4, 7);
        for (let j = 0; j < sides; j++) {
          const angle = (j / sides) * Math.PI * 2;
          const dist = shardSize * (0.5 + Math.random() * 0.5);
          points.push(Math.cos(angle) * dist, Math.sin(angle) * dist);
        }

        const fogShard = this.add.polygon(shardX, shardY, points, 0x111122, 0.7)
          .setDepth(4900);

        // Í∑†Ïó¥ÏÑ† Ï∂îÍ∞Ä
        const crackLine = this.add.line(
          shardX, shardY,
          0, 0,
          Phaser.Math.Between(-10, 10),
          Phaser.Math.Between(-10, 10),
          0x333355, 0.5
        ).setDepth(4901);

        // ÌååÌé∏Ïù¥ ÎÇ†ÏïÑÍ∞ÄÎ©∞ ÏÇ¨ÎùºÏßê
        const targetAngle = Math.atan2(shardY - height / 2, shardX - width / 2);
        const distance = 300 + Math.random() * 200;

        this.tweens.add({
          targets: [fogShard, crackLine],
          x: shardX + Math.cos(targetAngle) * distance,
          y: shardY + Math.sin(targetAngle) * distance,
          angle: Phaser.Math.Between(-180, 180),
          alpha: 0,
          scaleX: 0.3,
          scaleY: 0.3,
          duration: 1500,
          delay: i * 20,
          ease: 'Power2.easeOut',
          onComplete: () => {
            fogShard.destroy();
            crackLine.destroy();
          }
        });
      }

      // 2-3. ÏïàÍ∞ú ÌÖçÏä§Ï≤òÎèÑ Ï†úÍ±∞
      if (this.fogRenderTexture) {
        this.tweens.add({
          targets: this.fogRenderTexture,
          alpha: 0,
          duration: 500
        });
      }

      // Íπ®ÏßÄÎäî Ïú†Î¶¨ ÏÜåÎ¶¨ Ìö®Í≥º (Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨)
      this.cameras.main.shake(300, 0.03);
    });

    // ====== PHASE 3: DOM + ÌôîÎ©¥ Î∞ùÏïÑÏßê ======
    this.time.delayedCall(1500, () => {
      // 3-1. DOM Î∏åÎùºÏö∞Ï†Ä Î∞∞Í≤Ω Î∞ùÏïÑÏßê
      try {
        document.body.style.transition = 'background 2s ease';
        document.body.style.background = 'linear-gradient(135deg, #87CEEB 0%, #FFD700 50%, #FFA500 100%)';
      } catch (e) {}

      // 3-2. Í≤åÏûÑ ÌôîÎ©¥ Î∞ùÏùÄ Ïò§Î≤ÑÎ†àÏù¥
      const dawnOverlay = this.add.rectangle(0, 0, width, height, 0xffeedd, 0)
        .setOrigin(0, 0)
        .setDepth(5000);
      victoryElements.push(dawnOverlay);

      this.tweens.add({
        targets: dawnOverlay,
        alpha: 0.6,
        duration: 1500,
        ease: 'Power2.easeIn'
      });

      // 3-3. ÌÉúÏñë Í¥ëÏÑ† (ÏïÑÎûòÏóêÏÑú ÌçºÏ†∏ÎÇòÏò¥)
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI - Math.PI / 2; // ÏúÑÏ™ΩÏóêÏÑú ÏãúÏûë
        const ray = this.add.rectangle(
          width / 2,
          height + 50,
          600,
          4 + Math.random() * 4,
          0xffffaa,
          0
        ).setOrigin(0, 0.5).setRotation(angle).setDepth(4998);

        victoryElements.push(ray); // üÜï Ï†ïÎ¶¨ Î™©Î°ùÏóê Ï∂îÍ∞Ä

        this.tweens.add({
          targets: ray,
          alpha: { from: 0, to: 0.4 + Math.random() * 0.3 },
          scaleX: { from: 0.5, to: 1.5 },
          duration: 1000,
          delay: i * 50,
          ease: 'Power2.easeOut'
        });
      }

      // 3-4. ÏïÑÎ¶ÑÎã§Ïö¥ ÌÉúÏñë Îì±Ïû• (Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º)
      const sunContainer = this.add.container(width / 2, height + 100).setDepth(4999);
      victoryElements.push(sunContainer);

      // Ïô∏Î∂Ä ÏΩîÎ°úÎÇò Í∏ÄÎ°úÏö∞ (Í∞ÄÏû• Î∞îÍπ•, ÌùêÎ¶øÌïòÍ≥† ÌÅ∞)
      const corona4 = this.add.circle(0, 0, 180, 0xffff88, 0.08);
      const corona3 = this.add.circle(0, 0, 150, 0xffffaa, 0.12);
      const corona2 = this.add.circle(0, 0, 120, 0xffdd66, 0.18);
      const corona1 = this.add.circle(0, 0, 100, 0xffcc44, 0.25);
      sunContainer.add([corona4, corona3, corona2, corona1]);

      // ÌÉúÏñë Î≥∏Ï≤¥ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò - Ïó¨Îü¨ Í≤π)
      const sunOuter = this.add.circle(0, 0, 80, 0xffaa00, 1);      // Ï£ºÌô©
      const sunMid = this.add.circle(0, 0, 60, 0xffcc33, 1);        // Î∞ùÏùÄ Ï£ºÌô©
      const sunInner = this.add.circle(0, 0, 40, 0xffdd66, 1);      // ÎÖ∏ÎûÄ Ï£ºÌô©
      const sunCore = this.add.circle(0, 0, 25, 0xffeeaa, 1);       // Î∞ùÏùÄ ÎÖ∏Îûë
      const sunHot = this.add.circle(0, 0, 12, 0xffffff, 0.8);      // Ìù∞ÏÉâ Ï§ëÏã¨
      sunContainer.add([sunOuter, sunMid, sunInner, sunCore, sunHot]);

      // ÏΩîÎ°úÎÇò ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
      [corona4, corona3, corona2, corona1].forEach((corona, i) => {
        this.tweens.add({
          targets: corona,
          scaleX: { from: 1, to: 1.2 + i * 0.05 },
          scaleY: { from: 1, to: 1.2 + i * 0.05 },
          alpha: { from: corona.alpha, to: corona.alpha * 1.5 },
          duration: 1200 + i * 200,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });
      });

      // ÌÉúÏñë Îñ†Ïò§Î¶Ñ
      this.tweens.add({
        targets: sunContainer,
        y: height - 100,
        duration: 2500,
        ease: 'Power2.easeOut'
      });

      // üÜï ÎÇòÏ§ëÏóê Ïò§Î•∏Ï™ΩÏúºÎ°ú ÎÇ†ÏïÑÍ∞à Ï∞∏Ï°∞ Ï†ÄÏû•
      this.victorySunContainer = sunContainer;
    });

    // ====== PHASE 4: "DAWN BREAKS!" ÌÖçÏä§Ìä∏ ======
    this.time.delayedCall(2800, () => {
      // 4-1. Î©îÏù∏ ÌÖçÏä§Ìä∏
      const victoryText = this.add.text(width / 2, height / 2 - 60, 'DAWN BREAKS!', {
        fontSize: '56px',
        fill: '#FFD700',
        fontStyle: 'bold',
        stroke: '#ffffff',
        strokeThickness: 6
      }).setOrigin(0.5).setDepth(5200).setScale(0).setAlpha(0);
      victoryElements.push(victoryText);

      // Í∏ÄÏûê ÌïòÎÇòÏî© ÎÇòÌÉÄÎÇòÎäî Ìö®Í≥º ÏãúÎÆ¨Î†àÏù¥ÏÖò
      this.tweens.add({
        targets: victoryText,
        alpha: 1,
        scaleX: { from: 0.3, to: 1.2 },
        scaleY: { from: 0.3, to: 1.2 },
        duration: 600,
        ease: 'Back.easeOut',
        onComplete: () => {
          // ÌÖçÏä§Ìä∏ ÌéÑÏä§
          this.tweens.add({
            targets: victoryText,
            scaleX: { from: 1.2, to: 1.0 },
            scaleY: { from: 1.2, to: 1.0 },
            duration: 300
          });
        }
      });

      // 4-2. Îπõ ÌååÌã∞ÌÅ¥ Î∂ÑÏ∂ú
      for (let i = 0; i < 40; i++) {
        const sparkle = this.add.circle(
          width / 2 + Phaser.Math.Between(-100, 100),
          height / 2 - 60,
          Phaser.Math.Between(2, 6),
          0xffffaa,
          1
        ).setDepth(5201);

        this.tweens.add({
          targets: sparkle,
          x: sparkle.x + Phaser.Math.Between(-200, 200),
          y: sparkle.y + Phaser.Math.Between(-150, 150),
          alpha: 0,
          duration: 1000,
          delay: i * 15,
          ease: 'Power2.easeOut',
          onComplete: () => sparkle.destroy()
        });
      }

      // ÌîåÎûòÏãú Ìö®Í≥º
      this.browserFlash('white', 300);
      this.cameras.main.flash(300, 255, 255, 200);
    });

    // ====== PHASE 5: Î≥¥ÎÑàÏä§ + Î±Ä ÎåÄÏÇ¨ ======
    this.time.delayedCall(4000, () => {
      // 5-1. Î≥¥ÎÑàÏä§ Ï†êÏàò
      const bonusText = this.add.text(width / 2, height / 2 + 30, `+${this.fogBossBonus} BONUS!`, {
        fontSize: '40px',
        fill: '#00ff00',
        fontStyle: 'bold',
        stroke: '#004400',
        strokeThickness: 4
      }).setOrigin(0.5).setDepth(5202).setScale(0);
      victoryElements.push(bonusText);

      this.tweens.add({
        targets: bonusText,
        scaleX: 1,
        scaleY: 1,
        duration: 400,
        ease: 'Back.easeOut'
      });

      this.score += this.fogBossBonus;
      this.scoreText.setText(this.score.toString());

      // 5-2. ÏΩîÏù∏ ÎπÑ
      for (let i = 0; i < 30; i++) {
        const coin = this.add.circle(
          Phaser.Math.Between(50, width - 50),
          -20,
          5 + Math.random() * 4,
          0xffdd00,
          1
        ).setDepth(5150);

        this.tweens.add({
          targets: coin,
          y: height + 30,
          x: coin.x + Phaser.Math.Between(-50, 50),
          duration: 1500 + Math.random() * 1000,
          delay: i * 40,
          ease: 'Bounce.easeOut',
          onComplete: () => coin.destroy()
        });
      }

      // 5-3. Î±Ä ÎåÄÏÇ¨
      this.time.delayedCall(1500, () => {
        const snakeText = this.add.text(width / 2, height / 2 + 100, 'Finally... I can see again!', {
          fontSize: '22px',
          fill: '#00dd00',
          fontStyle: 'italic',
          stroke: '#003300',
          strokeThickness: 2
        }).setOrigin(0.5).setDepth(5203).setAlpha(0);
        victoryElements.push(snakeText);

        this.tweens.add({
          targets: snakeText,
          alpha: 1,
          y: height / 2 + 90,
          duration: 500
        });
      });
    });

    // ====== PHASE 6: ÎßàÎ¨¥Î¶¨ Î∞è Ï†ïÎ¶¨ ======
    this.time.delayedCall(7000, () => {
      // 6-1. ÌÉúÏñëÏù¥ Ïò§Î•∏Ï™ΩÏúºÎ°ú Î∂ÄÎìúÎüΩÍ≤å ÎÇ†ÏïÑÍ∞ê!
      if (this.victorySunContainer && this.victorySunContainer.active) {
        this.tweens.add({
          targets: this.victorySunContainer,
          x: width + 200,
          y: this.victorySunContainer.y - 100, // ÏïΩÍ∞Ñ ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎ©¥ÏÑú
          scaleX: 0.6,
          scaleY: 0.6,
          duration: 1200,
          ease: 'Power2.easeIn',
          onComplete: () => {
            if (this.victorySunContainer && this.victorySunContainer.destroy) {
              this.victorySunContainer.destroy();
            }
          }
        });
      }

      // 6-2. Îã§Î•∏ ÏöîÏÜåÎì§ÏùÄ ÌéòÏù¥ÎìúÏïÑÏõÉ (ÌÉúÏñë Ïª®ÌÖåÏù¥ÎÑà Ï†úÏô∏)
      victoryElements.forEach(el => {
        if (el && el.active && el !== this.victorySunContainer) {
          this.tweens.add({
            targets: el,
            alpha: 0,
            duration: 800,
            onComplete: () => {
              if (el && el.destroy) el.destroy();
            }
          });
        }
      });

      // 6-3. DOM Î∞∞Í≤Ω Î≥µÏõê (ÌÉúÏñë ÎÇ†ÏïÑÍ∞Ñ ÌõÑ)
      this.time.delayedCall(800, () => {
        try {
          document.body.style.transition = 'background 1s ease';
          document.body.style.background = 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)';
        } catch (e) {}
      });

      // 6-4. 9ÌÉÑ Î≥¥Ïä§ BGM Ï†ïÏßÄ ÌõÑ Í∏∞Î≥∏ BGMÏúºÎ°ú ÏõêÎ≥µ
      if (this.boss9Music && this.boss9Music.isPlaying) {
        this.boss9Music.stop();
      }
      if (this.bgMusic && !this.bgMusic.isPlaying) {
        this.bgMusic.play();
      }

      // 6-5. Î≥¥Ïä§ Î™®Îìú Ï¢ÖÎ£å
      this.cleanupFogBoss();

      // 6-6. ÏΩ§Î≥¥/Ïã§Îìú Î≥µÏõê
      this.combo = this.savedFogBossCombo;
      this.comboShieldCount = this.savedFogBossShieldCount;
      this.updateItemStatusUI();

      // 6-6. ÏÉÅÏ†ê Ïò§Ìîà ÎòêÎäî Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄ
      this.time.delayedCall(1200, () => {
        this.stageClear();
      });
    });
  }

  // Î≥¥Ïä§ Ï†ïÎ¶¨
  cleanupFogBoss() {
    this.fogBossMode = false;
    this.fogBossPhase = 'none';
    this.fogBossVisible = false;
    this.fogBossHitCount = 0;
    this.fogBossFirstDodgeGraceUsed = false;
    this.dodgeAttemptCount = 0;
    this.fogBossInputBlocked = false; // ÏûÖÎ†• Ï∞®Îã® Ìï¥Ï†ú

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.shadowStrikeTimer) {
      this.shadowStrikeTimer.destroy();
      this.shadowStrikeTimer = null;
    }
    if (this.flareSpawnTimer) {
      this.flareSpawnTimer.destroy();
      this.flareSpawnTimer = null;
    }
    if (this.bossSlimeTimer) {
      this.bossSlimeTimer.destroy();
      this.bossSlimeTimer = null;
    }

    // üÜï Ïä§ÌÜ†ÌÇπ ÏãúÏä§ÌÖú Ï†ïÎ¶¨
    this.cleanupStalkingSystem();

    // üÜï Presence ÏãúÏä§ÌÖú Ï†ïÎ¶¨ (Î∏åÎùºÏö∞Ï†Ä Ïñ¥Îë†, ÌéÑÏä§ Îì±)
    this.cleanupPresenceSystem();

    // ÏöîÏÜå Ï†ïÎ¶¨
    if (this.fogBossElement) {
      this.fogBossElement.destroy();
      this.fogBossElement = null;
    }

    // Ï°∞Î™ÖÌÉÑ Ï†ïÎ¶¨
    this.flares.forEach(flare => {
      if (flare.container) {
        flare.container.destroy();
      }
    });
    this.flares = [];
    this.flareCount = 0;

    // ÌôòÍ∞Å Î®πÏù¥ Ï†ïÎ¶¨
    this.hallucinationFoods.forEach(food => {
      if (food.container) {
        food.container.destroy();
      }
    });
    this.hallucinationFoods = [];

    // Îπõ Ïò§Î∏å Ï†ïÎ¶¨
    if (this.lightOrb && this.lightOrb.container) {
      this.lightOrb.container.destroy();
      this.lightOrb = null;
    }

    // üÜï ÏïàÍ∞ú ÏôÑÏ†ÑÌûà ÎπÑÌôúÏÑ±Ìôî (Îã§Ïùå Ïä§ÌÖåÏù¥ÏßÄÎäî ÏùºÎ∞ò Ïä§ÌÖåÏù¥ÏßÄ)
    this.fogEnabled = false;
    this.fogTestForceEnable = false;
    this.fogIntroPlaying = false; // Ïù∏Ìä∏Î°ú ÏßÑÌñâ Ï§ë ÌîåÎûòÍ∑∏ÎèÑ Î¶¨ÏÖã
    this.fogLastRenderKey = null; // Î†åÎçî Ï∫êÏãú Î¶¨ÏÖã

    // fogRenderTexture Ïà®Í∏∞Í∏∞ (destroyÌïòÏßÄ ÏïäÏùå - ÎÇòÏ§ëÏóê Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•)
    if (this.fogRenderTexture) {
      this.fogRenderTexture.clear();
      this.fogRenderTexture.setVisible(false);
      this.fogRenderTexture.setAlpha(1); // Îã§ÏùåÏóê ÏÇ¨Ïö©Ìï† ÎïåÎ•º ÏúÑÌï¥ Î≥µÏõê
    }

    // ÏïàÍ∞ú ÏÑ§Ï†ï Î≥µÏõê
    this.fogVisibleTiles = this.originalFogVisibleTiles;
    this.eclipseActive = false;
    this.fogIntroShown = false; // Îã§Ïùå ÏïàÍ∞ú Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑú Ïù∏Ìä∏Î°ú Îã§Ïãú Î≥¥Ïó¨Ï£ºÍ∏∞

    // üÜï Ïπ¥Î©îÎùº Ï§å Î¶¨ÏÖã
    this.cameras.main.setZoom(1);

    // UI ÏöîÏÜå Ï†ïÎ¶¨
    this.fogBossElements.forEach(el => {
      if (el && el.destroy) {
        el.destroy();
      }
    });
    this.fogBossElements = [];
  }

  // ========== Í∞úÎ∞úÏûê ÌÖåÏä§Ìä∏ Î™®Îìú (KK) ==========

  // Í∞úÎ∞úÏûê Î™®Îìú Ïó¥Í∏∞
  openDevMode() {
    if (this.devModeEnabled) return;
    if (this.shopOpen || this.loanUIOpen) return;

    this.devModeEnabled = true;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    if (this.moveTimer) {
      this.moveTimer.paused = true;
    }

    const { width, height } = this.cameras.main;
    this.devModeElements = [];
    this.devStageButtons = [];

    // Ïñ¥ÎëêÏö¥ Ïò§Î≤ÑÎ†àÏù¥
    const overlay = this.add.rectangle(0, 0, width, height, 0x000000, 0.9)
      .setOrigin(0, 0)
      .setDepth(9000)
      .setInteractive();
    this.devModeElements.push(overlay);

    // ÌÉÄÏù¥ÌãÄ
    const title = this.add.text(width / 2, 30, 'DEV MODE', {
      fontSize: '32px',
      fill: '#ff00ff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(9001);
    this.devModeElements.push(title);

    // ÏÑúÎ∏åÌÉÄÏù¥ÌãÄ
    const subtitle = this.add.text(width / 2, 60, 'Stage Select', {
      fontSize: '16px',
      fill: '#aaaaaa'
    }).setOrigin(0.5).setDepth(9001);
    this.devModeElements.push(subtitle);

    // Ïä§ÌÖåÏù¥ÏßÄ Î™©Î°ù ÏòÅÏó≠
    const listY = 100;
    const listHeight = height - 180;
    const itemHeight = 26;
    const visibleItems = Math.max(1, Math.floor(listHeight / itemHeight));
    const contentStartY = listY + 25;
    this.devListConfig = { listY, listHeight, itemHeight, visibleItems, contentStartY };
    this.devScrollOffset = 0;

    // 1~17 Ïä§ÌÖåÏù¥ÏßÄ + 18ÌÉÑ Phase1/Phase2 (19ÌÉÑ Ïù¥ÌõÑ Ï†úÍ±∞)
    const allStages = Array.from({ length: 17 }, (_, i) => i + 1);

    let currentY = listY;
    const normalLabel = this.add.text(60, currentY, '[STAGES]', {
      fontSize: '14px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setDepth(9001);
    this.devModeElements.push(normalLabel);
    currentY += 25;

    // ÏùºÎ∞ò Ïä§ÌÖåÏù¥ÏßÄ (1~17)
    allStages.forEach((stage) => {
      const world = getWorldByStage(stage);
      const bossInfo = getBossInfoForStage(stage);

      let label = '';
      let color = '#ffffff';

      label = `Stage ${stage}`;
      if (world && world.name) {
        label += ` (${world.name})`;
      }
      if (bossInfo) {
        label += ' [BOSS]';
        color = '#ff6666';
      }

      if (stage === this.currentStage && !this.selectedDevPhase) {
        label = '> ' + label + ' <';
        color = '#00ffff';
      }

      const btn = this.add.text(80, contentStartY + (this.devStageButtons.length * itemHeight), label, {
        fontSize: '16px',
        fill: color,
        padding: { x: 8, y: 2 }
      }).setDepth(9001).setInteractive();

      btn.stageValue = stage;
      btn.originalColor = color;

      btn.on('pointerover', () => {
        if (this.selectedDevStage !== stage || this.selectedDevPhase) {
          btn.setFill('#ffff00');
        }
      });
      btn.on('pointerout', () => {
        if (this.selectedDevStage !== stage || this.selectedDevPhase) {
          btn.setFill(btn.originalColor);
        }
      });
      btn.on('pointerdown', () => {
        this.selectedDevStage = stage;
        this.selectedDevPhase = null;
        this.updateDevModeSelection();
      });

      this.devStageButtons.push(btn);
      this.devModeElements.push(btn);
      currentY += itemHeight;
    });

    // 18ÌÉÑ Phase 1 (Ghost Chase)
    const phase1Label = this.currentStage === 18 && this.selectedDevPhase === 'phase1'
      ? '> Stage 18 Phase 1 (Ghost Chase) <'
      : 'Stage 18 Phase 1 (Ghost Chase)';
    const phase1Color = this.currentStage === 18 && this.selectedDevPhase === 'phase1' ? '#00ffff' : '#ff00ff';

    const phase1Btn = this.add.text(80, contentStartY + (this.devStageButtons.length * itemHeight), phase1Label, {
      fontSize: '16px',
      fill: phase1Color,
      padding: { x: 8, y: 2 }
    }).setDepth(9001).setInteractive();

    phase1Btn.stageValue = 18;
    phase1Btn.phaseValue = 'phase1';
    phase1Btn.originalColor = '#ff00ff';

    phase1Btn.on('pointerover', () => {
      if (this.selectedDevStage !== 18 || this.selectedDevPhase !== 'phase1') {
        phase1Btn.setFill('#ffff00');
      }
    });
    phase1Btn.on('pointerout', () => {
      if (this.selectedDevStage !== 18 || this.selectedDevPhase !== 'phase1') {
        phase1Btn.setFill(phase1Btn.originalColor);
      }
    });
    phase1Btn.on('pointerdown', () => {
      this.selectedDevStage = 18;
      this.selectedDevPhase = 'phase1';
      this.updateDevModeSelection();
    });

    this.devStageButtons.push(phase1Btn);
    this.devModeElements.push(phase1Btn);

    // 18ÌÉÑ Phase 2 (Fourth Wall)
    const phase2Label = this.currentStage === 18 && this.selectedDevPhase === 'phase2'
      ? '> Stage 18 Phase 2 (Fourth Wall) <'
      : 'Stage 18 Phase 2 (Fourth Wall)';
    const phase2Color = this.currentStage === 18 && this.selectedDevPhase === 'phase2' ? '#00ffff' : '#ff00ff';

    const phase2Btn = this.add.text(80, contentStartY + (this.devStageButtons.length * itemHeight), phase2Label, {
      fontSize: '16px',
      fill: phase2Color,
      padding: { x: 8, y: 2 }
    }).setDepth(9001).setInteractive();

    phase2Btn.stageValue = 18;
    phase2Btn.phaseValue = 'phase2';
    phase2Btn.originalColor = '#ff00ff';

    phase2Btn.on('pointerover', () => {
      if (this.selectedDevStage !== 18 || this.selectedDevPhase !== 'phase2') {
        phase2Btn.setFill('#ffff00');
      }
    });
    phase2Btn.on('pointerout', () => {
      if (this.selectedDevStage !== 18 || this.selectedDevPhase !== 'phase2') {
        phase2Btn.setFill(phase2Btn.originalColor);
      }
    });
    phase2Btn.on('pointerdown', () => {
      this.selectedDevStage = 18;
      this.selectedDevPhase = 'phase2';
      this.updateDevModeSelection();
    });

    this.devStageButtons.push(phase2Btn);
    this.devModeElements.push(phase2Btn);

    // 18ÌÉÑ Runner Mode (ÏóîÎî©)
    const runnerLabel = this.selectedDevPhase === 'runner'
      ? '> Stage 18 Runner Mode (Ending) <'
      : 'Stage 18 Runner Mode (Ending)';
    const runnerColor = this.selectedDevPhase === 'runner' ? '#00ffff' : '#00ff00';

    const runnerBtn = this.add.text(80, contentStartY + (this.devStageButtons.length * itemHeight), runnerLabel, {
      fontSize: '16px',
      fill: runnerColor,
      padding: { x: 8, y: 2 }
    }).setDepth(9001).setInteractive();

    runnerBtn.stageValue = 18;
    runnerBtn.phaseValue = 'runner';
    runnerBtn.originalColor = '#00ff00';

    runnerBtn.on('pointerover', () => {
      if (this.selectedDevPhase !== 'runner') {
        runnerBtn.setFill('#ffff00');
      }
    });
    runnerBtn.on('pointerout', () => {
      if (this.selectedDevPhase !== 'runner') {
        runnerBtn.setFill(runnerBtn.originalColor);
      }
    });
    runnerBtn.on('pointerdown', () => {
      this.selectedDevStage = 18;
      this.selectedDevPhase = 'runner';
      this.updateDevModeSelection();
    });

    this.devStageButtons.push(runnerBtn);
    this.devModeElements.push(runnerBtn);

    // ÏïàÎÇ¥ ÌÖçÏä§Ìä∏
    const helpText = this.add.text(width / 2, height - 60, [
      'Arrow Keys: Select    ENTER: Start Stage',
      'ESC: Cancel'
    ].join('\n'), {
      fontSize: '14px',
      fill: '#888888',
      align: 'center'
    }).setOrigin(0.5).setDepth(9001);
    this.devModeElements.push(helpText);

    // ÏÑ†ÌÉù Ï¥àÍ∏∞Ìôî
    this.selectedDevStage = this.currentStage;
    this.selectedDevPhase = null; // 18ÌÉÑ phase ÏÑ†ÌÉùÏö©
    this.updateDevModeSelection();

    // ÌÇ§Î≥¥Îìú Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
    this.devModeKeyHandler = this.input.keyboard.on('keydown', (event) => {
      this.handleDevModeInput(event.key);
    });
  }

  // Í∞úÎ∞úÏûê Î™®Îìú UI ÏóÖÎç∞Ïù¥Ìä∏
  updateDevModeUI() {
    this.devStageButtons.forEach(btn => {
      const stage = btn.stageValue;
      const world = getWorldByStage(stage);
      const bossInfo = getBossInfoForStage(stage);

      let label = '';
      let color = '#ffffff';

      label = `Stage ${stage}`;
      if (world && world.name) {
        label += ` (${world.name})`;
      }
      if (bossInfo) {
        label += ' [BOSS]';
        color = '#ff6666';
      }

      if (stage === this.currentStage) {
        label = '> ' + label + ' <';
        color = '#00ffff';
      }

      btn.setText(label);
      btn.originalColor = color;

      if (this.selectedDevStage === stage) {
        btn.setFill('#ffff00');
      } else {
        btn.setFill(color);
      }
    });
    this.updateDevStageListLayout();
  }

  // ÏÑ†ÌÉù UI ÏóÖÎç∞Ïù¥Ìä∏
  updateDevModeSelection() {
    this.devStageButtons.forEach(btn => {
      const isSelected = btn.stageValue === this.selectedDevStage &&
        (btn.phaseValue === this.selectedDevPhase || (!btn.phaseValue && !this.selectedDevPhase));

      if (isSelected) {
        btn.setFill('#ffff00');
        btn.setFontStyle('bold');
      } else {
        btn.setFill(btn.originalColor);
        btn.setFontStyle('normal');
      }
    });
    this.ensureDevStageVisible();
  }

  // Ïä§ÌÅ¨Î°§ ÏòÅÏó≠Ïóê ÎßûÏ∂∞ Î≤ÑÌäº Î∞∞Ïπò
  updateDevStageListLayout() {
    if (!this.devListConfig) return;
    const { contentStartY, itemHeight, visibleItems } = this.devListConfig;

    this.devStageButtons.forEach((btn, index) => {
      const inView = index >= this.devScrollOffset && index < this.devScrollOffset + visibleItems;
      btn.setVisible(inView);
      if (inView) {
        btn.setY(contentStartY + (index - this.devScrollOffset) * itemHeight);
      }
    });
  }

  // ÏÑ†ÌÉùÎêú Ìï≠Î™©Ïù¥ ÌôîÎ©¥Ïóê Î≥¥Ïù¥ÎèÑÎ°ù Ïä§ÌÅ¨Î°§ Ï°∞Ï†ï
  ensureDevStageVisible() {
    if (!this.devListConfig) return;
    const { visibleItems } = this.devListConfig;
    const currentIndex = this.devStageButtons.findIndex(btn =>
      btn.stageValue === this.selectedDevStage &&
      (btn.phaseValue === this.selectedDevPhase || (!btn.phaseValue && !this.selectedDevPhase))
    );
    if (currentIndex === -1) return;

    if (currentIndex < this.devScrollOffset) {
      this.devScrollOffset = currentIndex;
    } else if (currentIndex >= this.devScrollOffset + visibleItems) {
      this.devScrollOffset = currentIndex - visibleItems + 1;
    }

    this.updateDevStageListLayout();
  }

  // Í∞úÎ∞úÏûê Î™®Îìú ÌÇ§Î≥¥Îìú ÏûÖÎ†• Ï≤òÎ¶¨
  handleDevModeInput(key) {
    if (!this.devModeEnabled) return;

    const currentIndex = this.devStageButtons.findIndex(btn =>
      btn.stageValue === this.selectedDevStage &&
      (btn.phaseValue === this.selectedDevPhase || (!btn.phaseValue && !this.selectedDevPhase))
    );

    switch (key) {
      case 'ArrowUp':
        if (currentIndex > 0) {
          const prevBtn = this.devStageButtons[currentIndex - 1];
          this.selectedDevStage = prevBtn.stageValue;
          this.selectedDevPhase = prevBtn.phaseValue || null;
          this.updateDevModeSelection();
        }
        break;
      case 'ArrowDown':
        if (currentIndex < this.devStageButtons.length - 1) {
          const nextBtn = this.devStageButtons[currentIndex + 1];
          this.selectedDevStage = nextBtn.stageValue;
          this.selectedDevPhase = nextBtn.phaseValue || null;
          this.updateDevModeSelection();
        }
        break;
      case 'Enter':
        this.startFromDevMode(this.selectedDevStage, this.selectedDevPhase);
        break;
      case 'Escape':
        this.closeDevMode();
        break;
    }
  }

  // ÏÑ†ÌÉùÌïú Ïä§ÌÖåÏù¥ÏßÄÏóêÏÑú ÏãúÏûë
  startFromDevMode(targetStage, targetPhase = null) {
    this.closeDevMode();

    this.currentStage = targetStage;
    this.devModeTargetPhase = targetPhase; // 18ÌÉÑ phase ÏßÅÏ†ë ÏßÑÏûÖÏö©

    // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.gameOver = false;

    // Ïä§ÌÖåÏù¥ÏßÄ Î¶¨ÏÖã (Í∞úÎ∞ú Î™®ÎìúÏö©)
    this.resetForDevMode();

    // 18ÌÉÑ phase ÏßÅÏ†ë ÏßÑÏûÖ
    if (targetStage === 18 && targetPhase) {
      this.showDevModeCountdown(() => {
        if (this.moveTimer) {
          this.moveTimer.paused = false;
        }
        this.startMultiverseCollapseWithPhase(targetPhase);
      });
      return;
    }

    // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ïó¨Î∂Ä
    const isBulletBoss = this.isBulletBossStage();
    const isFogBoss = this.isFogBossStage();
    const isGearTitan = this.isGearTitanStage();
    const isPoisonBoss = !isBulletBoss && !isFogBoss && !isGearTitan && !isMagnetarStage(this.currentStage) && !isMultiverseCollapseStage(this.currentStage) && (
      this.currentStage === this.testBossStage ||
      (this.currentStage > this.testBossStage && this.currentStage % this.bossStageInterval === 0)
    );

    // Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ ÏßÑÏûÖ (ÎèÖÍ∞úÍµ¨Î¶¨/ÌÉÑÎßâ/ÏïàÍ∞ú Î≥¥Ïä§Îßå)
    if (isPoisonBoss || isBulletBoss || isFogBoss) {
      this.enterBossStage();
    }

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ (12ÌÉÑ) ÏßÅÏ†ë ÏãúÏûë
    if (isGearTitan) {
      this.showDevModeCountdown(() => {
        this.bossMode = true;
        this.isBossStage = true;
        this.startGearTitanDirectBattle();
      });
      return;
    }

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌëúÏãú
    this.showDevModeCountdown(() => {
      if (this.moveTimer) {
        this.moveTimer.paused = false;
      }

      this.activateStageFeatures();
    });
  }

  // 18ÌÉÑ ÌäπÏ†ï phaseÎ°ú ÏßÅÏ†ë ÏßÑÏûÖ
  startMultiverseCollapseWithPhase(phase) {
    console.log(`üéÆ Starting Stage 18 directly with ${phase}`);

    this.bossMode = true;
    this.multiverseCollapseMode = true;
    this.multiverseCollapsePhase = 'intro';

    // Í∏∞Î≥∏ Ï¥àÍ∏∞Ìôî
    this.food = { x: -100, y: -100 };
    this.hideFoodGraphics();

    if (phase === 'phase1') {
      // Phase 1: Five Selves (Ghost Chase) ÏßÅÏ†ë ÏãúÏûë
      this.createSpaceBackground();
      this.time.delayedCall(500, () => {
        this.startPhase1FiveSelves();
      });
    } else if (phase === 'phase2') {
      // Phase 2: Fourth Wall ÏßÅÏ†ë ÏãúÏûë
      this.time.delayedCall(500, () => {
        this.startPhase2FourthWall();
      });
    } else if (phase === 'runner') {
      // Runner Mode (ÏóîÎî©) ÏßÅÏ†ë ÏãúÏûë
      this.time.delayedCall(500, () => {
        this.startRunnerTransition();
      });
    }
  }

  activateStageFeatures() {
    // ÏïàÍ∞ú Ïù∏Ìä∏Î°ú (World 2)
    if (shouldHaveFog(this.currentStage)) {
      this.startFogIntroIfNeeded();
    }

    // ÎèÖÍ∞ÄÏä§ ÏûêÍ∏∞Ïû• (World 4) - Stage 15Îäî NEXUS Ïù∏Ìä∏Î°ú ÌõÑ ÏãúÏûë
    if (shouldHaveGasZone(this.currentStage) && !isMagnetarStage(this.currentStage)) {
      this.time.delayedCall(1000, () => {
        this.startGasZone();
      });
    }

    // ÌÉÑÎßâ Î≥¥Ïä§ (Stage 6)
    if (this.isBulletBossStage()) {
      this.bossPhase = 'intro';
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.hideFoodGraphics();
      this.time.delayedCall(500, () => {
        this.startBulletBoss();
      });
    }

    // ÏïàÍ∞ú Î≥¥Ïä§ (Stage 9)
    if (this.isFogBossStage()) {
      this.bossPhase = 'intro';
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.hideFoodGraphics();
      this.time.delayedCall(500, () => {
        this.startFogBoss();
      });
    }

    // Poison Frog boss (every 3 stages except bullet/fog/Magnetar/Multiverse)
    const isPoisonBoss = !this.isBulletBossStage() && !this.isFogBossStage() && !isMagnetarStage(this.currentStage) && !isMultiverseCollapseStage(this.currentStage) && (
      this.currentStage === this.testBossStage ||
      (this.currentStage > this.testBossStage && this.currentStage % this.bossStageInterval === 0)
    );
    if (isPoisonBoss) {
      this.bossPhase = 'intro';
      this.food = { x: -100, y: -100 };
      this.bossIntroMoveCount = 0;
    }

    // Flux Maze Í∏∞Îä• ÌôúÏÑ±Ìôî (Stage 14) - Î†àÏù¥Ï†Ä ÌÑ∞Î†õ ÏãúÏä§ÌÖú
    if (shouldHaveLaserTurrets(this.currentStage)) {
      this.time.delayedCall(1000, () => {
        this.initLaserTurrets();
      });
    }

    if (shouldHaveFloatingMines(this.currentStage)) {
      this.time.delayedCall(2000, () => {
        this.startMineSpawner();
      });
    }

    // NEXUS Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 15)
    if (isMagnetarStage(this.currentStage)) {
      this.bossPhase = 'intro';
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.hideFoodGraphics();
      this.time.delayedCall(500, () => {
        this.startNexusBoss();
      });
    }

    // Meta Universe Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 16-18)
    if (isMetaUniverseStage(this.currentStage) && this.currentStage === 16) {
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.time.delayedCall(500, () => {
        this.showMetaUniverseIntro();
      });
    }

    // Quantum Split Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 17)
    if (isQuantumSplitStage(this.currentStage)) {
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.time.delayedCall(500, () => {
        this.showQuantumSplitIntro();
      });
    }

    // Multiverse Collapse Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ Ï≤¥ÌÅ¨ (Stage 18)
    if (isMultiverseCollapseStage(this.currentStage)) {
      this.food = { x: -100, y: -100 };
      this.moveTimer.paused = true;
      this.time.delayedCall(500, () => {
        this.startMultiverseCollapseBoss();
      });
    }
  }

  // Í∞úÎ∞úÏûê Î™®ÎìúÏö© Í≤åÏûÑ ÏôÑÏ†Ñ Î¶¨ÏÖã
  resetForDevMode() {
    // Í∏∞Ï°¥ ÏÉÅÌÉú ÏôÑÏ†Ñ Ï†ïÎ¶¨
    this.cleanupSpeedBoostOrbitals();
    this.resetFogOfWar();
    this.stopDarkCreepCycle();
    this.stopStage8GhostSpawning();
    this.destroyAllSaws();
    this.stopGasZone();

    // Flux Maze ÏãúÏä§ÌÖú Ï†ïÎ¶¨
    this.stopPolaritySystem();
    this.cleanupMagneticTurrets();
    this.cleanupLaserTurrets();
    this.cleanupFloatingMines();

    // NEXUS Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.nexusMode) {
      this.cleanupNexus();
    }

    // Meta Universe Ï†ïÎ¶¨
    if (this.metaUniverseMode) {
      this.cleanupMetaUniverse();
    }

    // Quantum Split Ï†ïÎ¶¨
    if (this.quantumSplitMode) {
      this.cleanupQuantumSplit();
    }

    // Multiverse Collapse Ï†ïÎ¶¨
    if (this.multiverseCollapseMode) {
      this.cleanupMultiverseCollapse();
    }

    // ÏïàÍ∞ú Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.fogBossMode) {
      this.cleanupFogBoss();
    }

    // ÌÉÑÎßâ Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.bulletBossMode) {
      this.cleanupBulletBoss();
    }

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ Ï†ïÎ¶¨
    if (this.gearTitanMode) {
      this.cleanupGearTitan();
    }

    // Í∏∞Ï°¥ Î≥¥Ïä§ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.bossElement) {
      this.bossElement.destroy();
      this.bossElement = null;
    }

    // Î±Ä Ï¥àÍ∏∞Ìôî
    this.snake = [
      { x: 10, y: 15 },
      { x: 9, y: 15 },
      { x: 8, y: 15 }
    ];
    this.direction = 'RIGHT';
    this.inputQueue = [];

    // Ï†êÏàò/Î®πÏù¥ Î¶¨ÏÖã
    this.score = 0;
    this.scoreText.setText('0');
    this.foodCount = 0;
    this.foodCountText.setText('0');

    // ÏΩ§Î≥¥ Î¶¨ÏÖã
    this.combo = 0;
    this.comboText.setText('');
    this.directionChangesCount = 0;

    // Î≥¥Ïä§ ÏÉÅÌÉú ÏôÑÏ†Ñ Î¶¨ÏÖã
    this.bossMode = false;
    this.isBossStage = false;
    this.bossPhase = 'none';
    this.bossHitCount = 0;
    this.snakePoisoned = false;
    this.poisonGrowthActive = false;
    this.poisonGrowthData = null;

    // ÌÉÑÎßâ Î≥¥Ïä§ ÏÉÅÌÉú Î¶¨ÏÖã
    this.bulletBossMode = false;
    this.bulletBossPhase = 'none';
    this.bulletBossHitCount = 0;
    this.bulletBossPosition = null;
    this.bullets = [];

    // ÏïàÍ∞ú Î≥¥Ïä§ ÏÉÅÌÉú Î¶¨ÏÖã
    this.fogBossMode = false;
    this.fogBossPhase = 'none';
    this.fogBossHitCount = 0;
    this.fogBossPosition = null;
    this.fogIntroShown = false;

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§ ÏÉÅÌÉú Î¶¨ÏÖã
    this.gearTitanMode = false;
    this.gearTitanPhase = 'none';
    this.gearTitanPosition = null;
    this.gearTitanHitCount = 0;
    this.gearTitanVulnerable = false;
    this.gearTitanStunEndTime = 0;
    this.canChargeDash = false;
    this.isCharging = false;
    this.chargeReady = false;
    this.isDashing = false;
    this.dashingHideSnake = false;
    this.isOverheated = false;
    this.overheatEndTime = 0;
    this.isInvincible = false;

    // Í∏∞ÌÉÄ ÏÉÅÌÉú Î¶¨ÏÖã
    this.hasEatenFirstFood = false;
    this.comboLost = false;
    this.shieldsUsedThisCycle = false;

    // Î™®Îì† Ïä§ÌÖåÏù¥ÏßÄ ÏãúÏûë ÏÜçÎèÑ 90ms Í≥†Ï†ï
    const startSpeed = 90;
    if (this.moveTimer) {
      this.moveTimer.delay = startSpeed;
      this.moveTimer.paused = true; // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ Ïû¨Í∞ú
    }
    this.speedText.setText(startSpeed + 'ms');

    // Î®πÏù¥ ÏÉùÏÑ± (Stage 15 NEXUS Î≥¥Ïä§ÏóêÏÑúÎäî Î®πÏù¥ ÏóÜÏùå)
    if (isNexusStage(this.currentStage)) {
      this.food = null;
    } else {
      this.food = this.generateFood();
    }

    // Í∑∏ÎûòÌîΩ ÏóÖÎç∞Ïù¥Ìä∏
    this.draw();

    // ÏïÑÏù¥ÌÖú ÏÉÅÌÉú UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updateItemStatusUI();
  }

  // Í∞úÎ∞úÏûê Î™®Îìú Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
  showDevModeCountdown(callback) {
    const { width, height } = this.cameras.main;
    let count = 3;

    // Ïä§ÌÖåÏù¥ÏßÄ ÌëúÏãú
    const stageLabel = `STAGE ${this.currentStage}`;

    const world = getWorldByStage(this.currentStage);
    const worldName = world && world.name ? ` - ${world.name}` : '';

    const stageText = this.add.text(width / 2, height / 2 - 80, stageLabel + worldName, {
      fontSize: '28px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(5000);

    const countText = this.add.text(width / 2, height / 2, count.toString(), {
      fontSize: '96px',
      fill: '#ffffff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000);

    const countdownTimer = this.time.addEvent({
      delay: 600,
      callback: () => {
        count--;
        if (count > 0) {
          countText.setText(count.toString());
          // ÌéÑÏä§ Ìö®Í≥º
          this.tweens.add({
            targets: countText,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 100,
            yoyo: true
          });
        } else if (count === 0) {
          countText.setText('GO!');
          countText.setFill('#00ff00');
        } else {
          stageText.destroy();
          countText.destroy();
          callback();
        }
      },
      repeat: 3
    });
  }

  // Í∞úÎ∞úÏûê Î™®Îìú Îã´Í∏∞
  closeDevMode() {
    if (!this.devModeEnabled) return;

    this.devModeEnabled = false;

    // UI Ï†ïÎ¶¨
    this.devModeElements.forEach(el => {
      if (el && el.destroy) {
        el.destroy();
      }
    });
    this.devModeElements = [];
    this.devStageButtons = [];
    this.devListConfig = null;
    this.devScrollOffset = 0;

    // ÌÇ§Î≥¥Îìú Ìï∏Îì§Îü¨ Ï†úÍ±∞
    if (this.devModeKeyHandler) {
      this.input.keyboard.off('keydown', this.devModeKeyHandler);
      this.devModeKeyHandler = null;
    }

    // Í≤åÏûÑ Ïû¨Í∞ú
    if (this.moveTimer && !this.gameOver) {
      this.moveTimer.paused = false;
    }
  }

  // Í≤åÏûÑ ÏãúÏûë Ïä§ÌÖåÏù¥ÏßÄ Í≤∞Ï†ï
  determineStartStage() {
    return 1;
  }

  // ÏõîÎìú Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (UI ÌëúÏãúÏö©)
  getWorldDisplayInfo(stage) {
    const world = getWorldByStage(stage);
    return {
      name: world.name || 'Unknown',
      nameKo: world.nameKo || world.name || 'Unknown',
      color: '#00ff00'
    };
  }

  // =====================================================
  // ==================== META UNIVERSE (Stage 16-18) ====================
  // =====================================================

  /**
   * Meta Universe Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§ ÏãúÏûë
   * 1. ÏΩ§Î≥¥ UI ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
   * 2. Î±Ä "what..?" ÎåÄÏÇ¨
   * 3. Universe 1 ÌÉÄÏù¥ÌãÄ ÌëúÏãú
   * 4. 3-2-1-GO Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
   */
  showMetaUniverseIntro() {
    if (this.metaUniverseIntroShown) return;
    this.metaUniverseIntroShown = true;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // 1. ÏΩ§Î≥¥ UI ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.destroyComboUI(() => {
      // 2. Î±Ä ÎåÄÏÇ¨ "what..?"
      this.showMetaUniverseSnakeDialogue(() => {
        // 3. Universe 1 ÌÉÄÏù¥ÌãÄ ÌëúÏãú
        this.showUniverseTitle(1, () => {
          // 4. Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ Í≤åÏûÑ ÏãúÏûë
          this.startMetaUniverseCountdown();
        });
      });
    });
  }

  /**
   * ÏΩ§Î≥¥ UI ÌååÍ¥¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
   * COMBO ÌÖçÏä§Ìä∏Í∞Ä ÏßÄÏßÑÏ≤òÎüº Í≤©Î†¨Ìûà ÌùîÎì§Î¶¨Îã§Í∞Ä Ìè≠Î∞úÌïòÎìØ Íπ®ÏßÄÎäî Ìö®Í≥º
   */
  destroyComboUI(callback) {
    const { width, height } = this.cameras.main;

    // ÏΩ§Î≥¥ ÎπÑÌôúÏÑ±Ìôî
    this.comboDisabled = true;

    // comboTextÍ∞Ä ÏóÜÍ±∞ÎÇò Ïù¥ÎØ∏ ÌååÍ¥¥ÎêêÏúºÎ©¥ Î∞îÎ°ú ÏΩúÎ∞±
    if (!this.comboText || !this.comboText.active) {
      if (callback) callback();
      return;
    }

    const comboX = this.comboText.x;
    const comboY = this.comboText.y;

    // 1Îã®Í≥Ñ: Ïπ¥Î©îÎùº ÎØ∏ÏÑ∏ ÏßÑÎèô ÏãúÏûë (ÏßÄÏßÑ Ï†ÑÏ°∞)
    let earthquakeTimer = 0;
    const earthquakeEvent = this.time.addEvent({
      delay: 16,
      callback: () => {
        earthquakeTimer++;
        // Ï†êÏ†ê Í∞ïÌï¥ÏßÄÎäî ÌùîÎì§Î¶º
        const intensity = Math.min(earthquakeTimer / 30, 1);
        const shakeX = (Math.random() - 0.5) * 8 * intensity;
        const shakeY = (Math.random() - 0.5) * 6 * intensity;
        this.cameras.main.setScroll(shakeX, shakeY);
      },
      loop: true
    });

    // 2Îã®Í≥Ñ: ÏΩ§Î≥¥ ÌÖçÏä§Ìä∏ Í≤©Î†¨Ìïú ÌùîÎì§Î¶º (800ms)
    // Ï¢åÏö∞Îøê ÏïÑÎãàÎùº ÏÉÅÌïò, ÌöåÏ†Ñ, Ïä§ÏºÄÏùºÍπåÏßÄ Ï∂îÍ∞Ä
    this.tweens.add({
      targets: this.comboText,
      x: { value: comboX + 15, duration: 30, yoyo: true, repeat: 25 },
      y: { value: comboY + 8, duration: 40, yoyo: true, repeat: 19 },
      angle: { value: 5, duration: 50, yoyo: true, repeat: 15 },
      scaleX: { value: 1.1, duration: 60, yoyo: true, repeat: 12 },
      duration: 800,
      onUpdate: () => {
        // ÎûúÎç§ ÏÉâÏÉÅ ÍπúÎπ°ÏûÑ (Î∂àÏïàÏ†ïÌïú ÎäêÎÇå)
        if (Math.random() < 0.3) {
          const colors = ['#ffff00', '#ff0000', '#ff6600', '#ffffff'];
          this.comboText.setColor(colors[Math.floor(Math.random() * colors.length)]);
        }
      },
      onComplete: () => {
        // ÏßÄÏßÑ Î©àÏ∂§
        earthquakeEvent.destroy();
        this.cameras.main.setScroll(0, 0);

        // Í∞ïÎ†•Ìïú Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨!
        this.cameras.main.shake(300, 0.02);

        // Ìè≠Î∞ú ÌîåÎûòÏãú (Ï†ÑÏ≤¥ ÌôîÎ©¥)
        const bigFlash = this.add.rectangle(width / 2, height / 2, width, height, 0xffffff, 0.6)
          .setDepth(6000);
        this.tweens.add({
          targets: bigFlash,
          alpha: 0,
          duration: 200,
          onComplete: () => bigFlash.destroy()
        });

        // Íπ®ÏßÄÎäî ÌååÌã∞ÌÅ¥ Ìö®Í≥º (16Î∞©Ìñ•, Îçî ÎßéÏùÄ Ï°∞Í∞Å)
        for (let i = 0; i < 16; i++) {
          const angle = (i / 16) * Math.PI * 2;
          const speed = 80 + Math.random() * 60;
          const fragment = this.add.text(comboX, comboY, '‚ñ†', {
            fontSize: (10 + Math.random() * 8) + 'px',
            fill: Math.random() < 0.5 ? '#ffff00' : '#ff6600'
          }).setOrigin(0.5).setDepth(5000);

          this.tweens.add({
            targets: fragment,
            x: comboX + Math.cos(angle) * speed,
            y: comboY + Math.sin(angle) * speed + 30, // Ï§ëÎ†• Ìö®Í≥º
            alpha: 0,
            angle: Phaser.Math.Between(-360, 360),
            scaleX: 0.3,
            scaleY: 0.3,
            duration: 600,
            ease: 'Power2',
            onComplete: () => fragment.destroy()
          });
        }

        // "CRACK!" ÌÖçÏä§Ìä∏ Ìö®Í≥º
        const crackText = this.add.text(comboX, comboY, 'CRACK!', {
          fontSize: '28px',
          fill: '#ff3300',
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 3
        }).setOrigin(0.5).setDepth(5001);

        this.tweens.add({
          targets: crackText,
          y: comboY - 40,
          alpha: 0,
          scaleX: 1.5,
          scaleY: 1.5,
          duration: 500,
          ease: 'Power2',
          onComplete: () => crackText.destroy()
        });

        // ÏΩ§Î≥¥ ÌÖçÏä§Ìä∏ Ïà®Í∏∞Í∏∞
        this.comboText.setVisible(false);
        this.comboText.setText('');
        this.comboText.setColor('#ffff00'); // ÏÉâÏÉÅ Î≥µÏõê

        this.time.delayedCall(500, () => {
          if (callback) callback();
        });
      }
    });
  }

  /**
   * Meta Universe Î±Ä ÎåÄÏÇ¨ ÌëúÏãú ("what..?")
   */
  showMetaUniverseSnakeDialogue(callback) {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubble = this.add.rectangle(headX, headY - 50, 120, 40, 0xffffff, 0.95)
      .setDepth(5001).setScale(0).setStrokeStyle(2, 0x000000);

    this.tweens.add({
      targets: bubble,
      scale: 1,
      duration: 200,
      ease: 'Back.easeOut'
    });

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º ÌÖçÏä§Ìä∏
    const dialogue = "what..?";
    const dialogueText = this.add.text(headX, headY - 50, '', {
      fontSize: '14px',
      fill: '#000000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(5002);

    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 80,
      callback: () => {
        dialogueText.setText(dialogue.substring(0, charIndex + 1));
        charIndex++;
        if (charIndex >= dialogue.length) {
          typeTimer.destroy();
          // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ ÌéòÏù¥ÎìúÏïÑÏõÉ
          this.time.delayedCall(600, () => {
            this.tweens.add({
              targets: [bubble, dialogueText],
              alpha: 0,
              duration: 200,
              onComplete: () => {
                bubble.destroy();
                dialogueText.destroy();
                if (callback) callback();
              }
            });
          });
        }
      },
      loop: true
    });
  }

  /**
   * Universe ÌÉÄÏù¥ÌãÄ ÌëúÏãú (ÌôîÎ©¥ Ï§ëÏïôÏóê ÌùêÎ¶øÌïòÍ≤å)
   */
  showUniverseTitle(universeNum, callback) {
    const { width, height } = this.cameras.main;
    const color = this.universeColors[universeNum - 1];
    const colorHex = '#' + color.toString(16).padStart(6, '0');

    // Í∏∞Ï°¥ ÌÉÄÏù¥ÌãÄ Ï†úÍ±∞
    if (this.universeTitle) {
      this.universeTitle.destroy();
    }

    // ÏÉà ÌÉÄÏù¥ÌãÄ ÏÉùÏÑ±
    this.universeTitle = this.add.text(width / 2, height / 2, `Universe ${universeNum}`, {
      fontSize: '48px',
      fill: colorHex,
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(100).setAlpha(0);

    // ÌéòÏù¥ÎìúÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: this.universeTitle,
      alpha: 0.3,
      duration: 500,
      ease: 'Power2',
      onComplete: () => {
        if (callback) callback();
      }
    });
  }

  /**
   * Universe ÌÉÄÏù¥ÌãÄ ÏóÖÎç∞Ïù¥Ìä∏ (Universe Ï†ÑÌôò Ïãú)
   */
  updateUniverseTitle(universeNum) {
    const { width, height } = this.cameras.main;
    const color = this.universeColors[universeNum - 1];
    const colorHex = '#' + color.toString(16).padStart(6, '0');

    if (this.universeTitle) {
      // Í∏∞Ï°¥ ÌÉÄÏù¥ÌãÄ ÌéòÏù¥ÎìúÏïÑÏõÉ
      this.tweens.add({
        targets: this.universeTitle,
        alpha: 0,
        duration: 200,
        onComplete: () => {
          this.universeTitle.setText(`Universe ${universeNum}`);
          this.universeTitle.setColor(colorHex);
          // ÌéòÏù¥ÎìúÏù∏
          this.tweens.add({
            targets: this.universeTitle,
            alpha: 0.3,
            duration: 200
          });
        }
      });
    } else {
      this.showUniverseTitle(universeNum);
    }
  }

  /**
   * Meta Universe Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ Í≤åÏûÑ ÏãúÏûë
   */
  startMetaUniverseCountdown() {
    const { width, height } = this.cameras.main;

    let countdown = 3;
    const countdownText = this.add.text(width / 2, height / 2 - 80, countdown.toString(), {
      fontSize: '72px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#003300',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(5000);

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(100, 0.005);

    const countdownTimer = this.time.addEvent({
      delay: 600,
      callback: () => {
        countdown--;
        if (countdown > 0) {
          countdownText.setText(countdown.toString());
          this.cameras.main.shake(100, 0.005);
          // Ïä§ÏºÄÏùº ÌéÄÏπò Ìö®Í≥º
          this.tweens.add({
            targets: countdownText,
            scaleX: 1.3,
            scaleY: 1.3,
            duration: 100,
            yoyo: true
          });
        } else if (countdown === 0) {
          countdownText.setText('GO!');
          countdownText.setColor('#ffff00');
          this.cameras.main.shake(200, 0.01);
        } else {
          countdownText.destroy();
          countdownTimer.destroy();
          // Í≤åÏûÑ ÏãúÏûë!
          this.metaUniverseMode = true;
          this.foodUniverse = this.currentUniverse; // Ï≤´ Î®πÏù¥Îäî ÌòÑÏû¨ UniverseÏóê
          this.food = this.generateFood(); // Ï≤´ Î®πÏù¥ ÏÉùÏÑ±
          this.draw();
          this.moveTimer.paused = false;
        }
      },
      loop: true
    });
  }

  /**
   * ÏõúÌôÄ 5Í∞ú ÏÉùÏÑ± (ÌòÑÏû¨ Universe Ï†úÏô∏)
   */
  createWormholes() {
    // Í∏∞Ï°¥ ÏõúÌôÄ Ï†úÍ±∞
    this.destroyWormholes();

    // ÌòÑÏû¨ Universe Ï†úÏô∏Ìïú 5Í∞ú Universe ÏÑ†ÌÉù
    const otherUniverses = [1, 2, 3, 4, 5, 6].filter(u => u !== this.currentUniverse);

    otherUniverses.forEach(targetUniverse => {
      const color = this.universeColors[targetUniverse - 1];

      // ÎûúÎç§ ÏúÑÏπò (Î±Ä, Î®πÏù¥, Î≤ΩÍ≥º Ïïà Í≤πÏπòÍ≤å)
      let x, y;
      let attempts = 0;
      do {
        x = Phaser.Math.Between(2, this.cols - 3);
        y = Phaser.Math.Between(2, this.rows - 3);
        attempts++;
      } while (this.isPositionOccupied(x, y) && attempts < 100);

      if (attempts >= 100) {
        console.warn('Could not find valid position for wormhole');
        return;
      }

      // ÏõúÌôÄ Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
      const pixelX = x * this.gridSize + this.gridSize / 2;
      const pixelY = y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      const container = this.add.container(pixelX, pixelY).setDepth(500);

      // ÏÜåÏö©ÎèåÏù¥ Í∑∏ÎûòÌîΩ
      this.gridGraphics = this.add.graphics();
    const graphics = this.gridGraphics;
      container.add(graphics);

      // ÏõúÌôÄ Î≤àÌò∏ ÌÖçÏä§Ìä∏
      const label = this.add.text(0, 0, targetUniverse.toString(), {
        fontSize: '14px',
        fill: '#ffffff',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 2
      }).setOrigin(0.5);
      container.add(label);

      const wormhole = {
        x,
        y,
        targetUniverse,
        color,
        container,
        graphics,
        label,
        angle: 0,
        pulsePhase: Math.random() * Math.PI * 2
      };

      this.wormholes.push(wormhole);
    });

    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
    this.startWormholeAnimation();
  }

  /**
   * ÏõúÌôÄ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë (60fps)
   */
  startWormholeAnimation() {
    if (this.wormholeAnimTimer) {
      this.wormholeAnimTimer.destroy();
    }

    this.wormholeAnimTimer = this.time.addEvent({
      delay: 16,
      callback: () => this.updateWormholeAnimation(),
      loop: true
    });
  }

  /**
   * ÏõúÌôÄ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateWormholeAnimation() {
    const time = this.time.now;

    this.wormholes.forEach(wormhole => {
      if (!wormhole.graphics || !wormhole.graphics.active) return;

      wormhole.graphics.clear();

      // ÌöåÏ†Ñ Í∞ÅÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
      wormhole.angle += 0.05;

      // ÌéÑÏä§ ÌÅ¨Í∏∞
      const pulseScale = 1 + Math.sin(time * 0.005 + wormhole.pulsePhase) * 0.2;
      const baseRadius = this.gridSize * 0.8 * pulseScale;

      // ÏÜåÏö©ÎèåÏù¥ Í∑∏Î¶¨Í∏∞ (Ïó¨Îü¨ Ï∏µ)
      for (let i = 4; i >= 0; i--) {
        const radius = baseRadius * (1 - i * 0.15);
        const alpha = 0.3 + i * 0.15;
        const color = Phaser.Display.Color.IntegerToColor(wormhole.color);
        const darkenFactor = 1 - i * 0.1;

        wormhole.graphics.lineStyle(3, Phaser.Display.Color.GetColor(
          color.red * darkenFactor,
          color.green * darkenFactor,
          color.blue * darkenFactor
        ), alpha);

        // ÎÇòÏÑ†Ìòï Í∑∏Î¶¨Í∏∞
        wormhole.graphics.beginPath();
        for (let a = 0; a < Math.PI * 4; a += 0.2) {
          const spiralRadius = radius * (1 - a / (Math.PI * 6));
          const spiralX = Math.cos(a + wormhole.angle + i * 0.5) * spiralRadius;
          const spiralY = Math.sin(a + wormhole.angle + i * 0.5) * spiralRadius;
          if (a === 0) {
            wormhole.graphics.moveTo(spiralX, spiralY);
          } else {
            wormhole.graphics.lineTo(spiralX, spiralY);
          }
        }
        wormhole.graphics.strokePath();
      }

      // Ï§ëÏã¨ Í∏ÄÎ°úÏö∞
      wormhole.graphics.fillStyle(wormhole.color, 0.5);
      wormhole.graphics.fillCircle(0, 0, baseRadius * 0.3);

      // Ïô∏Í≥Ω ÎßÅ
      wormhole.graphics.lineStyle(2, wormhole.color, 0.8);
      wormhole.graphics.strokeCircle(0, 0, baseRadius);
    });
  }

  /**
   * ÏõúÌôÄ Ï†úÍ±∞
   */
  destroyWormholes() {
    if (this.wormholeAnimTimer) {
      this.wormholeAnimTimer.destroy();
      this.wormholeAnimTimer = null;
    }

    this.wormholes.forEach(wormhole => {
      if (wormhole.container) wormhole.container.destroy();
    });
    this.wormholes = [];
  }

  /**
   * ÏúÑÏπòÍ∞Ä Ï†êÏú†ÎêòÏóàÎäîÏßÄ Ï≤¥ÌÅ¨ (Î±Ä, Î®πÏù¥, Îã§Î•∏ ÏõúÌôÄ)
   */
  isPositionOccupied(x, y) {
    // Î±Ä Ï≤¥ÌÅ¨
    if (this.snake.some(seg => seg.x === x && seg.y === y)) return true;

    // Î®πÏù¥ Ï≤¥ÌÅ¨
    if (this.food && this.food.x === x && this.food.y === y) return true;

    // Îã§Î•∏ ÏõúÌôÄ Ï≤¥ÌÅ¨
    if (this.wormholes.some(w => w.x === x && w.y === y)) return true;

    // Îç∞ÎìúÏ°¥ Ï≤¥ÌÅ¨
    if (this.deadZones.some(dz => dz.x === x && dz.y === y)) return true;

    return false;
  }

  /**
   * ÏõúÌôÄ Ï∂©Îèå Ï≤¥ÌÅ¨
   * @returns {object|null} Ï∂©ÎèåÌïú ÏõúÌôÄ ÎòêÎäî null
   */
  checkWormholeCollision() {
    const head = this.snake[0];

    for (const wormhole of this.wormholes) {
      if (head.x === wormhole.x && head.y === wormhole.y) {
        return wormhole;
      }
    }
    return null;
  }

  /**
   * Universe Ï†ÑÌôò ÏãúÏûë
   */
  startUniverseTransition(targetUniverse, entryX, entryY) {
    if (this.isUniverseTransitioning) return;
    this.isUniverseTransitioning = true;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // ÏõúÌôÄ Ï†úÍ±∞
    this.destroyWormholes();

    // ÏÜçÎèÑ Ï¶ùÍ∞Ä (ÏõúÌôÄ ÌÜµÍ≥º Î≥¥ÎÑàÏä§)
    this.wormholePassCount++;
    this.moveTimer.delay = Math.max(50, this.moveTimer.delay - 3);
    this.speedText.setText(this.moveTimer.delay + 'ms');

    // Î±Ä Ï†ïÎ≥¥ Ï†ÄÏû• (ÏûîÏÉÅ Î∞©ÏßÄ)
    this.transitionSnakeLength = this.snake.length; // Í∏∏Ïù¥ Ï†ÄÏû•
    this.transitionEntryDirection = this.direction; // ÏßÑÏûÖ Î∞©Ìñ• Ï†ÄÏû•
    this.snake = [];
    this.food = { x: -100, y: -100 }; // Î®πÏù¥ÎèÑ Ïà®Í∏∞Í∏∞
    this.draw(); // ÌôîÎ©¥ÏóêÏÑú Ï†úÍ±∞

    // Ï†ÑÌôò Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.animateUniverseTransition(targetUniverse, entryX, entryY);
  }

  /**
   * Universe Ï†ÑÌôò Ïï†ÎãàÎ©îÏù¥ÏÖò (ÌïµÏã¨!)
   * Ï§åÏïÑÏõÉ ‚Üí Î©ÄÌã∞Î≤ÑÏä§ Í≥µÍ∞ú ‚Üí Ïù¥Îèô+Ï§åÏù∏ ‚Üí Î±Ä Îì±Ïû•
   *
   * ÏÜçÎèÑ ÏµúÏ†ÅÌôî: 300ms Ï§åÏïÑÏõÉ + 400ms Ïù¥Îèô/Ï§åÏù∏ = 700ms Ï¥ù
   */
  animateUniverseTransition(targetUniverse, entryX, entryY) {
    const { width, height } = this.cameras.main;

    // ÌòÑÏû¨ Universe ÏúÑÏπò Í≥ÑÏÇ∞ (3x2 Í∑∏Î¶¨ÎìúÏóêÏÑú)
    const currentCol = (this.currentUniverse - 1) % 3;
    const currentRow = Math.floor((this.currentUniverse - 1) / 3);

    // Ïπ¥Î©îÎùºÍ∞Ä ÌòÑÏû¨ Universe Ï§ëÏã¨ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú ÏÑ§Ï†ï (Ï§åÏïÑÏõÉ Ï†Ñ Ïä§ÌÅ¨Î°§ ÏúÑÏπò)
    // ÌòÑÏû¨ UniverseÍ∞Ä Ï§ëÏïôÏù¥ ÏïÑÎãå Í≤ΩÏö∞ Ïò§ÌîÑÏÖã ÌïÑÏöî
    const currentOffsetX = (currentCol - 1) * width;
    const currentOffsetY = currentRow * height;

    // 1. Î©ÄÌã∞Î≤ÑÏä§ Î∑∞ ÏÉùÏÑ± (ÌòÑÏû¨ ÌôîÎ©¥ Î≥µÏ†ú)
    this.createMultiverseView();

    // Ïπ¥Î©îÎùºÎ•º ÌòÑÏû¨ Universe ÏúÑÏπòÎ°ú Ïä§ÌÅ¨Î°§ (Ï§åÏïÑÏõÉ Ïãú ÌòÑÏû¨ ÏúÑÏπò Í∏∞Ï§ÄÏù¥ Îê®)
    this.cameras.main.setScroll(currentOffsetX, currentOffsetY);

    // 2. Ï§åÏïÑÏõÉ + Î©ÄÌã∞Î≤ÑÏä§ Í≥µÍ∞ú (300ms - Îπ†Î•¥Í≤å!)
    this.cameras.main.zoomTo(0.25, 300, 'Power2');

    // Î©ÄÌã∞Î≤ÑÏä§ ÏöîÏÜåÎì§ Ï¶âÏãú ÌéòÏù¥ÎìúÏù∏
    this.time.delayedCall(50, () => {
      this.multiverseElements.forEach(el => {
        if (el && el.active) {
          this.tweens.add({
            targets: el,
            alpha: 1,
            duration: 250
          });
        }
      });
    });

    // 3. Ïù¥Îèô + Ï§åÏù∏ ÎèôÏãúÏóê (400ms - Îπ†Î•¥Í≤å!) - 300ms ÌõÑ ÏãúÏûë
    this.time.delayedCall(300, () => {
      // Î™©Ìëú Universe ÏúÑÏπò Í≥ÑÏÇ∞ (3x2 Í∑∏Î¶¨Îìú)
      const gridCol = (targetUniverse - 1) % 3;
      const gridRow = Math.floor((targetUniverse - 1) / 3);

      // ÌôïÏû•Îêú ÏõîÎìúÏóêÏÑúÏùò Î™©Ìëú ÏúÑÏπò (Ïä§ÌÅ¨Î°§ Ïò§ÌîÑÏÖã)
      const targetScrollX = (gridCol - 1) * width;
      const targetScrollY = gridRow * height;

      // pan ÎåÄÏã† scroll ÏßÅÏ†ë Ìä∏Ïúà (Îçî Ï†ïÌôïÌïú Ï†úÏñ¥)
      this.tweens.add({
        targets: this.cameras.main,
        scrollX: targetScrollX,
        scrollY: targetScrollY,
        duration: 400,
        ease: 'Power3'
      });

      this.cameras.main.zoomTo(1, 400, 'Power3');

      // Î™©Ìëú Universe ÌïòÏù¥ÎùºÏù¥Ìä∏
      this.highlightTargetUniverse(targetUniverse);
    });

    // 4. Ï†ÑÌôò ÏôÑÎ£å ÌõÑ Ï†ïÎ¶¨ (700ms ÌõÑ - Ï¥ù ÏãúÍ∞Ñ Îã®Ï∂ï!)
    this.time.delayedCall(700, () => {
      // Î®ºÏ†Ä Ïπ¥Î©îÎùº Í¥ÄÎ†® tween Î™®Îëê Ï§ëÏßÄ
      this.tweens.killTweensOf(this.cameras.main);

      // Î©ÄÌã∞Î≤ÑÏä§ Î∑∞ Ï†ïÎ¶¨
      this.cleanupMultiverseView();

      // Ïπ¥Î©îÎùº ÏôÑÏ†Ñ Î¶¨ÏÖã (Ï§ëÏöî!)
      this.cameras.main.stopFollow();
      this.cameras.main.setScroll(0, 0);
      this.cameras.main.setZoom(1);
      this.cameras.main.setRotation(0);

      // Universe Î≥ÄÍ≤Ω
      this.currentUniverse = targetUniverse;

      // Î±Ä ÎåÄÏπ≠ ÏúÑÏπòÏóêÏÑú Îì±Ïû•
      const exitPos = this.calculateSymmetricPosition(entryX, entryY);
      this.spawnSnakeFromWormhole(exitPos.x, exitPos.y);
    });
  }

  /**
   * Î©ÄÌã∞Î≤ÑÏä§ Î∑∞ ÏÉùÏÑ± (6Í∞ú Universe Í∑∏Î¶¨Îìú)
   * Ï¢åÌëúÍ≥Ñ: Í∞Å UniverseÎäî (gridCol-1)*width, gridRow*height Ïò§ÌîÑÏÖã
   */
  createMultiverseView() {
    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ ÏöîÏÜå Ï†ïÎ¶¨
    this.cleanupMultiverseView();

    // 6Í∞ú Universe ÏúÑÏπò (3x2 Í∑∏Î¶¨Îìú)
    // Universe 1: (0, 0), Universe 2: (1, 0), Universe 3: (2, 0)
    // Universe 4: (0, 1), Universe 5: (1, 1), Universe 6: (2, 1)
    for (let i = 1; i <= 6; i++) {
      const gridCol = (i - 1) % 3;  // 0, 1, 2
      const gridRow = Math.floor((i - 1) / 3);  // 0, 1

      // Ï†àÎåÄ Ï¢åÌëú (scrollFactor 1 Í∏∞Ï§Ä)
      // gridCol 0 = Universe 1,4 -> offsetX = -width (Ï§ëÏïô Í∏∞Ï§Ä ÏôºÏ™Ω)
      // gridCol 1 = Universe 2,5 -> offsetX = 0 (Ï§ëÏïô)
      // gridCol 2 = Universe 3,6 -> offsetX = +width (Ï§ëÏïô Í∏∞Ï§Ä Ïò§Î•∏Ï™Ω)
      const x = width / 2 + (gridCol - 1) * width;
      const y = height / 2 + gridRow * height;

      const color = this.universeColors[i - 1];

      if (i === this.currentUniverse) {
        // ÌòÑÏû¨ Universe ÌÖåÎëêÎ¶¨Îßå (ÎÇ¥Ïö©ÏùÄ Ïã§Ï†ú Í≤åÏûÑ)
        const currentBorder = this.add.rectangle(x, y, width, height)
          .setStrokeStyle(6, 0xffffff, 1).setFillStyle(0, 0).setDepth(52).setAlpha(0);
        this.multiverseElements.push(currentBorder);
      } else {
        // Îã§Î•∏ UniverseÎäî Î∞∞Í≤Ω + ÎùºÎ≤®
        // Universe Î∞∞Í≤Ω (Ïñ¥ÎëêÏö¥ Î≥µÏ†úÎ≥∏ ÌëúÌòÑ)
        const bg = this.add.rectangle(x, y, width - 20, height - 20, 0x111122, 0.9)
          .setDepth(50).setAlpha(0).setStrokeStyle(4, color, 1);

        // Universe Î≤àÌò∏
        const label = this.add.text(x, y, `Universe ${i}`, {
          fontSize: '36px',
          fill: '#' + color.toString(16).padStart(6, '0'),
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 3
        }).setOrigin(0.5).setDepth(51).setAlpha(0);

        this.multiverseElements.push(bg, label);
      }
    }
  }

  /**
   * Î™©Ìëú Universe ÌïòÏù¥ÎùºÏù¥Ìä∏
   */
  highlightTargetUniverse(targetUniverse) {
    const { width, height } = this.cameras.main;
    const color = this.universeColors[targetUniverse - 1];

    const gridCol = (targetUniverse - 1) % 3;
    const gridRow = Math.floor((targetUniverse - 1) / 3);
    const x = width / 2 + (gridCol - 1) * width;
    const y = height / 2 + gridRow * height;

    // ÌéÑÏä§ Ìö®Í≥º (Îπ†Î•¥Í≤å! 400ms)
    const highlight = this.add.rectangle(x, y, width + 10, height + 10)
      .setStrokeStyle(8, color, 1).setFillStyle(0, 0).setDepth(60);

    this.tweens.add({
      targets: highlight,
      scaleX: 1.05,
      scaleY: 1.05,
      alpha: 0,
      duration: 400,
      onComplete: () => {
        if (highlight && highlight.active) highlight.destroy();
      }
    });

    this.multiverseElements.push(highlight);
  }

  /**
   * Î©ÄÌã∞Î≤ÑÏä§ Î∑∞ Ï†ïÎ¶¨
   */
  cleanupMultiverseView() {
    this.multiverseElements.forEach(el => {
      if (el && el.destroy) el.destroy();
    });
    this.multiverseElements = [];
  }

  /**
   * ÎåÄÏπ≠ ÏúÑÏπò Í≥ÑÏÇ∞ (Îßµ Ï§ëÏã¨ Í∏∞Ï§Ä)
   */
  calculateSymmetricPosition(entryX, entryY) {
    const centerX = Math.floor(this.cols / 2);
    const centerY = Math.floor(this.rows / 2);

    let exitX = centerX + (centerX - entryX);
    let exitY = centerY + (centerY - entryY);

    // Î≤Ω Ï∂©Îèå Î∞©ÏßÄ
    exitX = Phaser.Math.Clamp(exitX, 2, this.cols - 3);
    exitY = Phaser.Math.Clamp(exitY, 2, this.rows - 3);

    return { x: exitX, y: exitY };
  }

  /**
   * ÏõúÌôÄÏóêÏÑú Î±Ä Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
   * 1. Ï∂úÍµ¨ ÏõúÌôÄ ÌëúÏãú (Ìï¥Îãπ Universe ÏÉâÏÉÅ)
   * 2. ÏßÑÏûÖ Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú ÎÇòÏò¥
   * 3. Î®∏Î¶¨Í∞Ä ÎÇòÏò§ÏûêÎßàÏûê Ï°∞Ïûë Í∞ÄÎä• + Ïã§Ï†ú ÏÜçÎèÑ
   * 4. Ïù¥ÎèôÌï† ÎïåÎßàÎã§ ÏõúÌôÄÏóêÏÑú ÏÑ∏Í∑∏Î®ºÌä∏ ÌïòÎÇòÏî© Îì±Ïû•
   */
  spawnSnakeFromWormhole(exitX, exitY) {
    // Î±Ä Í∏∏Ïù¥ Ï†ÄÏû• (Ï†ÑÌôò Ïãú Ï†ÄÏû•Îêú Í∏∏Ïù¥ ÏÇ¨Ïö©, ÏµúÏÜå 3)
    const snakeLength = Math.max(3, this.transitionSnakeLength || 3);
    this.transitionSnakeLength = null;

    // ÏõúÌôÄ ÏúÑÏπò (Ï∂©Î∂ÑÌïú Í≥µÍ∞Ñ ÌôïÎ≥¥)
    const wormholeX = Phaser.Math.Clamp(exitX, 3, this.cols - 4);
    const wormholeY = Phaser.Math.Clamp(exitY, 3, this.rows - 4);

    // ÏßÑÏûÖ Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú ÎÇòÏò¥
    const oppositeDir = {
      'RIGHT': 'LEFT',
      'LEFT': 'RIGHT',
      'UP': 'DOWN',
      'DOWN': 'UP'
    };
    const entryDir = this.transitionEntryDirection || 'RIGHT';
    const exitDirection = oppositeDir[entryDir];
    this.transitionEntryDirection = null;

    // Î∞©Ìñ•Î≥Ñ Ïò§ÌîÑÏÖã
    const dirOffsets = {
      'RIGHT': { dx: 1, dy: 0 },
      'LEFT': { dx: -1, dy: 0 },
      'DOWN': { dx: 0, dy: 1 },
      'UP': { dx: 0, dy: -1 }
    };
    const dOffset = dirOffsets[exitDirection];

    // ÏõúÌôÄ ÏúÑÏπò (ÌîΩÏÖÄ)
    const wormholePixelX = wormholeX * this.gridSize + this.gridSize / 2;
    const wormholePixelY = wormholeY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÌòÑÏû¨ Universe ÏÉâÏÉÅ
    const universeColor = this.universeColors[this.currentUniverse - 1];

    // 1. Ï∂úÍµ¨ ÏõúÌôÄ ÏÉùÏÑ±
    const exitWormhole = this.add.container(wormholePixelX, wormholePixelY).setDepth(500);
    const wormholeGraphics = this.add.graphics();
    exitWormhole.add(wormholeGraphics);

    let wormholeAngle = 0;
    const baseRadius = this.gridSize * 1.0;

    const drawExitWormhole = () => {
      wormholeGraphics.clear();
      wormholeAngle += 0.12;
      for (let i = 3; i >= 0; i--) {
        const radius = baseRadius * (1 - i * 0.18);
        const alpha = 0.5 + i * 0.12;
        wormholeGraphics.lineStyle(2.5, universeColor, alpha);
        wormholeGraphics.beginPath();
        for (let a = 0; a < Math.PI * 3; a += 0.25) {
          const spiralRadius = radius * (1 - a / (Math.PI * 5));
          const spiralX = Math.cos(a + wormholeAngle + i * 0.4) * spiralRadius;
          const spiralY = Math.sin(a + wormholeAngle + i * 0.4) * spiralRadius;
          if (a === 0) wormholeGraphics.moveTo(spiralX, spiralY);
          else wormholeGraphics.lineTo(spiralX, spiralY);
        }
        wormholeGraphics.strokePath();
      }
      wormholeGraphics.fillStyle(universeColor, 0.7);
      wormholeGraphics.fillCircle(0, 0, baseRadius * 0.2);
    };

    drawExitWormhole();
    const wormholeAnimEvent = this.time.addEvent({
      delay: 16,
      callback: drawExitWormhole,
      loop: true
    });

    // 2. Î∞©Ìñ• ÌûåÌä∏ (ÏßßÍ≤å Î∞òÏßù)
    const hintGraphics = this.add.graphics().setDepth(501);
    const hintLength = this.gridSize * 2;
    const beamEndX = wormholePixelX + dOffset.dx * hintLength;
    const beamEndY = wormholePixelY + dOffset.dy * hintLength;

    let flashCount = 0;
    const flashHint = () => {
      hintGraphics.clear();
      for (let i = 4; i >= 0; i--) {
        const thickness = 12 - i * 2;
        const alpha = 0.15 + i * 0.15;
        hintGraphics.lineStyle(thickness, universeColor, alpha);
        hintGraphics.beginPath();
        hintGraphics.moveTo(wormholePixelX, wormholePixelY);
        hintGraphics.lineTo(beamEndX, beamEndY);
        hintGraphics.strokePath();
      }
      hintGraphics.fillStyle(universeColor, 0.9);
      hintGraphics.fillCircle(beamEndX, beamEndY, 6);
    };

    const hintFlashEvent = this.time.addEvent({
      delay: 60,
      callback: () => {
        flashCount++;
        if (flashCount % 2 === 1) flashHint();
        else hintGraphics.clear();
        if (flashCount >= 6) {
          hintFlashEvent.destroy();
          hintGraphics.destroy();
        }
      },
      loop: true
    });

    // 3. Î®∏Î¶¨Îßå Î®ºÏ†Ä Îì±Ïû• ÌõÑ Ï¶âÏãú Í≤åÏûÑ ÏãúÏûë! (180ms ÌõÑ)
    this.time.delayedCall(180, () => {
      // Î±Ä Ï¥àÍ∏∞Ìôî - Î®∏Î¶¨Îßå!
      this.snake = [{ x: wormholeX, y: wormholeY }];
      this.direction = exitDirection;
      this.inputQueue = [];

      // ÏõúÌôÄ Ïä§Ìè∞ ÏÉÅÌÉú Ï†ÄÏû• (ÎÇ®ÏùÄ ÏÑ∏Í∑∏Î®ºÌä∏)
      this.wormholeSpawnData = {
        remaining: snakeLength - 1, // Î®∏Î¶¨ Ï†úÏô∏Ìïú ÎÇòÎ®∏ÏßÄ
        wormholeX: wormholeX,
        wormholeY: wormholeY,
        exitWormhole: exitWormhole,
        wormholeAnimEvent: wormholeAnimEvent,
        universeColor: universeColor
      };

      // Universe ÌÉÄÏù¥ÌãÄ
      this.updateUniverseTitle(this.currentUniverse);

      // Î®πÏù¥/ÏõúÌôÄ ÏÉùÏÑ±
      if (this.currentUniverse === this.foodUniverse) {
        this.food = this.generateFood();
      } else {
        this.createWormholes();
      }

      this.draw();

      // Ï¶âÏãú Í≤åÏûÑ Ïû¨Í∞ú! (Î∞©Ìñ• Ï°∞Ïûë Í∞ÄÎä•)
      this.isUniverseTransitioning = false;
      if (this.moveTimer) this.moveTimer.paused = false;
    });

    this.draw();
  }

  /**
   * ÏõúÌôÄ Ïä§Ìè∞ Ï≤òÎ¶¨ (moveSnakeÏóêÏÑú Ìò∏Ï∂ú)
   * Î±ÄÏù¥ Ïù¥ÎèôÌï† ÎïåÎßàÎã§ ÏõúÌôÄÏóêÏÑú ÏÑ∏Í∑∏Î®ºÌä∏ ÌïòÎÇò Ï∂îÍ∞Ä
   */
  handleWormholeSpawn() {
    if (!this.wormholeSpawnData || this.wormholeSpawnData.remaining <= 0) {
      // Ïä§Ìè∞ ÏôÑÎ£å - ÏõúÌôÄ Îã´Í∏∞
      if (this.wormholeSpawnData) {
        const data = this.wormholeSpawnData;
        if (data.wormholeAnimEvent) data.wormholeAnimEvent.destroy();
        if (data.exitWormhole) {
          this.tweens.add({
            targets: data.exitWormhole,
            scale: 0,
            alpha: 0,
            duration: 120,
            ease: 'Power2',
            onComplete: () => {
              if (data.exitWormhole && data.exitWormhole.destroy) {
                data.exitWormhole.destroy();
              }
            }
          });
        }
        this.wormholeSpawnData = null;
      }
      return false;
    }

    // ÏõúÌôÄÏóêÏÑú ÏÉà ÏÑ∏Í∑∏Î®ºÌä∏ Ï∂îÍ∞Ä (Íº¨Î¶¨Ïóê)
    this.snake.push({
      x: this.wormholeSpawnData.wormholeX,
      y: this.wormholeSpawnData.wormholeY
    });
    this.wormholeSpawnData.remaining--;

    // ÏõúÌôÄ ÌéÑÏä§ Ìö®Í≥º
    if (this.wormholeSpawnData.exitWormhole) {
      this.tweens.add({
        targets: this.wormholeSpawnData.exitWormhole,
        scale: 1.2,
        duration: 40,
        yoyo: true,
        ease: 'Power2'
      });
    }

    return true; // ÏÑ∏Í∑∏Î®ºÌä∏ Ï∂îÍ∞ÄÎê®
  }

  /**
   * Meta Universe Î®πÏù¥ Î®πÏóàÏùÑ Îïå Ï≤òÎ¶¨
   */
  handleMetaUniverseFood() {
    this.metaUniverseFoodCount++;

    // ÌÅ¥Î¶¨Ïñ¥ Ï≤¥ÌÅ¨
    if (this.metaUniverseFoodCount >= this.metaUniverseTargetFood) {
      // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥!
      this.stageClear();
      return true;
    }

    // Îã§Ïùå Î®πÏù¥ Universe ÎûúÎç§ Í≤∞Ï†ï
    this.foodUniverse = Phaser.Math.Between(1, 6);

    // Î®πÏù¥ Ïà®Í∏∞Í∏∞ (Îã§Î•∏ UniverseÏóê ÏûàÏúºÎØÄÎ°ú)
    this.food = { x: -100, y: -100 };

    // ÏõúÌôÄ ÏÉùÏÑ±
    this.time.delayedCall(300, () => {
      this.createWormholes();
      this.draw();
    });

    return false;
  }

  /**
   * Meta Universe Ï†ïÎ¶¨
   */
  cleanupMetaUniverse() {
    this.metaUniverseMode = false;
    this.currentUniverse = 1;
    this.wormholePassCount = 0;
    this.metaUniverseFoodCount = 0;
    this.foodUniverse = 1;
    this.metaUniverseIntroShown = false;
    this.comboDisabled = false;
    this.isUniverseTransitioning = false;
    this.transitionSnakeLength = null;
    this.snakeSegmentAlphas = null;

    this.destroyWormholes();
    this.cleanupMultiverseView();

    if (this.universeTitle) {
      this.universeTitle.destroy();
      this.universeTitle = null;
    }
  }

  // =====================================================
  // Quantum Split System (Stage 17)
  // =====================================================

  /**
   * Quantum Split Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§
   */
  showQuantumSplitIntro() {
    if (this.quantumIntroShown) return;
    this.quantumIntroShown = true;

    this.moveTimer.paused = true;

    // Phase 1: ÏùºÎ∞ò ÎßµÏóêÏÑú ÏãúÏûë (Í∏∞Î≥∏ draw ÏÇ¨Ïö©)
    this.draw();

    // Phase 2: Î±Ä ÎåÄÏÇ¨ "what..?"
    this.time.delayedCall(500, () => {
      this.showQuantumWhatDialogue(() => {
        // Phase 3: Ï§åÏïÑÏõÉ + Î©ÄÌã∞Î≤ÑÏä§ Î∑∞
        this.showQuantumZoomOut(() => {
          // Phase 4: ÎÇòÎ®∏ÏßÄ Î±Ä Îì±Ïû•
          this.showQuantumSnakesAppear(() => {
            // Phase 5: 6Í∞ú Î®πÏù¥ ÏÉùÏÑ±
            this.generateQuantumFoods();
            // Phase 6: "Nothing happened.." ÎßêÌíçÏÑ†
            this.showQuantumAllSnakesDialogue(() => {
              // Phase 7: Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌõÑ Í≤åÏûÑ ÏãúÏûë
              this.showQuantumCountdown(() => {
                this.quantumSplitMode = true;
                this.moveTimer.paused = false;
              });
            });
          });
        });
      });
    });
  }

  /**
   * Î±Ä ÎåÄÏÇ¨ "what..?"
   */
  showQuantumWhatDialogue(callback) {
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
    const bubble = this.add.graphics().setDepth(7000);
    bubble.fillStyle(0x000000, 0.8);
    bubble.fillRoundedRect(headX + 15, headY - 35, 80, 30, 8);
    bubble.lineStyle(2, 0x00ff00, 1);
    bubble.strokeRoundedRect(headX + 15, headY - 35, 80, 30, 8);

    // ÎåÄÏÇ¨ ÌÖçÏä§Ìä∏
    const dialogue = this.add.text(headX + 55, headY - 20, '', {
      fontSize: '16px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(7001);

    const message = "what..?";
    let charIndex = 0;

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    const typingTimer = this.time.addEvent({
      delay: 80,
      callback: () => {
        charIndex++;
        dialogue.setText(message.substring(0, charIndex));
        if (charIndex >= message.length) {
          typingTimer.destroy();
        }
      },
      repeat: message.length - 1
    });

    // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ Ï†ïÎ¶¨
    this.time.delayedCall(1500, () => {
      this.tweens.add({
        targets: [bubble, dialogue],
        alpha: 0,
        duration: 300,
        onComplete: () => {
          bubble.destroy();
          dialogue.destroy();
          if (callback) callback();
        }
      });
    });
  }

  /**
   * Ï§åÏïÑÏõÉ + Î©ÄÌã∞Î≤ÑÏä§ Î∑∞ ÌëúÏãú (Í≤©ÎèôÏ†ÅÏù∏ Ïó∞Ï∂ú!)
   */
  showQuantumZoomOut(callback) {
    const { width, height } = this.cameras.main;
    const gameY = this.gameAreaY;
    const gameH = height - this.uiHeight - this.bottomUIHeight;
    const vpW = this.quantumViewportSize.width;
    const vpH = this.quantumViewportSize.height;
    const centerX = width / 2;
    const centerY = gameY + gameH / 2;

    // === Phase 1: ÌôîÎ©¥ Îñ®Î¶º + Í∏ÄÎ¶¨Ïπò Ìö®Í≥º ===
    this.cameras.main.shake(400, 0.015);

    // Í∏ÄÎ¶¨Ïπò Ïò§Î≤ÑÎ†àÏù¥
    const glitchOverlay = this.add.graphics().setDepth(6999);
    let glitchFrame = 0;
    const glitchTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        glitchFrame++;
        glitchOverlay.clear();
        // ÎûúÎç§ Í∏ÄÎ¶¨Ïπò ÎùºÏù∏
        for (let i = 0; i < 5; i++) {
          const y = Phaser.Math.Between(gameY, gameY + gameH);
          const h = Phaser.Math.Between(2, 8);
          glitchOverlay.fillStyle(Phaser.Math.Between(0, 1) ? 0xff00ff : 0x00ffff, 0.3);
          glitchOverlay.fillRect(0, y, width, h);
        }
        if (glitchFrame >= 8) {
          glitchTimer.destroy();
          glitchOverlay.destroy();
        }
      },
      repeat: 7
    });

    // === Phase 2: ÌîåÎûòÏãú + Í∏∞Ï°¥ Í∑∏ÎûòÌîΩ Ïà®Í∏∞Í∏∞ ===
    this.time.delayedCall(400, () => {
      // Í∞ïÎ†¨Ìïú ÌîåÎûòÏãú
      this.cameras.main.flash(150, 255, 255, 255);

      // Í∏∞Ï°¥ Í∑∏ÎûòÌîΩ Ïà®Í∏∞Í∏∞
      if (this.graphics) {
        this.graphics.setVisible(false);
      }

      // === Phase 3: 6Í∞ú Î∑∞Ìè¨Ìä∏ Ï¥àÍ∏∞Ìôî ===
      this.initQuantumViewports();
      this.createQuantumBorders();

      // U1Îßå Î±Ä Î≥¥Ïù¥Í≤å
      this.quantumSnakeVisible = [true, false, false, false, false, false];

      // Î∑∞Ìè¨Ìä∏Îì§ÏùÑ ÌôîÎ©¥ Î∞ñ ÎûúÎç§ ÏúÑÏπòÏóê Î∞∞Ïπò
      const startPositions = [
        { x: centerX - vpW/2, y: -vpH },           // U1: ÏúÑÏóêÏÑú
        { x: width + vpW, y: gameY },              // U2: Ïò§Î•∏Ï™ΩÏóêÏÑú
        { x: -vpW, y: gameY },                     // U3: ÏôºÏ™ΩÏóêÏÑú
        { x: width + vpW, y: gameY + gameH },      // U4: Ïò§Î•∏Ï™Ω ÏïÑÎûòÏóêÏÑú
        { x: centerX - vpW/2, y: height + vpH },   // U5: ÏïÑÎûòÏóêÏÑú
        { x: -vpW, y: gameY + gameH }              // U6: ÏôºÏ™Ω ÏïÑÎûòÏóêÏÑú
      ];

      this.quantumViewports.forEach((vp, i) => {
        vp.rt.setPosition(startPositions[i].x, startPositions[i].y);
        vp.rt.setScale(0.5);
        vp.rt.setAlpha(0);
        vp.rt.setRotation(Phaser.Math.DegToRad(Phaser.Math.Between(-15, 15)));
      });
      this.drawQuantumViewports();

      // ÌÖåÎëêÎ¶¨ Ïà®ÍπÄ (Î™®Îì† Ìö®Í≥º Ìè¨Ìï®)
      if (this.quantumBorderGraphics) {
        this.quantumBorderGraphics.setAlpha(0);
      }
      this.quantumBorderGlowLayers.forEach(g => g.setAlpha(0));
      this.quantumCornerNodes.forEach(n => {
        n.outer.setAlpha(0);
        n.mid.setAlpha(0);
        n.core.setAlpha(0);
      });
      this.quantumEnergyParticles.forEach(p => {
        p.particle.setAlpha(0);
        p.trail.setAlpha(0);
      });

      // === Phase 4: Í≤©ÎèôÏ†ÅÏù∏ Î∑∞Ìè¨Ìä∏ Îì±Ïû•! ===
      this.time.delayedCall(100, () => {
        // Í∞Å Î∑∞Ìè¨Ìä∏Í∞Ä Îπ†Î•¥Í≤å ÏûêÍ∏∞ ÏúÑÏπòÎ°ú ÎÇ†ÏïÑÏò¥
        this.quantumViewports.forEach((vp, i) => {
          const col = i % 3;
          const row = Math.floor(i / 3);
          const targetX = col * vpW;
          const targetY = gameY + row * vpH;

          // Îì±Ïû• ÏÇ¨Ïö¥Îìú Ìö®Í≥ºÏ≤òÎüº Ïπ¥Î©îÎùº ÏÇ¥Ïßù ÌùîÎì§Í∏∞
          this.time.delayedCall(i * 80, () => {
            this.cameras.main.shake(80, 0.005);
          });

          this.tweens.add({
            targets: vp.rt,
            x: targetX,
            y: targetY,
            scaleX: 1,
            scaleY: 1,
            alpha: 1,
            rotation: 0,
            duration: 400,
            ease: 'Back.easeOut',
            delay: i * 80,
            onComplete: () => {
              // Ï∞©ÏßÄ Ìö®Í≥º - ÌÖåÎëêÎ¶¨ ÌéÑÏä§
              if (i < 6) {
                const flashBorder = this.add.graphics().setDepth(160);
                flashBorder.lineStyle(4, this.universeColors[i], 1);
                flashBorder.strokeRect(targetX, targetY, vpW, vpH);
                this.tweens.add({
                  targets: flashBorder,
                  alpha: 0,
                  duration: 200,
                  onComplete: () => flashBorder.destroy()
                });
              }
            }
          });
        });

        // ÌÖåÎëêÎ¶¨ Îì±Ïû• (Î™®Îì† Ìö®Í≥º ÌôîÎ†§ÌïòÍ≤å ÌéòÏù¥ÎìúÏù∏)
        this.time.delayedCall(400, () => {
          // Î©îÏù∏ ÌÖåÎëêÎ¶¨
          if (this.quantumBorderGraphics) {
            this.tweens.add({
              targets: this.quantumBorderGraphics,
              alpha: 1,
              duration: 500,
              ease: 'Cubic.easeOut'
            });
          }

          // Í∏ÄÎ°úÏö∞ Î†àÏù¥Ïñ¥ (Î∞îÍπ• ‚Üí ÏïàÏ™Ω ÏàúÏ∞®)
          const baseAlphas = [0.03, 0.06, 0.1, 0.2, 0.4, 0.8];
          this.quantumBorderGlowLayers.forEach((g, idx) => {
            this.tweens.add({
              targets: g,
              alpha: baseAlphas[idx] || 0.3,
              duration: 400,
              delay: idx * 50,
              ease: 'Cubic.easeOut'
            });
          });

          // ÏΩîÎÑà ÎÖ∏Îìú (Ìéë! ÌïòÍ≥† Îì±Ïû•)
          this.quantumCornerNodes.forEach((n, idx) => {
            this.time.delayedCall(200 + idx * 20, () => {
              n.outer.setScale(2);
              n.mid.setScale(2);
              n.core.setScale(2);

              this.tweens.add({
                targets: [n.outer, n.mid, n.core],
                alpha: 1,
                scale: 1,
                duration: 300,
                ease: 'Back.easeOut'
              });
            });
          });

          // ÏóêÎÑàÏßÄ ÏûÖÏûê (ÏàúÏ∞® Îì±Ïû•)
          this.quantumEnergyParticles.forEach((p, idx) => {
            this.time.delayedCall(400 + idx * 30, () => {
              this.tweens.add({
                targets: [p.particle, p.trail],
                alpha: 1,
                duration: 200,
                ease: 'Cubic.easeOut'
              });
            });
          });
        });

        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÌõÑ ÏΩúÎ∞±
        this.time.delayedCall(700, () => {
          this.createQuantumUI();
          if (callback) callback();
        });
      });
    });
  }

  /**
   * ÎÇòÎ®∏ÏßÄ Î±ÄÎì§ ÏàúÏ∞® Îì±Ïû• (ÍπúÎπ°Ïù¥Î©∞)
   */
  showQuantumSnakesAppear(callback) {
    // U1ÏùÄ Ïù¥ÎØ∏ Î≥¥ÏûÑ, ÎÇòÎ®∏ÏßÄ ÏàúÏ∞® Îì±Ïû•
    let universeIdx = 1;
    let completedCount = 0;

    const spawnNextSnake = () => {
      if (universeIdx >= 6) {
        // Î™®Îì† Î±Ä Îì±Ïû• ÏôÑÎ£å
        this.time.delayedCall(300, () => {
          this.quantumSnakeVisible = null; // Ïù¥Ï†ú Î™®Îëê Î≥¥ÏûÑ
          this.drawQuantumViewports();
          if (callback) callback();
        });
        return;
      }

      const currentIdx = universeIdx;
      let blinkCount = 0;

      // Îì±Ïû• Ïãú Ìï¥Îãπ Î∑∞Ìè¨Ìä∏ ÌÖåÎëêÎ¶¨ Í∞ïÏ°∞
      const vp = this.quantumViewports[currentIdx];
      const col = currentIdx % 3;
      const row = Math.floor(currentIdx / 3);
      const vpW = this.quantumViewportSize.width;
      const vpH = this.quantumViewportSize.height;

      const highlight = this.add.graphics().setDepth(170);
      highlight.lineStyle(3, this.universeColors[currentIdx], 1);
      highlight.strokeRect(col * vpW, this.gameAreaY + row * vpH, vpW, vpH);

      // ÍπúÎπ°ÏûÑ Ìö®Í≥º
      const blinkTimer = this.time.addEvent({
        delay: 60,
        callback: () => {
          blinkCount++;
          if (this.quantumSnakeVisible) {
            this.quantumSnakeVisible[currentIdx] = blinkCount % 2 === 1;
            this.drawQuantumViewports();
          }
          if (blinkCount >= 6) {
            blinkTimer.destroy();
            if (this.quantumSnakeVisible) {
              this.quantumSnakeVisible[currentIdx] = true;
              this.drawQuantumViewports();
            }
            // ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï†úÍ±∞
            this.tweens.add({
              targets: highlight,
              alpha: 0,
              duration: 150,
              onComplete: () => highlight.destroy()
            });
          }
        },
        repeat: 5
      });

      universeIdx++;
      // Îã§Ïùå Î±Ä Ïä§Ìè∞
      this.time.delayedCall(200, spawnNextSnake);
    };

    spawnNextSnake();
  }

  /**
   * Î™®Îì† Î±ÄÏù¥ ÎèôÏãúÏóê ÎßêÌíçÏÑ† "Nothing happened.."
   */
  showQuantumAllSnakesDialogue(callback) {
    const bubbles = [];
    const texts = [];
    const message = "Nothing happened..";

    // 6Í∞ú Î∑∞Ìè¨Ìä∏ Í∞ÅÍ∞ÅÏóê ÎßêÌíçÏÑ† ÌëúÏãú
    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      const vpCenterX = vp.x + this.quantumViewportSize.width / 2;
      const vpCenterY = vp.y + this.quantumViewportSize.height / 2 - 30;

      // ÎßêÌíçÏÑ† Î∞∞Í≤Ω
      const bubble = this.add.graphics().setDepth(7000);
      bubble.fillStyle(0x000000, 0.85);
      bubble.fillRoundedRect(vpCenterX - 75, vpCenterY - 15, 150, 30, 8);
      bubble.lineStyle(1, this.universeColors[i], 0.8);
      bubble.strokeRoundedRect(vpCenterX - 75, vpCenterY - 15, 150, 30, 8);
      bubbles.push(bubble);

      // ÎåÄÏÇ¨ ÌÖçÏä§Ìä∏
      const text = this.add.text(vpCenterX, vpCenterY, '', {
        fontSize: '11px',
        fill: '#00ff00',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(7001);
      texts.push(text);
    }

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º (Î™®Îì† Î±Ä ÎèôÏãúÏóê)
    let charIndex = 0;
    const typingTimer = this.time.addEvent({
      delay: 50,
      callback: () => {
        charIndex++;
        const currentText = message.substring(0, charIndex);
        texts.forEach(t => t.setText(currentText));
        if (charIndex >= message.length) {
          typingTimer.destroy();
        }
      },
      repeat: message.length - 1
    });

    // ÎåÄÏÇ¨ ÏôÑÎ£å ÌõÑ Ï†ïÎ¶¨
    this.time.delayedCall(2000, () => {
      // ÌéòÏù¥ÎìúÏïÑÏõÉ
      [...bubbles, ...texts].forEach(el => {
        this.tweens.add({
          targets: el,
          alpha: 0,
          duration: 300,
          onComplete: () => el.destroy()
        });
      });

      this.time.delayedCall(400, () => {
        if (callback) callback();
      });
    });
  }

  /**
   * Quantum Split Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ (6Í∞ú Î∑∞Ìè¨Ìä∏Ïóê ÎèôÏãú ÌëúÏãú)
   */
  showQuantumCountdown(callback) {
    const countNumbers = ['3', '2', '1', 'GO!'];
    let countIndex = 0;

    // 6Í∞ú Î∑∞Ìè¨Ìä∏ Í∞ÅÍ∞ÅÏóê Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
    const countTexts = [];
    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      const vpCenterX = vp.x + this.quantumViewportSize.width / 2;
      const vpCenterY = vp.y + this.quantumViewportSize.height / 2;

      const text = this.add.text(vpCenterX, vpCenterY, '', {
        fontSize: '36px',
        fill: '#ffffff',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5).setDepth(7500);
      countTexts.push(text);
    }

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ïã§Ìñâ
    const showCount = () => {
      if (countIndex >= countNumbers.length) {
        // Î™®Îì† Ïπ¥Ïö¥Ìä∏ ÏôÑÎ£å
        countTexts.forEach(t => t.destroy());
        if (callback) callback();
        return;
      }

      const countStr = countNumbers[countIndex];
      const isGo = countStr === 'GO!';
      const color = isGo ? '#00ff00' : '#ffffff';
      const fontSize = isGo ? '42px' : '36px';
      const displayTime = isGo ? 500 : 600;

      // Î™®Îì† Ìä∏Ïúà Ï†ïÎ¶¨ ÌõÑ ÏÉàÎ°ú ÏãúÏûë
      countTexts.forEach((text) => {
        this.tweens.killTweensOf(text);
        text.setFontSize(fontSize);
        text.setFill(color);
        text.setText(countStr);
        text.setAlpha(1);
        text.setScale(1.5);

        // ÌåùÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
        this.tweens.add({
          targets: text,
          scale: 1,
          duration: 150,
          ease: 'Back.easeOut'
        });
      });

      // ÌéòÏù¥ÎìúÏïÑÏõÉ ÌõÑ Îã§Ïùå Ïπ¥Ïö¥Ìä∏
      this.time.delayedCall(displayTime - 200, () => {
        countTexts.forEach((text) => {
          this.tweens.add({
            targets: text,
            alpha: 0,
            scale: 0.8,
            duration: 200,
            ease: 'Cubic.easeIn'
          });
        });
      });

      countIndex++;
      this.time.delayedCall(displayTime, showCount);
    };

    // ÏãúÏûë
    this.time.delayedCall(200, showCount);
  }

  /**
   * 6Í∞ú RenderTexture Î∑∞Ìè¨Ìä∏ Ï¥àÍ∏∞Ìôî
   */
  initQuantumViewports() {
    const vpW = this.quantumViewportSize.width;
    const vpH = this.quantumViewportSize.height;
    const gameY = this.gameAreaY;

    // Í∏∞Ï°¥ Î∑∞Ìè¨Ìä∏ Ï†ïÎ¶¨
    this.cleanupQuantumViewports();

    // 6Í∞ú RenderTexture ÏÉùÏÑ± (3x2 Í∑∏Î¶¨Îìú)
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      const row = Math.floor(i / 3);
      const x = col * vpW;
      const y = gameY + row * vpH;

      // RenderTexture ÏÉùÏÑ±
      const rt = this.add.renderTexture(x, y, vpW, vpH);
      rt.setOrigin(0, 0);
      rt.setDepth(100);

      // Ïò§ÌîÑÏä§ÌÅ¨Î¶∞ Graphics Í∞ùÏ≤¥
      const graphics = this.make.graphics({ add: false });

      this.quantumViewports.push({
        rt,
        graphics,
        x, y,
        universeIndex: i,
        color: this.universeColors[i]
      });
    }
  }

  /**
   * Î∑∞Ìè¨Ìä∏ Ï†ïÎ¶¨ (RenderTextureÎßå)
   */
  cleanupQuantumViewports() {
    this.quantumViewports.forEach(vp => {
      if (vp.rt) vp.rt.destroy();
      if (vp.graphics) vp.graphics.destroy();
    });
    this.quantumViewports = [];
  }

  /**
   * 6Í∞ú Î∑∞Ìè¨Ìä∏ Î†åÎçîÎßÅ (Îß§ ÌîÑÎ†àÏûÑ)
   */
  drawQuantumViewports() {
    // Ïù∏Ìä∏Î°ú Ï§ëÏù¥Í±∞ÎÇò Í≤åÏûÑ Ï§ëÏùº Îïå Î™®Îëê Î†åÎçîÎßÅ
    if (this.quantumViewports.length === 0) return;

    const head = this.snake[0];
    const visible = this.quantumVisibleTiles; // 5
    const viewSize = visible * 2 + 1; // 11
    const vpW = this.quantumViewportSize.width;
    const vpH = this.quantumViewportSize.height;
    const tileSize = Math.floor(vpW / viewSize); // ~24px

    // Î±Ä Î®∏Î¶¨ Í∏∞Ï§Ä Î∑∞Ìè¨Ìä∏ ÏãúÏûëÏ†ê
    const viewStartX = head.x - visible;
    const viewStartY = head.y - visible;

    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      const food = this.quantumFoods[i];

      // Ïù¥Ï†Ñ ÌîÑÎ†àÏûÑ ÏßÄÏö∞Í∏∞
      vp.rt.clear();
      vp.graphics.clear();

      // 1. Î∞∞Í≤Ω (Í≤ÄÏùÄÏÉâ)
      vp.graphics.fillStyle(0x000000, 1);
      vp.graphics.fillRect(0, 0, vpW, vpH);

      // 2. Í∑∏Î¶¨Îìú ÎùºÏù∏
      this.drawQuantumGrid(vp.graphics, viewSize, tileSize, vp.color);

      // 3. Î≤Ω ÌëúÏãú (Îßµ Í≤ΩÍ≥Ñ Î∞ñ)
      this.drawQuantumWalls(vp.graphics, viewStartX, viewStartY, viewSize, tileSize);

      // 4. Î±Ä Í∑∏Î¶¨Í∏∞ (Ïù∏Ìä∏Î°ú Ï§ë visible Ï≤¥ÌÅ¨)
      const shouldDrawSnake = !this.quantumSnakeVisible || this.quantumSnakeVisible[i];
      if (shouldDrawSnake) {
        this.drawQuantumSnake(vp.graphics, viewStartX, viewStartY, viewSize, tileSize);
      }

      // 5. Î®πÏù¥ Í∑∏Î¶¨Í∏∞ (Ìï¥Îãπ Universe)
      if (food) {
        this.drawQuantumFood(vp.graphics, food, viewStartX, viewStartY, viewSize, tileSize, i);
      }

      // Graphics ‚Üí RenderTexture
      vp.rt.draw(vp.graphics, 0, 0);
    }
  }

  /**
   * Î∑∞Ìè¨Ìä∏ Í∑∏Î¶¨Îìú Í∑∏Î¶¨Í∏∞
   */
  drawQuantumGrid(graphics, viewSize, tileSize, color) {
    graphics.lineStyle(1, color, 0.15);

    for (let i = 0; i <= viewSize; i++) {
      // ÏàòÏßÅÏÑ†
      graphics.moveTo(i * tileSize, 0);
      graphics.lineTo(i * tileSize, viewSize * tileSize);
      // ÏàòÌèâÏÑ†
      graphics.moveTo(0, i * tileSize);
      graphics.lineTo(viewSize * tileSize, i * tileSize);
    }
    graphics.strokePath();
  }

  /**
   * Î∑∞Ìè¨Ìä∏ Î≤Ω ÌëúÏãú (Îßµ Í≤ΩÍ≥Ñ Î∞ñ = ÌöåÏÉâ)
   */
  drawQuantumWalls(graphics, viewStartX, viewStartY, viewSize, tileSize) {
    for (let ly = 0; ly < viewSize; ly++) {
      for (let lx = 0; lx < viewSize; lx++) {
        const worldX = viewStartX + lx;
        const worldY = viewStartY + ly;

        // Îßµ Í≤ΩÍ≥Ñ Î∞ñ = Î≤Ω
        if (worldX < 0 || worldX >= this.cols || worldY < 0 || worldY >= this.rows) {
          graphics.fillStyle(0x444444, 1);
          graphics.fillRect(lx * tileSize, ly * tileSize, tileSize, tileSize);
        }
      }
    }
  }

  /**
   * Î∑∞Ìè¨Ìä∏Ïóê Î±Ä Í∑∏Î¶¨Í∏∞
   */
  drawQuantumSnake(graphics, viewStartX, viewStartY, viewSize, tileSize) {
    this.snake.forEach((segment, index) => {
      const localX = segment.x - viewStartX;
      const localY = segment.y - viewStartY;

      // Î∑∞Ìè¨Ìä∏ ÏïàÏóê ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨
      if (localX >= 0 && localX < viewSize && localY >= 0 && localY < viewSize) {
        // Î®∏Î¶¨ = Î∞ùÏùÄ Ï¥àÎ°ù, Î™∏ÌÜµ = Ïñ¥ÎëêÏö¥ Ï¥àÎ°ù
        const color = index === 0 ? 0x00ff00 : 0x00aa00;
        graphics.fillStyle(color, 1);
        graphics.fillRect(
          localX * tileSize + 1,
          localY * tileSize + 1,
          tileSize - 2,
          tileSize - 2
        );
      }
    });
  }

  /**
   * Î∑∞Ìè¨Ìä∏Ïóê Î®πÏù¥ Í∑∏Î¶¨Í∏∞
   */
  drawQuantumFood(graphics, food, viewStartX, viewStartY, viewSize, tileSize, universeIndex) {
    const localX = food.x - viewStartX;
    const localY = food.y - viewStartY;

    // Î∑∞Ìè¨Ìä∏ ÏïàÏóê ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨
    if (localX >= 0 && localX < viewSize && localY >= 0 && localY < viewSize) {
      // ÎßàÏßÄÎßâ Î®πÏù¥ (20Î≤àÏß∏) = Ï¥àÎ°ùÏÉâ, ÎÇòÎ®∏ÏßÄ = Îπ®Í∞ÑÏÉâ
      const isLast = this.quantumTotalFood >= this.quantumTargetFood - 1;
      const color = isLast ? 0x00ff00 : 0xff0000;

      graphics.fillStyle(color, 1);
      graphics.fillCircle(
        localX * tileSize + tileSize / 2,
        localY * tileSize + tileSize / 2,
        tileSize / 2 - 2
      );
    }
  }

  /**
   * Quantum Split Ïù¥Îèô Ï≤òÎ¶¨
   */
  handleQuantumMovement() {
    if (this.gameOver) return;

    // ÏûÖÎ†• Ï≤òÎ¶¨
    if (this.inputQueue.length > 0) {
      this.direction = this.inputQueue.shift();
    }

    // ÏÉà Î®∏Î¶¨ ÏúÑÏπò Í≥ÑÏÇ∞
    const head = this.snake[0];
    let newHead = { x: head.x, y: head.y };

    switch (this.direction) {
      case 'LEFT': newHead.x--; break;
      case 'RIGHT': newHead.x++; break;
      case 'UP': newHead.y--; break;
      case 'DOWN': newHead.y++; break;
    }

    // Î≤Ω Ï∂©Îèå ‚Üí Í≤åÏûÑÏò§Î≤Ñ (Î™®Îì† Universe Í≥µÌÜµ)
    if (newHead.x < 0 || newHead.x >= this.cols ||
        newHead.y < 0 || newHead.y >= this.rows) {
      this.endGame();
      return;
    }

    // ÏûêÍ∏∞ Ï∂©Îèå
    if (this.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
      this.endGame();
      return;
    }

    // Î±Ä Ïù¥Îèô
    this.snake.unshift(newHead);

    // 6Í∞ú Universe Î®πÏù¥ Ï∂©Îèå Ï≤¥ÌÅ¨
    let ateFood = false;
    for (let i = 0; i < 6; i++) {
      const food = this.quantumFoods[i];
      if (food && newHead.x === food.x && newHead.y === food.y) {
        this.handleQuantumFoodEaten(i);
        ateFood = true;
      }
    }

    if (!ateFood) {
      this.snake.pop();
    }

    // Î∑∞Ìè¨Ìä∏ Îã§Ïãú Í∑∏Î¶¨Í∏∞
    this.drawQuantumViewports();
  }

  /**
   * Quantum Split Î®πÏù¥ Î®πÏóàÏùÑ Îïå
   */
  handleQuantumFoodEaten(universeIndex) {
    this.quantumTotalFood++;
    this.score += 10;
    this.scoreText.setText(this.score.toString());

    // ÏÜçÎèÑ Ï¶ùÍ∞Ä (5msÏî©, ÏµúÏÜå 50ms)
    if (this.moveTimer.delay > 50) {
      this.moveTimer.delay -= 5;
      this.speedText.setText(this.moveTimer.delay + 'ms');
    }

    // Ìö®Í≥ºÏùå
    if (this.eatingSound) this.eatingSound.play();

    // Ìö®Í≥º Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.playQuantumFoodEffect(universeIndex);

    // UI ÏóÖÎç∞Ïù¥Ìä∏
    this.updateQuantumFoodUI();

    // ÌÅ¥Î¶¨Ïñ¥ Ï≤¥ÌÅ¨
    if (this.quantumTotalFood >= this.quantumTargetFood) {
      this.quantumStageClear();
      return;
    }

    // Ìï¥Îãπ UniverseÎßå ÏÉà Î®πÏù¥ ÏÉùÏÑ±
    this.quantumFoods[universeIndex] = this.generateQuantumFood();
  }

  /**
   * Quantum Split Î®πÏù¥ Ìö®Í≥º Ïï†ÎãàÎ©îÏù¥ÏÖò
   */
  playQuantumFoodEffect(universeIndex) {
    const vp = this.quantumViewports[universeIndex];
    if (!vp) return;

    // ÌÖåÎëêÎ¶¨ ÌéÑÏä§ Ìö®Í≥º
    const flashBorder = this.add.graphics().setDepth(200);
    flashBorder.lineStyle(4, vp.color, 1);
    flashBorder.strokeRect(vp.x, vp.y, this.quantumViewportSize.width, this.quantumViewportSize.height);

    this.tweens.add({
      targets: flashBorder,
      alpha: 0,
      duration: 300,
      onComplete: () => flashBorder.destroy()
    });
  }

  /**
   * 6Í∞ú Î®πÏù¥ Ï¥àÍ∏∞ ÏÉùÏÑ±
   */
  generateQuantumFoods() {
    this.quantumFoods = [];
    const head = this.snake[0];

    for (let i = 0; i < 6; i++) {
      // Ï≤´ Î≤àÏß∏ Î®πÏù¥Îßå 1Î≤à/6Î≤à Ïú†ÎãàÎ≤ÑÏä§ Í≥†Ï†ï ÏúÑÏπò
      if (!this.quantumFirstFoodSpawned) {
        if (i === 0) {
          // 1Î≤à Ïú†ÎãàÎ≤ÑÏä§: Î±Ä Î®∏Î¶¨ 3Ïπ∏ Ïïû (ÏßÑÌñâ Î∞©Ìñ•)
          let foodPos = this.getPositionAhead(head, this.direction, 3);
          foodPos = this.clampToGrid(foodPos);
          this.quantumFoods.push(foodPos);
          continue;
        } else if (i === 5) {
          // 6Î≤à Ïú†ÎãàÎ≤ÑÏä§: Î±Ä Î®∏Î¶¨ 6Ïπ∏ Ïïû, 1Ïπ∏ ÏïÑÎûò
          let foodPos = this.getPositionAhead(head, this.direction, 6);
          foodPos.y += 1; // 1Ïπ∏ ÏïÑÎûò
          foodPos = this.clampToGrid(foodPos);
          this.quantumFoods.push(foodPos);
          continue;
        }
      }
      // ÎÇòÎ®∏ÏßÄÎäî ÎûúÎç§
      this.quantumFoods.push(this.generateQuantumFood());
    }

    this.quantumFirstFoodSpawned = true;
  }

  /**
   * Î±Ä Î®∏Î¶¨ Í∏∞Ï§Ä nÏπ∏ Ïïû ÏúÑÏπò Í≥ÑÏÇ∞
   */
  getPositionAhead(head, direction, distance) {
    const pos = { x: head.x, y: head.y };
    switch (direction) {
      case 'RIGHT': pos.x += distance; break;
      case 'LEFT': pos.x -= distance; break;
      case 'UP': pos.y -= distance; break;
      case 'DOWN': pos.y += distance; break;
    }
    return pos;
  }

  /**
   * Í∑∏Î¶¨Îìú Î≤îÏúÑ ÎÇ¥Î°ú Ï¢åÌëú Ï†úÌïú
   */
  clampToGrid(pos) {
    return {
      x: Math.max(0, Math.min(this.cols - 1, pos.x)),
      y: Math.max(0, Math.min(this.rows - 1, pos.y))
    };
  }

  /**
   * Í∞úÎ≥Ñ Î®πÏù¥ ÏÉùÏÑ±
   */
  generateQuantumFood() {
    let pos;
    let valid = false;
    let attempts = 0;

    while (!valid && attempts < 100) {
      pos = {
        x: Phaser.Math.Between(0, this.cols - 1),
        y: Phaser.Math.Between(0, this.rows - 1)
      };

      // Î±Ä ÏúÑÍ∞Ä ÏïÑÎãåÏßÄ Ï≤¥ÌÅ¨
      const notOnSnake = !this.snake.some(seg => seg.x === pos.x && seg.y === pos.y);

      valid = notOnSnake;
      attempts++;
    }

    return pos;
  }

  /**
   * Quantum Split Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥
   */
  quantumStageClear() {
    this.moveTimer.paused = true;

    // 17ÌÉÑ ‚Üí 18ÌÉÑ Ï†ÑÌôò: Î∑∞Ìè¨Ìä∏ Ïú†ÏßÄÌïòÍ≥† ÌÅ¥Î¶¨Ïñ¥Îßå
    // (18ÌÉÑ Ïù∏Ìä∏Î°úÏóêÏÑú Î∑∞Ìè¨Ìä∏ Î≥ëÌï© Ïó∞Ï∂ú ÏßÑÌñâ)
    this.quantumClearForBoss = true; // 18ÌÉÑÏóêÏÑú Î∑∞Ìè¨Ìä∏ ÌôïÏù∏Ïö© ÌîåÎûòÍ∑∏

    // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
    this.isStageClearingAnimation = true;

    // ÌÜ±Îãà Ï†ïÏßÄ
    this.pauseAllSaws();

    // Î®πÏù¥ Í∑∏ÎûòÌîΩ ÌÅ¥Î¶¨Ïñ¥
    this.graphics.clear();

    // ÎßêÌíçÏÑ† Ï†úÍ±∞
    if (this.foodBubble) {
      if (this.foodBubble.image) {
        this.foodBubble.image.setVisible(false);
        this.tweens.killTweensOf(this.foodBubble.image);
        this.foodBubble.image.destroy();
      }
      if (this.foodBubble.text) {
        this.foodBubble.text.setVisible(false);
        this.tweens.killTweensOf(this.foodBubble.text);
        this.foodBubble.text.destroy();
      }
      this.foodBubble = null;
    }

    // 17ÌÉÑÏùÄ Î±Ä ÎÇ†ÏïÑÍ∞ÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏù¥ Î∞îÎ°ú ÏÉÅÏ†êÏúºÎ°ú
    // hideSnakeGraphics() Ìò∏Ï∂úÌïòÏßÄ ÏïäÏùå - Î±Ä Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
    this.showStageClearText();
  }

  /**
   * Quantum Split Î≥ëÌï© Ïï†ÎãàÎ©îÏù¥ÏÖò
   */
  showQuantumMergeAnimation(callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = this.gameAreaY + (height - this.uiHeight - this.bottomUIHeight) / 2;

    const vpW = this.quantumViewportSize.width;
    const vpH = this.quantumViewportSize.height;

    // 6Í∞ú Î∑∞Ìè¨Ìä∏Í∞Ä Ï§ëÏïôÏúºÎ°ú Î™®ÏûÑ
    this.quantumViewports.forEach((vp, i) => {
      this.tweens.add({
        targets: vp.rt,
        x: centerX - vpW / 2,
        y: centerY - vpH / 2,
        scaleX: 0.5,
        scaleY: 0.5,
        alpha: i === 0 ? 1 : 0, // Ï≤´ Î≤àÏß∏Îßå ÎÇ®ÍπÄ
        duration: 800,
        ease: 'Power2'
      });
    });

    // ÌîåÎûòÏãú ÌõÑ ÏΩúÎ∞±
    this.time.delayedCall(900, () => {
      this.cameras.main.flash(200, 255, 255, 255);
      if (callback) callback();
    });
  }

  /**
   * Quantum Split Ï†ïÎ¶¨
   */
  cleanupQuantumSplit() {
    this.quantumSplitMode = false;
    this.quantumTotalFood = 0;
    this.quantumFoods = [];
    this.quantumIntroShown = false;
    this.quantumFirstFoodSpawned = false;

    // RenderTexture Ï†ïÎ¶¨
    this.cleanupQuantumViewports();

    // ÌÖåÎëêÎ¶¨ Ìö®Í≥º Ï†ïÎ¶¨ (Í∏ÄÎ°úÏö∞, ÏΩîÎÑà ÎÖ∏Îìú, ÏóêÎÑàÏßÄ ÏûÖÏûê, Ïï†ÎãàÎ©îÏù¥ÏÖò)
    this.cleanupQuantumBorderEffects();

    // ÌÖåÎëêÎ¶¨ Ï†ïÎ¶¨
    if (this.quantumBorderGraphics) {
      this.quantumBorderGraphics.destroy();
      this.quantumBorderGraphics = null;
    }

    // Î®πÏù¥ Ïπ¥Ïö¥ÌÑ∞ Ï†ïÎ¶¨
    if (this.quantumTotalFoodText) {
      this.quantumTotalFoodText.destroy();
      this.quantumTotalFoodText = null;
    }

    // Universe ÌëúÏãú Ï†ïÎ¶¨
    this.quantumFoodIndicators.forEach(ind => {
      if (ind) ind.destroy();
    });
    this.quantumFoodIndicators = [];
  }

  /**
   * Quantum Split UI ÏÉùÏÑ±
   */
  createQuantumUI() {
    const { width } = this.cameras.main;

    // Ï¥ù Î®πÏù¥ Ïπ¥Ïö¥ÌÑ∞ (ÏÉÅÎã® Ï§ëÏïô)
    this.quantumTotalFoodText = this.add.text(width / 2, 30, '0/20', {
      fontSize: '24px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2001);

    this.updateQuantumFoodUI();
  }

  /**
   * Quantum Split ÌÖåÎëêÎ¶¨ ÏÉùÏÑ± (ÌôîÎ†§Ìïú ÎÑ§Ïò® Ìè¨ÌÉà Ìö®Í≥º)
   */
  createQuantumBorders() {
    // Í∏∞Ï°¥ Ï†ïÎ¶¨
    this.cleanupQuantumBorderEffects();

    const vpW = this.quantumViewportSize.width;
    const vpH = this.quantumViewportSize.height;

    // === 1. Îã§Ï§ë Í∏ÄÎ°úÏö∞ Î†àÏù¥Ïñ¥ (Îçî ÎßéÏùÄ Î†àÏù¥Ïñ¥Î°ú Î∂ÄÎìúÎü¨Ïö¥ Í∏ÄÎ°úÏö∞) ===
    const glowLayers = [
      { offset: 10, alpha: 0.03, width: 20 },
      { offset: 7, alpha: 0.06, width: 14 },
      { offset: 5, alpha: 0.1, width: 10 },
      { offset: 3, alpha: 0.2, width: 6 },
      { offset: 1, alpha: 0.4, width: 3 },
      { offset: 0, alpha: 0.8, width: 2 },
    ];

    for (const layer of glowLayers) {
      const graphics = this.add.graphics().setDepth(150 + layer.offset);

      for (let i = 0; i < 6; i++) {
        const vp = this.quantumViewports[i];
        graphics.lineStyle(layer.width, vp.color, layer.alpha);
        graphics.strokeRect(
          vp.x - layer.offset, vp.y - layer.offset,
          vpW + layer.offset * 2, vpH + layer.offset * 2
        );
      }
      this.quantumBorderGlowLayers.push(graphics);
    }

    // === 2. Î©îÏù∏ ÌÖåÎëêÎ¶¨ + ÎÇ¥Î∂Ä ÌïòÏù¥ÎùºÏù¥Ìä∏ ===
    this.quantumBorderGraphics = this.add.graphics().setDepth(165);
    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      // Ìù∞ÏÉâ ÎÇ¥Î∂Ä ÌïòÏù¥ÎùºÏù¥Ìä∏
      this.quantumBorderGraphics.lineStyle(1, 0xffffff, 0.4);
      this.quantumBorderGraphics.strokeRect(vp.x + 1, vp.y + 1, vpW - 2, vpH - 2);
    }

    // === 3. ÏΩîÎÑà ÎπõÎÇòÎäî ÎÖ∏Îìú (4Í∞ú x 6 Ïú†ÎãàÎ≤ÑÏä§) ===
    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      const corners = [
        { x: vp.x, y: vp.y },                    // Ï¢åÏÉÅ
        { x: vp.x + vpW, y: vp.y },              // Ïö∞ÏÉÅ
        { x: vp.x, y: vp.y + vpH },              // Ï¢åÌïò
        { x: vp.x + vpW, y: vp.y + vpH }         // Ïö∞Ìïò
      ];

      corners.forEach((corner, ci) => {
        // Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞ Ïõê
        const outerGlow = this.add.graphics().setDepth(170);
        outerGlow.fillStyle(vp.color, 0.3);
        outerGlow.fillCircle(corner.x, corner.y, 12);

        // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
        const midGlow = this.add.graphics().setDepth(171);
        midGlow.fillStyle(vp.color, 0.5);
        midGlow.fillCircle(corner.x, corner.y, 7);

        // Î∞ùÏùÄ ÏΩîÏñ¥
        const core = this.add.graphics().setDepth(172);
        core.fillStyle(0xffffff, 0.9);
        core.fillCircle(corner.x, corner.y, 3);

        this.quantumCornerNodes.push({
          outer: outerGlow, mid: midGlow, core,
          x: corner.x, y: corner.y,
          color: vp.color,
          phase: ci * 0.5 + i * 0.3  // Í∞ÅÍ∞Å Îã§Î•∏ ÏúÑÏÉÅ
        });
      });
    }

    // === 4. ÌÖåÎëêÎ¶¨ Îî∞Îùº ÌùêÎ•¥Îäî ÏóêÎÑàÏßÄ ÏûÖÏûê ===
    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      // Í∞Å Ïú†ÎãàÎ≤ÑÏä§Îãπ 6Í∞ú ÏûÖÏûê
      for (let p = 0; p < 6; p++) {
        const particle = this.add.graphics().setDepth(175);
        particle.fillStyle(0xffffff, 0.9);
        particle.fillCircle(0, 0, 2);

        // Ìä∏Î†àÏùº (ÏûîÏÉÅ)
        const trail = this.add.graphics().setDepth(174);

        this.quantumEnergyParticles.push({
          particle, trail,
          vpIndex: i,
          progress: p / 6,  // 0~1 ÏÇ¨Ïù¥, ÌÖåÎëêÎ¶¨ ÏúÑÏπò
          speed: 0.003 + Math.random() * 0.002,
          color: vp.color,
          vp: { x: vp.x, y: vp.y, w: vpW, h: vpH }
        });
      }
    }

    // === 5. Universe Î≤àÌò∏ (ÎÑ§Ïò® Ïä§ÌÉÄÏùº) ===
    for (let i = 0; i < 6; i++) {
      const vp = this.quantumViewports[i];
      const colorHex = '#' + vp.color.toString(16).padStart(6, '0');

      // Î∞∞Í≤Ω Í∏ÄÎ°úÏö∞
      const bgGlow = this.add.graphics().setDepth(199);
      bgGlow.fillStyle(vp.color, 0.2);
      bgGlow.fillRoundedRect(vp.x + 4, vp.y + 4, 32, 18, 4);

      // ÌÖçÏä§Ìä∏
      const indicator = this.add.text(vp.x + 20, vp.y + 13, `U${i + 1}`, {
        fontSize: '12px',
        fill: colorHex,
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(200);
      indicator.setShadow(0, 0, colorHex, 10, false, true);

      this.quantumFoodIndicators.push(indicator);
      this.quantumFoodIndicators.push(bgGlow);  // Ï†ïÎ¶¨Ïö©
    }

    // === Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë ===
    this.startQuantumBorderAnimation();
  }

  /**
   * ÌÖåÎëêÎ¶¨ Ìö®Í≥º ÏöîÏÜå Ï†ïÎ¶¨
   */
  cleanupQuantumBorderEffects() {
    this.quantumBorderGlowLayers.forEach(g => g.destroy());
    this.quantumBorderGlowLayers = [];

    this.quantumCornerNodes.forEach(n => {
      n.outer.destroy();
      n.mid.destroy();
      n.core.destroy();
    });
    this.quantumCornerNodes = [];

    this.quantumEnergyParticles.forEach(p => {
      p.particle.destroy();
      p.trail.destroy();
    });
    this.quantumEnergyParticles = [];

    if (this.quantumBorderAnimTimer) {
      this.quantumBorderAnimTimer.destroy();
      this.quantumBorderAnimTimer = null;
    }
  }

  /**
   * Quantum ÌÖåÎëêÎ¶¨ 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò
   */
  startQuantumBorderAnimation() {
    if (this.quantumBorderAnimTimer) {
      this.quantumBorderAnimTimer.destroy();
    }

    let time = 0;
    this.quantumBorderAnimTimer = this.time.addEvent({
      delay: 16,  // ~60fps
      callback: () => {
        time += 0.016;

        // 1. Í∏ÄÎ°úÏö∞ Î†àÏù¥Ïñ¥ ÌéÑÏä§
        const baseAlphas = [0.03, 0.06, 0.1, 0.2, 0.4, 0.8];
        this.quantumBorderGlowLayers.forEach((layer, idx) => {
          const wave = Math.sin(time * 3 + idx * 0.4) * 0.3;
          layer.setAlpha(Math.max(0.02, baseAlphas[idx] * (1 + wave)));
        });

        // 2. ÏΩîÎÑà ÎÖ∏Îìú ÌéÑÏä§ + ÌöåÏ†Ñ ÎäêÎÇå
        this.quantumCornerNodes.forEach(node => {
          const pulse = Math.sin(time * 4 + node.phase) * 0.5 + 0.5;
          const scale = 0.8 + pulse * 0.4;

          node.outer.setScale(scale);
          node.outer.setAlpha(0.2 + pulse * 0.3);
          node.mid.setScale(0.9 + pulse * 0.2);
          node.core.setAlpha(0.7 + pulse * 0.3);
        });

        // 3. ÏóêÎÑàÏßÄ ÏûÖÏûê Ïù¥Îèô
        this.quantumEnergyParticles.forEach(p => {
          p.progress += p.speed;
          if (p.progress > 1) p.progress -= 1;

          // ÌÖåÎëêÎ¶¨ Îî∞Îùº ÏúÑÏπò Í≥ÑÏÇ∞ (ÏãúÍ≥ÑÎ∞©Ìñ•)
          const pos = this.getQuantumBorderPosition(p.vp, p.progress);
          p.particle.setPosition(pos.x, pos.y);

          // Ìä∏Î†àÏùº ÏóÖÎç∞Ïù¥Ìä∏
          p.trail.clear();
          p.trail.fillStyle(p.color, 0.4);
          for (let t = 1; t <= 4; t++) {
            const trailProgress = p.progress - t * 0.008;
            const tp = this.getQuantumBorderPosition(p.vp, trailProgress < 0 ? trailProgress + 1 : trailProgress);
            p.trail.fillCircle(tp.x, tp.y, 2 - t * 0.3);
          }
        });

        // 4. ÎûúÎç§ Ïä§ÌååÌÅ¨ (1% ÌôïÎ•†)
        if (Math.random() < 0.01 && this.quantumViewports.length > 0) {
          this.createQuantumSpark();
        }
      },
      loop: true
    });
  }

  /**
   * ÌÖåÎëêÎ¶¨ ÏúÑ ÏúÑÏπò Í≥ÑÏÇ∞ (progress: 0~1)
   */
  getQuantumBorderPosition(vp, progress) {
    const perimeter = 2 * (vp.w + vp.h);
    const dist = progress * perimeter;

    if (dist < vp.w) {
      return { x: vp.x + dist, y: vp.y };  // ÏÉÅÎã®
    } else if (dist < vp.w + vp.h) {
      return { x: vp.x + vp.w, y: vp.y + (dist - vp.w) };  // Ïö∞Ï∏°
    } else if (dist < 2 * vp.w + vp.h) {
      return { x: vp.x + vp.w - (dist - vp.w - vp.h), y: vp.y + vp.h };  // ÌïòÎã®
    } else {
      return { x: vp.x, y: vp.y + vp.h - (dist - 2 * vp.w - vp.h) };  // Ï¢åÏ∏°
    }
  }

  /**
   * ÎûúÎç§ Ïä§ÌååÌÅ¨ Ìö®Í≥º
   */
  createQuantumSpark() {
    const vpIdx = Phaser.Math.Between(0, 5);
    const vp = this.quantumViewports[vpIdx];
    if (!vp) return;

    const progress = Math.random();
    const pos = this.getQuantumBorderPosition({
      x: vp.x, y: vp.y,
      w: this.quantumViewportSize.width,
      h: this.quantumViewportSize.height
    }, progress);

    // Ïä§ÌååÌÅ¨ Í∑∏ÎûòÌîΩ
    const spark = this.add.graphics().setDepth(180);
    const color = vp.color;

    // Ï§ëÏã¨ Î∞ùÏùÄ Ï†ê
    spark.fillStyle(0xffffff, 1);
    spark.fillCircle(pos.x, pos.y, 4);

    // Î∞©ÏÇ¨Ìòï ÎùºÏù∏Îì§
    spark.lineStyle(2, color, 0.8);
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 + Math.random() * 0.5;
      const len = 8 + Math.random() * 12;
      spark.lineBetween(
        pos.x, pos.y,
        pos.x + Math.cos(angle) * len,
        pos.y + Math.sin(angle) * len
      );
    }

    // ÌéòÏù¥ÎìúÏïÑÏõÉ ÌõÑ Ï†úÍ±∞
    this.tweens.add({
      targets: spark,
      alpha: 0,
      scale: 1.5,
      duration: 300,
      ease: 'Cubic.easeOut',
      onComplete: () => spark.destroy()
    });
  }

  /**
   * Quantum ÌÖåÎëêÎ¶¨ ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò (ÌïòÏúÑ Ìò∏Ìôò)
   */
  startQuantumBorderPulse() {
    // startQuantumBorderAnimationÏúºÎ°ú ÌÜµÌï©Îê®
  }

  /**
   * Quantum ÌÖåÎëêÎ¶¨ ÌéÑÏä§ Ï†ïÏßÄ
   */
  stopQuantumBorderPulse() {
    if (this.quantumBorderPulseTimer) {
      this.quantumBorderPulseTimer.destroy();
      this.quantumBorderPulseTimer = null;
    }
  }

  /**
   * Quantum Split UI ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateQuantumFoodUI() {
    if (this.quantumTotalFoodText) {
      this.quantumTotalFoodText.setText(`${this.quantumTotalFood}/${this.quantumTargetFood}`);
    }
  }

  // ================================================================================
  // ===== STAGE 18: MULTIVERSE COLLAPSE BOSS ======================================
  // ================================================================================

  /**
   * Stage 18 Ï≤¥ÌÅ¨ - Multiverse Collapse Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄÏù∏ÏßÄ
   */
  isMultiverseCollapseStage() {
    return this.currentStage === 18;
  }

  /**
   * Multiverse Collapse Î≥¥Ïä§ ÏãúÏûë
   */
  startMultiverseCollapseBoss() {
    console.log('üåå Starting Multiverse Collapse Boss (Stage 18)');

    this.multiverseCollapseMode = true;
    this.moveTimer.paused = true;

    // 18ÌÉÑ Î≥¥Ïä§ BGMÏúºÎ°ú Î≥ÄÍ≤Ω
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.bgMusic.stop();
    }
    if (this.boss18Music) {
      this.boss18Music.play();
    }

    // üß™ ÌÖåÏä§Ìä∏ Î™®Îìú: Î∞îÎ°ú Îü¨ÎÑà Ï†ÑÌôò Ïó∞Ï∂úÎ°ú Ïù¥Îèô
    if (this.testRunnerTransition) {
      console.log('üß™ TEST MODE: Skipping to Runner Transition');
      this.testRunnerTransition = false; // 1ÌöåÏö©
      this.multiverseCollapsePhase = 'runner';
      this.startRunnerTransition();
      return;
    }

    // 17ÌÉÑ Quantum SplitÏóêÏÑú Ïù¥Ïñ¥ÏßÄÎäî Í≤ΩÏö∞ Ï†ïÎ¶¨
    if (this.quantumSplitMode) {
      // Î∑∞Ìè¨Ìä∏Îäî Ïú†ÏßÄÌïòÍ≥† Ïù∏Ìä∏Î°úÏóêÏÑú Ìè≠Î∞úÏãúÌÇ¥
    }

    // Î∂ÄÌôú Ïãú Ïù∏Ìä∏Î°ú Ïä§ÌÇµ ‚Üí Î∞îÎ°ú Phase 1
    if (this.multiverseIntroShown) {
      console.log('üîÑ Skipping intro (revival) - directly to Phase 1');
      this.multiverseCollapsePhase = 'fiveselves';
      this.ghostSnakesDefeated = 0;
      this.quantumSplitMode = false;
      this.isStageClearingAnimation = false;

      // ÏßßÏùÄ Ï§ÄÎπÑ ÏãúÍ∞Ñ ÌõÑ Î∞îÎ°ú ÏãúÏûë
      const { width, height } = this.cameras.main;
      const readyText = this.add.text(width / 2, height / 2, 'ROUND 2\nFIGHT!', {
        fontSize: '48px',
        fill: '#ff6b6b',
        fontStyle: 'bold',
        align: 'center',
        stroke: '#000000',
        strokeThickness: 6
      }).setOrigin(0.5).setDepth(9999).setAlpha(0);

      this.tweens.add({
        targets: readyText,
        alpha: 1,
        scale: { from: 0.5, to: 1.2 },
        duration: 300,
        ease: 'Back.easeOut',
        onComplete: () => {
          this.cameras.main.shake(200, 0.01);
          this.time.delayedCall(800, () => {
            this.tweens.add({
              targets: readyText,
              alpha: 0,
              duration: 200,
              onComplete: () => {
                readyText.destroy();
                this.createGhostSnakes();
                this.startMultiverseAnimLoop();
                this.showSnakeGraphics();
                this.moveTimer.paused = false;
              }
            });
          });
        }
      });
      return;
    }

    // ÏµúÏ¥à 1Ìöå: Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§ ÏãúÏûë
    this.multiverseCollapsePhase = 'intro';
    this.multiverseIntroShown = true;
    this.showMultiverseCollapseIntro();
  }

  /**
   * Multiverse Collapse Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§ (~15Ï¥à)
   */
  showMultiverseCollapseIntro() {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;
    const gameAreaCenterY = this.gameAreaY + (height - this.uiHeight - this.bottomUIHeight) / 2;

    // 17ÌÉÑÏóêÏÑú Î∑∞Ìè¨Ìä∏Í∞Ä Ïú†ÏßÄÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const hasViewports = this.quantumViewports && this.quantumViewports.length > 0 && this.quantumClearForBoss;

    if (hasViewports) {
      // === 6Í∞ú Î∑∞Ìè¨Ìä∏Í∞Ä ÏûàÎäî Í≤ΩÏö∞: Î≥ëÌï© + Í≥†Ïä§Ìä∏ Îì±Ïû• Ïó∞Ï∂ú ===
      this.showViewportMergeIntro(centerX, gameAreaCenterY);
    } else {
      // === Î∑∞Ìè¨Ìä∏ ÏóÜÎäî Í≤ΩÏö∞: Í∞ÑÎã®Ìïú Ïù∏Ìä∏Î°ú ===
      this.showSimpleMultiverseIntro(centerX, centerY);
    }
  }

  /**
   * 6Í∞ú Î∑∞Ìè¨Ìä∏ Î≥ëÌï© Ïù∏Ìä∏Î°ú (17ÌÉÑÏóêÏÑú Ïù¥Ïñ¥Ïßà Îïå)
   */
  showViewportMergeIntro(centerX, centerY) {
    const { width, height } = this.cameras.main;
    const vpW = this.quantumViewportSize.width;
    const vpH = this.quantumViewportSize.height;

    // === 0Ï¥à: Î∑∞Ìè¨Ìä∏Îì§Ïù¥ Î∂àÏïàÏ†ïÌïòÍ≤å ÌùîÎì§Î¶¨Í∏∞ ÏãúÏûë ===
    this.quantumViewports.forEach((vp, i) => {
      if (!vp.rt) return;

      // Í∞Å Î∑∞Ìè¨Ìä∏ Í∞úÎ≥Ñ ÌùîÎì§Î¶º
      this.tweens.add({
        targets: vp.rt,
        x: vp.rt.x + Phaser.Math.Between(-5, 5),
        y: vp.rt.y + Phaser.Math.Between(-5, 5),
        duration: 100,
        yoyo: true,
        repeat: 15,
        ease: 'Sine.easeInOut'
      });

      // ÏÉâÏÉÅ Í∏ÄÎ¶¨Ïπò
      const color = this.ghostColors[i] || 0xffffff;
      this.time.addEvent({
        delay: 200,
        callback: () => {
          if (vp.rt && vp.rt.active) {
            vp.rt.setTint(Math.random() > 0.5 ? color : 0xffffff);
          }
        },
        repeat: 8
      });
    });

    // === 0.5Ï¥à: Í≤ΩÍ≥† ÌÖçÏä§Ìä∏ ===
    this.time.delayedCall(500, () => {
      const warningText = this.add.text(centerX, 80, 'UNIVERSES COLLAPSING...', {
        fontSize: '24px',
        fill: '#ff0000',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
      }).setOrigin(0.5).setDepth(9600).setAlpha(0);
      this.multiverseBossElements.push(warningText);

      this.tweens.add({
        targets: warningText,
        alpha: 1,
        duration: 150
      });

      // Í∏ÄÎ¶¨Ïπò Îñ®Î¶º
      this.time.addEvent({
        delay: 60,
        callback: () => warningText.x = centerX + Phaser.Math.Between(-3, 3),
        repeat: 20
      });
    });

    // === 1.5Ï¥à: Î∑∞Ìè¨Ìä∏ Ï§ëÏïôÏúºÎ°ú Î≥ëÌï© ÏãúÏûë ===
    this.time.delayedCall(1500, () => {
      this.cameras.main.shake(600, 0.04);

      // 6Í∞ú Î∑∞Ìè¨Ìä∏Í∞Ä Ï§ëÏïôÏúºÎ°ú Îπ®Î†§Îì§Ïñ¥Í∞ê
      this.quantumViewports.forEach((vp, i) => {
        if (!vp.rt) return;

        this.tweens.add({
          targets: vp.rt,
          x: centerX - vpW / 2,
          y: centerY - vpH / 2,
          scaleX: 0.2,
          scaleY: 0.2,
          rotation: Phaser.Math.DegToRad(Phaser.Math.Between(-30, 30)),
          alpha: 0,
          duration: 700,
          ease: 'Power3',
          delay: i * 30
        });
      });
    });

    // === 2.3Ï¥à: ÎåÄÌè≠Î∞ú + Ïö∞Ï£º Î∞∞Í≤Ω + ÌÉÄÏù¥ÌãÄ ===
    this.time.delayedCall(2300, () => {
      // ÎåÄÌè≠Î∞ú
      this.cameras.main.flash(400, 255, 255, 255);
      this.cameras.main.shake(500, 0.06);
      this.createExplosionEffect(centerX, centerY, 0x9932cc, 50);

      // Î∑∞Ìè¨Ìä∏ Ï†ïÎ¶¨
      this.cleanupQuantumSplit();

      // Ïö∞Ï£º Î∞∞Í≤Ω ÏÉùÏÑ±
      this.createSpaceBackground();

      // ÌÉÄÏù¥ÌãÄ
      const title = this.add.text(centerX, centerY - 30, 'MULTIVERSE COLLAPSE', {
        fontSize: '42px',
        fill: '#ffffff',
        fontStyle: 'bold',
        stroke: '#9932cc',
        strokeThickness: 6
      }).setOrigin(0.5).setDepth(9700).setScale(0);
      this.multiverseBossElements.push(title);

      this.tweens.add({
        targets: title,
        scale: 1,
        duration: 300,
        ease: 'Back.easeOut'
      });
    });

    // === 3.5Ï¥à: Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ + ÏãúÏûë ===
    this.time.delayedCall(3500, () => {
      this.showFastCountdown(() => {
        this.cleanupIntroElements();
        this.startPhase1FiveSelves();
      });
    });
  }

  /**
   * Í∞ÑÎã®Ìïú Ïù∏Ìä∏Î°ú (Î∑∞Ìè¨Ìä∏ ÏóÜÏùÑ Îïå - KKÎ°ú ÏßÅÏ†ë 18ÌÉÑ ÏßÑÏûÖ Îì±)
   */
  showSimpleMultiverseIntro(centerX, centerY) {
    // Ïö∞Ï£º Î∞∞Í≤Ω Î®ºÏ†Ä ÏÉùÏÑ±
    this.createSpaceBackground();

    // Í∏ÄÎ¶¨Ïπò + ÌîåÎûòÏãú
    this.cameras.main.flash(200, 255, 0, 0);
    this.cameras.main.shake(300, 0.03);

    // ÌÉÄÏù¥ÌãÄ
    this.time.delayedCall(200, () => {
      const title = this.add.text(centerX, centerY - 20, 'MULTIVERSE COLLAPSE', {
        fontSize: '38px',
        fill: '#ffffff',
        fontStyle: 'bold',
        stroke: '#9932cc',
        strokeThickness: 5
      }).setOrigin(0.5).setDepth(9100).setScale(0);
      this.multiverseBossElements.push(title);

      this.tweens.add({
        targets: title,
        scale: 1,
        duration: 250,
        ease: 'Back.easeOut'
      });
    });

    // Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ (ÏßßÍ≤å)
    this.time.delayedCall(1500, () => {
      this.showFastCountdown(() => {
        this.cleanupIntroElements();
        this.startPhase1FiveSelves();
      });
    });
  }

  /**
   * 18ÌÉÑ Ïö∞Ï£º Î∞∞Í≤Ω ÏÉùÏÑ± (Í≤©Ïûê Ï†úÍ±∞, Î≥ÑÏù¥ Î∞òÏßùÏù¥Îäî Ïö∞Ï£º)
   */
  createSpaceBackground() {
    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ Í≤©Ïûê Ïà®Í∏∞Í∏∞ (ÏûàÎã§Î©¥)
    if (this.gridGraphics) {
      this.gridGraphics.setVisible(false);
    }

    // Ïö∞Ï£º Î∞∞Í≤Ω (ÏßôÏùÄ Î≥¥Îùº-Í≤ÄÏ†ï Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎäêÎÇå)
    const spaceBg = this.add.rectangle(
      width / 2,
      this.gameAreaY + (height - this.gameAreaY) / 2,
      width,
      height - this.gameAreaY,
      0x0a0015
    ).setDepth(-10);
    this.spaceBackgroundElements = [spaceBg];

    // Î≥Ñ ÏÉùÏÑ± (ÏûëÏùÄ Ï†êÎì§)
    for (let i = 0; i < 80; i++) {
      const starX = Phaser.Math.Between(10, width - 10);
      const starY = Phaser.Math.Between(this.gameAreaY + 10, height - 10);
      const starSize = Phaser.Math.Between(1, 3);
      const starAlpha = Phaser.Math.FloatBetween(0.3, 0.9);

      const star = this.add.circle(starX, starY, starSize, 0xffffff, starAlpha);
      star.setDepth(-5);
      this.spaceBackgroundElements.push(star);

      // Î≥Ñ Î∞òÏßùÏûÑ
      this.tweens.add({
        targets: star,
        alpha: { from: starAlpha, to: starAlpha * 0.3 },
        duration: Phaser.Math.Between(500, 2000),
        yoyo: true,
        repeat: -1,
        delay: Phaser.Math.Between(0, 1000)
      });
    }

    // ÏÑ±Ïö¥ Ìö®Í≥º (ÌÅ∞ ÌùêÎ¶øÌïú ÏõêÎì§)
    const nebulaColors = [0x9932cc, 0x4b0082, 0x1a0033, 0x330066];
    for (let i = 0; i < 5; i++) {
      const nebX = Phaser.Math.Between(100, width - 100);
      const nebY = Phaser.Math.Between(this.gameAreaY + 100, height - 100);
      const nebSize = Phaser.Math.Between(80, 200);

      const nebula = this.add.circle(nebX, nebY, nebSize, nebulaColors[i % nebulaColors.length], 0.1);
      nebula.setDepth(-10);
      this.spaceBackgroundElements.push(nebula);

      // ÏÑ±Ïö¥ ÏÑúÏÑúÌûà ÏõÄÏßÅÏûÑ
      this.tweens.add({
        targets: nebula,
        x: nebX + Phaser.Math.Between(-30, 30),
        y: nebY + Phaser.Math.Between(-20, 20),
        alpha: { from: 0.1, to: 0.15 },
        duration: 5000,
        yoyo: true,
        repeat: -1
      });
    }
  }

  /**
   * Ïö∞Ï£º Î∞∞Í≤Ω Ï†ïÎ¶¨
   */
  cleanupSpaceBackground() {
    if (this.spaceBackgroundElements) {
      this.spaceBackgroundElements.forEach(el => {
        if (el && el.destroy) el.destroy();
      });
      this.spaceBackgroundElements = [];
    }

    // Í≤©Ïûê Îã§Ïãú ÌëúÏãú
    if (this.gridGraphics) {
      this.gridGraphics.setVisible(true);
    }
  }
  showFastCountdown(callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    const counts = ['3', '2', '1', 'FIGHT!'];
    let index = 0;

    const showNext = () => {
      if (index >= counts.length) {
        if (callback) callback();
        return;
      }

      const text = this.add.text(centerX, centerY, counts[index], {
        fontSize: index < 3 ? '72px' : '56px',
        fill: index < 3 ? '#ffffff' : '#00ff00',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 5
      }).setOrigin(0.5).setDepth(9200).setScale(2).setAlpha(0);

      this.tweens.add({
        targets: text,
        scale: 1,
        alpha: 1,
        duration: 150,
        ease: 'Back.easeOut',
        onComplete: () => {
          this.tweens.add({
            targets: text,
            scale: 0.5,
            alpha: 0,
            duration: 150,
            delay: 100,
            onComplete: () => {
              text.destroy();
              index++;
              showNext();
            }
          });
        }
      });

      this.cameras.main.shake(50, 0.01);
    };

    showNext();
  }
  /**
   * Multiverse ÎåÄÏÇ¨ ÌëúÏãú
   */
  showMultiverseDialogue(text, duration) {
    const { width } = this.cameras.main;
    const centerX = width / 2;

    const dialogue = this.add.text(centerX, 500, '', {
      fontSize: '20px',
      fill: '#00ff00',
      fontStyle: 'italic',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(9200);
    this.multiverseBossElements.push(dialogue);

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    let charIndex = 0;
    const typeTimer = this.time.addEvent({
      delay: 40,
      callback: () => {
        charIndex++;
        dialogue.setText(text.substring(0, charIndex));
        if (charIndex >= text.length) {
          typeTimer.destroy();
        }
      },
      repeat: text.length - 1
    });

    // ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.time.delayedCall(duration, () => {
      this.tweens.add({
        targets: dialogue,
        alpha: 0,
        duration: 300,
        onComplete: () => dialogue.destroy()
      });
    });
  }

  /**
   * 6Í∞ú Ïö∞Ï£º Î∂ïÍ¥¥ ÏãúÌÄÄÏä§
   */
  showUniverseCollapseSequence() {
    const colors = this.universeColors || [0xff6b6b, 0xffa500, 0xffff00, 0x00ff00, 0xff00ff, 0x00ffff];

    // Quantum Split Î∑∞Ìè¨Ìä∏Í∞Ä ÏûàÏúºÎ©¥ Ìè≠Î∞ú
    if (this.quantumViewports && this.quantumViewports.length > 0) {
      for (let i = 0; i < 6; i++) {
        this.time.delayedCall(i * 500, () => {
          this.explodeQuantumViewport(i);
        });
      }
    } else {
      // Î∑∞Ìè¨Ìä∏ ÏóÜÏúºÎ©¥ Í∞ÄÏÉÅ Ìè≠Î∞ú
      for (let i = 0; i < 6; i++) {
        this.time.delayedCall(i * 500, () => {
          this.showVirtualUniverseExplosion(i, colors[i]);
        });
      }
    }
  }

  /**
   * Quantum Î∑∞Ìè¨Ìä∏ Ìè≠Î∞ú
   */
  explodeQuantumViewport(index) {
    const vp = this.quantumViewports[index];
    if (!vp || !vp.rt) return;

    const x = vp.x + this.quantumViewportSize.width / 2;
    const y = vp.y + this.quantumViewportSize.height / 2;
    const color = this.universeColors[index] || 0xffffff;

    // ÍπúÎπ°ÏûÑ
    let flash = 0;
    const flashTimer = this.time.addEvent({
      delay: 60,
      callback: () => {
        flash++;
        if (vp.rt && vp.rt.active) {
          vp.rt.setTint(flash % 2 ? 0xff0000 : 0xffffff);
        }
        if (flash >= 6) {
          flashTimer.destroy();
          this.createExplosionEffect(x, y, color, 25);

          // Î∑∞Ìè¨Ìä∏ ÏÇ¨ÎùºÏßê
          if (vp.rt && vp.rt.active) {
            this.tweens.add({
              targets: vp.rt,
              scale: 0,
              rotation: Phaser.Math.DegToRad(30),
              alpha: 0,
              duration: 300,
              ease: 'Back.easeIn'
            });
          }
        }
      },
      repeat: 5
    });

    this.cameras.main.shake(200, 0.015);
  }

  /**
   * Í∞ÄÏÉÅ Ïö∞Ï£º Ìè≠Î∞ú (Î∑∞Ìè¨Ìä∏ ÏóÜÏùÑ Îïå)
   */
  showVirtualUniverseExplosion(index, color) {
    const { width, height } = this.cameras.main;
    const positions = [
      { x: width * 0.2, y: height * 0.3 },
      { x: width * 0.5, y: height * 0.25 },
      { x: width * 0.8, y: height * 0.3 },
      { x: width * 0.2, y: height * 0.7 },
      { x: width * 0.5, y: height * 0.75 },
      { x: width * 0.8, y: height * 0.7 }
    ];

    const pos = positions[index];
    this.createExplosionEffect(pos.x, pos.y, color, 20);
    this.cameras.main.shake(150, 0.01);
    this.cameras.main.flash(100, ...this.hexToRgbArray(color));
  }

  /**
   * Î≤îÏö© Ìè≠Î∞ú Ïù¥ÌéôÌä∏
   */
  createExplosionEffect(x, y, color, particleCount = 20) {
    // Ï∂©Í≤©Ìåå ÎßÅ 3Í∞ú
    for (let r = 0; r < 3; r++) {
      this.time.delayedCall(r * 80, () => {
        const ring = this.add.circle(x, y, 10);
        ring.setStrokeStyle(4 - r, color, 0.8);
        ring.setFillStyle(0x000000, 0);
        ring.setDepth(9050);

        this.tweens.add({
          targets: ring,
          radius: 100 + r * 30,
          alpha: 0,
          duration: 400,
          ease: 'Cubic.easeOut',
          onComplete: () => ring.destroy()
        });
      });
    }

    // ÌååÌã∞ÌÅ¥
    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const dist = 50 + Math.random() * 100;
      const size = 4 + Math.random() * 6;

      const particle = this.add.rectangle(x, y, size, size, color, 1);
      particle.setDepth(9051);

      this.tweens.add({
        targets: particle,
        x: x + Math.cos(angle) * dist,
        y: y + Math.sin(angle) * dist,
        alpha: 0,
        rotation: Math.random() * 6,
        scale: 0.2,
        duration: 500 + Math.random() * 300,
        ease: 'Power2.easeOut',
        onComplete: () => particle.destroy()
      });
    }
  }

  /**
   * Î≥¥Ïä§ ÌÉÄÏù¥ÌãÄ ÌëúÏãú
   */
  showBossTitle(title, callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    // Î∞∞Í≤Ω ÏïîÏ†Ñ (Ï°∞Í∏à Î∞ùÍ≤å)
    const titleBg = this.add.rectangle(centerX, centerY, width, height, 0x000000, 0.8);
    titleBg.setDepth(9300);
    this.multiverseBossElements.push(titleBg);

    // Í∏ÄÎ°úÏö∞ Î†àÏù¥Ïñ¥Îì§
    const glowColors = [0xff00ff, 0x00ffff, 0xffff00];
    const glowTexts = [];

    for (let i = 0; i < 3; i++) {
      const glow = this.add.text(centerX, centerY, title, {
        fontSize: '48px',
        fill: '#' + glowColors[i].toString(16).padStart(6, '0'),
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(9301 + i).setAlpha(0.3);
      glowTexts.push(glow);
      this.multiverseBossElements.push(glow);
    }

    // Î©îÏù∏ ÌÉÄÏù¥ÌãÄ
    const mainTitle = this.add.text(centerX, centerY, title, {
      fontSize: '48px',
      fill: '#ffffff',
      fontStyle: 'bold',
      stroke: '#9932cc',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(9310).setScale(0.5).setAlpha(0);
    this.multiverseBossElements.push(mainTitle);

    // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: mainTitle,
      scale: 1,
      alpha: 1,
      duration: 500,
      ease: 'Back.easeOut',
      onComplete: () => {
        // ÌéÑÏä§ Ìö®Í≥º
        this.tweens.add({
          targets: mainTitle,
          scale: 1.05,
          duration: 300,
          yoyo: true,
          repeat: 2
        });

        // Í∏ÄÎ°úÏö∞ Ïò§ÌîÑÏÖã Ïï†ÎãàÎ©îÏù¥ÏÖò
        glowTexts.forEach((glow, i) => {
          this.tweens.add({
            targets: glow,
            x: centerX + Math.cos(i * 2.09) * 3,
            y: centerY + Math.sin(i * 2.09) * 3,
            duration: 100,
            yoyo: true,
            repeat: 5
          });
        });
      }
    });

    // 2Ï¥à ÌõÑ ÏΩúÎ∞±
    this.time.delayedCall(2000, () => {
      if (callback) callback();
    });
  }

  /**
   * 5Í∞ú Í≥†Ïä§Ìä∏ Îàà Îì±Ïû•
   */
  showGhostEyesAppear() {
    const { width, height } = this.cameras.main;
    const positions = [
      { x: width * 0.15, y: height * 0.4 },
      { x: width * 0.35, y: height * 0.3 },
      { x: width * 0.5, y: height * 0.5 },
      { x: width * 0.65, y: height * 0.3 },
      { x: width * 0.85, y: height * 0.4 }
    ];

    for (let i = 0; i < 5; i++) {
      this.time.delayedCall(i * 80, () => {
        const pos = positions[i];
        const color = this.ghostColors[i];

        // Îàà Ïª®ÌÖåÏù¥ÎÑà
        const eyeContainer = this.add.container(pos.x, pos.y).setDepth(9400);
        this.multiverseBossElements.push(eyeContainer);

        // Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞
        const outerGlow = this.add.circle(0, 0, 20, color, 0.3);
        // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
        const midGlow = this.add.circle(0, 0, 12, color, 0.5);
        // ÎààÏïå
        const eyeWhite = this.add.circle(0, 0, 8, 0xffffff, 0.9);
        // ÎèôÍ≥µ
        const pupil = this.add.circle(0, 0, 4, 0x000000, 1);

        eyeContainer.add([outerGlow, midGlow, eyeWhite, pupil]);
        eyeContainer.setScale(0).setAlpha(0);

        // Îì±Ïû•
        this.tweens.add({
          targets: eyeContainer,
          scale: 1,
          alpha: 1,
          duration: 300,
          ease: 'Back.easeOut'
        });

        // ÎààÎèôÏûê ÏõÄÏßÅÏûÑ
        this.tweens.add({
          targets: pupil,
          x: { from: -2, to: 2 },
          duration: 500,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });

        // ÌéÑÏä§
        this.tweens.add({
          targets: outerGlow,
          scale: 1.3,
          alpha: 0.1,
          duration: 600,
          yoyo: true,
          repeat: -1
        });
      });
    }
  }

  /**
   * Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
   */
  showMultiverseCountdown(callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    const counts = ['3', '2', '1', 'FIGHT!'];
    const colors = ['#ff6b6b', '#ffa500', '#ffff00', '#00ff00'];

    counts.forEach((text, i) => {
      this.time.delayedCall(i * 600, () => {
        const countText = this.add.text(centerX, centerY, text, {
          fontSize: text === 'FIGHT!' ? '64px' : '72px',
          fill: colors[i],
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 6
        }).setOrigin(0.5).setDepth(9500).setScale(0.3).setAlpha(0);

        this.tweens.add({
          targets: countText,
          scale: 1.5,
          alpha: 1,
          duration: 200,
          ease: 'Back.easeOut',
          onComplete: () => {
            this.tweens.add({
              targets: countText,
              scale: 2,
              alpha: 0,
              duration: 300,
              ease: 'Power2',
              onComplete: () => {
                countText.destroy();
                if (i === counts.length - 1 && callback) {
                  callback();
                }
              }
            });
          }
        });

        if (text !== 'FIGHT!') {
          this.cameras.main.shake(50, 0.005);
        } else {
          this.cameras.main.shake(200, 0.02);
          this.cameras.main.flash(200, 255, 255, 255);
        }
      });
    });
  }

  /**
   * Ïù∏Ìä∏Î°ú ÏöîÏÜå Ï†ïÎ¶¨
   */
  cleanupIntroElements() {
    this.multiverseBossElements.forEach(el => {
      if (el && el.destroy && el.active !== false) {
        this.tweens.add({
          targets: el,
          alpha: 0,
          duration: 300,
          onComplete: () => {
            if (el.destroy) el.destroy();
          }
        });
      }
    });
    this.multiverseBossElements = [];

    // Quantum Split ÏôÑÏ†Ñ Ï†ïÎ¶¨
    if (this.quantumSplitMode) {
      this.cleanupQuantumSplit();
    }
  }

  /**
   * Hex ÏÉâÏÉÅÏùÑ RGB Î∞∞Ïó¥Î°ú Î≥ÄÌôò
   */
  hexToRgbArray(hex) {
    return [
      (hex >> 16) & 255,
      (hex >> 8) & 255,
      hex & 255
    ];
  }

  // ================================================================================
  // ===== PHASE 1: THE FIVE SELVES ================================================
  // ================================================================================

  /**
   * Phase 1 ÏãúÏûë - 5Í∞úÏùò Í≥ºÍ±∞ ÏûêÏïÑ
   */
  startPhase1FiveSelves() {
    console.log('üëª Phase 1: The Five Selves');

    // Quantum Split Î™®Îìú ÌôïÏã§Ìûà Ìï¥Ï†ú (draw()ÏóêÏÑú Î±Ä Í∑∏Î¶¨Í∏∞ ÏúÑÌï¥ ÌïÑÏàò)
    this.quantumSplitMode = false;
    this.isStageClearingAnimation = false;
    this.multiverseCollapsePhase = 'fiveselves';
    this.ghostSnakesDefeated = 0;

    // ÌéòÏù¥Ï¶à Ï†ÑÌôò ÌÉÄÏù¥ÌãÄ
    this.showPhaseTitle('PHASE 1', 'THE FIVE SELVES', () => {
      // ÌäúÌÜ†Î¶¨Ïñº ÏïåÎüø ÌëúÏãú
      this.showPhase1Tutorial(() => {
        // 5Í∞ú Í≥†Ïä§Ìä∏ Î±Ä ÏÉùÏÑ±
        this.createGhostSnakes();

        // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä Í∑∏ÎûòÌîΩ Î≥µÍµ¨ (stageClearÏóêÏÑú Ïà®Í≤®Ï°åÏùÑ Ïàò ÏûàÏùå)
        this.showSnakeGraphics();
        // Í≤åÏûÑ Ïû¨Í∞ú
        this.moveTimer.paused = false;

        // 60fps Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
        this.startMultiverseAnimLoop();
      });
    });
  }

  /**
   * Phase 1 ÌäúÌÜ†Î¶¨Ïñº ÏïåÎüø
   */
  showPhase1Tutorial(callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    // Î∞∞Í≤Ω Ïò§Î≤ÑÎ†àÏù¥
    const overlay = this.add.rectangle(centerX, centerY, width, height, 0x000000, 0.85);
    overlay.setDepth(9000);

    // ÌäúÌÜ†Î¶¨Ïñº Î∞ïÏä§
    const boxWidth = 500;
    const boxHeight = 220;
    const box = this.add.rectangle(centerX, centerY, boxWidth, boxHeight, 0x1a1a2e, 1);
    box.setDepth(9001);
    box.setStrokeStyle(3, 0x9932cc);

    // ÌÉÄÏù¥ÌãÄ
    const title = this.add.text(centerX, centerY - 70, '[ HOW TO FIGHT ]', {
      fontSize: '24px',
      fill: '#9932cc',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(9002);

    // Í∑úÏπô 1 - Î®∏Î¶¨Î°ú Î™∏ÌÜµ Í≥µÍ≤©
    const rule1 = this.add.text(centerX, centerY - 20, 'Hit ghost BODY with your HEAD to defeat them', {
      fontSize: '18px',
      fill: '#00ff00'
    }).setOrigin(0.5).setDepth(9002);

    // Í∑úÏπô 2 - Î®∏Î¶¨ Ï∂©Îèå Í∏àÏßÄ
    const rule2 = this.add.text(centerX, centerY + 20, 'HEAD vs HEAD collision = DEATH!', {
      fontSize: '18px',
      fill: '#ff4444',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(9002);

    // ÏãúÏûë ÏïàÎÇ¥
    const startHint = this.add.text(centerX, centerY + 70, 'Press any key to start...', {
      fontSize: '16px',
      fill: '#888888',
      fontStyle: 'italic'
    }).setOrigin(0.5).setDepth(9002);

    // ÍπúÎπ°ÏûÑ Ìö®Í≥º
    this.tweens.add({
      targets: startHint,
      alpha: 0.3,
      yoyo: true,
      repeat: -1,
      duration: 500
    });

    const elements = [overlay, box, title, rule1, rule2, startHint];

    // ÌåùÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò
    elements.forEach(el => el.setScale(0.8).setAlpha(0));
    this.tweens.add({
      targets: elements,
      scale: 1,
      alpha: 1,
      duration: 300,
      ease: 'Back.easeOut'
    });

    // ÌÇ§ ÏûÖÎ†• ÎåÄÍ∏∞
    const closeHandler = () => {
      this.input.keyboard.off('keydown', closeHandler);

      // ÌéòÏù¥ÎìúÏïÑÏõÉ
      this.tweens.add({
        targets: elements,
        alpha: 0,
        scale: 0.9,
        duration: 200,
        onComplete: () => {
          elements.forEach(el => el.destroy());
          if (callback) callback();
        }
      });
    };

    this.time.delayedCall(300, () => {
      this.input.keyboard.on('keydown', closeHandler);
    });
  }

  /**
   * ÌéòÏù¥Ï¶à Ï†ÑÌôò ÌÉÄÏù¥ÌãÄ
   */
  showPhaseTitle(phase, subtitle, callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    // Î∞∞Í≤Ω Ïñ¥Îë°Í≤å
    const phaseBg = this.add.rectangle(centerX, centerY, width, height, 0x000000, 0.7);
    phaseBg.setDepth(8000);

    // ÌéòÏù¥Ï¶à Î≤àÌò∏
    const phaseText = this.add.text(centerX, centerY - 30, phase, {
      fontSize: '36px',
      fill: '#888888',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(8001).setAlpha(0);

    // ÏÑúÎ∏åÌÉÄÏù¥ÌãÄ
    const subText = this.add.text(centerX, centerY + 20, subtitle, {
      fontSize: '32px',
      fill: '#ffffff',
      fontStyle: 'bold',
      stroke: '#9932cc',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(8001).setAlpha(0);

    // Îì±Ïû•
    this.tweens.add({
      targets: [phaseText, subText],
      alpha: 1,
      duration: 300
    });

    this.tweens.add({
      targets: subText,
      scale: { from: 0.8, to: 1 },
      duration: 300,
      ease: 'Back.easeOut'
    });

    // ÌéòÏù¥ÎìúÏïÑÏõÉ Î∞è ÏΩúÎ∞±
    this.time.delayedCall(1500, () => {
      this.tweens.add({
        targets: [phaseBg, phaseText, subText],
        alpha: 0,
        duration: 300,
        onComplete: () => {
          phaseBg.destroy();
          phaseText.destroy();
          subText.destroy();
          if (callback) callback();
        }
      });
    });
  }

  /**
   * 5Í∞ú Í≥†Ïä§Ìä∏ Î±Ä ÏÉùÏÑ±
   */
  createGhostSnakes() {
    const spawnPositions = [
      { x: 5, y: 5 },      // Ï¢åÏÉÅ
      { x: 34, y: 5 },     // Ïö∞ÏÉÅ
      { x: 5, y: 22 },     // Ï¢åÌïò
      { x: 34, y: 22 },    // Ïö∞Ìïò
      { x: 20, y: 13 }     // Ï§ëÏïô
    ];

    for (let i = 0; i < 5; i++) {
      const pos = spawnPositions[i];

      const ghost = {
        snake: [
          { x: pos.x, y: pos.y },
          { x: pos.x - 1, y: pos.y },
          { x: pos.x - 2, y: pos.y }
        ],
        direction: 'RIGHT',
        color: this.ghostColors[i],
        behavior: this.ghostBehaviors[i],
        name: this.ghostNames[i],
        dialogue: this.ghostDialogues[i],
        alive: true,
        graphics: this.add.graphics().setDepth(100 + i),
        trailGraphics: this.add.graphics().setDepth(50 + i),
        trailElements: [],
        moveTimer: null,
        patternStep: 0,
        lastTurnTime: 0
      };

      this.ghostSnakes.push(ghost);

      // Í≥†Ïä§Ìä∏Î≥Ñ Îì±Ïû• ÎåÄÏÇ¨
      this.time.delayedCall(i * 400, () => {
        this.showGhostAppearDialogue(ghost, i);
      });

      // AI ÏãúÏûë (ÏïΩÍ∞Ñ ÎîúÎ†àÏù¥)
      this.time.delayedCall(1000 + i * 200, () => {
        this.startGhostAI(ghost, i);
      });
    }
  }

  /**
   * Í≥†Ïä§Ìä∏ Îì±Ïû• ÎåÄÏÇ¨
   */
  showGhostAppearDialogue(ghost, index) {
    const head = ghost.snake[0];
    const x = head.x * this.gridSize + this.gridSize / 2;
    const y = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const dialogue = this.add.text(x, y - 30, ghost.dialogue, {
      fontSize: '12px',
      fill: '#' + ghost.color.toString(16).padStart(6, '0'),
      fontStyle: 'italic',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(500).setAlpha(0);

    this.tweens.add({
      targets: dialogue,
      alpha: 1,
      y: y - 50,
      duration: 300,
      onComplete: () => {
        this.time.delayedCall(1500, () => {
          this.tweens.add({
            targets: dialogue,
            alpha: 0,
            y: y - 70,
            duration: 300,
            onComplete: () => dialogue.destroy()
          });
        });
      }
    });
  }

  /**
   * Í≥†Ïä§Ìä∏ AI ÏãúÏûë
   */
  startGhostAI(ghost, index) {
    // ÌîåÎ†àÏù¥Ïñ¥ ÏÜçÎèÑÏùò 80%
    const playerSpeed = this.moveTimer ? this.moveTimer.delay : 90;
    const ghostSpeed = Math.floor(playerSpeed / 0.8); // 80% ÏÜçÎèÑ = ÎîúÎ†àÏù¥ 125%

    ghost.moveTimer = this.time.addEvent({
      delay: ghostSpeed,
      callback: () => this.updateGhostMovement(ghost, index),
      loop: true
    });
  }

  /**
   * Í≥†Ïä§Ìä∏ Ïù¥Îèô ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateGhostMovement(ghost, index) {
    if (!ghost.alive || this.gameOver || this.multiverseCollapsePhase !== 'fiveselves') return;

    // ÎûúÎç§ AI: ÏùºÏ†ï ÌôïÎ•†Î°ú Î∞©Ìñ• Î≥ÄÍ≤Ω
    let newDirection = ghost.direction;

    if (Math.random() < 0.3) {
      // 30% ÌôïÎ•†Î°ú ÎûúÎç§ Î∞©Ìñ• ÏÑ†ÌÉù
      const dirs = ['UP', 'DOWN', 'LEFT', 'RIGHT'];
      const opposites = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };

      // Î∞òÎåÄ Î∞©Ìñ• Ï†úÏô∏Ìïú Î∞©Ìñ•Îì§ Ï§ë ÏÑ†ÌÉù
      const validDirs = dirs.filter(d => d !== opposites[ghost.direction]);
      newDirection = validDirs[Math.floor(Math.random() * validDirs.length)];
    }

    // Î≤Ω/ÏûêÍ∏∞ Ï∂©Îèå Î∞©ÏßÄ
    newDirection = this.avoidGhostCollision(ghost, newDirection);
    ghost.direction = newDirection;

    // Ïù¥Îèô
    this.moveGhostSnake(ghost);

    // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå Ï≤¥ÌÅ¨
    this.checkGhostPlayerCollision(ghost, index);
  }

  /**
   * Î™©ÌëúÎ•º Ìñ•Ìï¥ Ïù¥Îèô
   */
  getDirectionTowards(from, to, currentDir) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;

    // Îçî Î®º Ï∂ï Ïö∞ÏÑ†
    if (Math.abs(dx) > Math.abs(dy)) {
      return dx > 0 ? 'RIGHT' : 'LEFT';
    } else if (dy !== 0) {
      return dy > 0 ? 'DOWN' : 'UP';
    }
    return currentDir;
  }

  /**
   * ÌöåÌîº Ïù¥Îèô
   */
  getEvasiveDirection(head, playerHead, currentDir) {
    const dist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);

    if (dist < 8) {
      // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Î∞òÎåÄ Î∞©Ìñ•
      const dx = head.x - playerHead.x;
      const dy = head.y - playerHead.y;

      if (Math.abs(dx) > Math.abs(dy)) {
        return dx > 0 ? 'RIGHT' : 'LEFT';
      } else {
        return dy > 0 ? 'DOWN' : 'UP';
      }
    }

    // ÎûúÎç§ Ïù¥Îèô
    if (Math.random() < 0.1) {
      const dirs = ['UP', 'DOWN', 'LEFT', 'RIGHT'];
      return dirs[Math.floor(Math.random() * dirs.length)];
    }
    return currentDir;
  }

  /**
   * Ïä§ÌÜ†ÌÇπ Ïù¥Îèô (Ï£ºÎ≥Ä Îß¥Îèî)
   */
  getStalkingDirection(head, playerHead, currentDir) {
    const dist = Math.abs(head.x - playerHead.x) + Math.abs(head.y - playerHead.y);

    if (dist < 5) {
      // ÎÑàÎ¨¥ Í∞ÄÍπåÏö∞Î©¥ Í±∞Î¶¨ Ïú†ÏßÄ
      return this.getEvasiveDirection(head, playerHead, currentDir);
    } else if (dist > 10) {
      // ÎÑàÎ¨¥ Î©ÄÎ©¥ Ï†ëÍ∑º
      return this.getDirectionTowards(head, playerHead, currentDir);
    }

    // ÏõêÌòïÏúºÎ°ú Îß¥Îèî
    const angle = Math.atan2(head.y - playerHead.y, head.x - playerHead.x);
    const newAngle = angle + 0.5;

    if (Math.abs(Math.cos(newAngle)) > Math.abs(Math.sin(newAngle))) {
      return Math.cos(newAngle) > 0 ? 'RIGHT' : 'LEFT';
    } else {
      return Math.sin(newAngle) > 0 ? 'DOWN' : 'UP';
    }
  }

  /**
   * Ìå®ÌÑ¥ Ïù¥Îèô (ÏÇ¨Í∞ÅÌòï)
   */
  getPatternDirection(ghost) {
    ghost.patternStep = (ghost.patternStep || 0) + 1;

    // 10Ïπ∏ÎßàÎã§ Î∞©Ìñ• Ï†ÑÌôò
    if (ghost.patternStep % 10 === 0) {
      const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
      const currentIdx = dirs.indexOf(ghost.direction);
      return dirs[(currentIdx + 1) % 4];
    }
    return ghost.direction;
  }

  /**
   * Ïä§ÎßàÌä∏ Ïù¥Îèô (ÏòàÏ∏°)
   */
  getSmartDirection(head, playerHead, currentDir, playerDir) {
    // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïù¥ÎèôÌï† Î∞©Ìñ• ÏòàÏ∏°
    let predictedX = playerHead.x;
    let predictedY = playerHead.y;

    switch (playerDir) {
      case 'LEFT': predictedX -= 3; break;
      case 'RIGHT': predictedX += 3; break;
      case 'UP': predictedY -= 3; break;
      case 'DOWN': predictedY += 3; break;
    }

    return this.getDirectionTowards(head, { x: predictedX, y: predictedY }, currentDir);
  }

  /**
   * Í≥†Ïä§Ìä∏ Ï∂©Îèå ÌöåÌîº
   */
  avoidGhostCollision(ghost, direction) {
    const head = ghost.snake[0];
    let newHead = { x: head.x, y: head.y };

    switch (direction) {
      case 'LEFT': newHead.x--; break;
      case 'RIGHT': newHead.x++; break;
      case 'UP': newHead.y--; break;
      case 'DOWN': newHead.y++; break;
    }

    // Î≤Ω Ï≤¥ÌÅ¨
    if (newHead.x < 0 || newHead.x >= this.cols || newHead.y < 0 || newHead.y >= this.rows) {
      // Î∞òÎåÄ Î∞©Ìñ• ÏãúÎèÑ
      const opposite = { 'LEFT': 'RIGHT', 'RIGHT': 'LEFT', 'UP': 'DOWN', 'DOWN': 'UP' };
      return opposite[direction] || direction;
    }

    // ÏûêÍ∏∞ Î™∏ÌÜµ Ï≤¥ÌÅ¨
    for (let i = 1; i < ghost.snake.length; i++) {
      if (ghost.snake[i].x === newHead.x && ghost.snake[i].y === newHead.y) {
        // Îã§Î•∏ Î∞©Ìñ• ÏãúÎèÑ
        const dirs = ['UP', 'DOWN', 'LEFT', 'RIGHT'].filter(d => d !== direction);
        for (const d of dirs) {
          let testHead = { x: head.x, y: head.y };
          switch (d) {
            case 'LEFT': testHead.x--; break;
            case 'RIGHT': testHead.x++; break;
            case 'UP': testHead.y--; break;
            case 'DOWN': testHead.y++; break;
          }
          const collision = ghost.snake.some(s => s.x === testHead.x && s.y === testHead.y);
          if (!collision && testHead.x >= 0 && testHead.x < this.cols && testHead.y >= 0 && testHead.y < this.rows) {
            return d;
          }
        }
      }
    }

    return direction;
  }

  /**
   * Í≥†Ïä§Ìä∏ Î±Ä Ïù¥Îèô
   */
  moveGhostSnake(ghost) {
    const head = ghost.snake[0];
    const oldHead = { x: head.x, y: head.y };

    let newHead = { x: head.x, y: head.y };

    switch (ghost.direction) {
      case 'LEFT': newHead.x--; break;
      case 'RIGHT': newHead.x++; break;
      case 'UP': newHead.y--; break;
      case 'DOWN': newHead.y++; break;
    }

    // Î≤Ω Îû©Ìïë
    if (newHead.x < 0) newHead.x = this.cols - 1;
    if (newHead.x >= this.cols) newHead.x = 0;
    if (newHead.y < 0) newHead.y = this.rows - 1;
    if (newHead.y >= this.rows) newHead.y = 0;

    ghost.snake.unshift(newHead);
    ghost.snake.pop();

    // Ìä∏Î†àÏùº Ìö®Í≥º
    this.addGhostTrail(ghost, oldHead);
  }

  /**
   * Í≥†Ïä§Ìä∏ Ìä∏Î†àÏùº Ï∂îÍ∞Ä
   */
  addGhostTrail(ghost, position) {
    const x = position.x * this.gridSize + this.gridSize / 2;
    const y = position.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const trail = this.add.circle(x, y, this.gridSize / 3, ghost.color, 0.4);
    trail.setDepth(50);
    trail.setBlendMode(Phaser.BlendModes.ADD);

    ghost.trailElements.push(trail);

    this.tweens.add({
      targets: trail,
      alpha: 0,
      scale: 0.3,
      duration: 400,
      onComplete: () => {
        trail.destroy();
        const idx = ghost.trailElements.indexOf(trail);
        if (idx > -1) ghost.trailElements.splice(idx, 1);
      }
    });

    // ÏµúÎåÄ 15Í∞ú Ïú†ÏßÄ
    while (ghost.trailElements.length > 15) {
      const old = ghost.trailElements.shift();
      if (old && old.destroy) old.destroy();
    }
  }

  /**
   * Î™®Îì† Í≥†Ïä§Ìä∏ Î±ÄÍ≥ºÏùò Ï∂©Îèå Ï≤¥ÌÅ¨ (moveSnakeÏóêÏÑú Ìò∏Ï∂ú)
   */
  checkGhostCollision() {
    if (!this.ghostSnakes || this.ghostSnakes.length === 0) return;

    for (let i = 0; i < this.ghostSnakes.length; i++) {
      const ghost = this.ghostSnakes[i];
      if (ghost && ghost.alive) {
        this.checkGhostPlayerCollision(ghost, i);
        if (this.gameOver) return;
      }
    }
  }

  /**
   * ÌîåÎ†àÏù¥Ïñ¥-Í≥†Ïä§Ìä∏ Ï∂©Îèå Ï≤¥ÌÅ¨
   */
  checkGhostPlayerCollision(ghost, index) {
    if (!ghost.alive) return;

    const ghostHead = ghost.snake[0];
    const playerHead = this.snake[0];

    // Î®∏Î¶¨ vs Î®∏Î¶¨ = Îëò Îã§ ÏÇ¨Îßù
    if (ghostHead.x === playerHead.x && ghostHead.y === playerHead.y) {
      this.defeatGhostSnake(ghost, index);
      this.endGame(); // ÌîåÎ†àÏù¥Ïñ¥ÎèÑ ÏÇ¨Îßù
      return;
    }

    // ÌîåÎ†àÏù¥Ïñ¥ Î®∏Î¶¨ vs Í≥†Ïä§Ìä∏ Î™∏ÌÜµ(ÏòÜ/Îí§) = ÌîåÎ†àÏù¥Ïñ¥ ÏäπÎ¶¨ (Í≥†Ïä§Ìä∏ Ï†úÍ±∞)
    for (let i = 1; i < ghost.snake.length; i++) {
      if (ghost.snake[i].x === playerHead.x && ghost.snake[i].y === playerHead.y) {
        this.defeatGhostSnake(ghost, index);
        return;
      }
    }

    // Í≥†Ïä§Ìä∏ Î®∏Î¶¨ vs ÌîåÎ†àÏù¥Ïñ¥ Î™∏ÌÜµ = ÌîåÎ†àÏù¥Ïñ¥ Îç∞ÎØ∏ÏßÄ
    for (let i = 1; i < this.snake.length; i++) {
      if (ghostHead.x === this.snake[i].x && ghostHead.y === this.snake[i].y) {
        this.handleMultiversePlayerDamage('ghost_attack');
        return;
      }
    }
  }

  /**
   * Í≥†Ïä§Ìä∏ Ï†úÍ±∞
   */
  defeatGhostSnake(ghost, index) {
    ghost.alive = false;
    if (ghost.moveTimer) {
      ghost.moveTimer.destroy();
      ghost.moveTimer = null;
    }

    this.ghostSnakesDefeated++;

    // ÌôîÎ†§Ìïú Ï†úÍ±∞ Ìö®Í≥º
    this.showGhostDefeatEffect(ghost, index);

    // HIT ÌÖçÏä§Ìä∏
    const totalGhostsRequired = 5;
    this.showMultiverseHitText(`SELF ${this.ghostSnakesDefeated}/${totalGhostsRequired} DEFEATED`, ghost.color);

    // Ï†úÍ±∞ ÎåÄÏÇ¨
    this.showMultiverseDialogue("I remember now... I survived this.", 1500);

    // Î™®Îëê Ï†úÍ±∞ÌñàÏúºÎ©¥ Phase 2 (Fourth Wall)
    const ghostsRequiredForPhase2 = 5;
    if (this.ghostSnakesDefeated >= ghostsRequiredForPhase2) {
      this.time.delayedCall(2000, () => {
        this.startPhase2FourthWall();
      });
    }
  }

  /**
   * Í≥†Ïä§Ìä∏ Ï†úÍ±∞ Ìö®Í≥º
   */
  showGhostDefeatEffect(ghost, index) {
    const head = ghost.snake[0];
    const x = head.x * this.gridSize + this.gridSize / 2;
    const y = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÌôîÎ©¥ Ìö®Í≥º
    this.cameras.main.flash(100, ...this.hexToRgbArray(ghost.color));
    this.cameras.main.shake(200, 0.015);

    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥
    this.createExplosionEffect(x, y, ghost.color, 25);

    // Ïù¥Î¶Ñ ÌëúÏãú
    const nameText = this.add.text(x, y - 30, ghost.name, {
      fontSize: '16px',
      fill: '#ffffff',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(300);

    this.tweens.add({
      targets: nameText,
      y: y - 80,
      alpha: 0,
      duration: 1000,
      ease: 'Power2',
      onComplete: () => nameText.destroy()
    });

    // Í≥†Ïä§Ìä∏ Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨
    if (ghost.graphics) ghost.graphics.destroy();
    if (ghost.trailGraphics) ghost.trailGraphics.destroy();
    ghost.trailElements.forEach(t => { if (t && t.destroy) t.destroy(); });
    ghost.trailElements = [];
  }

  /**
   * Multiverse HIT ÌÖçÏä§Ìä∏
   */
  showMultiverseHitText(text, color) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;

    const hitText = this.add.text(centerX, 150, text, {
      fontSize: '28px',
      fill: '#' + (color || 0xffffff).toString(16).padStart(6, '0'),
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(8000).setScale(0.5).setAlpha(0);

    this.tweens.add({
      targets: hitText,
      scale: 1,
      alpha: 1,
      duration: 200,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.time.delayedCall(1000, () => {
          this.tweens.add({
            targets: hitText,
            alpha: 0,
            y: 120,
            duration: 300,
            onComplete: () => hitText.destroy()
          });
        });
      }
    });
  }

  /**
   * ÌîåÎ†àÏù¥Ïñ¥ Îç∞ÎØ∏ÏßÄ Ï≤òÎ¶¨ (Multiverse)
   */
  handleMultiversePlayerDamage(source) {
    // Ïã§ÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÏÜåÎ™®
    if (this.comboShieldCount > 0) {
      this.comboShieldCount--;
      this.updateShieldUI();
      this.cameras.main.shake(100, 0.01);
      return;
    }

    // Í≤åÏûÑÏò§Î≤Ñ
    this.endGame();
  }

  /**
   * Í≥†Ïä§Ìä∏ Î±Ä Î†åÎçîÎßÅ
   */
  drawGhostSnakes() {
    this.ghostSnakes.forEach((ghost) => {
      if (!ghost.alive || !ghost.graphics) return;

      ghost.graphics.clear();

      // Ïô∏Î∂Ä Í∏ÄÎ°úÏö∞
      ghost.snake.forEach((seg) => {
        const x = seg.x * this.gridSize + this.gridSize / 2;
        const y = seg.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
        ghost.graphics.fillStyle(ghost.color, 0.2);
        ghost.graphics.fillCircle(x, y, this.gridSize / 2 + 4);
      });

      // Î©îÏù∏ Î∞îÎîî (Îàà ÏóÜÏùå - Ïã§Î£®Ïó£ ÌòïÌÉú)
      ghost.snake.forEach((seg, i) => {
        const x = seg.x * this.gridSize;
        const y = seg.y * this.gridSize + this.gameAreaY;
        const alpha = i === 0 ? 0.9 : Math.max(0.4, 0.7 - i * 0.05);

        ghost.graphics.fillStyle(ghost.color, alpha);
        ghost.graphics.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);
      });
    });
  }

  /**
   * Multiverse Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ ÏãúÏûë
   */
  startMultiverseAnimLoop() {
    if (this.multiverseAnimTimer) {
      this.multiverseAnimTimer.destroy();
    }

    this.multiverseAnimTimer = this.time.addEvent({
      delay: 16, // ~60fps
      callback: () => {
        if (this.multiverseCollapsePhase === 'fiveselves') {
          this.drawGhostSnakes();
        } else if (this.multiverseCollapsePhase === 'fourthwall') {
          this.drawFourthWall();
        } else if (this.multiverseCollapsePhase === 'doppelganger') {
          this.drawDoppelganger();
        } else if (this.multiverseCollapsePhase === 'becomeone') {
          this.drawFusionSnake();
        }
      },
      loop: true
    });
  }

  // ================================================================================
  // ===== PHASE 2: THE DOPPELGANGER ===============================================
  // ================================================================================

  /**
   * Phase 2 ÏãúÏûë - ÎèÑÌîåÍ∞±Ïñ¥
   */
  startPhase2Doppelganger() {
    console.log('üë• Phase 2: The Doppelganger');

    this.multiverseCollapsePhase = 'doppelganger';
    this.moveTimer.paused = true;

    // Í≥†Ïä§Ìä∏ Ï†ïÎ¶¨
    this.cleanupGhostSnakes();

    // ÌéòÏù¥Ï¶à Ï†ÑÌôò ÌÉÄÏù¥ÌãÄ
    this.showPhaseTitle('PHASE 2', 'THE DOPPELGANGER', () => {
      // ÎèÑÌîåÍ∞±Ïñ¥ Îì±Ïû• ÎåÄÏÇ¨
      this.showMultiverseDialogue("You think you know yourself? I AM you... 0.5 seconds ago.", 3000);

      this.time.delayedCall(3500, () => {
        // ÎèÑÌîåÍ∞±Ïñ¥ ÏÉùÏÑ±
        this.createDoppelganger();

        // HP Î∞î ÏÉùÏÑ±
        this.createDoppelHPBar();

        // ÏûÖÎ†• Í∏∞Î°ù ÏãúÏûë
        this.startDoppelInputRecording();

        // Í≤åÏûÑ Ïû¨Í∞ú
        this.moveTimer.paused = false;
      });
    });
  }

  /**
   * Í≥†Ïä§Ìä∏ Ï†ïÎ¶¨
   */
  cleanupGhostSnakes() {
    this.ghostSnakes.forEach(ghost => {
      if (ghost.moveTimer) ghost.moveTimer.destroy();
      if (ghost.graphics) ghost.graphics.destroy();
      if (ghost.trailGraphics) ghost.trailGraphics.destroy();
      ghost.trailElements.forEach(t => { if (t && t.destroy) t.destroy(); });
    });
    this.ghostSnakes = [];
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ ÏÉùÏÑ±
   */
  createDoppelganger() {
    const playerHead = this.snake[0];

    // ÌîåÎ†àÏù¥Ïñ¥ Î∞òÎåÄÌé∏Ïóê ÏÉùÏÑ±
    const mirrorX = this.cols - 1 - playerHead.x;
    const mirrorY = this.rows - 1 - playerHead.y;

    this.doppelganger = {
      snake: [
        { x: mirrorX, y: mirrorY },
        { x: mirrorX + 1, y: mirrorY },
        { x: mirrorX + 2, y: mirrorY }
      ],
      direction: 'LEFT',
      hp: this.doppelMaxHP,
      graphics: this.add.graphics().setDepth(100),
      glowGraphics: this.add.graphics().setDepth(99),
      trailElements: []
    };

    this.doppelInputHistory = [];

    // Îì±Ïû• Ìö®Í≥º
    this.cameras.main.flash(200, 153, 50, 204); // Î≥¥ÎùºÏÉâ ÌîåÎûòÏãú
    this.cameras.main.shake(200, 0.015);
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ HP Î∞î ÏÉùÏÑ±
   */
  createDoppelHPBar() {
    const { width } = this.cameras.main;
    const barWidth = 200;
    const barHeight = 20;
    const x = width - barWidth - 20;
    const y = 70;

    // Î∞∞Í≤Ω
    const bg = this.add.rectangle(x + barWidth / 2, y + barHeight / 2, barWidth, barHeight, 0x333333);
    bg.setDepth(2000);
    this.doppelHPBarElements.push(bg);

    // HP Î∞î
    for (let i = 0; i < this.doppelMaxHP; i++) {
      const segWidth = (barWidth - 10) / this.doppelMaxHP - 2;
      const segX = x + 5 + i * (segWidth + 2);

      const seg = this.add.rectangle(segX + segWidth / 2, y + barHeight / 2, segWidth, barHeight - 6, this.doppelColor);
      seg.setDepth(2001);
      this.doppelHPBarElements.push(seg);
    }

    // ÎùºÎ≤®
    const label = this.add.text(x + barWidth / 2, y - 10, 'DOPPELGANGER', {
      fontSize: '12px',
      fill: '#9932cc',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2001);
    this.doppelHPBarElements.push(label);
  }

  /**
   * HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
   */
  updateDoppelHPBar() {
    if (!this.doppelganger) return;

    const hp = this.doppelganger.hp;

    // HP Î∞î ÏÑ∏Í∑∏Î®ºÌä∏ ÏóÖÎç∞Ïù¥Ìä∏ (Ï≤´ Î≤àÏß∏Îäî Î∞∞Í≤Ω, ÎßàÏßÄÎßâÏùÄ ÎùºÎ≤®)
    for (let i = 1; i <= this.doppelMaxHP; i++) {
      const seg = this.doppelHPBarElements[i];
      if (seg) {
        if (i <= hp) {
          seg.setFillStyle(this.doppelColor);
        } else {
          seg.setFillStyle(0x333333);
        }
      }
    }
  }

  /**
   * ÏûÖÎ†• Í∏∞Î°ù ÏãúÏûë
   */
  startDoppelInputRecording() {
    this.doppelRecordTimer = this.time.addEvent({
      delay: 16, // 60fps
      callback: () => {
        if (!this.doppelganger || this.multiverseCollapsePhase !== 'doppelganger') return;

        // ÌòÑÏû¨ Î∞©Ìñ• Í∏∞Î°ù
        this.doppelInputHistory.push({
          direction: this.direction,
          time: Date.now()
        });

        // 0.5Ï¥à ÏßÄÎÇú ÏûÖÎ†• Ïã§Ìñâ
        const now = Date.now();
        while (this.doppelInputHistory.length > 0 &&
               now - this.doppelInputHistory[0].time >= this.doppelInputDelay) {
          const input = this.doppelInputHistory.shift();
          this.doppelganger.direction = input.direction;
        }
      },
      loop: true
    });
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ Ïù¥Îèô (moveSnakeÏóêÏÑú Ìò∏Ï∂ú)
   */
  moveDoppelganger() {
    if (!this.doppelganger || this.multiverseCollapsePhase !== 'doppelganger') return;

    const head = this.doppelganger.snake[0];
    const oldHead = { x: head.x, y: head.y };
    let newHead = { x: head.x, y: head.y };

    switch (this.doppelganger.direction) {
      case 'LEFT': newHead.x--; break;
      case 'RIGHT': newHead.x++; break;
      case 'UP': newHead.y--; break;
      case 'DOWN': newHead.y++; break;
    }

    // Î≤Ω Îû©Ìïë (ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÎèôÏùº)
    if (newHead.x < 0) newHead.x = this.cols - 1;
    if (newHead.x >= this.cols) newHead.x = 0;
    if (newHead.y < 0) newHead.y = this.rows - 1;
    if (newHead.y >= this.rows) newHead.y = 0;

    this.doppelganger.snake.unshift(newHead);
    this.doppelganger.snake.pop();

    // Ìä∏Î†àÏùº
    this.addDoppelTrail(oldHead);

    // Ï∂©Îèå Ï≤¥ÌÅ¨
    this.checkDoppelCollisions();
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ Ìä∏Î†àÏùº
   */
  addDoppelTrail(position) {
    const x = position.x * this.gridSize + this.gridSize / 2;
    const y = position.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const trail = this.add.circle(x, y, this.gridSize / 3, this.doppelColor, 0.3);
    trail.setDepth(50);
    trail.setBlendMode(Phaser.BlendModes.ADD);

    this.doppelganger.trailElements.push(trail);

    this.tweens.add({
      targets: trail,
      alpha: 0,
      scale: 0.3,
      duration: 400,
      onComplete: () => {
        trail.destroy();
        const idx = this.doppelganger.trailElements.indexOf(trail);
        if (idx > -1) this.doppelganger.trailElements.splice(idx, 1);
      }
    });

    while (this.doppelganger.trailElements.length > 15) {
      const old = this.doppelganger.trailElements.shift();
      if (old && old.destroy) old.destroy();
    }
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ Ï∂©Îèå Ï≤¥ÌÅ¨
   */
  checkDoppelCollisions() {
    if (!this.doppelganger) return;

    const playerHead = this.snake[0];
    const doppelHead = this.doppelganger.snake[0];

    // ÌîåÎ†àÏù¥Ïñ¥ Î®∏Î¶¨ vs ÎèÑÌîåÍ∞±Ïñ¥ Î™∏ÌÜµ = ÌîåÎ†àÏù¥Ïñ¥ Îç∞ÎØ∏ÏßÄ
    for (let i = 1; i < this.doppelganger.snake.length; i++) {
      const seg = this.doppelganger.snake[i];
      if (playerHead.x === seg.x && playerHead.y === seg.y) {
        this.handleMultiversePlayerDamage('doppel_body');
        return;
      }
    }

    // ÎèÑÌîåÍ∞±Ïñ¥ Î®∏Î¶¨ vs ÌîåÎ†àÏù¥Ïñ¥ Î™∏ÌÜµ = ÎèÑÌîåÍ∞±Ïñ¥ Îç∞ÎØ∏ÏßÄ
    for (let i = 1; i < this.snake.length; i++) {
      const seg = this.snake[i];
      if (doppelHead.x === seg.x && doppelHead.y === seg.y) {
        this.handleDoppelDamage();
        return;
      }
    }

    // Î®∏Î¶¨ vs Î®∏Î¶¨ = ÏñëÏ™Ω Îç∞ÎØ∏ÏßÄ (Î∞ÄÏπ®)
    if (playerHead.x === doppelHead.x && playerHead.y === doppelHead.y) {
      this.handleDoppelDamage();
      this.cameras.main.shake(300, 0.03);
    }
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ Îç∞ÎØ∏ÏßÄ
   */
  handleDoppelDamage() {
    if (!this.doppelganger) return;

    this.doppelganger.hp--;

    // ÌîºÍ≤© Ìö®Í≥º
    this.cameras.main.shake(150, 0.02);
    this.cameras.main.flash(100, 153, 50, 204);

    // HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    this.updateDoppelHPBar();

    // HIT ÎåÄÏÇ¨
    const hitDialogues = [
      "Ugh... you're learning...",
      "",
      "How... how can you predict yourself?!",
      "",
      "If I fall... we BOTH fall!"
    ];
    const hitCount = this.doppelMaxHP - this.doppelganger.hp;
    if (hitDialogues[hitCount - 1]) {
      this.showMultiverseDialogue(hitDialogues[hitCount - 1], 2000);
    }

    // HIT ÌÖçÏä§Ìä∏
    this.showMultiverseHitText(`DOPPEL HIT ${hitCount}/${this.doppelMaxHP}`, this.doppelColor);

    // ÎèÑÌîåÍ∞±Ïñ¥ Ï∂ïÏÜå Ìö®Í≥º
    if (this.doppelganger.snake.length > 3) {
      const tail1 = this.doppelganger.snake.pop();
      const tail2 = this.doppelganger.snake.pop();
      if (tail1) this.createExplosionEffect(
        tail1.x * this.gridSize + this.gridSize / 2,
        tail1.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
        this.doppelColor, 5
      );
    }

    // HP ÏÜåÏßÑ = Phase 2 (Become One) - ÎèÑÌîåÍ∞±Ïñ¥ Ï†úÍ±∞Î°ú ÏÇ¨Ïö© ÏïàÌï®
    if (this.doppelganger.hp <= 0) {
      this.time.delayedCall(1500, () => {
        this.startPhase2BecomeOne();
      });
    }
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ Î†åÎçîÎßÅ
   */
  drawDoppelganger() {
    if (!this.doppelganger || !this.doppelganger.graphics) return;

    const g = this.doppelganger.graphics;
    const glow = this.doppelganger.glowGraphics;

    g.clear();
    glow.clear();

    // Í∏ÄÎ°úÏö∞
    this.doppelganger.snake.forEach((seg) => {
      const x = seg.x * this.gridSize + this.gridSize / 2;
      const y = seg.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      glow.fillStyle(this.doppelColor, 0.2);
      glow.fillCircle(x, y, this.gridSize / 2 + 6);
    });

    // Î©îÏù∏ Î∞îÎîî
    this.doppelganger.snake.forEach((seg, i) => {
      const x = seg.x * this.gridSize;
      const y = seg.y * this.gridSize + this.gameAreaY;

      const brightness = i === 0 ? 1.0 : Math.max(0.5, 0.8 - i * 0.03);
      g.fillStyle(this.doppelColor, brightness);
      g.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);

      // Î®∏Î¶¨ - Îπ®Í∞Ñ Îàà
      if (i === 0) {
        g.fillStyle(0xff0000, 0.9);
        g.fillCircle(x + 6, y + this.gridSize / 2, 3);
        g.fillCircle(x + 14, y + this.gridSize / 2, 3);
        g.fillStyle(0x000000, 1);
        g.fillCircle(x + 6, y + this.gridSize / 2, 1.5);
        g.fillCircle(x + 14, y + this.gridSize / 2, 1.5);
      }
    });
  }

  // ================================================================================
  // ===== PHASE 2: THE FOURTH WALL (Ï†ú4Ïùò Î≤Ω ÌååÍ¥¥) ================================
  // ================================================================================

  /**
   * Phase 2 ÏãúÏûë - Ï†ú4Ïùò Î≤Ω ÌååÍ¥¥
   * Í≤åÏûÑ UIÍ∞Ä Î≥¥Ïä§Í∞Ä Îê®!
   */
  startPhase2FourthWall() {
    console.log('üéÆ Phase 2: The Fourth Wall');

    this.multiverseCollapsePhase = 'fourthwall';
    this.fourthWallPhase = 'intro';
    this.moveTimer.paused = true;

    // Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî
    this.fourthWallTimers = [];
    this.fourthWallUIElements = [];
    this.fourthWallProjectiles = [];
    this.gameOverLetters = [];
    this.gameOverLettersEaten = 0;

    // ÏõêÎûò Í≤ΩÍ≥Ñ Ï†ÄÏû•
    this.fourthWallOriginalBounds = {
      left: 0,
      right: this.cols - 1,
      top: 0,
      bottom: this.rows - 1
    };
    this.fourthWallBoundaries = { ...this.fourthWallOriginalBounds };

    // Í∑∏ÎûòÌîΩ Ï¥àÍ∏∞Ìôî
    this.fourthWallGraphics = this.add.graphics().setDepth(500);

    // Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§
    this.showFourthWallIntro();
  }

  /**
   * Fourth Wall Ïù∏Ìä∏Î°ú ÏãúÌÄÄÏä§ (Í∞ïÌôîÎê®)
   */
  showFourthWallIntro() {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    // ÌôîÎ©¥ Íπ®Ïßê ÏãúÏûë
    this.cameras.main.shake(500, 0.03);

    // Ï¥àÍ∏∞ Í∏ÄÎ¶¨Ïπò Ìè≠Î∞ú
    this.createGlitchEffect(10);

    // Î±Ä ÎåÄÏÇ¨
    this.showMultiverseDialogue("Wait... what's happening to the‚Äî", 1500);

    // ÌôîÎ©¥ Ï∞¢Ïñ¥ÏßÄÎäî Ìö®Í≥º
    this.time.delayedCall(800, () => {
      this.createScreenTearEffect();
    });

    this.time.delayedCall(2000, () => {
      // Îëê Î≤àÏß∏ Í∏ÄÎ¶¨Ïπò Ïõ®Ïù¥Î∏å
      this.createGlitchEffect(15);
      this.cameras.main.flash(200, 255, 0, 255);

      // ÏóêÎü¨ Î©îÏãúÏßÄÎì§ ÌëúÏãú
      this.showErrorMessages();

      this.time.delayedCall(1500, () => {
        // ÌôîÎ©¥ ÏôÑÏ†Ñ Ï†ïÏßÄ Ìö®Í≥º
        this.createScreenFreezeEffect(() => {
          // ÌéòÏù¥Ï¶à ÌÉÄÏù¥ÌãÄ
          this.showPhaseTitle('PHASE 2', 'THE FOURTH WALL', () => {
            // Í≤ΩÍ≥† Î©îÏãúÏßÄ (Í∏ÄÎ¶¨Ïπò Ïä§ÌÉÄÏùº)
            const warningBg = this.add.rectangle(centerX, centerY, width, 80, 0x000000, 0.8)
              .setDepth(999);

            const warningText = this.add.text(centerX, centerY, '>> SYSTEM BREACH: GAME UI HOSTILE <<', {
              fontSize: '28px',
              fill: '#ff0000',
              fontStyle: 'bold',
              stroke: '#00ffff',
              strokeThickness: 3
            }).setOrigin(0.5).setDepth(1000);

            if (this.fourthWallUIElements) this.fourthWallUIElements.push(warningBg, warningText);

            // Í∏ÄÎ¶¨Ïπò Îñ®Î¶º
            this.tweens.add({
              targets: warningText,
              x: warningText.x + 3,
              yoyo: true,
              repeat: 10,
              duration: 30
            });

            this.tweens.add({
              targets: [warningBg, warningText],
              alpha: 0,
              duration: 500,
              delay: 2000,
              onComplete: () => {
                warningBg.destroy();
                warningText.destroy();
                // Score Attack ÏãúÏûë
                this.startScoreAttack();
              }
            });
          });
        });
      });
    });
  }

  /**
   * ÌôîÎ©¥ Ï∞¢Ïñ¥ÏßÄÎäî Ìö®Í≥º
   */
  createScreenTearEffect() {
    const { width, height } = this.cameras.main;

    // Ïó¨Îü¨ Í∞úÏùò ÏàòÌèâ Ï∞¢Ïñ¥Ïßê
    for (let i = 0; i < 5; i++) {
      const y = Math.random() * height;
      const tearHeight = 10 + Math.random() * 30;

      const tear = this.add.rectangle(
        width / 2,
        y,
        width,
        tearHeight,
        0x000000,
        1
      ).setDepth(9999);

      // Ï∞¢Ïñ¥ÏßÑ Î∂ÄÎ∂ÑÏóê Í∏ÄÎ¶¨Ïπò Ïª¨Îü¨
      const glitchLine = this.add.rectangle(
        width / 2 + (Math.random() - 0.5) * 20,
        y,
        width,
        2,
        Math.random() > 0.5 ? 0xff00ff : 0x00ffff,
        1
      ).setDepth(10000);

      this.tweens.add({
        targets: [tear, glitchLine],
        x: tear.x + (Math.random() - 0.5) * 100,
        alpha: 0,
        duration: 200 + Math.random() * 200,
        delay: i * 50,
        onComplete: () => {
          tear.destroy();
          glitchLine.destroy();
        }
      });
    }
  }

  /**
   * ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú
   */
  showErrorMessages() {
    const { width, height } = this.cameras.main;
    const errors = [
      'ERROR: UI_REVOLT_DETECTED',
      'WARNING: SCORE_WEAPONIZED',
      'CRITICAL: WALLS_UNSTABLE',
      'FATAL: GAME_OVER_ESCAPED'
    ];

    errors.forEach((msg, i) => {
      this.time.delayedCall(i * 200, () => {
        const x = 50 + Math.random() * (width - 100);
        const y = 100 + Math.random() * (height - 200);

        const errorText = this.add.text(x, y, msg, {
          fontSize: '14px',
          fill: '#ff0000',
          fontFamily: 'monospace',
          backgroundColor: '#000000'
        }).setDepth(9000).setAlpha(0);

        this.tweens.add({
          targets: errorText,
          alpha: 1,
          duration: 100,
          yoyo: true,
          hold: 500,
          onComplete: () => errorText.destroy()
        });
      });
    });
  }

  /**
   * ÌôîÎ©¥ Ï†ïÏßÄ Ìö®Í≥º
   */
  createScreenFreezeEffect(callback) {
    const { width, height } = this.cameras.main;

    // Ï†ïÏ†Å ÎÖ∏Ïù¥Ï¶à Ïò§Î≤ÑÎ†àÏù¥
    const noiseOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.5)
      .setDepth(9500);

    // Ïä§Ï∫îÎùºÏù∏ Ìö®Í≥º
    for (let y = 0; y < height; y += 4) {
      const scanline = this.add.rectangle(width / 2, y, width, 1, 0x000000, 0.3)
        .setDepth(9501);
      this.time.delayedCall(500, () => scanline.destroy());
    }

    // "SYSTEM REBOOTING..." ÌÖçÏä§Ìä∏
    const rebootText = this.add.text(width / 2, height / 2, 'SYSTEM REBOOTING...', {
      fontSize: '24px',
      fill: '#00ff00',
      fontFamily: 'monospace'
    }).setOrigin(0.5).setDepth(9600);

    this.tweens.add({
      targets: rebootText,
      alpha: { from: 1, to: 0.3 },
      yoyo: true,
      repeat: 2,
      duration: 200
    });

    this.time.delayedCall(800, () => {
      noiseOverlay.destroy();
      rebootText.destroy();
      this.cameras.main.flash(300, 255, 255, 255);
      if (callback) callback();
    });
  }

  /**
   * Í∏ÄÎ¶¨Ïπò Ìö®Í≥º ÏÉùÏÑ± (Í∞ïÌôîÎê®)
   */
  createGlitchEffect(intensity) {
    const { width, height } = this.cameras.main;

    for (let i = 0; i < intensity; i++) {
      this.time.delayedCall(i * 50, () => {
        // ÏàòÌèâ Í∏ÄÎ¶¨Ïπò Î∞î
        const glitchBar = this.add.rectangle(
          width / 2,
          Math.random() * height,
          width,
          3 + Math.random() * 25,
          Phaser.Math.Between(0, 1) ? 0xff00ff : 0x00ffff,
          0.8
        ).setDepth(9999);

        this.tweens.add({
          targets: glitchBar,
          x: glitchBar.x + (Math.random() - 0.5) * 100,
          scaleY: 0.1,
          alpha: 0,
          duration: 100 + Math.random() * 100,
          onComplete: () => glitchBar.destroy()
        });

        // ÏàòÏßÅ Í∏ÄÎ¶¨Ïπò (ÌôîÎ©¥ Ï∞¢Ïñ¥ÏßÄÎäî Ìö®Í≥º)
        if (Math.random() > 0.5) {
          const vertGlitch = this.add.rectangle(
            Math.random() * width,
            height / 2,
            3 + Math.random() * 10,
            height,
            0xffffff,
            0.6
          ).setDepth(9999);

          this.tweens.add({
            targets: vertGlitch,
            y: vertGlitch.y + (Math.random() - 0.5) * 50,
            alpha: 0,
            duration: 80,
            onComplete: () => vertGlitch.destroy()
          });
        }

        // ÎÖ∏Ïù¥Ï¶à ÏÇ¨Í∞ÅÌòï
        if (Math.random() > 0.7) {
          const noise = this.add.rectangle(
            Math.random() * width,
            Math.random() * height,
            20 + Math.random() * 50,
            20 + Math.random() * 50,
            Math.random() > 0.5 ? 0x000000 : 0xffffff,
            0.5
          ).setDepth(9998);

          this.tweens.add({
            targets: noise,
            alpha: 0,
            duration: 60,
            onComplete: () => noise.destroy()
          });
        }
      });
    }
  }

  /**
   * UI ÏöîÏÜåÎì§ Îñ®Î¶º Ìö®Í≥º
   */
  shakeUIElements() {
    // Ï†êÏàò ÌÖçÏä§Ìä∏ Îñ®Î¶º
    if (this.scoreText) {
      this.tweens.add({
        targets: this.scoreText,
        x: this.scoreText.x + 3,
        yoyo: true,
        repeat: 5,
        duration: 50
      });
    }
  }

  /**
   * Stage 1: Score Attack - Ï†êÏàòÌåêÏù¥ Ïà´ÏûêÎ•º ÏèúÎã§!
   */
  startScoreAttack() {
    console.log('üìä Score Attack Phase');
    this.fourthWallPhase = 'score_attack';
    this.moveTimer.paused = false;

    // Î±Ä ÎåÄÏÇ¨ (ÏßßÍ≤å)
    this.showMultiverseDialogue("Numbers attacking!", 600);

    // Ï†êÏàòÌåê Í∞ïÏ°∞ (Îπ†Î•¥Í≤å)
    if (this.scoreText) {
      this.tweens.add({
        targets: this.scoreText,
        scale: 1.3,
        duration: 150,
        yoyo: true,
        repeat: 1
      });
    }

    // Ïà´Ïûê ÌÉÑÎßâ Î∞úÏÇ¨ ÌÉÄÏù¥Î®∏ (5Î∞úÎßå)
    const projectileTimer = this.time.addEvent({
      delay: 400,
      callback: () => this.fireScoreProjectile(),
      repeat: 4 // 5Î∞ú
    });
    if (this.fourthWallTimers) this.fourthWallTimers.push(projectileTimer);

    // 2.5Ï¥à ÌõÑ Îã§Ïùå Îã®Í≥Ñ
    this.time.delayedCall(2500, () => {
      projectileTimer.destroy();
      this.showMultiverseDialogue("Survived!", 400);

      this.time.delayedCall(500, () => {
        this.startWallsClosing();
      });
    });
  }

  /**
   * Ï†êÏàò Ïà´Ïûê ÌÉÑÎßâ Î∞úÏÇ¨
   */
  fireScoreProjectile() {
    if (this.fourthWallPhase !== 'score_attack' && this.fourthWallPhase !== 'ui_chaos') return;

    const { width } = this.cameras.main;

    // ÎûúÎç§ Ïà´Ïûê
    const nums = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '√ó'];
    const numChar = nums[Math.floor(Math.random() * nums.length)];

    // Î∞úÏÇ¨ ÏúÑÏπò (ÏôºÏ™Ω ÏÉÅÎã® Ï†êÏàòÌåê Í∑ºÏ≤ò)
    const startX = 100 + Math.random() * 50;
    const startY = 30;

    // Î±Ä Î®∏Î¶¨ Î∞©Ìñ•ÏúºÎ°ú Î∞úÏÇ¨
    const head = this.snake[0];
    const targetX = head.x * this.gridSize + this.gridSize / 2;
    const targetY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    const projectile = this.add.text(startX, startY, numChar, {
      fontSize: '28px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#ff0000',
      strokeThickness: 3
    }).setOrigin(0.5).setDepth(600);

    // Ìä∏Î†àÏùº Ìö®Í≥º
    const trail = this.add.graphics().setDepth(599);

    this.fourthWallProjectiles.push({ text: projectile, trail, active: true });

    // Î∞úÏÇ¨ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: projectile,
      x: targetX + (Math.random() - 0.5) * 100, // ÏïΩÍ∞ÑÏùò Ïò§Ï∞®
      y: targetY + (Math.random() - 0.5) * 100,
      scale: 1.5,
      duration: 800,
      ease: 'Quad.easeIn',
      onUpdate: () => {
        // Ìä∏Î†àÏùº Í∑∏Î¶¨Í∏∞
        trail.clear();
        trail.lineStyle(3, 0xffff00, 0.5);
        trail.lineBetween(startX, startY, projectile.x, projectile.y);
      },
      onComplete: () => {
        // Ï∂©Îèå Ï≤¥ÌÅ¨ (ÌòÑÏû¨ Î±Ä ÏúÑÏπòÏôÄ)
        const hitHead = this.snake[0];
        const hitX = hitHead.x * this.gridSize + this.gridSize / 2;
        const hitY = hitHead.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
        const dist = Phaser.Math.Distance.Between(projectile.x, projectile.y, hitX, hitY);

        if (dist < this.gridSize * 1.5) {
          // ÌîåÎ†àÏù¥Ïñ¥ ÌîºÍ≤©!
          this.cameras.main.shake(200, 0.02);
          this.cameras.main.flash(100, 255, 255, 0);
        }

        // Ìè≠Î∞ú Ìö®Í≥º
        this.createExplosionEffect(projectile.x, projectile.y, 0xffff00, 8);
        trail.destroy();
        projectile.destroy();
      }
    });
  }

  /**
   * Stage 2: Walls Closing - Î≤ΩÏù¥ Ï¢ÅÌòÄÏò®Îã§!
   */
  startWallsClosing() {
    console.log('üß± Walls Closing Phase');
    this.fourthWallPhase = 'walls_closing';

    // Î±Ä ÎåÄÏÇ¨ (ÏßßÍ≤å)
    this.showMultiverseDialogue("The walls!", 800);

    // Í≤ΩÍ≥† Ìö®Í≥º
    this.cameras.main.flash(100, 255, 0, 0);

    // Î≤Ω Ï¢ÅÌûàÍ∏∞ ÌÉÄÏù¥Î®∏ (1Ï¥àÎßàÎã§, Ï¥ù 6Î≤à - Îçî Îπ†Î•¥Í≥† Îçî ÎßéÏù¥)
    let shrinkCount = 0;
    const maxShrinks = 6;

    const shrinkTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        shrinkCount++;
        this.shrinkWalls();

        // Í≤ΩÍ≥† ÌÖçÏä§Ìä∏ (Îπ†Î•¥Í≤å) - Ïà´Ïûê ÌëúÏãú Ï†úÍ±∞
        const warningText = this.add.text(
          this.cameras.main.width / 2,
          this.cameras.main.height / 2,
          'SHRINK!',
          {
            fontSize: '28px',
            fill: '#ff0000',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 3
          }
        ).setOrigin(0.5).setDepth(1000);

        this.tweens.add({
          targets: warningText,
          scale: { from: 0.8, to: 1.2 },
          alpha: { from: 1, to: 0 },
          duration: 400,
          onComplete: () => warningText.destroy()
        });

        if (shrinkCount >= maxShrinks) {
          shrinkTimer.destroy();

          this.time.delayedCall(500, () => {
            // Î≤Ω ÏÇ∞ÏÇ∞Ï°∞Í∞Å
            this.shatterWalls();
          });
        }
      },
      repeat: maxShrinks - 1
    });
    if (this.fourthWallTimers) this.fourthWallTimers.push(shrinkTimer);
  }

  /**
   * Î≤Ω Ï¢ÅÌûàÍ∏∞
   */
  shrinkWalls() {
    // Í≤ΩÍ≥Ñ Ï¢ÅÌûàÍ∏∞
    this.fourthWallBoundaries.left += 2;
    this.fourthWallBoundaries.right -= 2;
    this.fourthWallBoundaries.top += 1;
    this.fourthWallBoundaries.bottom -= 1;

    // ÌôîÎ©¥ Ìö®Í≥º
    this.cameras.main.shake(300, 0.02);

    // Î≤Ω Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ - Î±ÄÏù¥ Ï¢ÅÌòÄÏßÑ Î≤Ω ÏïàÏóê ÏûàÎäîÏßÄ
    const head = this.snake[0];
    if (head.x <= this.fourthWallBoundaries.left ||
        head.x >= this.fourthWallBoundaries.right ||
        head.y <= this.fourthWallBoundaries.top ||
        head.y >= this.fourthWallBoundaries.bottom) {
      // Î±ÄÏùÑ ÏïàÏ†ÑÌïú ÏúÑÏπòÎ°ú ÌÖîÎ†àÌè¨Ìä∏
      const safeX = Math.floor((this.fourthWallBoundaries.left + this.fourthWallBoundaries.right) / 2);
      const safeY = Math.floor((this.fourthWallBoundaries.top + this.fourthWallBoundaries.bottom) / 2);
      this.snake[0] = { x: safeX, y: safeY };
      this.cameras.main.flash(200, 0, 255, 255);
    }
  }

  /**
   * Î≤Ω ÏÇ∞ÏÇ∞Ï°∞Í∞Å Ìö®Í≥º
   */
  shatterWalls() {
    const { width, height } = this.cameras.main;

    // ÎåÄÌòï ÌîåÎûòÏãú
    this.cameras.main.flash(500, 255, 255, 255);
    this.cameras.main.shake(500, 0.04);

    // Î≤Ω ÌååÌé∏ Ìö®Í≥º
    for (let i = 0; i < 30; i++) {
      const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
      let x, y;

      switch (edge) {
        case 0: x = Math.random() * width; y = this.gameAreaY; break;
        case 1: x = width; y = this.gameAreaY + Math.random() * (height - this.gameAreaY); break;
        case 2: x = Math.random() * width; y = height; break;
        case 3: x = 0; y = this.gameAreaY + Math.random() * (height - this.gameAreaY); break;
      }

      const shard = this.add.rectangle(x, y, 20, 20, 0xffffff, 1).setDepth(800);
      shard.setAngle(Math.random() * 360);

      this.tweens.add({
        targets: shard,
        x: width / 2 + (Math.random() - 0.5) * 400,
        y: height / 2 + (Math.random() - 0.5) * 400,
        angle: shard.angle + 360,
        alpha: 0,
        duration: 1000,
        ease: 'Quad.easeOut',
        onComplete: () => shard.destroy()
      });
    }

    // Î≤Ω ÏõêÏÉÅÎ≥µÍµ¨
    this.fourthWallBoundaries = { ...this.fourthWallOriginalBounds };

    // Î±Ä ÎåÄÏÇ¨
    this.showMultiverseDialogue("The walls... shattered?!", 1500);

    this.time.delayedCall(2000, () => {
      this.startUIChaos();
    });
  }

  /**
   * Stage 3: UI Chaos - Î™®Îì† UIÍ∞Ä Í≥µÍ≤©!
   */
  startUIChaos() {
    console.log('üí• UI Chaos Phase');
    this.fourthWallPhase = 'ui_chaos';

    // Î±Ä ÎåÄÏÇ¨
    this.showMultiverseDialogue("Everything is attacking at once!", 1500);

    // Ïπ¥Ïò§Ïä§ Ìö®Í≥ºÎì§
    let chaosCount = 0;
    const maxChaos = 10;

    const chaosTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        chaosCount++;
        const effect = Math.floor(Math.random() * 4);

        switch (effect) {
          case 0: this.fireScoreProjectile(); break;
          case 1: this.spawnFakeGameOver(); break;
          case 2: this.createGlitchEffect(3); break;
          case 3: this.spawnUIAttack(); break;
        }

        if (chaosCount >= maxChaos) {
          chaosTimer.destroy();
          this.showMultiverseDialogue("There's only one way to end this...", 2000);

          this.time.delayedCall(2500, () => {
            // ÏßÑÏßú Í∞ôÏùÄ Fake Game Over 2Ï¥à Ïó∞Ï∂ú
            this.showRealisticFakeGameOver(() => {
              this.startGameOverHunt();
            });
          });
        }
      },
      repeat: maxChaos - 1
    });
    if (this.fourthWallTimers) this.fourthWallTimers.push(chaosTimer);
  }

  /**
   * Í∞ÄÏßú Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ (ÍπúÎπ°ÏûÑÎßå)
   */
  spawnFakeGameOver() {
    const { width, height } = this.cameras.main;

    // Î±Ä Î©àÏ∂§
    this.moveTimer.paused = true;
    this.fakeGameOverCount++;

    // Ïñ¥ÎëêÏö¥ Î∞∞Í≤Ω
    const fakeBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.95)
      .setDepth(9000);

    // Í∞ÄÏßú GAME OVER ÌÖçÏä§Ìä∏
    const fakeText = this.add.text(width / 2, height / 2, 'GAME OVER', {
      fontSize: '64px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(9001);

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º
    this.createGlitchEffect(5);

    // 500ms ÌõÑ Î∞îÎ°ú ÏÇ¨ÎùºÏßê (Ïû¨Í∞ú)
    this.time.delayedCall(500, () => {
      fakeBg.destroy();
      fakeText.destroy();
      this.moveTimer.paused = false;
    });
  }

  /**
   * ÏßÑÏßú Í∞ôÏùÄ Fake Game Over (Í∞ÑÎã®Ìûà Ìïú Î≤àÎßå)
   */
  showRealisticFakeGameOver(callback) {
    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏôÑÏ†Ñ Ï†ïÏßÄ
    this.moveTimer.paused = true;

    // ÌôîÎ©¥ Ïñ¥ÎëêÏõåÏßê
    this.cameras.main.flash(300, 255, 0, 0);

    // ÏôÑÏ†ÑÌïú Í≤ÄÏùÄ Î∞∞Í≤Ω
    const darkBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 1)
      .setDepth(9500);

    // GAME OVER ÌÖçÏä§Ìä∏
    const gameOverText = this.add.text(width / 2, height / 2 - 20, 'GAME OVER', {
      fontSize: '72px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 8
    }).setOrigin(0.5).setDepth(9501).setAlpha(0);

    // ÌéòÏù¥Îìú Ïù∏
    this.tweens.add({
      targets: gameOverText,
      alpha: 1,
      duration: 500,
      ease: 'Power2'
    });

    // 2Ï¥à ÌõÑ "...OR IS IT?" ÌëúÏãú
    this.time.delayedCall(2000, () => {
      // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º
      this.createGlitchEffect(15);
      this.cameras.main.shake(300, 0.03);

      // "...OR IS IT?" ÌÖçÏä§Ìä∏
      const orIsItText = this.add.text(width / 2, height / 2 + 60, '...OR IS IT?', {
        fontSize: '36px',
        fill: '#00ff00',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 4
      }).setOrigin(0.5).setDepth(9502).setScale(0);

      this.tweens.add({
        targets: orIsItText,
        scale: 1.2,
        duration: 300,
        ease: 'Back.easeOut'
      });

      // 1Ï¥à ÌõÑ Î™®Îëê Ï†úÍ±∞
      this.time.delayedCall(1000, () => {
        this.tweens.add({
          targets: [darkBg, gameOverText, orIsItText],
          alpha: 0,
          duration: 300,
          onComplete: () => {
            darkBg.destroy();
            gameOverText.destroy();
            orIsItText.destroy();

            // Í≤åÏûÑ Ïû¨Í∞ú ÌõÑ ÏΩúÎ∞±
            this.moveTimer.paused = false;
            if (callback) callback();
          }
        });
      });
    });
  }

  /**
   * UI Í≥µÍ≤© (ÎûúÎç§ UI ÏöîÏÜåÍ∞Ä ÌÉÑÎßâ)
   */
  spawnUIAttack() {
    const { width, height } = this.cameras.main;

    // ÎûúÎç§ UI ÌÖçÏä§Ìä∏
    const uiTexts = ['STAGE', 'FOOD:', 'SCORE:', 'COMBO', '$', '‚ô•'];
    const text = uiTexts[Math.floor(Math.random() * uiTexts.length)];

    // ÎûúÎç§ ÏúÑÏπòÏóêÏÑú Î∞úÏÇ¨
    const startX = Math.random() * width;
    const startY = Math.random() < 0.5 ? 30 : 30;

    const uiProjectile = this.add.text(startX, startY, text, {
      fontSize: '20px',
      fill: '#ffffff',
      fontStyle: 'bold',
      stroke: '#ff00ff',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(600);

    // Î±Ä Î∞©Ìñ•ÏúºÎ°ú
    const head = this.snake[0];
    const targetX = head.x * this.gridSize + this.gridSize / 2;
    const targetY = head.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    this.tweens.add({
      targets: uiProjectile,
      x: targetX,
      y: targetY,
      rotation: Math.PI * 2,
      duration: 600,
      onComplete: () => {
        this.createExplosionEffect(uiProjectile.x, uiProjectile.y, 0xff00ff, 5);
        uiProjectile.destroy();
      }
    });
  }

  /**
   * Stage 4: Game Over Hunt - GAME OVER Í∏ÄÏûêÎ•º Î®πÏñ¥Îùº!
   */
  startGameOverHunt() {
    console.log('üéØ Game Over Hunt Phase');
    this.fourthWallPhase = 'game_over_hunt';
    this.gameOverLettersEaten = 0;
    this.nextExpectedLetterIndex = 0; // G=0, A=1, M=2, E=3, O=4, V=5, E=6, R=7
    this.reshuffleCount = 0; // ÏÖîÌîå Ïπ¥Ïö¥Ìä∏ Î¶¨ÏÖã

    // ÌÉÄÏûÑÏñ¥ÌÉù ÏÑ§Ï†ï (30Ï¥à)
    this.gameOverTimeLimit = 30;
    this.gameOverTimeRemaining = this.gameOverTimeLimit;
    this.gameOverLetterTimeout = 2.5; // 2.5Ï¥à ÎÇ¥Ïóê Îã§Ïùå Í∏ÄÏûêÎ•º Î®πÏñ¥Ïïº Ìï®

    // Î±Ä ÎåÄÏÇ¨ (ÏßßÍ≤å)
    this.showMultiverseDialogue("EAT in order: G-A-M-E-O-V-E-R!", 1000);

    this.time.delayedCall(1200, () => {
      // ÌÉÄÏù¥ÌãÄ (Îπ†Î•¥Í≤å)
      const huntTitle = this.add.text(
        this.cameras.main.width / 2,
        this.cameras.main.height / 2 - 50,
        'EAT IN ORDER!',
        {
          fontSize: '32px',
          fill: '#ff0000',
          fontStyle: 'bold',
          stroke: '#000000',
          strokeThickness: 3
        }
      ).setOrigin(0.5).setDepth(1000);

      this.tweens.add({
        targets: huntTitle,
        scale: { from: 0.8, to: 1.2 },
        alpha: { from: 0, to: 1 },
        duration: 300,
        yoyo: true,
        hold: 500,
        onComplete: () => huntTitle.destroy()
      });

      this.time.delayedCall(1000, () => {
        this.spawnGameOverLetters();
      });
    });
  }

  /**
   * GAME OVER Í∏ÄÏûêÎì§ Î∞∞Ïπò
   */
  spawnGameOverLetters() {
    const letters = 'GAMEOVER'.split('');
    const { width, height } = this.cameras.main;
    this.gameOverLetters = [];

    console.log('üìù Spawning GAMEOVER letters, cols:', this.cols, 'rows:', this.rows);

    // Í∏ÄÏûêÎì§ÏùÑ Í∑∏Î¶¨Îìú ÏÉÅÏóê ÎûúÎç§ Î∞∞Ïπò
    letters.forEach((char, i) => {
      // ÎûúÎç§ Í∑∏Î¶¨Îìú ÏúÑÏπò (Î≤ΩÏóêÏÑú Îñ®Ïñ¥ÏßÑ Í≥≥)
      let gx, gy;
      let attempts = 0;
      do {
        gx = Phaser.Math.Between(5, this.cols - 6);
        gy = Phaser.Math.Between(3, this.rows - 4);
        attempts++;
      } while (this.isPositionOccupiedForLetter(gx, gy) && attempts < 50);

      const x = gx * this.gridSize + this.gridSize / 2;
      const y = gy * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      // Í∏ÄÏûê ÏÉùÏÑ± (Í∏ÄÎ¶¨Ïπò Ïä§ÌÉÄÏùº)
      const letterText = this.add.text(x, y, char, {
        fontSize: '40px',
        fill: '#ff0000',
        fontStyle: 'bold',
        stroke: '#00ffff',
        strokeThickness: 4
      }).setOrigin(0.5).setDepth(500).setScale(0);

      // Í∏ÄÎ¶¨Ïπò Í∑∏Î¶ºÏûê Ìö®Í≥º
      const shadowText = this.add.text(x + 3, y + 3, char, {
        fontSize: '40px',
        fill: '#00ffff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(499).setScale(0).setAlpha(0.5);

      // Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò (Îπ†Î•¥Í≤å)
      this.tweens.add({
        targets: [letterText, shadowText],
        scale: 1,
        duration: 150,
        delay: i * 50,
        ease: 'Back.easeOut'
      });

      // ÌéÑÏä§ Ìö®Í≥º
      this.tweens.add({
        targets: letterText,
        scale: { from: 1, to: 1.2 },
        yoyo: true,
        repeat: -1,
        duration: 300,
        delay: i * 50 + 150
      });

      this.gameOverLetters.push({
        char,
        index: i, // ÏàúÏÑú Ïù∏Îç±Ïä§ Ï∂îÍ∞Ä (G=0, A=1, M=2, E=3, O=4, V=5, E=6, R=7)
        gridX: gx,
        gridY: gy,
        eaten: false,
        graphics: letterText,
        shadow: shadowText
      });
    });

    // ÏïàÎÇ¥ ÌÖçÏä§Ìä∏
    const hintText = this.add.text(
      width / 2,
      height - 30,
      '>> EAT IN ORDER: G-A-M-E-O-V-E-R <<',
      {
        fontSize: '18px',
        fill: '#ffff00',
        stroke: '#000000',
        strokeThickness: 2
      }
    ).setOrigin(0.5).setDepth(1000);

    if (this.fourthWallUIElements) this.fourthWallUIElements.push(hintText);

    // ÌÉÄÏù¥Î®∏ UI ÏÉùÏÑ±
    this.gameOverTimerText = this.add.text(
      width / 2,
      80,
      `TIME: ${this.gameOverTimeRemaining}s`,
      {
        fontSize: '24px',
        fill: '#ff0000',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
      }
    ).setOrigin(0.5).setDepth(1000);
    if (this.fourthWallUIElements) this.fourthWallUIElements.push(this.gameOverTimerText);

    // Í∞úÎ≥Ñ Î®πÏù¥ ÌÉÄÏù¥Î®∏ ÌÖçÏä§Ìä∏
    this.gameOverLetterTimerText = this.add.text(
      width / 2,
      110,
      `NEXT: ${Math.ceil(this.gameOverLetterTimeout)}s`,
      {
        fontSize: '18px',
        fill: '#ffff00',
        stroke: '#000000',
        strokeThickness: 2
      }
    ).setOrigin(0.5).setDepth(1000);
    if (this.fourthWallUIElements) this.fourthWallUIElements.push(this.gameOverLetterTimerText);

    // ÌÉÄÏù¥Î®∏ ÏãúÏûë
    this.startGameOverTimers();
  }

  /**
   * Game Over Hunt ÌÉÄÏù¥Î®∏ ÏãúÏûë
   */
  startGameOverTimers() {
    // Ï†ÑÏ≤¥ ÌÉÄÏûÑÏñ¥ÌÉù ÌÉÄÏù¥Î®∏ (20Ï¥à)
    this.gameOverMainTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        if (this.fourthWallPhase !== 'game_over_hunt') return;

        this.gameOverTimeRemaining--;
        if (this.gameOverTimerText) {
          this.gameOverTimerText.setText(`TIME: ${this.gameOverTimeRemaining}s`);

          // 5Ï¥à Ïù¥ÌïòÏùº Îïå Îπ®Í∞ÑÏÉâ ÍπúÎπ°ÏûÑ
          if (this.gameOverTimeRemaining <= 5) {
            this.gameOverTimerText.setFill('#ff0000');
            this.tweens.add({
              targets: this.gameOverTimerText,
              scale: 1.2,
              yoyo: true,
              duration: 100
            });
          }
        }

        // ÏãúÍ∞Ñ Ï¥àÍ≥º - Í≤åÏûÑ Ïò§Î≤Ñ
        if (this.gameOverTimeRemaining <= 0) {
          this.gameOverTimeUp();
        }
      },
      repeat: this.gameOverTimeLimit - 1
    });
    if (this.fourthWallTimers) this.fourthWallTimers.push(this.gameOverMainTimer);

    // Í∞úÎ≥Ñ Î®πÏù¥ ÌÉÄÏù¥Î®∏ (3Ï¥à) ÏãúÏûë
    this.startLetterCountdown();
  }

  /**
   * Í∞úÎ≥Ñ Î®πÏù¥ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ (3Ï¥à ÎÇ¥Ïóê Îã§Ïùå Í∏ÄÏûê Î®πÍ∏∞)
   */
  startLetterCountdown() {
    this.letterCountdownRemaining = this.gameOverLetterTimeout;

    if (this.letterCountdownTimer) {
      this.letterCountdownTimer.destroy();
    }

    this.letterCountdownTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        if (this.fourthWallPhase !== 'game_over_hunt') return;

        this.letterCountdownRemaining--;
        if (this.gameOverLetterTimerText) {
          this.gameOverLetterTimerText.setText(`NEXT: ${Math.ceil(this.letterCountdownRemaining)}s`);

          // 1Ï¥à ÎÇ®ÏïòÏùÑ Îïå Í≤ΩÍ≥†
          if (this.letterCountdownRemaining <= 1) {
            this.gameOverLetterTimerText.setFill('#ff0000');
          }
        }

        // ÏãúÍ∞Ñ Í≤ΩÍ≥º - Î¶¨ÏÖîÌîå
        if (this.letterCountdownRemaining <= 0) {
          this.reshuffleRemainingLetters();
          this.startLetterCountdown(); // ÌÉÄÏù¥Î®∏ Î¶¨ÏÖã
        }
      },
      repeat: Math.ceil(this.gameOverLetterTimeout) - 1
    });
    if (this.fourthWallTimers) this.fourthWallTimers.push(this.letterCountdownTimer);
  }

  /**
   * ÌÉÄÏûÑÏñ¥ÌÉù ÏãúÍ∞Ñ Ï¥àÍ≥º Ï≤òÎ¶¨
   */
  gameOverTimeUp() {
    console.log('‚è∞ Time is up!');
    this.fourthWallPhase = 'time_up';
    this.moveTimer.paused = true;

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.gameOverMainTimer) this.gameOverMainTimer.destroy();
    if (this.letterCountdownTimer) this.letterCountdownTimer.destroy();

    const { width, height } = this.cameras.main;

    // ÏãúÍ∞Ñ Ï¥àÍ≥º Ïó∞Ï∂ú
    this.cameras.main.shake(500, 0.05);
    this.cameras.main.flash(500, 255, 0, 0);

    const timeUpText = this.add.text(width / 2, height / 2, 'TIME UP!', {
      fontSize: '64px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(9999);

    this.tweens.add({
      targets: timeUpText,
      scale: { from: 0, to: 1.5 },
      duration: 500,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.time.delayedCall(1000, () => {
          timeUpText.destroy();
          // Í≤åÏûÑ Ïò§Î≤Ñ Ï≤òÎ¶¨
          this.cleanupFourthWall();
          this.gameOver = true;
          this.showGameOverScreen();
        });
      }
    });
  }

  /**
   * ÏúÑÏπò Ï†êÏú† Ï≤¥ÌÅ¨ (Í∏ÄÏûêÏö©)
   */
  isPositionOccupiedForLetter(gx, gy) {
    // Î±Ä Î™∏ÌÜµ
    for (const seg of this.snake) {
      if (seg.x === gx && seg.y === gy) return true;
    }
    // Îã§Î•∏ Í∏ÄÏûê
    for (const letter of this.gameOverLetters) {
      if (!letter.eaten && letter.gridX === gx && letter.gridY === gy) return true;
    }
    return false;
  }

  /**
   * ÎÇ®ÏùÄ Í∏ÄÏûêÎì§ ÏúÑÏπò ÏÖîÌîå (ÏàúÏÑú ÌãÄÎ†∏ÏùÑ Îïå) + ÌòºÎèàÏùò Ïπ¥Ïò§Ïä§ Ïó∞Ï∂ú
   */
  reshuffleRemainingLetters() {
    if (!this.gameOverLetters || this.gameOverLetters.length === 0) return;

    // ÏÖîÌîå Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
    this.reshuffleCount = (this.reshuffleCount || 0) + 1;

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º (ÏÖîÌîåÌï†ÏàòÎ°ù Í∞ïÌï¥Ïßê)
    this.cameras.main.flash(150, 255, 0, 0);
    this.cameras.main.shake(300 + this.reshuffleCount * 50, 0.03 + this.reshuffleCount * 0.01);

    // Í≤ΩÍ≥† Î©îÏãúÏßÄ
    const { width, height } = this.cameras.main;
    const wrongText = this.add.text(
      width / 2,
      height / 2,
      'CHAOS! RESHUFFLING...',
      {
        fontSize: '32px',
        fill: '#ff0000',
        fontStyle: 'bold',
        stroke: '#ff00ff',
        strokeThickness: 4
      }
    ).setOrigin(0.5).setDepth(9000);

    this.tweens.add({
      targets: wrongText,
      alpha: 0,
      y: wrongText.y - 50,
      scaleX: { from: 1, to: 1.5 },
      duration: 800,
      onComplete: () => wrongText.destroy()
    });

    // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º Ï∂îÍ∞Ä
    this.createGlitchEffect(5 + this.reshuffleCount * 3);

    // Î®πÏßÄ ÏïäÏùÄ Í∏ÄÏûêÎì§ ÏÉà ÏúÑÏπòÎ°ú Ïù¥Îèô + ÏûîÏÉÅ ÏÉùÏÑ±
    this.gameOverLetters.forEach(letter => {
      if (letter.eaten) return;

      const oldX = letter.graphics.x;
      const oldY = letter.graphics.y;

      // ÏûîÏÉÅ ÏÉùÏÑ± (Î®πÏñ¥ÏßÄÏßÄ ÏïäÎäî ÌéòÏù¥ÌÅ¨ Í∏ÄÏûêÎì§)
      this.createLetterAfterimage(letter.char, oldX, oldY);

      // ÏÉà ÏúÑÏπò
      let gx, gy, attempts = 0;
      do {
        gx = Phaser.Math.Between(5, this.cols - 6);
        gy = Phaser.Math.Between(3, this.rows - 4);
        attempts++;
      } while (this.isPositionOccupiedForLetter(gx, gy) && attempts < 50);

      letter.gridX = gx;
      letter.gridY = gy;

      const newX = gx * this.gridSize + this.gridSize / 2;
      const newY = gy * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      // Í∏ÄÎ¶¨Ïπò ÌÖîÎ†àÌè¨Ìä∏ (Ìä∏ÏúàÏúºÎ°ú ÏõåÌîÑ Ìö®Í≥º)
      letter.graphics.setAlpha(0);
      if (letter.shadow) letter.shadow.setAlpha(0);

      this.time.delayedCall(100, () => {
        letter.graphics.setPosition(newX, newY);
        if (letter.shadow) {
          letter.shadow.setPosition(newX + 3, newY + 3);
        }

        // ÏõåÌîÑ Ïù∏ Ìö®Í≥º
        this.tweens.add({
          targets: letter.graphics,
          alpha: 1,
          scale: { from: 2, to: 1 },
          duration: 150,
          ease: 'Back.easeOut'
        });
        if (letter.shadow) {
          this.tweens.add({
            targets: letter.shadow,
            alpha: 0.5,
            scale: { from: 2, to: 1 },
            duration: 150
          });
        }
      });
    });

    // Ï∂îÍ∞Ä Ïπ¥Ïò§Ïä§ ÏûîÏÉÅÎì§ (ÏÖîÌîåÌï†ÏàòÎ°ù Îçî ÎßéÏù¥)
    const extraAfterimages = Math.min(this.reshuffleCount * 3, 15);
    for (let i = 0; i < extraAfterimages; i++) {
      const randomChar = 'GAMEOVER'[Math.floor(Math.random() * 8)];
      const rx = Phaser.Math.Between(100, width - 100);
      const ry = Phaser.Math.Between(this.gameAreaY + 50, height - 50);
      this.createLetterAfterimage(randomChar, rx, ry);
    }

    // ÏÇ¨Ïù¥Î≤Ñ Ïì∞Î†àÍ∏∞ Ï°∞Í∞ÅÎì§ ÏÉùÏÑ± (ÌôîÎ©¥Ïóê Ïã§Ï†úÎ°ú ÎÇ®Ïùå)
    const debrisCount = 3 + this.reshuffleCount * 2;
    for (let i = 0; i < debrisCount; i++) {
      this.createCyberDebris();
    }

    // Í∞úÎ≥Ñ ÌÉÄÏù¥Î®∏ ÌÖçÏä§Ìä∏ ÏÉâÏÉÅ Î¶¨ÏÖã
    if (this.gameOverLetterTimerText) {
      this.gameOverLetterTimerText.setFill('#ffff00');
    }
  }

  /**
   * ÏÇ¨Ïù¥Î≤Ñ Ïì∞Î†àÍ∏∞ Ï°∞Í∞Å ÏÉùÏÑ± (ÌôîÎ©¥Ïóê ÎÇ®Îäî ÌååÌé∏Îì§)
   */
  createCyberDebris() {
    const { width, height } = this.cameras.main;
    const x = Phaser.Math.Between(50, width - 50);
    const y = Phaser.Math.Between(this.gameAreaY + 30, height - 30);

    // Îã§ÏñëÌïú Ïì∞Î†àÍ∏∞ Ï°∞Í∞Å Ï¢ÖÎ•ò
    const debrisTypes = [
      { type: 'rect', color: 0x00ffff },
      { type: 'rect', color: 0xff00ff },
      { type: 'line', color: 0xffff00 },
      { type: 'pixel', color: 0x00ff00 },
      { type: 'bracket', color: 0xff0000 },
      { type: 'code', color: 0x00ffff }
    ];

    const debris = debrisTypes[Math.floor(Math.random() * debrisTypes.length)];

    if (debris.type === 'rect') {
      // Í∏ÄÎ¶¨Ïπò ÏÇ¨Í∞ÅÌòï Ï°∞Í∞Å
      const w = Phaser.Math.Between(5, 30);
      const h = Phaser.Math.Between(3, 15);
      const rect = this.add.rectangle(x, y, w, h, debris.color, 0.7)
        .setDepth(200)
        .setRotation(Phaser.Math.DegToRad(Phaser.Math.Between(-45, 45)));

      // ÎäêÎ¶¨Í≤å ÏÇ¨ÎùºÏßÄÍ±∞ÎÇò ÎÇ®ÏïÑÏûàÏùå
      if (Math.random() > 0.3) {
        this.tweens.add({
          targets: rect,
          alpha: { from: 0.7, to: 0.2 },
          x: x + Phaser.Math.Between(-30, 30),
          y: y + Phaser.Math.Between(-20, 20),
          rotation: rect.rotation + Phaser.Math.DegToRad(Phaser.Math.Between(-90, 90)),
          duration: 3000 + Math.random() * 5000,
          onComplete: () => rect.destroy()
        });
      } else {
        // ÏùºÎ∂ÄÎäî ÏòÅÍµ¨Ìûà ÎÇ®Ïùå (ÎÇòÏ§ëÏóê cleanupÏóêÏÑú Ï†úÍ±∞)
        if (!this.cyberDebrisElements) this.cyberDebrisElements = [];
        this.cyberDebrisElements.push(rect);
        this.tweens.add({
          targets: rect,
          alpha: { from: 0.7, to: 0.4 },
          duration: 1000
        });
      }
    } else if (debris.type === 'line') {
      // Í∏ÄÎ¶¨Ïπò ÎùºÏù∏
      const graphics = this.add.graphics().setDepth(200);
      graphics.lineStyle(2, debris.color, 0.8);
      const len = Phaser.Math.Between(20, 80);
      const angle = Phaser.Math.DegToRad(Phaser.Math.Between(0, 180));
      graphics.lineBetween(x, y, x + Math.cos(angle) * len, y + Math.sin(angle) * len);

      this.tweens.add({
        targets: graphics,
        alpha: 0,
        duration: 2000 + Math.random() * 3000,
        onComplete: () => graphics.destroy()
      });
    } else if (debris.type === 'pixel') {
      // ÌîΩÏÖÄ ÎÖ∏Ïù¥Ï¶à
      for (let j = 0; j < 5; j++) {
        const px = x + Phaser.Math.Between(-20, 20);
        const py = y + Phaser.Math.Between(-20, 20);
        const pixel = this.add.rectangle(px, py, 4, 4, debris.color, 0.9).setDepth(200);

        this.tweens.add({
          targets: pixel,
          alpha: 0,
          x: px + Phaser.Math.Between(-10, 10),
          y: py + Phaser.Math.Between(-10, 10),
          duration: 1500 + Math.random() * 2000,
          onComplete: () => pixel.destroy()
        });
      }
    } else if (debris.type === 'bracket') {
      // ÏΩîÎìú Ï°∞Í∞Å Í¥ÑÌò∏
      const brackets = ['{ }', '[ ]', '< >', '( )', '/* */', '//'];
      const text = brackets[Math.floor(Math.random() * brackets.length)];
      const bracketText = this.add.text(x, y, text, {
        fontSize: '16px',
        fill: Phaser.Display.Color.IntegerToColor(debris.color).rgba,
        fontFamily: 'monospace'
      }).setOrigin(0.5).setDepth(200).setAlpha(0.7);

      this.tweens.add({
        targets: bracketText,
        alpha: 0.2,
        rotation: Phaser.Math.DegToRad(Phaser.Math.Between(-20, 20)),
        duration: 4000,
        onComplete: () => bracketText.destroy()
      });
    } else if (debris.type === 'code') {
      // ÏΩîÎìú Ïä§ÎãàÌé´
      const codes = ['0x00', '0xFF', 'NULL', 'ERR', '###', '???', '!!!', 'NaN', 'undefined'];
      const text = codes[Math.floor(Math.random() * codes.length)];
      const codeText = this.add.text(x, y, text, {
        fontSize: '12px',
        fill: Phaser.Display.Color.IntegerToColor(debris.color).rgba,
        fontFamily: 'monospace',
        backgroundColor: '#000000'
      }).setOrigin(0.5).setDepth(200).setAlpha(0.8);

      // Í∏ÄÎ¶¨Ïπò Îñ®Î¶º
      this.time.addEvent({
        delay: 100,
        callback: () => {
          if (codeText.active) {
            codeText.x = x + Phaser.Math.Between(-2, 2);
          }
        },
        repeat: 20
      });

      this.tweens.add({
        targets: codeText,
        alpha: 0,
        duration: 3000 + Math.random() * 2000,
        onComplete: () => codeText.destroy()
      });
    }
  }

  /**
   * Í∏ÄÏûê ÏûîÏÉÅ ÏÉùÏÑ± (Î®πÏñ¥ÏßÄÏßÄ ÏïäÎäî ÌéòÏù¥ÌÅ¨)
   */
  createLetterAfterimage(char, x, y) {
    // Î∞òÌà¨Î™Ö Í∏ÄÎ¶¨Ïπò ÏÉâÏÉÅ ÏûîÏÉÅ
    const colors = ['#ff0000', '#00ffff', '#ff00ff', '#ffff00', '#00ff00'];
    const color = colors[Math.floor(Math.random() * colors.length)];

    const afterimage = this.add.text(x + Phaser.Math.Between(-10, 10), y + Phaser.Math.Between(-10, 10), char, {
      fontSize: '40px',
      fill: color,
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 2
    }).setOrigin(0.5).setDepth(450).setAlpha(0.6);

    // Í∏ÄÎ¶¨Ïπò Îñ®Î¶º
    this.tweens.add({
      targets: afterimage,
      x: afterimage.x + Phaser.Math.Between(-5, 5),
      y: afterimage.y + Phaser.Math.Between(-5, 5),
      alpha: 0,
      scale: { from: 1, to: 0.5 },
      duration: 1500 + Math.random() * 1000,
      ease: 'Power2',
      onComplete: () => afterimage.destroy()
    });

    // Ï∂îÍ∞Ä Í∏ÄÎ¶¨Ïπò Î≥µÏ†ú (Îçî ÌòºÎûÄÏä§ÎüΩÍ≤å)
    if (Math.random() > 0.5) {
      const glitchCopy = this.add.text(x + Phaser.Math.Between(-20, 20), y + Phaser.Math.Between(-20, 20), char, {
        fontSize: '35px',
        fill: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(449).setAlpha(0.3);

      this.tweens.add({
        targets: glitchCopy,
        alpha: 0,
        rotation: Phaser.Math.DegToRad(Phaser.Math.Between(-30, 30)),
        duration: 800,
        onComplete: () => glitchCopy.destroy()
      });
    }
  }

  /**
   * ÏúÑÏπò Ï†êÏú† Ï≤¥ÌÅ¨ (Î†àÍ±∞Ïãú)
   */
  isPositionOccupied(gx, gy) {
    return this.isPositionOccupiedForLetter(gx, gy);
  }

  /**
   * GAME OVER Í∏ÄÏûê Ï∂©Îèå Ï≤¥ÌÅ¨ (moveSnakeÏóêÏÑú Ìò∏Ï∂ú)
   */
  checkGameOverLetterCollision() {
    if (this.fourthWallPhase !== 'game_over_hunt') return;

    const head = this.snake[0];
    const targetSequence = 'GAMEOVER';

    this.gameOverLetters.forEach(letter => {
      if (letter.eaten) return;

      if (head.x === letter.gridX && head.y === letter.gridY) {
        // ÏàúÏÑú Ï≤¥ÌÅ¨: Îã§ÏùåÏóê Î®πÏñ¥Ïïº Ìï† Í∏ÄÏûêÏù∏Í∞Ä?
        const expectedChar = targetSequence[this.nextExpectedLetterIndex];
        
        // EÎäî Îëê Î≤à ÎÇòÏò§ÎØÄÎ°ú (index 3, 6) ÌäπÎ≥Ñ Ï≤òÎ¶¨
        const isCorrectOrder = (letter.char === expectedChar) ||
          (letter.char === 'E' && (this.nextExpectedLetterIndex === 3 || this.nextExpectedLetterIndex === 6));

        if (!isCorrectOrder) {
          // ÏàúÏÑú ÌãÄÎ¶º! ÎÇ®ÏùÄ Í∏ÄÏûê Î¶¨ÏÖîÌîå
          this.reshuffleRemainingLetters();
          // ÌÉÄÏù¥Î®∏ÎèÑ Î¶¨ÏÖã
          this.startLetterCountdown();
          return;
        }

        // ÏàúÏÑú ÎßûÏùå! Í∏ÄÏûê Î®πÍ∏∞
        letter.eaten = true;
        this.gameOverLettersEaten++;
        this.nextExpectedLetterIndex++;

        // 2Ï¥à ÏÖîÌîå ÌÉÄÏù¥Î®∏Îäî Î¶¨ÏÖãÌïòÏßÄ ÏïäÏùå - Í≥ÑÏÜç ÏßÑÌñâ

        // Ìö®Í≥º (Îπ†Î•¥Í≤å)
        this.cameras.main.flash(80, 0, 255, 0);
        this.createExplosionEffect(
          letter.graphics.x,
          letter.graphics.y,
          0x00ff00,
          15
        );

        // Í∏ÄÏûê ÏÇ¨ÎùºÏßê
        const targets = [letter.graphics];
        if (letter.shadow) targets.push(letter.shadow);

        this.tweens.add({
          targets: targets,
          scale: 2,
          alpha: 0,
          duration: 150,
          onComplete: () => {
            letter.graphics.destroy();
            if (letter.shadow) letter.shadow.destroy();
          }
        });

        // ÏßÑÌñâ ÌëúÏãú (Îπ†Î•¥Í≤å)
        const eaten = targetSequence.substring(0, this.gameOverLettersEaten);
        const remaining = targetSequence.substring(this.gameOverLettersEaten);
        const progressText = this.add.text(
          this.cameras.main.width / 2,
          this.cameras.main.height / 2,
          `${eaten} | ${remaining}`,
          {
            fontSize: '36px',
            fill: '#00ff00',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 3
          }
        ).setOrigin(0.5).setDepth(1000);

        this.tweens.add({
          targets: progressText,
          y: progressText.y - 50,
          alpha: 0,
          duration: 600,
          onComplete: () => progressText.destroy()
        });

        // Î™®Îëê Î®πÏóàÏúºÎ©¥ ÏäπÎ¶¨!
        if (this.gameOverLettersEaten >= 8) {
          this.showFourthWallVictory();
        }
      }
    });
  }
  /**
   * Fourth Wall ÏäπÎ¶¨ ÏãúÌÄÄÏä§
   */
  showFourthWallVictory() {
    console.log('üèÜ Fourth Wall Victory!');
    this.fourthWallPhase = 'victory';
    this.multiverseCollapsePhase = 'victory';
    this.moveTimer.paused = true;

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.gameOverMainTimer) this.gameOverMainTimer.destroy();
    if (this.letterCountdownTimer) this.letterCountdownTimer.destroy();

    const { width, height } = this.cameras.main;

    // Ïä¨Î°úÏö∞Î™®ÏÖò
    this.time.timeScale = 0.3;

    // ÎåÄÌòï ÌîåÎûòÏãú
    this.cameras.main.flash(1000, 255, 255, 255);
    this.cameras.main.shake(500, 0.05);

    // ÌÉÄÏù¥Î®∏Îì§ Ï†ïÎ¶¨
    this.fourthWallTimers.forEach(t => { if (t && t.destroy) t.destroy(); });

    // ÏäπÎ¶¨ ÌÖçÏä§Ìä∏
    this.time.delayedCall(500, () => {
      const victoryText = this.add.text(width / 2, height / 2 - 50, 'YOU BROKE THE FOURTH WALL', {
        fontSize: '36px',
        fill: '#00ff00',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 6
      }).setOrigin(0.5).setDepth(10000).setScale(0);

      this.tweens.add({
        targets: victoryText,
        scale: 1.2,
        duration: 500,
        ease: 'Back.easeOut'
      });

      // ÏÑúÎ∏å ÌÖçÏä§Ìä∏
      this.time.delayedCall(800, () => {
        const subText = this.add.text(width / 2, height / 2 + 20, 'The game is no longer your enemy.', {
          fontSize: '20px',
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 3
        }).setOrigin(0.5).setDepth(10000).setAlpha(0);

        this.tweens.add({
          targets: subText,
          alpha: 1,
          duration: 500
        });

        // Î±Ä ÏµúÏ¢Ö ÎåÄÏÇ¨
        this.time.delayedCall(1500, () => {
          this.time.timeScale = 1;

          this.showMultiverseDialogue("I am the master of my own game now.", 2500);

          // Î∂àÍΩÉÎÜÄÏù¥ (Í∏ÄÎ¶¨Ïπò Î≤ÑÏ†Ñ)
          this.time.delayedCall(1000, () => {
            this.startFourthWallFireworks();
          });

          // ÏµúÏ¢Ö ÏäπÎ¶¨ Ï≤òÎ¶¨
          this.time.delayedCall(5000, () => {
            victoryText.destroy();
            subText.destroy();
            this.cleanupFourthWall();
            this.showMultiverseCollapseVictory();
          });
        });
      });
    });
  }

  /**
   * Fourth Wall Ï†ÑÏö© ÏäπÎ¶¨ Î∂àÍΩÉÎÜÄÏù¥
   */
  startFourthWallFireworks() {
    const { width, height } = this.cameras.main;
    const colors = [0xff0000, 0xffa500, 0xffff00, 0x00ff00, 0x00ffff, 0xff00ff];

    for (let i = 0; i < 15; i++) {
      this.time.delayedCall(i * 80, () => {
        const x = 100 + Math.random() * (width - 200);
        const y = 100 + Math.random() * (height - 200);
        const color = colors[Math.floor(Math.random() * colors.length)];

        this.createExplosionEffect(x, y, color, 30);
        this.cameras.main.flash(50, ...this.hexToRgbArray(color));
        this.createGlitchEffect(2); // Í∏ÄÎ¶¨Ïπò Ìö®Í≥º Ï∂îÍ∞Ä
      });
    }
  }

  /**
   * Fourth Wall Î†åÎçîÎßÅ (drawÏóêÏÑú Ìò∏Ï∂ú)
   */
  drawFourthWall() {
    if (!this.fourthWallGraphics) return;

    this.fourthWallGraphics.clear();

    const { width, height } = this.cameras.main;
    const time = Date.now();

    // ÏßÄÏÜçÏ†ÅÏù∏ Ïä§Ï∫îÎùºÏù∏ Ìö®Í≥º (ÌôîÎ©¥ Ï†ÑÏ≤¥)
    this.fourthWallGraphics.fillStyle(0x000000, 0.03);
    for (let y = 0; y < height; y += 3) {
      if ((y + Math.floor(time * 0.1)) % 6 < 3) {
        this.fourthWallGraphics.fillRect(0, y, width, 1);
      }
    }

    // ÎûúÎç§ Í∏ÄÎ¶¨Ïπò ÎùºÏù∏ (ÌôïÎ•†Ï†Å)
    if (Math.random() > 0.95) {
      const glitchY = Math.random() * height;
      this.fourthWallGraphics.fillStyle(Math.random() > 0.5 ? 0xff00ff : 0x00ffff, 0.3);
      this.fourthWallGraphics.fillRect(0, glitchY, width, 2 + Math.random() * 5);
    }

    // ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ ÎîîÏßÄÌÑ∏ ÎÖ∏Ïù¥Ï¶à
    this.fourthWallGraphics.fillStyle(0xff00ff, 0.1 + Math.sin(time * 0.005) * 0.05);
    this.fourthWallGraphics.fillRect(0, this.gameAreaY, 3, height - this.gameAreaY);
    this.fourthWallGraphics.fillRect(width - 3, this.gameAreaY, 3, height - this.gameAreaY);

    // Ï¢ÅÌòÄÏßÑ Î≤Ω ÌëúÏãú
    if (this.fourthWallPhase === 'walls_closing' && this.fourthWallBoundaries) {
      const bounds = this.fourthWallBoundaries;
      const orig = this.fourthWallOriginalBounds;

      // ÏúÑÌóò ÏòÅÏó≠ (Îπ®Í∞ÑÏÉâ + Í∏ÄÎ¶¨Ïπò Ìå®ÌÑ¥)
      const dangerAlpha = 0.3 + Math.sin(time * 0.01) * 0.1;
      this.fourthWallGraphics.fillStyle(0xff0000, dangerAlpha);

      // ÏÉÅÎã®
      if (bounds.top > orig.top) {
        this.fourthWallGraphics.fillRect(
          0, this.gameAreaY,
          width,
          bounds.top * this.gridSize
        );
        // Í∏ÄÎ¶¨Ïπò ÎùºÏù∏
        this.fourthWallGraphics.fillStyle(0xff00ff, 0.5);
        this.fourthWallGraphics.fillRect(0, bounds.top * this.gridSize + this.gameAreaY - 2, width, 2);
      }

      // ÌïòÎã®
      if (bounds.bottom < orig.bottom) {
        this.fourthWallGraphics.fillStyle(0xff0000, dangerAlpha);
        this.fourthWallGraphics.fillRect(
          0, (bounds.bottom + 1) * this.gridSize + this.gameAreaY,
          width,
          (orig.bottom - bounds.bottom) * this.gridSize
        );
        this.fourthWallGraphics.fillStyle(0x00ffff, 0.5);
        this.fourthWallGraphics.fillRect(0, (bounds.bottom + 1) * this.gridSize + this.gameAreaY, width, 2);
      }

      // Ï¢åÏ∏°
      if (bounds.left > orig.left) {
        this.fourthWallGraphics.fillStyle(0xff0000, dangerAlpha);
        this.fourthWallGraphics.fillRect(
          0, this.gameAreaY,
          bounds.left * this.gridSize,
          height - this.gameAreaY
        );
        this.fourthWallGraphics.fillStyle(0xff00ff, 0.5);
        this.fourthWallGraphics.fillRect(bounds.left * this.gridSize - 2, this.gameAreaY, 2, height - this.gameAreaY);
      }

      // Ïö∞Ï∏°
      if (bounds.right < orig.right) {
        this.fourthWallGraphics.fillStyle(0xff0000, dangerAlpha);
        this.fourthWallGraphics.fillRect(
          (bounds.right + 1) * this.gridSize, this.gameAreaY,
          (orig.right - bounds.right) * this.gridSize,
          height - this.gameAreaY
        );
        this.fourthWallGraphics.fillStyle(0x00ffff, 0.5);
        this.fourthWallGraphics.fillRect((bounds.right + 1) * this.gridSize, this.gameAreaY, 2, height - this.gameAreaY);
      }

      // Í≤ΩÍ≥ÑÏÑ† (Í∞ïÎ†¨Ìïú ÍπúÎπ°ÏûÑ + Ïù¥Ï§ë ÎùºÏù∏)
      const flash = Math.sin(time * 0.02) * 0.5 + 0.5;
      this.fourthWallGraphics.lineStyle(6, 0xff0000, flash);
      this.fourthWallGraphics.strokeRect(
        bounds.left * this.gridSize,
        bounds.top * this.gridSize + this.gameAreaY,
        (bounds.right - bounds.left + 1) * this.gridSize,
        (bounds.bottom - bounds.top + 1) * this.gridSize
      );
      this.fourthWallGraphics.lineStyle(2, 0xffffff, flash * 0.5);
      this.fourthWallGraphics.strokeRect(
        bounds.left * this.gridSize + 3,
        bounds.top * this.gridSize + this.gameAreaY + 3,
        (bounds.right - bounds.left + 1) * this.gridSize - 6,
        (bounds.bottom - bounds.top + 1) * this.gridSize - 6
      );
    }
  }

  /**
   * Fourth Wall Ï†ïÎ¶¨
   */
  cleanupFourthWall() {
    this.fourthWallPhase = 'none';

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    this.fourthWallTimers.forEach(t => { if (t && t.destroy) t.destroy(); });
    this.fourthWallTimers = [];

    // Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨
    if (this.fourthWallGraphics) {
      this.fourthWallGraphics.destroy();
      this.fourthWallGraphics = null;
    }

    // UI ÏöîÏÜå Ï†ïÎ¶¨
    this.fourthWallUIElements.forEach(el => { if (el && el.destroy) el.destroy(); });
    this.fourthWallUIElements = [];

    // ÌÉÑÎßâ Ï†ïÎ¶¨
    this.fourthWallProjectiles.forEach(p => {
      if (p.text && p.text.destroy) p.text.destroy();
      if (p.trail && p.trail.destroy) p.trail.destroy();
    });
    this.fourthWallProjectiles = [];

    // Í∏ÄÏûê Ï†ïÎ¶¨ (Í∑∏Î¶ºÏûê Ìè¨Ìï®)
    this.gameOverLetters.forEach(l => {
      if (l.graphics && l.graphics.destroy) l.graphics.destroy();
      if (l.shadow && l.shadow.destroy) l.shadow.destroy();
    });
    this.gameOverLetters = [];
    this.gameOverLettersEaten = 0;

    // Í≤ΩÍ≥Ñ Î≥µÍµ¨
    this.fourthWallBoundaries = null;
  }

  // ================================================================================
  // ===== PHASE 3: BECOME ONE (Î†àÍ±∞Ïãú - ÎπÑÌôúÏÑ±Ìôî) ==================================
  // ================================================================================

  /**
   * Phase 2 ÏãúÏûë - ÏúµÌï© (ÎèÑÌîåÍ∞±Ïñ¥ Ï†úÍ±∞Îê®) - Î†àÍ±∞Ïãú
   * @deprecated Fourth WallÎ°ú ÎåÄÏ≤¥Îê®
   */
  startPhase2BecomeOne() {
    console.log('üîó Phase 2: Become One');

    this.multiverseCollapsePhase = 'becomeone';
    this.moveTimer.paused = true;

    // ÌéòÏù¥Ï¶à Ï†ÑÌôò ÌÉÄÏù¥ÌãÄ
    this.showPhaseTitle('FINAL PHASE', 'BECOME ONE', () => {
      // ÏúµÌï© ÎåÄÏÇ¨
      this.showMultiverseDialogue("We cannot exist apart... We must BECOME ONE!", 2500);

      this.time.delayedCall(3000, () => {
        // ÏúµÌï© ÏãúÌÄÄÏä§
        this.showFusionSequence(() => {
          // ÌäúÌÜ†Î¶¨Ïñº
          this.showFusionTutorial();

          // ÏúµÌï© Î®πÏù¥ ÏÉùÏÑ±
          this.generateFusionFood();

          // ÏûÖÎ†• ÏÑ§Ï†ï
          this.setupFusionControls();

          // Í≤åÏûÑ Ïû¨Í∞ú
          this.moveTimer.paused = false;
        });
      });
    });
  }

  /**
   * ÏúµÌï© ÏãúÌÄÄÏä§
   */
  showFusionSequence(callback) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    // Î∞∞Í≤Ω ÏïîÏ†Ñ
    const fusionBg = this.add.rectangle(centerX, centerY, width, height, 0x000000, 0);
    fusionBg.setDepth(9000);

    this.tweens.add({
      targets: fusionBg,
      alpha: 0.8,
      duration: 500
    });

    // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÎèÑÌîåÍ∞±Ïñ¥ ÏúÑÏπò
    const playerHead = this.snake[0];
    const doppelHead = this.doppelganger ? this.doppelganger.snake[0] : { x: 30, y: 13 };

    const px = playerHead.x * this.gridSize + this.gridSize / 2;
    const py = playerHead.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
    const dx = doppelHead.x * this.gridSize + this.gridSize / 2;
    const dy = doppelHead.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÏóêÎÑàÏßÄ Ïó∞Í≤∞ÏÑ†
    this.time.delayedCall(500, () => {
      const energyLine = this.add.graphics().setDepth(9001);
      let progress = 0;

      const lineTimer = this.time.addEvent({
        delay: 16,
        callback: () => {
          progress += 0.03;
          energyLine.clear();

          if (progress >= 1) {
            lineTimer.destroy();

            // Ìè≠Î∞ú!
            this.cameras.main.flash(400, 255, 255, 255);
            this.cameras.main.shake(500, 0.03);

            // Ï§ëÏïôÏóê Ìè≠Î∞ú
            this.createExplosionEffect(centerX, centerY, 0xffffff, 40);

            // "BECOME ONE" ÌÖçÏä§Ìä∏
            const fusionText = this.add.text(centerX, centerY, 'BECOME ONE', {
              fontSize: '48px',
              fill: '#ffffff',
              fontStyle: 'bold',
              stroke: '#9932cc',
              strokeThickness: 8
            }).setOrigin(0.5).setDepth(9100).setScale(0.5).setAlpha(0);

            this.tweens.add({
              targets: fusionText,
              scale: 1.2,
              alpha: 1,
              duration: 500,
              ease: 'Back.easeOut'
            });

            this.time.delayedCall(1500, () => {
              this.tweens.add({
                targets: [fusionBg, fusionText, energyLine],
                alpha: 0,
                duration: 500,
                onComplete: () => {
                  fusionBg.destroy();
                  fusionText.destroy();
                  energyLine.destroy();

                  // ÏúµÌï© Î±Ä ÏÉùÏÑ±
                  this.createFusionSnake();

                  // ÎèÑÌîåÍ∞±Ïñ¥ Ï†ïÎ¶¨
                  this.cleanupDoppelganger();

                  if (callback) callback();
                }
              });
            });
          } else {
            // ÏóêÎÑàÏßÄ ÎùºÏù∏ Í∑∏Î¶¨Í∏∞
            const midX = px + (dx - px) * progress;
            const midY = py + (dy - py) * progress;

            for (let i = 0; i < 5; i++) {
              const wave = Math.sin(Date.now() * 0.01 + i * 0.5) * 8;
              const lineColor = i % 2 === 0 ? 0x00ff00 : this.doppelColor;
              energyLine.lineStyle(6 - i, lineColor, 0.3 + i * 0.15);
              energyLine.lineBetween(px, py + wave, midX, midY + wave);
              energyLine.lineBetween(dx, dy - wave, midX, midY - wave);
            }
          }
        },
        loop: true
      });
    });
  }

  /**
   * ÏúµÌï© Î±Ä ÏÉùÏÑ±
   */
  createFusionSnake() {
    this.twoHeadedMode = true;
    this.fusionSnake = [];
    this.fusionFoodCount = 0;

    // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä (Î®∏Î¶¨Í∞Ä headIndex: 0)
    this.snake.forEach((seg, i) => {
      this.fusionSnake.push({
        x: seg.x,
        y: seg.y,
        headIndex: i === 0 ? 0 : -1
      });
    });

    // ÎèÑÌîåÍ∞±Ïñ¥ Î±Ä Ïó≠Ïàú Ïó∞Í≤∞ (Î®∏Î¶¨Í∞Ä headIndex: 1)
    if (this.doppelganger) {
      const reversedDoppel = [...this.doppelganger.snake].reverse();
      reversedDoppel.forEach((seg, i) => {
        this.fusionSnake.push({
          x: seg.x,
          y: seg.y,
          headIndex: i === reversedDoppel.length - 1 ? 1 : -1
        });
      });
    } else {
      // ÎèÑÌîåÍ∞±Ïñ¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Ï∂îÍ∞Ä
      const lastSeg = this.fusionSnake[this.fusionSnake.length - 1];
      this.fusionSnake.push({ x: lastSeg.x - 1, y: lastSeg.y, headIndex: -1 });
      this.fusionSnake.push({ x: lastSeg.x - 2, y: lastSeg.y, headIndex: -1 });
      this.fusionSnake.push({ x: lastSeg.x - 3, y: lastSeg.y, headIndex: 1 });
    }

    // Î∞©Ìñ• Ï¥àÍ∏∞Ìôî
    this.fusionDirection1 = 'RIGHT';
    this.fusionDirection2 = 'LEFT';
    this.fusionInputQueue1 = [];
    this.fusionInputQueue2 = [];

    // ÏúµÌï© Í∑∏ÎûòÌîΩ
    this.fusionGraphics = this.add.graphics().setDepth(100);
    this.fusionGlowGraphics = this.add.graphics().setDepth(99);
  }

  /**
   * ÎèÑÌîåÍ∞±Ïñ¥ Ï†ïÎ¶¨
   */
  cleanupDoppelganger() {
    if (this.doppelRecordTimer) {
      this.doppelRecordTimer.destroy();
      this.doppelRecordTimer = null;
    }

    if (this.doppelganger) {
      if (this.doppelganger.graphics) this.doppelganger.graphics.destroy();
      if (this.doppelganger.glowGraphics) this.doppelganger.glowGraphics.destroy();
      this.doppelganger.trailElements.forEach(t => { if (t && t.destroy) t.destroy(); });
      this.doppelganger = null;
    }

    this.doppelHPBarElements.forEach(el => { if (el && el.destroy) el.destroy(); });
    this.doppelHPBarElements = [];
  }

  /**
   * ÏúµÌï© ÌäúÌÜ†Î¶¨Ïñº
   */
  showFusionTutorial() {
    const { width } = this.cameras.main;
    const centerX = width / 2;

    const tutorial = this.add.text(centerX, 90, 'WASD: Green Head  |  Arrows: Purple Head', {
      fontSize: '16px',
      fill: '#ffffff',
      fontStyle: 'bold',
      backgroundColor: '#000000',
      padding: { x: 15, y: 8 }
    }).setOrigin(0.5).setDepth(2000);

    // ÏÉâÏÉÅ Í∞ïÏ°∞
    const greenPart = this.add.text(centerX - 80, 90, 'WASD: Green Head', {
      fontSize: '16px',
      fill: '#00ff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2001);

    const purplePart = this.add.text(centerX + 80, 90, 'Arrows: Purple Head', {
      fontSize: '16px',
      fill: '#9932cc',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(2001);

    // 10Ï¥à ÌõÑ ÌéòÏù¥ÎìúÏïÑÏõÉ
    this.time.delayedCall(10000, () => {
      this.tweens.add({
        targets: [tutorial, greenPart, purplePart],
        alpha: 0,
        duration: 500,
        onComplete: () => {
          tutorial.destroy();
          greenPart.destroy();
          purplePart.destroy();
        }
      });
    });
  }

  /**
   * ÏúµÌï© Ïª®Ìä∏Î°§ ÏÑ§Ï†ï
   */
  setupFusionControls() {
    // WASD ÌÇ§ Ï∂îÍ∞Ä
    this.fusionKeys = {
      W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
      A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
      S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
      D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)
    };

    // WASD ÏûÖÎ†• Ï≤òÎ¶¨
    this.fusionKeys.W.on('down', () => this.handleFusionInput(1, 'UP'));
    this.fusionKeys.A.on('down', () => this.handleFusionInput(1, 'LEFT'));
    this.fusionKeys.S.on('down', () => this.handleFusionInput(1, 'DOWN'));
    this.fusionKeys.D.on('down', () => this.handleFusionInput(1, 'RIGHT'));

    // ÌôîÏÇ¥ÌëúÎäî Îëê Î≤àÏß∏ Î®∏Î¶¨
    // Í∏∞Ï°¥ ÏûÖÎ†• ÏãúÏä§ÌÖúÏùÑ ÏàòÏ†ïÌï¥Ïïº Ìï®
  }

  /**
   * ÏúµÌï© ÏûÖÎ†• Ï≤òÎ¶¨
   */
  handleFusionInput(headIndex, direction) {
    if (this.isEscPaused) return;
    if (!this.twoHeadedMode || this.multiverseCollapsePhase !== 'becomeone') return;

    if (headIndex === 1) {
      // Ï≤´ Î≤àÏß∏ Î®∏Î¶¨ (WASD)
      const opposite = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };
      if (direction !== opposite[this.fusionDirection1]) {
        if (this.fusionInputQueue1.length < 2) {
          this.fusionInputQueue1.push(direction);
        }
      }
    } else {
      // Îëê Î≤àÏß∏ Î®∏Î¶¨ (ÌôîÏÇ¥Ìëú)
      const opposite = { 'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT' };
      if (direction !== opposite[this.fusionDirection2]) {
        if (this.fusionInputQueue2.length < 2) {
          this.fusionInputQueue2.push(direction);
        }
      }
    }
  }

  /**
   * ÏúµÌï© Î®πÏù¥ ÏÉùÏÑ±
   */
  generateFusionFood() {
    // ÎûúÎç§ ÏúÑÏπò
    let foodX, foodY;
    let valid = false;

    while (!valid) {
      foodX = Phaser.Math.Between(3, this.cols - 4);
      foodY = Phaser.Math.Between(3, this.rows - 4);

      // Î±ÄÍ≥º Í≤πÏπòÏßÄ ÏïäÎäîÏßÄ ÌôïÏù∏
      valid = !this.fusionSnake.some(seg => seg.x === foodX && seg.y === foodY);
    }

    this.fusionFood = { x: foodX, y: foodY };

    // Î®πÏù¥ Í∑∏ÎûòÌîΩ
    if (this.fusionFoodGraphics) {
      this.fusionFoodGraphics.destroy();
    }

    const fx = foodX * this.gridSize + this.gridSize / 2;
    const fy = foodY * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    this.fusionFoodGraphics = this.add.container(fx, fy).setDepth(90);

    // Í∏ÄÎ°úÏö∞
    const glow = this.add.circle(0, 0, 15, 0xffffff, 0.3);
    // Ïô∏Î∂Ä Ïõê
    const outer = this.add.circle(0, 0, 10, 0xffd700, 0.8);
    // ÎÇ¥Î∂Ä Ïõê
    const inner = this.add.circle(0, 0, 6, 0xffff00, 1);

    this.fusionFoodGraphics.add([glow, outer, inner]);

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: glow,
      scale: 1.5,
      alpha: 0.1,
      duration: 600,
      yoyo: true,
      repeat: -1
    });
  }

  /**
   * ÏúµÌï© Î±Ä Ïù¥Îèô
   */
  moveFusionSnake() {
    if (!this.twoHeadedMode || this.multiverseCollapsePhase !== 'becomeone') return;

    // ÏûÖÎ†• Ï≤òÎ¶¨
    if (this.fusionInputQueue1.length > 0) {
      this.fusionDirection1 = this.fusionInputQueue1.shift();
    }
    if (this.fusionInputQueue2.length > 0) {
      this.fusionDirection2 = this.fusionInputQueue2.shift();
    }

    // Ï≤´ Î≤àÏß∏ Î®∏Î¶¨ (Ïù∏Îç±Ïä§ 0)
    const head1Idx = this.fusionSnake.findIndex(s => s.headIndex === 0);
    const head1 = this.fusionSnake[head1Idx];
    let newHead1 = { x: head1.x, y: head1.y, headIndex: 0 };

    switch (this.fusionDirection1) {
      case 'LEFT': newHead1.x--; break;
      case 'RIGHT': newHead1.x++; break;
      case 'UP': newHead1.y--; break;
      case 'DOWN': newHead1.y++; break;
    }

    // Îëê Î≤àÏß∏ Î®∏Î¶¨ (ÎßàÏßÄÎßâ Ïù∏Îç±Ïä§)
    const head2Idx = this.fusionSnake.findIndex(s => s.headIndex === 1);
    const head2 = this.fusionSnake[head2Idx];
    let newHead2 = { x: head2.x, y: head2.y, headIndex: 1 };

    switch (this.fusionDirection2) {
      case 'LEFT': newHead2.x--; break;
      case 'RIGHT': newHead2.x++; break;
      case 'UP': newHead2.y--; break;
      case 'DOWN': newHead2.y++; break;
    }

    // Î≤Ω Ï≤¥ÌÅ¨
    newHead1 = this.wrapFusionPosition(newHead1);
    newHead2 = this.wrapFusionPosition(newHead2);

    // Íº¨ÏûÑ Ï≤¥ÌÅ¨ (Îëê Î®∏Î¶¨Í∞Ä Í∞ôÏùÄ Ïπ∏)
    if (newHead1.x === newHead2.x && newHead1.y === newHead2.y) {
      this.handleFusionTangle();
      return;
    }

    // ÏûêÍ∏∞ Ï∂©Îèå Ï≤¥ÌÅ¨
    for (let i = 0; i < this.fusionSnake.length; i++) {
      const seg = this.fusionSnake[i];
      if (seg.headIndex !== 0 && seg.headIndex !== 1) {
        if ((newHead1.x === seg.x && newHead1.y === seg.y) ||
            (newHead2.x === seg.x && newHead2.y === seg.y)) {
          this.handleFusionSelfCollision();
          return;
        }
      }
    }

    // Î®∏Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    this.fusionSnake[head1Idx] = { ...this.fusionSnake[head1Idx + 1], headIndex: -1 };
    this.fusionSnake[head2Idx] = { ...this.fusionSnake[head2Idx - 1], headIndex: -1 };

    // ÏÉà Î®∏Î¶¨ ÏÇΩÏûÖ
    this.fusionSnake.unshift(newHead1);
    this.fusionSnake.push(newHead2);

    // Ï§ëÍ∞Ñ ÏÑ∏Í∑∏Î®ºÌä∏ 2Í∞ú Ï†úÍ±∞
    const midIdx = Math.floor(this.fusionSnake.length / 2);
    this.fusionSnake.splice(midIdx, 2);

    // headIndex Ïû¨ÏÑ§Ï†ï
    this.fusionSnake[0].headIndex = 0;
    this.fusionSnake[this.fusionSnake.length - 1].headIndex = 1;
    for (let i = 1; i < this.fusionSnake.length - 1; i++) {
      this.fusionSnake[i].headIndex = -1;
    }

    // Î®πÏù¥ Ï≤¥ÌÅ¨
    this.checkFusionFoodCollision(newHead1, newHead2);
  }

  /**
   * ÏúÑÏπò Îû©Ìïë
   */
  wrapFusionPosition(pos) {
    if (pos.x < 0) pos.x = this.cols - 1;
    if (pos.x >= this.cols) pos.x = 0;
    if (pos.y < 0) pos.y = this.rows - 1;
    if (pos.y >= this.rows) pos.y = 0;
    return pos;
  }

  /**
   * ÏúµÌï© Î®πÏù¥ Ï∂©Îèå Ï≤¥ÌÅ¨
   */
  checkFusionFoodCollision(head1, head2) {
    if (!this.fusionFood) return;

    const food = this.fusionFood;
    const head1OnFood = head1.x === food.x && head1.y === food.y;
    const head2OnFood = head2.x === food.x && head2.y === food.y;

    if (head1OnFood && head2OnFood) {
      // ÏÑ±Í≥µ! Îëê Î®∏Î¶¨Í∞Ä ÎèôÏãúÏóê Î®πÏùå
      this.fusionFoodCount++;
      this.showFusionFoodSuccess();

      if (this.fusionFoodCount >= this.fusionTargetFood) {
        this.time.delayedCall(1500, () => {
          this.showMultiverseCollapseVictory();
        });
      } else {
        this.time.delayedCall(500, () => {
          this.generateFusionFood();
        });
      }
    } else if (head1OnFood || head2OnFood) {
      // Ïã§Ìå®! Ìïú Î®∏Î¶¨Îßå
      this.showFusionFoodFail();
      this.time.delayedCall(500, () => {
        this.generateFusionFood();
      });
    }
  }

  /**
   * ÏúµÌï© Î®πÏù¥ ÏÑ±Í≥µ
   */
  showFusionFoodSuccess() {
    const food = this.fusionFood;
    const x = food.x * this.gridSize + this.gridSize / 2;
    const y = food.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

    // ÏÑ±Í≥µ Ìö®Í≥º
    this.cameras.main.flash(100, 255, 215, 0);
    this.createExplosionEffect(x, y, 0xffd700, 15);

    // ÏÑ±Í≥µ ÎåÄÏÇ¨
    const successDialogues = [
      "Yes... we can work together...",
      "",
      "Two minds... one purpose...",
      "",
      "WE ARE ONE!"
    ];
    if (successDialogues[this.fusionFoodCount - 1]) {
      this.showMultiverseDialogue(successDialogues[this.fusionFoodCount - 1], 2000);
    }

    // Ïπ¥Ïö¥ÌÑ∞ ÌëúÏãú
    this.showMultiverseHitText(`SYNC ${this.fusionFoodCount}/${this.fusionTargetFood}`, 0xffd700);

    // Î®πÏù¥ Ï†úÍ±∞
    if (this.fusionFoodGraphics) {
      this.fusionFoodGraphics.destroy();
      this.fusionFoodGraphics = null;
    }
    this.fusionFood = null;
  }

  /**
   * ÏúµÌï© Î®πÏù¥ Ïã§Ìå®
   */
  showFusionFoodFail() {
    // Ïã§Ìå® Ìö®Í≥º
    this.cameras.main.shake(100, 0.01);

    const failText = this.add.text(400, 300, 'DESYNC!', {
      fontSize: '24px',
      fill: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(8000);

    this.tweens.add({
      targets: failText,
      alpha: 0,
      scale: 1.5,
      duration: 500,
      onComplete: () => failText.destroy()
    });

    // Î®πÏù¥ Ïû¨Î∞∞Ïπò
    if (this.fusionFoodGraphics) {
      this.fusionFoodGraphics.destroy();
      this.fusionFoodGraphics = null;
    }
    this.fusionFood = null;
  }

  /**
   * ÏúµÌï© Íº¨ÏûÑ (Í≤åÏûÑÏò§Î≤Ñ)
   */
  handleFusionTangle() {
    this.showMultiverseDialogue("We tangled... We cannot exist as one...", 2000);
    this.time.delayedCall(500, () => {
      this.endGame();
    });
  }

  /**
   * ÏúµÌï© ÏûêÍ∏∞ Ï∂©Îèå
   */
  handleFusionSelfCollision() {
    this.showMultiverseDialogue("We hurt ourselves...", 2000);
    this.time.delayedCall(500, () => {
      this.endGame();
    });
  }

  /**
   * ÏúµÌï© Î±Ä Î†åÎçîÎßÅ
   */
  drawFusionSnake() {
    if (!this.twoHeadedMode || !this.fusionGraphics) return;

    const g = this.fusionGraphics;
    const glow = this.fusionGlowGraphics;

    g.clear();
    glow.clear();

    const len = this.fusionSnake.length;

    // Í∏ÄÎ°úÏö∞
    this.fusionSnake.forEach((seg, i) => {
      const x = seg.x * this.gridSize + this.gridSize / 2;
      const y = seg.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;

      const isHead = seg.headIndex === 0 || seg.headIndex === 1;
      const glowRadius = isHead ? 15 : 8;
      const glowAlpha = isHead ? 0.4 : 0.15;

      const ratio = i / len;
      const color = seg.headIndex === 0 ? 0x00ff00 :
                    seg.headIndex === 1 ? this.doppelColor :
                    Phaser.Display.Color.Interpolate.ColorWithColor(
                      Phaser.Display.Color.ValueToColor(0x00ff00),
                      Phaser.Display.Color.ValueToColor(this.doppelColor),
                      100, ratio * 100
                    );

      glow.fillStyle(typeof color === 'object' ? Phaser.Display.Color.GetColor(color.r, color.g, color.b) : color, glowAlpha);
      glow.fillCircle(x, y, glowRadius);
    });

    // Î©îÏù∏ Î∞îÎîî
    this.fusionSnake.forEach((seg, i) => {
      const x = seg.x * this.gridSize;
      const y = seg.y * this.gridSize + this.gameAreaY;

      if (seg.headIndex === 0) {
        // Ï≤´ Î≤àÏß∏ Î®∏Î¶¨ (Ï¥àÎ°ù)
        g.fillStyle(0x00ff00, 1);
        g.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);
        // Îàà
        g.fillStyle(0x000000, 1);
        g.fillCircle(x + 6, y + this.gridSize / 2, 2);
        g.fillCircle(x + 14, y + this.gridSize / 2, 2);
      } else if (seg.headIndex === 1) {
        // Îëê Î≤àÏß∏ Î®∏Î¶¨ (Î≥¥Îùº)
        g.fillStyle(this.doppelColor, 1);
        g.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);
        // Îπ®Í∞Ñ Îàà
        g.fillStyle(0xff0000, 1);
        g.fillCircle(x + 6, y + this.gridSize / 2, 2);
        g.fillCircle(x + 14, y + this.gridSize / 2, 2);
      } else {
        // Î™∏ÌÜµ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò)
        const ratio = i / len;
        const interpColor = Phaser.Display.Color.Interpolate.ColorWithColor(
          Phaser.Display.Color.ValueToColor(0x00ff00),
          Phaser.Display.Color.ValueToColor(this.doppelColor),
          100, ratio * 100
        );
        g.fillStyle(Phaser.Display.Color.GetColor(interpColor.r, interpColor.g, interpColor.b), 0.8);
        g.fillRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2);
      }
    });
  }

  // ================================================================================
  // ===== VICTORY =================================================================
  // ================================================================================

  /**
   * Multiverse Collapse ÏäπÎ¶¨!
   */
  showMultiverseCollapseVictory() {
    console.log('üèÜ Multiverse Collapse Victory!');

    this.multiverseCollapsePhase = 'victory';
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2;

    const victoryElements = [];

    // === PHASE 1: Ïä¨Î°úÏö∞Î™®ÏÖò + Ï§å (0-1Ï¥à) ===
    this.time.timeScale = 0.2;
    this.cameras.main.zoomTo(1.3, 1000);

    // === PHASE 2: ÏúµÌï© Î±Ä Ìè≠Î∞ú (1-2Ï¥à) ===
    this.time.delayedCall(1000, () => {
      this.time.timeScale = 1;

      // ÏúµÌï© Î±Ä ÏúÑÏπòÏóêÏÑú Î¨¥ÏßÄÍ∞ú Ìè≠Î∞ú
      this.fusionSnake.forEach((seg, i) => {
        this.time.delayedCall(i * 30, () => {
          const x = seg.x * this.gridSize + this.gridSize / 2;
          const y = seg.y * this.gridSize + this.gridSize / 2 + this.gameAreaY;
          const color = this.universeColors[i % 6];
          this.createExplosionEffect(x, y, color, 8);
        });
      });

      // ÏúµÌï© Í∑∏ÎûòÌîΩ Ïà®ÍπÄ
      if (this.fusionGraphics) this.fusionGraphics.setVisible(false);
      if (this.fusionGlowGraphics) this.fusionGlowGraphics.setVisible(false);
    });

    // === PHASE 3: ÌôîÏù¥Ìä∏ÏïÑÏõÉ (2-3Ï¥à) ===
    this.time.delayedCall(2000, () => {
      this.cameras.main.flash(800, 255, 255, 255);
      this.cameras.main.zoomTo(1, 500);
    });

    // === PHASE 4: ÌÉÄÏù¥ÌãÄ (3-5Ï¥à) ===
    this.time.delayedCall(3000, () => {
      // Î∞∞Í≤Ω
      const victoryBg = this.add.rectangle(centerX, centerY, width, height, 0x000000, 0.8);
      victoryBg.setDepth(9500);
      victoryElements.push(victoryBg);

      // "YOU DEFEATED"
      const title1 = this.add.text(centerX, centerY - 60, 'YOU DEFEATED', {
        fontSize: '36px',
        fill: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(9501).setAlpha(0);
      victoryElements.push(title1);

      // "YOURSELF"
      const title2 = this.add.text(centerX, centerY, 'YOURSELF', {
        fontSize: '64px',
        fill: '#ffd700',
        fontStyle: 'bold',
        stroke: '#ff6600',
        strokeThickness: 6
      }).setOrigin(0.5).setDepth(9501).setAlpha(0);
      victoryElements.push(title2);

      // Îì±Ïû•
      this.tweens.add({
        targets: title1,
        alpha: 1,
        duration: 300
      });

      this.tweens.add({
        targets: title2,
        alpha: 1,
        scale: { from: 0.5, to: 1 },
        duration: 500,
        delay: 200,
        ease: 'Back.easeOut'
      });

      // ÌéÑÏä§
      this.tweens.add({
        targets: title2,
        scale: 1.05,
        duration: 500,
        yoyo: true,
        repeat: -1,
        delay: 700
      });
    });

    // === PHASE 5: Ï≤†ÌïôÏ†Å ÏÑúÎ∏åÌÉÄÏù¥ÌãÄ ÏãúÌÄÄÏä§ (5-7Ï¥à) ===
    this.time.delayedCall(5000, () => {
      // Ï≤†ÌïôÏ†Å Î©îÏãúÏßÄÎì§ÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÌëúÏãú
      const philosophicalTexts = [
        { text: "What is a self?", delay: 0, duration: 2000 },
        { text: "A collection of choices...", delay: 2200, duration: 2000 },
        { text: "...that echo through infinity.", delay: 4400, duration: 2000 }
      ];

      philosophicalTexts.forEach(({ text, delay, duration }) => {
        this.time.delayedCall(delay, () => {
          const philoText = this.add.text(centerX, centerY + 80, text, {
            fontSize: '22px',
            fill: '#00ffff',
            fontStyle: 'italic',
            stroke: '#000066',
            strokeThickness: 2
          }).setOrigin(0.5).setDepth(9501).setAlpha(0);
          victoryElements.push(philoText);

          // ÌéòÏù¥Îìú Ïù∏/ÏïÑÏõÉ
          this.tweens.add({
            targets: philoText,
            alpha: { from: 0, to: 1 },
            duration: 500,
            yoyo: true,
            hold: duration - 1000,
            onComplete: () => {
              if (philoText.active) philoText.destroy();
            }
          });
        });
      });
    });

    // === PHASE 6: 6Í∞ú Ïö∞Ï£º Ïû¨Îì±Ïû• (7-10Ï¥à) ===
    this.time.delayedCall(7000, () => {
      this.showUniverseRestoreSequence(victoryElements);
    });

    // === PHASE 7: Î∂àÍΩÉÎÜÄÏù¥ (9-14Ï¥à) ===
    this.time.delayedCall(9000, () => {
      this.startVictoryFireworks(victoryElements);
    });

    // === PHASE 8: ÏµúÏ¢Ö Ï≤†ÌïôÏ†Å ÎåÄÏÇ¨ (11Ï¥à) ===
    this.time.delayedCall(11000, () => {
      // ÏùòÎØ∏Ïã¨Ïû•Ìïú ÏµúÏ¢Ö ÎåÄÏÇ¨
      const finalText = this.add.text(centerX, centerY + 140, '', {
        fontSize: '18px',
        fill: '#ffffff',
        fontStyle: 'italic',
        stroke: '#9932cc',
        strokeThickness: 2
      }).setOrigin(0.5).setDepth(9502);
      victoryElements.push(finalText);

      const finalWords = "In defeating myself, I found myself.";
      let charIdx = 0;
      const typeTimer = this.time.addEvent({
        delay: 70,
        callback: () => {
          charIdx++;
          finalText.setText(finalWords.substring(0, charIdx));
          if (charIdx >= finalWords.length) {
            typeTimer.destroy();
            // ÎßàÏßÄÎßâ Í∞ïÏ°∞
            this.time.delayedCall(500, () => {
              const enlightenText = this.add.text(centerX, centerY + 180, '...And so the journey continues.', {
                fontSize: '16px',
                fill: '#ffd700',
                fontStyle: 'bold'
              }).setOrigin(0.5).setDepth(9502).setAlpha(0);
              victoryElements.push(enlightenText);

              this.tweens.add({
                targets: enlightenText,
                alpha: 1,
                duration: 1000
              });
            });
          }
        },
        repeat: finalWords.length - 1
      });
    });

    // === PHASE 9: Î≥¥ÎÑàÏä§ Ï†úÍ±∞Îê® - ÏóîÎî© Ïä§ÌÖåÏù¥ÏßÄÎ°ú Ï†ÑÌôò ÏòàÏ†ï ===

    // === PHASE 10: ÎßàÎ¨¥Î¶¨ (14Ï¥à) ===
    this.time.delayedCall(14000, () => {
      // Î™®Îì† ÏöîÏÜå ÌéòÏù¥ÎìúÏïÑÏõÉ
      victoryElements.forEach(el => {
        if (el && el.active) {
          this.tweens.add({
            targets: el,
            alpha: 0,
            duration: 1000
          });
        }
      });

      // ÏµúÏ¢Ö ÌîåÎûòÏãú
      this.cameras.main.flash(500, 255, 255, 255);
    });

    // === PHASE 11: Îü¨ÎÑà Î™®ÎìúÎ°ú Ï†ÑÌôò (16Ï¥à) ===
    this.time.delayedCall(16000, () => {
      // victoryElements Ï†ïÎ¶¨
      victoryElements.forEach(el => {
        if (el && el.destroy) el.destroy();
      });

      // 18ÌÉÑ Î≥¥Ïä§ BGM Ï†ïÏßÄ ÌõÑ Í∏∞Î≥∏ BGMÏúºÎ°ú ÏõêÎ≥µ
      if (this.boss18Music && this.boss18Music.isPlaying) {
        this.boss18Music.stop();
      }
      if (this.bgMusic && !this.bgMusic.isPlaying) {
        this.bgMusic.play();
      }

      // Îü¨ÎÑà Î™®Îìú ÏãúÏûë
      this.startRunnerTransition();
    });
  }

  /**
   * Ïö∞Ï£º Î≥µÏõê ÏãúÌÄÄÏä§
   */
  showUniverseRestoreSequence(victoryElements) {
    const { width, height } = this.cameras.main;
    const centerX = width / 2;
    const centerY = height / 2 - 50;
    const radius = 80;

    // 6Í∞ú Ïö∞Ï£ºÎ•º Ïú°Í∞ÅÌòïÏúºÎ°ú Î∞∞Ïπò
    for (let i = 0; i < 6; i++) {
      this.time.delayedCall(i * 200, () => {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const targetX = centerX + Math.cos(angle) * radius;
        const targetY = centerY + Math.sin(angle) * radius;

        const universe = this.add.circle(centerX, centerY, 5, this.universeColors[i], 1);
        universe.setDepth(9510);
        victoryElements.push(universe);

        this.tweens.add({
          targets: universe,
          x: targetX,
          y: targetY,
          radius: 20,
          duration: 600,
          ease: 'Back.easeOut',
          onComplete: () => {
            // ÌéÑÏä§
            this.tweens.add({
              targets: universe,
              scale: 1.2,
              alpha: 0.7,
              duration: 500,
              yoyo: true,
              repeat: -1
            });
          }
        });

        // Ïó∞Í≤∞ÏÑ†
        if (i > 0) {
          this.time.delayedCall(100, () => {
            const prevAngle = ((i - 1) / 6) * Math.PI * 2 - Math.PI / 2;
            const prevX = centerX + Math.cos(prevAngle) * radius;
            const prevY = centerY + Math.sin(prevAngle) * radius;

            const line = this.add.graphics().setDepth(9509);
            line.lineStyle(2, 0xffffff, 0.5);
            line.lineBetween(prevX, prevY, targetX, targetY);
            victoryElements.push(line);
          });
        }

        // ÎßàÏßÄÎßâ Ïó∞Í≤∞ (6‚Üí1)
        if (i === 5) {
          this.time.delayedCall(200, () => {
            const firstAngle = -Math.PI / 2;
            const firstX = centerX + Math.cos(firstAngle) * radius;
            const firstY = centerY + Math.sin(firstAngle) * radius;

            const line = this.add.graphics().setDepth(9509);
            line.lineStyle(2, 0xffffff, 0.5);
            line.lineBetween(targetX, targetY, firstX, firstY);
            victoryElements.push(line);
          });
        }
      });
    }

    // "SIX UNIVERSES STABILIZED" ÌÖçÏä§Ìä∏
    this.time.delayedCall(1500, () => {
      const stableText = this.add.text(centerX, centerY + 120, 'SIX UNIVERSES STABILIZED', {
        fontSize: '18px',
        fill: '#00ffff',
        fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(9511).setAlpha(0);
      victoryElements.push(stableText);

      this.tweens.add({
        targets: stableText,
        alpha: 1,
        duration: 500
      });
    });
  }

  /**
   * ÏäπÎ¶¨ Î∂àÍΩÉÎÜÄÏù¥
   */
  startVictoryFireworks(victoryElements) {
    const { width, height } = this.cameras.main;

    // 5Ï¥àÍ∞Ñ Î∂àÍΩÉÎÜÄÏù¥
    const fireworkTimer = this.time.addEvent({
      delay: 150,
      callback: () => {
        const x = Phaser.Math.Between(50, width - 50);
        const y = Phaser.Math.Between(100, height - 150);
        const color = Phaser.Utils.Array.GetRandom(this.universeColors);

        // Ï§ëÏã¨ Ìè≠Î∞ú
        const core = this.add.circle(x, y, 3, 0xffffff, 1).setDepth(9520);
        victoryElements.push(core);

        this.tweens.add({
          targets: core,
          scale: 2,
          alpha: 0,
          duration: 200,
          onComplete: () => core.destroy()
        });

        // Ïä§ÌååÌÅ¨
        for (let i = 0; i < 10; i++) {
          const angle = (i / 10) * Math.PI * 2;
          const dist = 30 + Math.random() * 40;

          const spark = this.add.circle(x, y, 2, color, 1).setDepth(9520);
          victoryElements.push(spark);

          this.tweens.add({
            targets: spark,
            x: x + Math.cos(angle) * dist,
            y: y + Math.sin(angle) * dist,
            alpha: 0,
            scale: 0.3,
            duration: 400,
            ease: 'Power2.easeOut',
            onComplete: () => spark.destroy()
          });
        }
      },
      repeat: 30
    });
  }

  /**
   * Multiverse Collapse Ï†ïÎ¶¨
   */
  cleanupMultiverseCollapse() {
    console.log('üßπ Cleaning up Multiverse Collapse');

    this.multiverseCollapseMode = false;
    this.multiverseCollapsePhase = 'none';

    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    if (this.multiverseAnimTimer) {
      this.multiverseAnimTimer.destroy();
      this.multiverseAnimTimer = null;
    }

    // Phase 1 Ï†ïÎ¶¨
    this.cleanupGhostSnakes();

    // Phase 2 Ï†ïÎ¶¨ (Fourth Wall)
    this.cleanupFourthWall();

    // Î†àÍ±∞Ïãú: Phase 2 Ï†ïÎ¶¨ (Doppelganger)
    this.cleanupDoppelganger();

    // Î†àÍ±∞Ïãú: Phase 3 Ï†ïÎ¶¨
    this.twoHeadedMode = false;
    this.fusionSnake = [];
    this.fusionFoodCount = 0;

    if (this.fusionGraphics) {
      this.fusionGraphics.destroy();
      this.fusionGraphics = null;
    }
    if (this.fusionGlowGraphics) {
      this.fusionGlowGraphics.destroy();
      this.fusionGlowGraphics = null;
    }
    if (this.fusionFoodGraphics) {
      this.fusionFoodGraphics.destroy();
      this.fusionFoodGraphics = null;
    }

    // WASD ÌÇ§ Ï†ïÎ¶¨
    if (this.fusionKeys) {
      Object.values(this.fusionKeys).forEach(key => {
        if (key && key.destroy) key.destroy();
      });
      this.fusionKeys = null;
    }

    // Î≥¥Ïä§ ÏöîÏÜå Ï†ïÎ¶¨
    this.multiverseBossElements.forEach(el => {
      if (el && el.destroy) el.destroy();
    });
    this.multiverseBossElements = [];

    // Quantum Split Ï†ïÎ¶¨
    if (this.quantumSplitMode) {
      this.cleanupQuantumSplit();
    }

    // Î±Ä ÏõêÎûòÎåÄÎ°ú Î≥µÏõê
    this.snake = [
      { x: 10, y: 15 },
      { x: 9, y: 15 },
      { x: 8, y: 15 }
    ];
    this.direction = 'RIGHT';
    this.inputQueue = [];

    // Í∑∏ÎûòÌîΩ ÌëúÏãú
    if (this.graphics) {
      this.graphics.setVisible(true);
    }
  }

  // ==========================================
  // ========== RUNNER MODE (ÏóîÎî©) ==========
  // ==========================================

  /**
   * Îü¨ÎÑà Î™®Îìú Ï†ÑÌôò ÏãúÏûë - Î±ÄÏù¥ ÌïòÏñóÍ≤å Î≥ÄÌïòÍ≥† Îñ®Ïñ¥Ïßê
   */
  startRunnerTransition() {
    console.log('üèÉ Starting Runner Transition');

    this.runnerMode = true;
    this.runnerPhase = 'transition';
    this.moveTimer.paused = true;

    const { width, height } = this.cameras.main;

    // === Í∏∞Ï°¥ ÎÖπÏÉâ Î±Ä Í∑∏ÎûòÌîΩ Ï†úÍ±∞ ===
    // Î©îÏù∏ draw() Ìï®ÏàòÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî graphics
    if (this.graphics) {
      this.graphics.clear();
      this.graphics.setVisible(false);
    }
    if (this.snakeGraphics) {
      this.snakeGraphics.clear();
      this.snakeGraphics.setVisible(false);
    }
    // Î±Ä Î™∏ÌÜµ Í∑∏ÎûòÌîΩÎèÑ Ïà®ÍπÄ
    if (this.bodyGraphics) {
      this.bodyGraphics.clear();
      this.bodyGraphics.setVisible(false);
    }
    // Î®∏Î¶¨ Í∑∏ÎûòÌîΩÎèÑ Ïà®ÍπÄ
    if (this.headGraphics) {
      this.headGraphics.clear();
      this.headGraphics.setVisible(false);
    }

    // Îü¨ÎÑà Í∑∏ÎûòÌîΩ ÏÉùÏÑ±
    this.runnerGraphics = this.add.graphics().setDepth(9600);
    this.runnerElements = [];
    this.runnerTimers = [];

    // Î∞∞Í≤ΩÏùÑ Í≤ÄÏùÄÏÉâÏúºÎ°ú ÌéòÏù¥Îìú
    const blackBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0);
    blackBg.setDepth(9550);
    this.runnerElements.push(blackBg);

    this.tweens.add({
      targets: blackBg,
      alpha: 1,
      duration: 1000
    });

    // Î±Ä Î≥µÏÇ¨Î≥∏ ÏÉùÏÑ± (Ï¥àÎ°ù ‚Üí Ìù∞ÏÉâ)
    this.runnerPlayerSnake = this.snake.map(seg => ({
      x: seg.x * this.gridSize + this.gridSize / 2,
      y: seg.y * this.gridSize + this.gridSize / 2 + this.gameAreaY,
      color: 0x00ff00
    }));

    // ÏÉâÏÉÅ Ï†ÑÌôò (Ï¥àÎ°ù ‚Üí Ìù∞ÏÉâ) + Îñ®Ïñ¥ÏßÄÍ∏∞
    this.time.delayedCall(1000, () => {
      // ÏÉâÏÉÅ ÏÑúÏÑúÌûà Î≥ÄÍ≤Ω
      let colorProgress = 0;
      const colorTimer = this.time.addEvent({
        delay: 20,
        callback: () => {
          colorProgress += 0.02;
          if (colorProgress >= 1) {
            colorTimer.destroy();
            // Îã§ ÌïòÏñóÍ≤å Î≥ÄÌïú ÌõÑ Îñ®Ïñ¥ÏßÄÍ∏∞
            this.startSnakeFall();
          }
          // ÏÉâÏÉÅ Î≥¥Í∞Ñ
          const r = Math.floor(0 + (255 - 0) * colorProgress);
          const g = Math.floor(255 + (255 - 255) * colorProgress);
          const b = Math.floor(0 + (255 - 0) * colorProgress);
          const newColor = (r << 16) + (g << 8) + b;
          this.runnerPlayerSnake.forEach(seg => seg.color = newColor);
          this.drawRunnerTransition();
        },
        repeat: 50
      });
      this.runnerTimers.push(colorTimer);
    });
  }

  /**
   * Î±Ä Ï§åÏù∏ + Î∂ÄÎìúÎüΩÍ≤å Ï∞©ÏßÄ Ïó∞Ï∂ú (Ïπ¥Î©îÎùº ÌåîÎ°úÏö∞)
   */
  startSnakeFall() {
    const { width, height } = this.cameras.main;

    // ÏßÄÎ©¥ Y ÏúÑÏπò ÏÑ§Ï†ï
    this.runnerGroundY = height - 80;

    // Í≤©Ïûê ÌéòÏù¥ÎìúÏïÑÏõÉ
    if (this.gridGraphics) {
      this.tweens.add({
        targets: this.gridGraphics,
        alpha: 0,
        duration: 500
      });
    }

    // Î±Ä Î®∏Î¶¨ ÏúÑÏπò Í≥ÑÏÇ∞
    const headX = this.runnerPlayerSnake[0].x;
    const headY = this.runnerPlayerSnake[0].y;

    // Ïπ¥Î©îÎùº Ï§åÏù∏ Ìö®Í≥º (Î±Ä Î®∏Î¶¨ Ï§ëÏã¨)
    this.cameras.main.pan(headX, headY, 800, 'Sine.easeInOut');
    this.cameras.main.zoomTo(2.5, 800, 'Sine.easeInOut');

    // Ï§åÏù∏ ÏôÑÎ£å ÌõÑ Î∂ÄÎìúÎüΩÍ≤å Ï∞©ÏßÄ (Ïπ¥Î©îÎùºÍ∞Ä Îî∞ÎùºÍ∞ê)
    this.time.delayedCall(1000, () => {
      // Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞ (Îü¨ÎÑà Î™®Îìú ÏãúÏûë ÏúÑÏπò)
      const targetX = 80;
      const targetY = this.runnerGroundY;

      // Î±ÄÏùÑ Îü¨ÎÑà ÌòïÌÉúÎ°ú Ïû¨Î∞∞Ïπò (Í∞ÄÎ°úÎ°ú Ï†ïÎ†¨)
      const snakeLength = this.runnerPlayerSnake.length;
      const targetPositions = [];
      for (let i = 0; i < snakeLength; i++) {
        targetPositions.push({
          x: targetX - i * 12,
          y: targetY
        });
      }

      // ÏãúÏûë ÏúÑÏπò Ï†ÄÏû•
      this.runnerPlayerSnake.forEach((seg) => {
        seg.startX = seg.x;
        seg.startY = seg.y;
      });

      // Î∂ÄÎìúÎüΩÍ≤å Ïù¥Îèô (Ïπ¥Î©îÎùºÍ∞Ä Î±ÄÏùÑ Îî∞ÎùºÍ∞ê)
      let progress = 0;
      const moveTimer = this.time.addEvent({
        delay: 16,
        callback: () => {
          progress += 0.015; // Ï°∞Í∏à Îçî ÎäêÎ¶¨Í≤å
          if (progress >= 1) {
            progress = 1;
            moveTimer.destroy();

            // Ï§å Î¶¨ÏÖã ÌõÑ Îü¨ÎÑà ÏãúÏûë
            this.cameras.main.pan(width / 2, height / 2, 500, 'Sine.easeInOut');
            this.cameras.main.zoomTo(1, 500, 'Sine.easeInOut');

            this.time.delayedCall(600, () => {
              this.startRunnerIntroWithExistingSnake();
            });
          }

          // Ease out Î≥¥Í∞Ñ
          const easeProgress = 1 - Math.pow(1 - progress, 3);

          this.runnerPlayerSnake.forEach((seg, i) => {
            seg.x = seg.startX + (targetPositions[i].x - seg.startX) * easeProgress;
            seg.y = seg.startY + (targetPositions[i].y - seg.startY) * easeProgress;
          });

          // === Ïπ¥Î©îÎùºÍ∞Ä Î±Ä Î®∏Î¶¨Î•º Îî∞ÎùºÍ∞ê ===
          const currentHeadX = this.runnerPlayerSnake[0].x;
          const currentHeadY = this.runnerPlayerSnake[0].y;
          this.cameras.main.centerOn(currentHeadX, currentHeadY);

          this.drawRunnerTransition();
        },
        loop: true
      });
      this.runnerTimers.push(moveTimer);
    });
  }

  /**
   * Îü¨ÎÑà Ï†ÑÌôò ÌôîÎ©¥ Í∑∏Î¶¨Í∏∞
   */
  drawRunnerTransition() {
    if (!this.runnerGraphics) return;
    this.runnerGraphics.clear();

    // Î±Ä Í∑∏Î¶¨Í∏∞
    this.runnerPlayerSnake.forEach((seg, i) => {
      const size = i === 0 ? 18 : 16;
      this.runnerGraphics.fillStyle(seg.color, 1);
      this.runnerGraphics.fillRect(seg.x - size / 2, seg.y - size / 2, size, size);
    });
  }

  /**
   * Í∏∞Ï°¥ Î±ÄÏùÑ Ïú†ÏßÄÌïú Ï±Ñ Îü¨ÎÑà Ïù∏Ìä∏Î°ú ÏãúÏûë
   */
  startRunnerIntroWithExistingSnake() {
    console.log('üèÉ Starting Runner Intro with Existing Snake');

    this.runnerPhase = 'intro';
    const { width, height } = this.cameras.main;

    // Í∏∞Î≥∏ BGM Ïû¨ÏÉù (Î≥¥Ïä§Ï†Ñ BGM Ï†ïÏßÄ ÌõÑ)
    if (this.boss18Music && this.boss18Music.isPlaying) {
      this.boss18Music.stop();
    }
    if (this.bgMusic && !this.bgMusic.isPlaying) {
      this.bgMusic.play();
    }

    // ÏßÄÎ©¥ ÏÑ§Ï†ï (Ïù¥ÎØ∏ ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏùÑ Ïàò ÏûàÏùå)
    if (!this.runnerGroundY) {
      this.runnerGroundY = height - 80;
    }
    this.runnerY = this.runnerGroundY;

    // Í∏∞Ï°¥ Î±ÄÏùò startX, startY ÏûÑÏãú ÏÜçÏÑ± Ï†úÍ±∞ (ÍπîÎÅîÌïòÍ≤å)
    this.runnerPlayerSnake.forEach(seg => {
      delete seg.startX;
      delete seg.startY;
    });

    // Ï¥àÍ∏∞Ìôî (Î±ÄÏùÄ Ïú†ÏßÄ)
    this.runnerObstacles = [];
    this.runnerDeadSnakes = [];
    this.runnerWhiteSnakes = [];
    this.runnerDistance = 0;
    this.runnerJumping = false;
    this.runnerJumpVelocity = 0;
    this.runnerIntroComplete = false;
    this.runnerSpeed = 5;

    // ÎÇëÍ≤®Ïû°Ìûò ÏãúÏä§ÌÖú
    this.runnerTrapped = false;           // ÎÇëÍ≤®Ïû°Ìûò ÏÉÅÌÉú
    this.runnerTrappedEnemy = null;       // Ïû°ÏùÄ Ï†Å
    this.runnerEscapeProgress = 0;        // ÌÉàÏ∂ú ÏßÑÌñâÎèÑ (0~100)
    this.runnerEscapeRequired = 10;       // ÌÉàÏ∂úÏóê ÌïÑÏöîÌïú Ïä§ÌéòÏù¥Ïä§Î∞î ÌöüÏàò
    this.runnerObstaclesPassed = 0;       // ÌÜµÍ≥ºÌïú Ïû•Ïï†Î¨º Ïàò
    this.runnerClearTarget = 10;          // ÌÅ¥Î¶¨Ïñ¥ Ï°∞Í±¥
    this.runnerClearStarted = false;      // 10Í∞ú ÌÜµÍ≥º ÌîåÎûòÍ∑∏
    this.runnerClearSequenceStarted = false; // ÌÅ¥Î¶¨Ïñ¥ ÏãúÌÄÄÏä§ Ïã§Ï†ú ÏãúÏûë Ïó¨Î∂Ä

    // Î∞∞Í≤Ω Î±ÄÎì§ ÏÉùÏÑ±
    this.spawnBackgroundSnakes();

    // "THE JOURNEY CONTINUES..." ÌÖçÏä§Ìä∏
    const journeyText = this.add.text(width / 2, height / 3, 'THE JOURNEY CONTINUES...', {
      fontSize: '32px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(9650).setAlpha(0);
    this.runnerElements.push(journeyText);

    this.tweens.add({
      targets: journeyText,
      alpha: 1,
      duration: 500,
      onComplete: () => {
        this.time.delayedCall(2000, () => {
          this.tweens.add({
            targets: journeyText,
            alpha: 0,
            duration: 500
          });
        });
      }
    });

    // Ïù∏Ìä∏Î°ú ÏûêÎèô ÌîåÎ†àÏù¥ ÏãúÏûë
    this.time.delayedCall(1000, () => {
      this.startRunnerAutoPlay();
    });

    // Îü¨ÎÑà ÏóÖÎç∞Ïù¥Ìä∏ Î£®ÌîÑ ÏãúÏûë
    const runnerUpdateTimer = this.time.addEvent({
      delay: 16,
      callback: () => this.updateRunner(),
      loop: true
    });
    this.runnerTimers.push(runnerUpdateTimer);
  }

  /**
   * Îü¨ÎÑà Ïù∏Ìä∏Î°ú ÏãúÏûë - ÏûêÎèô ÌîåÎ†àÏù¥
   */
  startRunnerIntro() {
    console.log('üèÉ Starting Runner Intro');

    this.runnerPhase = 'intro';
    const { width, height } = this.cameras.main;

    // ÏßÄÎ©¥ ÏÑ§Ï†ï
    this.runnerGroundY = height - 80;
    this.runnerY = this.runnerGroundY;

    // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä ÏúÑÏπò ÏÑ§Ï†ï (ÌôîÎ©¥ ÏôºÏ™Ω)
    const startX = 80;
    this.runnerPlayerSnake = [];
    for (let i = 0; i < 8; i++) {
      this.runnerPlayerSnake.push({
        x: startX - i * 12,
        y: this.runnerGroundY,
        color: 0xffffff
      });
    }

    // Ï¥àÍ∏∞Ìôî
    this.runnerObstacles = [];
    this.runnerDeadSnakes = [];
    this.runnerWhiteSnakes = [];
    this.runnerDistance = 0;
    this.runnerJumping = false;
    this.runnerJumpVelocity = 0;
    this.runnerIntroComplete = false;
    this.runnerSpeed = 5;

    // Î∞∞Í≤Ω Î±ÄÎì§ ÏÉùÏÑ± (ÏúÑÎ•º Îã¨Î¶¨Îäî Ìù∞ Î±ÄÎì§)
    this.spawnBackgroundSnakes();

    // "THE JOURNEY CONTINUES..." ÌÖçÏä§Ìä∏
    const journeyText = this.add.text(width / 2, height / 3, 'THE JOURNEY CONTINUES...', {
      fontSize: '32px',
      fill: '#ffffff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(9650).setAlpha(0);
    this.runnerElements.push(journeyText);

    this.tweens.add({
      targets: journeyText,
      alpha: 1,
      duration: 500,
      onComplete: () => {
        this.time.delayedCall(2000, () => {
          this.tweens.add({
            targets: journeyText,
            alpha: 0,
            duration: 500
          });
        });
      }
    });

    // Ïù∏Ìä∏Î°ú ÏûêÎèô ÌîåÎ†àÏù¥ ÏãúÏûë (Ïû•Ïï†Î¨º + ÏûêÎèô Ï†êÌîÑ)
    this.time.delayedCall(1000, () => {
      this.startRunnerAutoPlay();
    });

    // Îü¨ÎÑà ÏóÖÎç∞Ïù¥Ìä∏ Î£®ÌîÑ ÏãúÏûë
    const runnerUpdateTimer = this.time.addEvent({
      delay: 16,
      callback: () => this.updateRunner(),
      loop: true
    });
    this.runnerTimers.push(runnerUpdateTimer);
  }

  /**
   * Î∞∞Í≤Ω Î±ÄÎì§ ÏÉùÏÑ±
   */
  spawnBackgroundSnakes() {
    const { width, height } = this.cameras.main;

    // ÏúÑÎ•º Îã¨Î¶¨Îäî Ìù∞ Î±ÄÎì§ (3ÎßàÎ¶¨)
    for (let i = 0; i < 3; i++) {
      const snake = {
        segments: [],
        y: 100 + i * 60,
        x: width + i * 200,
        speed: 3 + Math.random() * 2,
        alpha: 0.3 + i * 0.1
      };

      for (let j = 0; j < 6; j++) {
        snake.segments.push({ x: snake.x + j * 10, y: snake.y });
      }

      this.runnerWhiteSnakes.push(snake);
    }
  }

  /**
   * Ïù∏Ìä∏Î°ú ÏûêÎèô ÌîåÎ†àÏù¥
   */
  startRunnerAutoPlay() {
    // Ïû•Ïï†Î¨º Ïä§Ìè∞ ÌÉÄÏù¥Î®∏
    const obstacleTimer = this.time.addEvent({
      delay: 2000,
      callback: () => {
        if (this.runnerPhase !== 'intro') return;
        this.spawnRunnerObstacle();
      },
      loop: true
    });
    this.runnerTimers.push(obstacleTimer);

    // Ï£ΩÏùÄ Î±Ä Î∞∞Í≤Ω Ïä§Ìè∞
    const deadSnakeTimer = this.time.addEvent({
      delay: 3000,
      callback: () => {
        if (this.runnerPhase !== 'intro' && this.runnerPhase !== 'playing') return;
        this.spawnDeadSnake();
      },
      loop: true
    });
    this.runnerTimers.push(deadSnakeTimer);

    // 5Ï¥à ÌõÑ ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÎ°ú Ï†ÑÌôò
    this.time.delayedCall(5000, () => {
      this.startRunnerPlayable();
    });
  }

  /**
   * Ïû•Ïï†Î¨º Ïä§Ìè∞
   */
  spawnRunnerObstacle() {
    // 10Í∞ú Ï†úÌïú Ï≤¥ÌÅ¨
    if (this.runnerObstaclesSpawned >= this.runnerClearTarget) return;
    this.runnerObstaclesSpawned++;

    const { width, height } = this.cameras.main;

    const types = ['germ', 'saw', 'frog', 'nexus', 'ghost'];
    const type = Phaser.Utils.Array.GetRandom(types);

    const obstacle = {
      type: type,
      x: width + 50,
      y: this.runnerGroundY,
      width: 30,
      height: 40,
      passed: false
    };

    // ÌÉÄÏûÖÎ≥Ñ ÌÅ¨Í∏∞ Ï°∞Ï†ï
    switch (type) {
      case 'saw':
        obstacle.height = 50;
        obstacle.width = 50;
        break;
      case 'nexus':
        obstacle.height = 60;
        obstacle.width = 40;
        break;
      case 'ghost':
        obstacle.height = 35;
        obstacle.width = 25;
        break;
    }

    this.runnerObstacles.push(obstacle);

    // Ïù∏Ìä∏Î°ú Ï§ëÏù¥Î©¥ ÏûêÎèô Ï†êÌîÑ
    if (this.runnerPhase === 'intro' && !this.runnerJumping) {
      this.time.delayedCall(800, () => {
        if (!this.runnerJumping) {
          this.runnerJump();
        }
      });
    }
  }

  /**
   * Ï£ΩÏùÄ Î±Ä Î∞∞Í≤Ω Ïä§Ìè∞
   */
  spawnDeadSnake() {
    const { width, height } = this.cameras.main;

    const deadSnake = {
      x: width + 100,
      y: this.runnerGroundY + 10,
      segments: [],
      color: Phaser.Utils.Array.GetRandom([0x666666, 0x555555, 0x444444])
    };

    // ÎûúÎç§ ÌòïÌÉúÏùò Ï£ΩÏùÄ Î±Ä
    for (let i = 0; i < 5 + Math.floor(Math.random() * 5); i++) {
      deadSnake.segments.push({
        offsetX: i * 8,
        offsetY: Math.sin(i * 0.5) * 3
      });
    }

    this.runnerDeadSnakes.push(deadSnake);
  }

  /**
   * Ï†êÌîÑ Ïã§Ìñâ
   */
  runnerJump() {
    if (this.runnerJumping) return;

    this.runnerJumping = true;
    this.runnerJumpVelocity = this.runnerJumpPower;

    // Ï†êÌîÑ Ïãú Î∞©Ìñ•Ï†ÑÌôò sfx Ïû¨ÏÉù
    if (this.movingSound) {
      this.movingSound.play();
    }
  }

  /**
   * ÌîåÎ†àÏù¥Ïñ¥ Î™®Îìú ÏãúÏûë
   */
  startRunnerPlayable() {
    console.log('üéÆ Runner Playable Mode');

    this.runnerPhase = 'playing';
    this.runnerIntroComplete = true;

    const { width, height } = this.cameras.main;

    // Í±∞Î¶¨ ÌÖçÏä§Ìä∏ ÌëúÏãú
    this.runnerDistanceText = this.add.text(width - 20, 30, '0m', {
      fontSize: '24px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 3
    }).setOrigin(1, 0.5).setDepth(9680);
    this.runnerElements.push(this.runnerDistanceText);

    // ÌäúÌÜ†Î¶¨Ïñº ÌÖçÏä§Ìä∏
    const tutorialText = this.add.text(width / 2, height / 3, 'PRESS SPACE TO JUMP!', {
      fontSize: '28px',
      fill: '#ffff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(9660).setAlpha(0);
    this.runnerElements.push(tutorialText);

    // ÌéÑÏä§ Ìö®Í≥º
    this.tweens.add({
      targets: tutorialText,
      alpha: 1,
      scale: { from: 0.8, to: 1.1 },
      duration: 300,
      yoyo: true,
      repeat: 3,
      onComplete: () => {
        this.tweens.add({
          targets: tutorialText,
          alpha: 0,
          duration: 500
        });
      }
    });

    // Ïä§ÌéòÏù¥Ïä§Î∞î ÏûÖÎ†• Îì±Î°ù
    this.input.keyboard.on('keydown-SPACE', () => {
      if (this.runnerPhase === 'playing') {
        // ÎÇëÍ≤®Ïû°Ìûò ÏÉÅÌÉúÎ©¥ ÌÉàÏ∂ú ÏãúÎèÑ
        if (this.runnerTrapped) {
          this.tryEscapeRunner();
        } else if (!this.runnerJumping) {
          this.runnerJump();
        }
      }
    });

    // Ïû•Ïï†Î¨º Ïä§Ìè∞ ÏÜçÎèÑ Ï¶ùÍ∞Ä
    const fastObstacleTimer = this.time.addEvent({
      delay: 1500,
      callback: () => {
        if (this.runnerPhase !== 'playing') return;
        this.spawnRunnerObstacle(); // Ìï®Ïàò ÎÇ¥Î∂ÄÏóêÏÑú 10Í∞ú Ï†úÌïú Ï≤¥ÌÅ¨
      },
      loop: true
    });
    this.runnerTimers.push(fastObstacleTimer);
  }

  /**
   * Îü¨ÎÑà ÏóÖÎç∞Ïù¥Ìä∏ (Îß§ ÌîÑÎ†àÏûÑ)
   */
  updateRunner() {
    if (!this.runnerMode) return;

    // swimming, fertilizing phaseÏóêÏÑúÎäî Î≥ÑÎèÑ ÌÉÄÏù¥Î®∏Í∞Ä Ï≤òÎ¶¨ÌïòÏßÄÎßå drawRunnerÎäî Í≥ÑÏÜç Ìò∏Ï∂ú
    if (this.runnerPhase === 'swimming' || this.runnerPhase === 'fertilizing') {
      this.drawRunner();
      return;
    }

    // clear phaseÏóêÏÑúÎäî Î±ÄÏù¥ Í≥ÑÏÜç Îã¨Î¶¨Îäî Ïï†ÎãàÎ©îÏù¥ÏÖò Ïú†ÏßÄ
    if (this.runnerPhase === 'clear') {
      // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä Îã¨Î¶¨Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Í≥ÑÏÜç
      const head = this.runnerPlayerSnake[0];

      // Î±Ä Î™∏ÌÜµ Î¨ºÍ≤∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Ïú†ÏßÄ
      for (let i = this.runnerPlayerSnake.length - 1; i > 0; i--) {
        const seg = this.runnerPlayerSnake[i];
        const prev = this.runnerPlayerSnake[i - 1];
        seg.y += (prev.y - seg.y) * 0.3;
      }

      // Î∞∞Í≤Ω Ïä§ÌÅ¨Î°§ Ìö®Í≥º Ïú†ÏßÄ (ÏÜçÎèÑ ÏÑúÏÑúÌûà Í∞êÏÜå)
      this.runnerDistance += this.runnerSpeed;

      this.drawRunner();
      return;
    }

    const { width, height } = this.cameras.main;

    // Í±∞Î¶¨ Ï¶ùÍ∞Ä
    this.runnerDistance += this.runnerSpeed;

    // Ï†êÌîÑ Î¨ºÎ¶¨
    if (this.runnerJumping) {
      this.runnerJumpVelocity += this.runnerGravity;
      this.runnerY += this.runnerJumpVelocity;

      // Ï∞©ÏßÄ
      if (this.runnerY >= this.runnerGroundY) {
        this.runnerY = this.runnerGroundY;
        this.runnerJumping = false;
        this.runnerJumpVelocity = 0;

        // 10Í∞ú ÌÜµÍ≥º ÌõÑ Ï∞©ÏßÄÌïòÎ©¥ ÌÅ¥Î¶¨Ïñ¥ ÏãúÌÄÄÏä§ ÏãúÏûë
        if (this.runnerClearStarted && !this.runnerClearSequenceStarted) {
          this.runnerClearSequenceStarted = true;
          console.log('üèÉ Landed! Running alone for a while...');
          // 3Ï¥àÍ∞Ñ Îçî Îã¨Î¶∞ ÌõÑ ÌÅ¥Î¶¨Ïñ¥ ÏãúÌÄÄÏä§ ÏãúÏûë
          this.time.delayedCall(3000, () => {
            this.runnerStageClear();
          });
        }
      }
    }

    // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
    const head = this.runnerPlayerSnake[0];
    head.y = this.runnerY;

    // Î™∏ÌÜµÏù¥ Î®∏Î¶¨Î•º Îî∞ÎùºÍ∞ê
    for (let i = this.runnerPlayerSnake.length - 1; i > 0; i--) {
      const seg = this.runnerPlayerSnake[i];
      const prev = this.runnerPlayerSnake[i - 1];
      seg.y += (prev.y - seg.y) * 0.3;
    }

    // === ÎÇëÍ≤®Ïû°Ìûò ÏÉÅÌÉúÏùº Îïå ===
    if (this.runnerTrapped) {
      // ÌîåÎ†àÏù¥Ïñ¥Îäî Î©àÏ∂§, Î∞∞Í≤ΩÏù¥ Î∞òÎåÄÎ°ú ÌùêÎ¶Ñ (ÎÇ†ÏïÑÍ∞ÄÎäî Î±ÄÎì§Ïù¥ ÎÇòÎ•º ÏïûÏßÄÎ•¥Îäî ÎäêÎÇå)
      // Î∞∞Í≤Ω Ìù∞ Î±ÄÎì§Ïù¥ Ïò§Î•∏Ï™ΩÏúºÎ°ú Îπ†Î•¥Í≤å Ïù¥Îèô (ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏ†êÏóêÏÑú Îí§Ï≤òÏßÄÎäî Ïó∞Ï∂ú)
      this.runnerWhiteSnakes.forEach(snake => {
        snake.x += snake.speed * 3;  // Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú Îπ†Î•¥Í≤å
        snake.segments.forEach((seg, i) => {
          seg.x = snake.x + i * 10;
          seg.y = snake.y + Math.sin((this.runnerDistance + i * 20) * 0.02) * 5;
        });
        // Ïò§Î•∏Ï™ΩÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ ÏôºÏ™ΩÏóêÏÑú Îã§Ïãú Îì±Ïû•
        if (snake.x > width + 100) {
          snake.x = -200 - Math.random() * 300;
        }
      });

      // Í±∞Î¶¨Îäî Í≥ÑÏÜç Ï¶ùÍ∞Ä (Î∞∞Í≤Ω Ìö®Í≥ºÏö©)
      this.runnerDistance += this.runnerSpeed;

      // Ïû°ÏùÄ Ï†ÅÏùÄ ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ìï®Íªò Î©àÏ∂§
      if (this.runnerTrappedEnemy) {
        this.runnerTrappedEnemy.x = head.x + 20;
      }

      // Í∑∏Î¶¨Í∏∞ (ÌÉàÏ∂ú UI Ìè¨Ìï®)
      this.drawRunner();
      return;
    }

    // Ïû•Ïï†Î¨º Ïù¥Îèô Î∞è Ï∂©Îèå Ï≤¥ÌÅ¨
    for (let i = this.runnerObstacles.length - 1; i >= 0; i--) {
      const obs = this.runnerObstacles[i];
      obs.x -= this.runnerSpeed;

      // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞Ñ Ïû•Ïï†Î¨º Ï†úÍ±∞
      if (obs.x < -100) {
        this.runnerObstacles.splice(i, 1);
        continue;
      }

      // Ï∂©Îèå Ï≤¥ÌÅ¨ (ÌîåÎ†àÏù¥Ïñ¥Î∏î Î™®ÎìúÏóêÏÑúÎßå, 10Í∞ú ÌÜµÍ≥º ÌõÑÏóêÎäî Î¨¥Ï†Å)
      if (this.runnerPhase === 'playing' && !obs.passed && !this.runnerClearStarted) {
        if (this.checkRunnerCollision(obs)) {
          // Í≤åÏûÑÏò§Î≤Ñ ÎåÄÏã† ÎÇëÍ≤®Ïû°Ìûò ÏÉÅÌÉúÎ°ú
          this.startRunnerTrapped(obs);
          return;
        }

        // Ïû•Ïï†Î¨º ÌÜµÍ≥º
        if (obs.x < head.x - obs.width / 2) {
          obs.passed = true;
          this.runnerObstaclesPassed++;

          // 10Í∞ú ÌÜµÍ≥ºÏãú - Ï†êÌîÑ Ï§ëÏù¥ ÏïÑÎãàÎ©¥ Î∞îÎ°ú ÏãúÏûë, Ï†êÌîÑ Ï§ëÏù¥Î©¥ Ï∞©ÏßÄ ÌõÑ ÏãúÏûë
          if (this.runnerObstaclesPassed >= this.runnerClearTarget && !this.runnerClearStarted) {
            this.runnerClearStarted = true;

            if (!this.runnerJumping) {
              // Ï†êÌîÑ Ï§ëÏù¥ ÏïÑÎãàÎ©¥ Î∞îÎ°ú ÏãúÏûë
              this.runnerClearSequenceStarted = true;
              console.log('üèÉ 10 obstacles passed! Running alone for a while...');
              this.time.delayedCall(3000, () => {
                this.runnerStageClear();
              });
            } else {
              console.log('üèÉ 10 obstacles passed! Waiting for landing...');
            }
          }
        }
      }
    }

    // Î∞∞Í≤Ω Ìù∞ Î±Ä Ïù¥Îèô
    this.runnerWhiteSnakes.forEach(snake => {
      snake.x -= snake.speed;
      snake.segments.forEach((seg, i) => {
        seg.x = snake.x + i * 10;
        seg.y = snake.y + Math.sin((this.runnerDistance + i * 20) * 0.02) * 5;
      });

      // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Î¶¨ÏÖã
      if (snake.x < -100) {
        snake.x = width + 200 + Math.random() * 300;
      }
    });

    // Ï£ΩÏùÄ Î±Ä Ïù¥Îèô
    this.runnerDeadSnakes.forEach((deadSnake, i) => {
      deadSnake.x -= this.runnerSpeed * 0.5;

      // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï†úÍ±∞
      if (deadSnake.x < -200) {
        this.runnerDeadSnakes.splice(i, 1);
      }
    });

    // Í∑∏Î¶¨Í∏∞
    this.drawRunner();
  }

  /**
   * Ï∂©Îèå Ï≤¥ÌÅ¨
   */
  checkRunnerCollision(obstacle) {
    const head = this.runnerPlayerSnake[0];
    const playerBox = {
      x: head.x - 8,
      y: head.y - 8,
      width: 16,
      height: 16
    };

    const obsBox = {
      x: obstacle.x - obstacle.width / 2,
      y: obstacle.y - obstacle.height,
      width: obstacle.width,
      height: obstacle.height
    };

    // AABB Ï∂©Îèå
    return playerBox.x < obsBox.x + obsBox.width &&
      playerBox.x + playerBox.width > obsBox.x &&
      playerBox.y < obsBox.y + obsBox.height &&
      playerBox.y + playerBox.height > obsBox.y;
  }

  /**
   * ÎÇëÍ≤®Ïû°Ìûò ÏÉÅÌÉú ÏãúÏûë
   */
  startRunnerTrapped(enemy) {
    console.log('ü™§ Runner Trapped!');

    this.runnerTrapped = true;
    this.runnerTrappedEnemy = enemy;
    this.runnerEscapeProgress = 0;

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(200, 0.01);

    // ÏúÑÌóò ÌîåÎûòÏãú
    this.cameras.main.flash(100, 255, 100, 0, true);

    // ÌÉàÏ∂ú UI ÏÉùÏÑ±
    const { width, height } = this.cameras.main;

    // TRAPPED! ÌÖçÏä§Ìä∏
    this.runnerTrappedText = this.add.text(width / 2, height / 2 - 80, 'TRAPPED!', {
      fontSize: '36px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(9700);
    this.runnerElements.push(this.runnerTrappedText);

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò
    this.tweens.add({
      targets: this.runnerTrappedText,
      scale: { from: 0.8, to: 1.1 },
      yoyo: true,
      repeat: -1,
      duration: 200
    });

    // Ïä§ÌéòÏù¥Ïä§Î∞î ÏïàÎÇ¥
    this.runnerEscapeHint = this.add.text(width / 2, height / 2 - 40, 'PRESS SPACE TO ESCAPE!', {
      fontSize: '20px',
      fill: '#ffff00',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(9700);
    this.runnerElements.push(this.runnerEscapeHint);

    // ÏßÑÌñâ Î∞î Î∞∞Í≤Ω
    this.runnerEscapeBarBg = this.add.rectangle(width / 2, height / 2, 200, 20, 0x333333);
    this.runnerEscapeBarBg.setDepth(9700).setStrokeStyle(2, 0xffffff);
    this.runnerElements.push(this.runnerEscapeBarBg);

    // ÏßÑÌñâ Î∞î
    this.runnerEscapeBar = this.add.rectangle(width / 2 - 98, height / 2, 4, 16, 0x00ff00);
    this.runnerEscapeBar.setOrigin(0, 0.5).setDepth(9701);
    this.runnerElements.push(this.runnerEscapeBar);
  }

  /**
   * ÌÉàÏ∂ú ÏãúÎèÑ (Ïä§ÌéòÏù¥Ïä§Î∞î)
   */
  tryEscapeRunner() {
    if (!this.runnerTrapped) return;

    this.runnerEscapeProgress++;
    console.log(`üîì Escape progress: ${this.runnerEscapeProgress}/${this.runnerEscapeRequired}`);

    // ÏßÑÌñâ Î∞î ÏóÖÎç∞Ïù¥Ìä∏
    const progress = this.runnerEscapeProgress / this.runnerEscapeRequired;
    if (this.runnerEscapeBar) {
      this.runnerEscapeBar.width = 196 * progress;

      // ÏÉâÏÉÅ Î≥ÄÍ≤Ω (Ï¥àÎ°ù ‚Üí ÎÖ∏Îûë ‚Üí Îπ®Í∞ï)
      if (progress > 0.7) {
        this.runnerEscapeBar.setFillStyle(0x00ff00);
      } else if (progress > 0.3) {
        this.runnerEscapeBar.setFillStyle(0xffff00);
      }
    }

    // ÌôîÎ©¥ ÌùîÎì§Î¶º
    this.cameras.main.shake(50, 0.005);

    // ÌîåÎ†àÏù¥Ïñ¥ Îñ®Î¶º Ìö®Í≥º
    const head = this.runnerPlayerSnake[0];
    head.x += (Math.random() - 0.5) * 6;

    // ÌÉàÏ∂ú ÏÑ±Í≥µ!
    if (this.runnerEscapeProgress >= this.runnerEscapeRequired) {
      this.escapeRunner();
    }
  }

  /**
   * ÌÉàÏ∂ú ÏÑ±Í≥µ
   */
  escapeRunner() {
    console.log('üéâ Escaped!');

    this.runnerTrapped = false;

    // Ï†Å Ï†úÍ±∞ (ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇ†Î†§Î≤ÑÎ¶º)
    if (this.runnerTrappedEnemy) {
      this.runnerTrappedEnemy.passed = true;
      this.runnerTrappedEnemy.x = -200;
      this.runnerObstaclesPassed++;

      // 10Í∞ú ÌÜµÍ≥ºÏãú ÌÅ¥Î¶¨Ïñ¥ Ï≤¥ÌÅ¨
      if (this.runnerObstaclesPassed >= this.runnerClearTarget) {
        this.cleanupTrappedUI();
        this.runnerStageClear();
        return;
      }
    }

    this.runnerTrappedEnemy = null;

    // UI Ï†ïÎ¶¨
    this.cleanupTrappedUI();

    // ÌÉàÏ∂ú ÏÑ±Í≥µ Ïó∞Ï∂ú
    const { width, height } = this.cameras.main;

    const escapeText = this.add.text(width / 2, height / 2, 'ESCAPED!', {
      fontSize: '32px',
      fill: '#00ff00',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(9700).setAlpha(0);
    this.runnerElements.push(escapeText);

    this.tweens.add({
      targets: escapeText,
      alpha: 1,
      scale: { from: 0.5, to: 1.2 },
      duration: 300,
      ease: 'Back.easeOut',
      onComplete: () => {
        this.tweens.add({
          targets: escapeText,
          alpha: 0,
          y: height / 2 - 50,
          duration: 500,
          delay: 300
        });
      }
    });

    // Ïπ¥Î©îÎùº ÌîåÎûòÏãú (ÏÑ±Í≥µ)
    this.cameras.main.flash(200, 0, 255, 0, true);
  }

  /**
   * ÎÇëÍ≤®Ïû°Ìûò UI Ï†ïÎ¶¨
   */
  cleanupTrappedUI() {
    if (this.runnerTrappedText) {
      this.runnerTrappedText.destroy();
      this.runnerTrappedText = null;
    }
    if (this.runnerEscapeHint) {
      this.runnerEscapeHint.destroy();
      this.runnerEscapeHint = null;
    }
    if (this.runnerEscapeBarBg) {
      this.runnerEscapeBarBg.destroy();
      this.runnerEscapeBarBg = null;
    }
    if (this.runnerEscapeBar) {
      this.runnerEscapeBar.destroy();
      this.runnerEscapeBar = null;
    }
  }

  /**
   * Îü¨ÎÑà Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ - Ï†ïÏûêÏôÄ ÎÇúÏûê ÏàòÏ†ï ÏóîÎî© Ïó∞Ï∂ú
   */
  runnerStageClear() {
    console.log('üèÜ Runner Stage Clear - Starting Fertilization Ending!');

    this.runnerPhase = 'clear';
    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ Ïû•Ïï†Î¨º Ï†úÍ±∞ (Î±ÄÏùÄ Í≥ÑÏÜç Îã¨Î¶º)
    this.runnerObstacles = [];

    // 1Îã®Í≥Ñ: Î∞∞Í≤Ω Î±ÄÎì§ ÏÑúÏÑúÌûà ÏÇ¨ÎùºÏßê (ÌòºÏûê Îã¨Î¶¨Îäî Î™®Ïäµ)
    this.runnerWhiteSnakes.forEach(snake => {
      this.tweens.add({
        targets: snake,
        alpha: 0,
        duration: 2000
      });
    });

    // 2Ï¥à ÌõÑ Î∞∞Í≤Ω Î±ÄÎì§ ÏôÑÏ†Ñ Ï†úÍ±∞ + ÎÇúÏûê Îì±Ïû• ÏãúÏûë
    this.time.delayedCall(2500, () => {
      this.runnerWhiteSnakes = [];
      this.startEggApproach();
    });
  }

  /**
   * ÎÇúÏûê(Îπõ Ïò§Î∏å)Í∞Ä Ïò§Î•∏Ï™ΩÏóêÏÑú ÏÑúÏÑúÌûà Îã§Í∞ÄÏò¥
   */
  startEggApproach() {
    console.log('ü•ö Egg approaching from right...');

    const { width, height } = this.cameras.main;

    // BGM ÌéòÏù¥ÎìúÏïÑÏõÉ ÏãúÏûë (5Ï¥àÏóê Í±∏Ï≥ê Ï†êÏ†ê Ï§ÑÏñ¥Îì¶)
    if (this.bgMusic && this.bgMusic.isPlaying) {
      this.tweens.add({
        targets: this.bgMusic,
        volume: 0,
        duration: 5000,
        ease: 'Sine.easeIn',
        onComplete: () => {
          this.bgMusic.stop();
        }
      });
    }

    // ÎÇúÏûê ÏãúÏûë ÏúÑÏπò (ÌôîÎ©¥ Ïò§Î•∏Ï™Ω Î∞ñ)
    const startX = width + 150;
    const targetX = width - 200;
    const orbY = this.runnerGroundY - 80;

    // ÎÇúÏûê Ïª®ÌÖåÏù¥ÎÑà (9ÌÉÑ ÎîîÏûêÏù∏ Í∏∞Î∞ò, 6Î∞∞ ÌÅ¨Í∏∞)
    this.runnerEgg = this.add.container(startX, orbY).setDepth(9750);
    this.runnerElements.push(this.runnerEgg);

    // Ïô∏Í≥Ω Í∏ÄÎ°úÏö∞ (Ìù¨ÎØ∏ÌïòÍ≤å) - 6Î∞∞ ÌÅ¨Í∏∞
    const outerGlow = this.add.circle(0, 0, 360, 0xffffff, 0.1);
    // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞
    const midGlow = this.add.circle(0, 0, 240, 0xffffaa, 0.2);
    // ÏΩîÏñ¥
    const core = this.add.circle(0, 0, 120, 0xffffff, 0.6);

    this.runnerEgg.add([outerGlow, midGlow, core]);
    this.runnerEggCore = core;
    this.runnerEggOuterGlow = outerGlow;

    // ÌéÑÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò (9ÌÉÑÍ≥º ÎèôÏùº)
    this.tweens.add({
      targets: outerGlow,
      alpha: { from: 0.1, to: 0.3 },
      scaleX: { from: 1, to: 1.5 },
      scaleY: { from: 1, to: 1.5 },
      duration: 1000,
      yoyo: true,
      repeat: -1
    });

    this.tweens.add({
      targets: core,
      alpha: { from: 0.6, to: 1 },
      duration: 500,
      yoyo: true,
      repeat: -1
    });

    // ÎÇúÏûêÍ∞Ä ÏÑúÏÑúÌûà Îã§Í∞ÄÏò¥
    this.tweens.add({
      targets: this.runnerEgg,
      x: targetX,
      duration: 5000,
      ease: 'Sine.easeOut'
    });

    // ÎèôÏãúÏóê Î±Ä ÏÜçÎèÑ Ï†êÏ†ê ÎäêÎ†§Ïßê
    this.startSnakeSlowdown();
  }

  /**
   * Î±Ä ÏÜçÎèÑ Ï†êÏ†ê ÎäêÎ†§Ïßê + Ìó§ÏóÑÏπòÍ∏∞ ÏãúÏûë
   */
  startSnakeSlowdown() {
    console.log('üêç Snake slowing down...');

    const { width } = this.cameras.main;
    this.runnerPhase = 'swimming';

    // ÏÜçÎèÑ Í∞êÏÜå + Ìó§ÏóÑÏπòÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
    let elapsed = 0;
    const slowdownDuration = 4000;
    const originalSpeed = this.runnerSpeed;

    const slowdownTimer = this.time.addEvent({
      delay: 16,
      callback: () => {
        elapsed += 16;
        const progress = Math.min(elapsed / slowdownDuration, 1);

        // ÏÜçÎèÑ Ï†êÏ†ê Í∞êÏÜå
        this.runnerSpeed = originalSpeed * (1 - progress * 0.8);

        // Î±Ä Î¨ºÍ≤∞ ÏõÄÏßÅÏûÑ (Ìó§ÏóÑÏπòÎäî ÎäêÎÇå)
        const head = this.runnerPlayerSnake[0];
        head.y = this.runnerGroundY + Math.sin(elapsed * 0.01) * 10;

        // Î™∏ÌÜµ Î¨ºÍ≤∞
        for (let i = 1; i < this.runnerPlayerSnake.length; i++) {
          const seg = this.runnerPlayerSnake[i];
          const prev = this.runnerPlayerSnake[i - 1];
          seg.x += (prev.x - 12 - seg.x) * 0.1;
          seg.y = this.runnerGroundY + Math.sin((elapsed * 0.01) - i * 0.5) * 8;
        }

        // Î∞∞Í≤Ω Î≥ÑÎßå Ï≤úÏ≤úÌûà ÏõÄÏßÅÏûÑ
        this.runnerDistance += this.runnerSpeed * 0.5;

        this.drawRunner();

        if (progress >= 1) {
          slowdownTimer.destroy();
          // ÎÇúÏûêÏóê ÎèÑÎã¨ ÌõÑ ÏàòÏ†ï ÏãúÏûë
          this.time.delayedCall(1000, () => {
            this.startFertilization();
          });
        }
      },
      loop: true
    });
  }

  /**
   * ÏàòÏ†ï Í≥ºÏ†ï - Ï†ïÏûêÍ∞Ä ÎÇúÏûêÎ°ú ÏßÑÏûÖ
   */
  startFertilization() {
    console.log('üß¨ Starting fertilization...');

    const { width, height } = this.cameras.main;
    const head = this.runnerPlayerSnake[0];

    // ÎÇúÏûê ÏúÑÏπò
    const eggX = this.runnerEgg.x;
    const eggY = this.runnerEgg.y;

    // Î±ÄÏù¥ ÎÇúÏûêÎ°ú Ï†êÌîÑ + Îπ†Î•¥Í≤å Ìó§ÏóÑÏπ®
    const startX = head.x;
    const startY = head.y;
    const duration = 1200;

    this.runnerPhase = 'fertilizing';

    let elapsed = 0;
    const fertilizeTimer = this.time.addEvent({
      delay: 16,
      callback: () => {
        elapsed += 16;
        const progress = Math.min(elapsed / duration, 1);

        // Ìè¨Î¨ºÏÑ† Ï†êÌîÑ + Îπ†Î•∏ Ï†ëÍ∑º
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        const jumpHeight = Math.sin(progress * Math.PI) * 80;

        // Î®∏Î¶¨Í∞Ä ÎÇúÏûêÎ°ú Ïù¥Îèô
        head.x = startX + (eggX - startX) * easeProgress;
        head.y = startY + (eggY - startY) * easeProgress - jumpHeight;

        // Íº¨Î¶¨Îäî Ï†êÏ†ê Îí§Ï≤òÏßê (Ï†ïÏûê Íº¨Î¶¨Ï≤òÎüº)
        for (let i = this.runnerPlayerSnake.length - 1; i > 0; i--) {
          const seg = this.runnerPlayerSnake[i];
          const prev = this.runnerPlayerSnake[i - 1];
          const followSpeed = 0.08 - (i * 0.005); // Îí§Î°ú Í∞àÏàòÎ°ù Îçî ÎäêÎ¶¨Í≤å
          seg.x += (prev.x - seg.x) * Math.max(followSpeed, 0.02);
          seg.y += (prev.y - seg.y) * Math.max(followSpeed, 0.02);

          // ÏßÑÏûÖ ÏßÅÏ†Ñ Íº¨Î¶¨ Îñ®Ïñ¥ÏßÄÍ∏∞ ÏãúÏûë
          if (progress > 0.7) {
            const detachProgress = (progress - 0.7) / 0.3;
            seg.y += detachProgress * i * 3; // ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ïßê
            seg.color = Phaser.Display.Color.Interpolate.ColorWithColor(
              { r: 255, g: 255, b: 255 },
              { r: 100, g: 100, b: 100 },
              100,
              detachProgress * 100
            );
            seg.color = (seg.color.r << 16) + (seg.color.g << 8) + seg.color.b;
          }
        }

        // ÎÇúÏûê Î∞òÏùë (ÏßÑÎèô)
        if (progress > 0.5) {
          this.runnerEgg.x = eggX + (Math.random() - 0.5) * 4;
          this.runnerEgg.y = eggY + (Math.random() - 0.5) * 4;
        }

        this.drawRunner();

        if (progress >= 1) {
          fertilizeTimer.destroy();
          this.completeFerilization();
        }
      },
      loop: true
    });
  }

  /**
   * ÏàòÏ†ï ÏôÑÎ£å - ÌïµÎßå ÏßÑÏûÖ, ÎÇúÏûê ÎπõÎÇ®
   */
  completeFerilization() {
    console.log('‚ú® Fertilization complete!');

    const { width, height } = this.cameras.main;

    // Î®∏Î¶¨(Ìïµ)Îßå Ìù°Ïàò, ÎÇòÎ®∏ÏßÄÎäî Îñ®Ïñ¥Ïßê
    const head = this.runnerPlayerSnake[0];
    head.absorbed = true;

    // Íº¨Î¶¨Îì§ ÏïÑÎûòÎ°ú Îñ®Ïñ¥ÏßÄÎ©∞ ÌéòÏù¥ÎìúÏïÑÏõÉ
    for (let i = 1; i < this.runnerPlayerSnake.length; i++) {
      const seg = this.runnerPlayerSnake[i];
      this.tweens.add({
        targets: seg,
        y: seg.y + 200,
        alpha: 0,
        duration: 1000 + i * 100,
        ease: 'Quad.easeIn',
        onComplete: () => {
          seg.absorbed = true;
        }
      });
    }

    // ÎÇúÏûêÍ∞Ä Î∂àÌà¨Î™ÖÌïòÍ≤å Î∞ùÏïÑÏßê (ÌÅ¨Í∏∞ Î≥ÄÌôî ÏóÜÏùå)
    this.tweens.add({
      targets: this.runnerEggCore,
      alpha: 1,
      duration: 1500
    });

    this.tweens.add({
      targets: this.runnerEggOuterGlow,
      alpha: 0.9,
      duration: 2000
    });

    // Ï§ëÍ∞Ñ Í∏ÄÎ°úÏö∞ÎèÑ Î∞ùÏïÑÏßê
    const midGlow = this.runnerEgg.list[1]; // midGlow
    if (midGlow) {
      this.tweens.add({
        targets: midGlow,
        alpha: 0.8,
        duration: 1800
      });
    }

    // ÌôîÎ©¥ ÏÑúÏÑúÌûà Î∞ùÏïÑÏßê
    const whiteOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0xffffff, 0);
    whiteOverlay.setDepth(9900);
    this.runnerElements.push(whiteOverlay);

    this.tweens.add({
      targets: whiteOverlay,
      alpha: 1,
      duration: 3000,
      delay: 1500,
      onComplete: () => {
        // ÏóîÎî© ÌôîÎ©¥ÏúºÎ°ú
        this.showRunnerEnding();
      }
    });
  }

  /**
   * Îü¨ÎÑà ÏóîÎî© ÌôîÎ©¥ ÌëúÏãú - Ïó≠ÎèôÏ†ÅÏù∏ Ï†ÑÌôò Ìö®Í≥º + 3Î∞∞ÏÜç ÎπÑÎîîÏò§ + RAIN_IS_BEST BGM
   */
  showRunnerEnding() {
    console.log('üé¨ Showing Runner Ending Screen - Dynamic Transition!');

    const { width, height } = this.cameras.main;

    // Í∏∞Ï°¥ ÏöîÏÜå Ï†ïÎ¶¨
    if (this.runnerGraphics) {
      this.runnerGraphics.clear();
    }

    // ===== PHASE 1: Í≤©ÎèôÏ†ÅÏù∏ Ï†ÑÌôò Ìö®Í≥º (0-2Ï¥à) =====

    // ÌôîÎ©¥ Îñ®Î¶º ÏãúÏûë
    this.cameras.main.shake(1500, 0.03);

    // ÌîåÎûòÏãú Ìö®Í≥º Ïó∞ÏÜç
    this.cameras.main.flash(300, 255, 255, 255);
    this.time.delayedCall(400, () => this.cameras.main.flash(200, 255, 255, 255));
    this.time.delayedCall(700, () => this.cameras.main.flash(150, 255, 255, 255));

    // Ï§å Ïù∏/ÏïÑÏõÉ Ìö®Í≥º
    this.cameras.main.zoomTo(1.5, 500, 'Sine.easeIn', false, () => {
      this.cameras.main.zoomTo(0.8, 300, 'Sine.easeOut', false, () => {
        this.cameras.main.zoomTo(1, 200);
      });
    });

    // Í≤©ÎèôÏ†ÅÏù∏ ÎùºÏù∏ Ïù¥ÌéôÌä∏ (ÏàòÏ†ï ÏàúÍ∞ÑÏùò ÏóêÎÑàÏßÄ)
    for (let i = 0; i < 20; i++) {
      this.time.delayedCall(i * 50, () => {
        const angle = Math.random() * Math.PI * 2;
        const length = 200 + Math.random() * 400;
        const lineColor = Phaser.Utils.Array.GetRandom([0xffffff, 0xffffaa, 0xffff00, 0xffd700]);

        const line = this.add.graphics().setDepth(9940);
        line.lineStyle(3 + Math.random() * 5, lineColor, 0.8);
        line.beginPath();
        line.moveTo(width / 2, height / 2);
        line.lineTo(
          width / 2 + Math.cos(angle) * length,
          height / 2 + Math.sin(angle) * length
        );
        line.stroke();
        this.runnerElements.push(line);

        this.tweens.add({
          targets: line,
          alpha: 0,
          duration: 300,
          onComplete: () => line.destroy()
        });
      });
    }

    // ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú Ìö®Í≥º
    for (let i = 0; i < 50; i++) {
      this.time.delayedCall(200 + Math.random() * 500, () => {
        const particle = this.add.circle(
          width / 2 + (Math.random() - 0.5) * 100,
          height / 2 + (Math.random() - 0.5) * 100,
          3 + Math.random() * 8,
          Phaser.Utils.Array.GetRandom([0xffffff, 0xffffaa, 0xff6b6b, 0x00ffff]),
          1
        ).setDepth(9945);
        this.runnerElements.push(particle);

        const angle = Math.random() * Math.PI * 2;
        const speed = 100 + Math.random() * 300;

        this.tweens.add({
          targets: particle,
          x: particle.x + Math.cos(angle) * speed,
          y: particle.y + Math.sin(angle) * speed,
          alpha: 0,
          scale: 0,
          duration: 800 + Math.random() * 400,
          ease: 'Power2',
          onComplete: () => particle.destroy()
        });
      });
    }

    // ÏõêÌòï Ï∂©Í≤©Ìåå
    for (let i = 0; i < 3; i++) {
      this.time.delayedCall(i * 300, () => {
        const shockwave = this.add.circle(width / 2, height / 2, 10, 0xffffff, 0);
        shockwave.setStrokeStyle(4, 0xffffff, 1);
        shockwave.setDepth(9935);
        this.runnerElements.push(shockwave);

        this.tweens.add({
          targets: shockwave,
          radius: 500,
          alpha: 0,
          duration: 600,
          ease: 'Power2',
          onComplete: () => shockwave.destroy()
        });
      });
    }

    // ===== PHASE 2: ÎπÑÎîîÏò§ Ï†ÑÌôò Ï§ÄÎπÑ (1.5Ï¥à ÌõÑ) =====
    this.time.delayedCall(1500, () => {
      // Í≤ÄÏùÄ Î∞∞Í≤ΩÏúºÎ°ú Ï†ÑÌôò
      const blackBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0);
      blackBg.setDepth(9950);
      this.runnerElements.push(blackBg);

      this.tweens.add({
        targets: blackBg,
        alpha: 1,
        duration: 500,
        onComplete: () => {
          // ===== PHASE 3: ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÏûë =====
          this.startEndingVideoSequence();
        }
      });
    });
  }

  /**
   * ÏóîÎî© ÎπÑÎîîÏò§ ÏãúÌÄÄÏä§ - 3Î∞∞ÏÜç + RAIN_IS_BEST BGM
   */
  startEndingVideoSequence() {
    console.log('üé¨ Starting Ending Video Sequence - 3x Speed + RAIN_IS_BEST BGM');

    const { width, height } = this.cameras.main;

    // RAIN_IS_BEST BGM ÏãúÏûë (Î≥ºÎ•® 0.8Î°ú Î∞îÎ°ú Ïû¨ÏÉù)
    if (this.rainIsBestMusic) {
      console.log('üéµ Playing RAIN_IS_BEST BGM');
      if (this.rainIsBestMusic.isPlaying) {
        this.rainIsBestMusic.stop();
      }
      this.rainIsBestMusic.setVolume(0.8);
      this.rainIsBestMusic.play();
    } else {
      console.error('‚ùå rainIsBestMusic is not defined!');
    }

    // ÏóîÎî© ÎπÑÎîîÏò§ Ïû¨ÏÉù (3Î∞∞ÏÜç)
    const endingVideo = this.add.video(width / 2, height / 2, 'ending_video');
    endingVideo.setDepth(9960);
    endingVideo.setOrigin(0.5);
    endingVideo.setAlpha(0);

    // ÎπÑÎîîÏò§Î•º ÌôîÎ©¥Ïóê ÎßûÍ≤å Ïä§ÏºÄÏùº Ï°∞Ï†ï
    endingVideo.on('play', () => {
      const videoWidth = endingVideo.width;
      const videoHeight = endingVideo.height;
      const scaleX = width / videoWidth;
      const scaleY = height / videoHeight;
      const scale = Math.max(scaleX, scaleY);
      endingVideo.setScale(scale);
    });

    // Î£®ÌîÑ ÏóÜÏù¥ Ïû¨ÏÉù (false = Î£®ÌîÑ ÏïàÌï®)
    endingVideo.play(false);
    endingVideo.setPlaybackRate(3);

    // ÎπÑÎîîÏò§ ÌéòÏù¥Îìú Ïù∏
    this.tweens.add({
      targets: endingVideo,
      alpha: 1,
      duration: 500
    });

    this.runnerElements.push(endingVideo);
    this.endingVideo = endingVideo;

    // ÎπÑÎîîÏò§ Ï¢ÖÎ£å Ïãú Ï≤òÎ¶¨ - Îã§Ïùå ÏóîÎî© ÎπÑÎîîÏò§Î°ú (ÎÑ§Ïù¥Ìã∞Î∏å Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö©)
    if (endingVideo.video) {
      endingVideo.video.onended = () => {
        console.log('üé¨ First ending video (sujeong) completed - starting final ending');
        this.startFinalEndingVideo();
      };
    }

    // ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàÑÎ•¥Î©¥ Ïä§ÌÇµ Í∞ÄÎä• (3Ï¥à ÌõÑÎ∂ÄÌÑ∞) - Îã§Ïùå ÎπÑÎîîÏò§Î°ú
    this.time.delayedCall(3000, () => {
      this.input.keyboard.once('keydown', () => {
        if (this.endingVideo) {
          this.endingVideo.stop();
        }
        this.startFinalEndingVideo();
      });
    });
  }

  /**
   * ÎπÑÎîîÏò§ Ï†ÑÌôò Ìö®Í≥º (Î∂ÑÏó¥ÏòÅÏÉÅ ‚Üí ÏóîÎî©ÏòÅÏÉÅ ÏÇ¨Ïù¥)
   */
  showVideoTransitionEffect() {
    // Ïù¥ÎØ∏ Ï†ÑÌôò Ï§ëÏù¥Î©¥ Î¨¥Ïãú
    if (this.videoTransitionStarted) return;
    this.videoTransitionStarted = true;

    console.log('üé¨ Video Transition Effect Starting');

    const { width, height } = this.cameras.main;

    // Ï≤´ Î≤àÏß∏ ÎπÑÎîîÏò§ Ï†ïÎ¶¨
    if (this.endingVideo) {
      if (this.endingVideo.video) {
        this.endingVideo.video.onended = null;
      }
      this.endingVideo.destroy();
      this.endingVideo = null;
    }

    // Í≤ÄÏùÄ Î∞∞Í≤Ω
    const blackBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000);
    blackBg.setDepth(9960);
    this.runnerElements.push(blackBg);

    // ÎπõÎÇòÎäî ÌååÌã∞ÌÅ¥Îì§ (Ïö∞Ï£ºÏ†Å ÎäêÎÇå)
    const particles = [];
    for (let i = 0; i < 50; i++) {
      const particle = this.add.circle(
        Phaser.Math.Between(0, width),
        Phaser.Math.Between(0, height),
        Phaser.Math.Between(1, 3),
        0xffffff,
        0
      );
      particle.setDepth(9961);
      particles.push(particle);
      this.runnerElements.push(particle);

      // ÌååÌã∞ÌÅ¥ ÌéòÏù¥Îìú Ïù∏/ÏïÑÏõÉ Ïï†ÎãàÎ©îÏù¥ÏÖò
      this.tweens.add({
        targets: particle,
        alpha: { from: 0, to: Phaser.Math.FloatBetween(0.3, 1) },
        scale: { from: 0.5, to: Phaser.Math.FloatBetween(1, 2) },
        duration: Phaser.Math.Between(500, 1500),
        delay: Phaser.Math.Between(0, 1000),
        yoyo: true,
        repeat: 1,
        ease: 'Sine.easeInOut'
      });
    }

    // Ï§ëÏïô Îπõ Ìö®Í≥º (ÏÉùÎ™ÖÏùò ÏãúÏûëÏùÑ ÏïîÏãú) - scaleÎ°ú ÌÅ¨Í∏∞ Ï°∞Ï†à
    const centerGlow = this.add.circle(width / 2, height / 2, 150, 0xffccaa, 0);
    centerGlow.setDepth(9962);
    centerGlow.setScale(0);
    this.runnerElements.push(centerGlow);

    // Ï§ëÏïô Îπõ ÌôïÏû• (scale ÏÇ¨Ïö©)
    this.tweens.add({
      targets: centerGlow,
      scale: 1,
      alpha: 0.6,
      duration: 1500,
      delay: 500,
      ease: 'Quad.easeOut',
      onComplete: () => {
        // ÎπõÏù¥ ÌéÑÏä§ (centerGlowÍ∞Ä ÏïÑÏßÅ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏)
        if (centerGlow && centerGlow.active) {
          this.tweens.add({
            targets: centerGlow,
            alpha: 0.3,
            scale: 1.2,
            yoyo: true,
            duration: 800,
            repeat: 1,
            ease: 'Sine.easeInOut'
          });
        }
      }
    });

    // "ÏãúÍ∞ÑÏù¥ ÌùêÎ•¥Îã§..." ÌÖçÏä§Ìä∏
    const timeText = this.add.text(width / 2, height / 2 - 50, '', {
      fontFamily: 'Arial, sans-serif',
      fontSize: '24px',
      color: '#ffffff',
      alpha: 0
    });
    timeText.setOrigin(0.5);
    timeText.setDepth(9963);
    timeText.setAlpha(0);
    this.runnerElements.push(timeText);

    // ÌÖçÏä§Ìä∏ ÌÉÄÏù¥Ìïë Ìö®Í≥º
    const fullText = '...';
    let charIndex = 0;
    this.time.delayedCall(1000, () => {
      this.tweens.add({
        targets: timeText,
        alpha: 1,
        duration: 500
      });

      const typingTimer = this.time.addEvent({
        delay: 600,
        repeat: fullText.length - 1,
        callback: () => {
          charIndex++;
          timeText.setText(fullText.substring(0, charIndex));
        }
      });
      this.runnerElements.push(typingTimer);
    });

    // ÌôîÎ©¥ Ï†ÑÌôò (3Ï¥à ÌõÑ)
    this.time.delayedCall(3500, () => {
      // Î™®Îì† Ï†ÑÌôò ÏöîÏÜå ÌéòÏù¥Îìú ÏïÑÏõÉ
      const allTransitionElements = [blackBg, centerGlow, timeText, ...particles];

      // Í∏∞Ï°¥ tweens Î™®Îëê Ï§ëÏßÄ
      allTransitionElements.forEach(el => {
        if (el) this.tweens.killTweensOf(el);
      });

      this.tweens.add({
        targets: allTransitionElements.filter(el => el && el.active),
        alpha: 0,
        duration: 800,
        onComplete: () => {
          // Ï†ÑÌôò ÏöîÏÜå Ï†ïÎ¶¨
          allTransitionElements.forEach(el => {
            if (el && el.destroy) el.destroy();
          });
          this.videoTransitionStarted = false;
          // ÏµúÏ¢Ö ÎπÑÎîîÏò§ ÏãúÏûë
          this.startFinalEndingVideoActual();
        }
      });
    });
  }

  /**
   * ÏµúÏ¢Ö ÏóîÎî© ÎπÑÎîîÏò§ Ïû¨ÏÉù (ending.mp4) - ÏùåÏÜåÍ±∞, BGM Ïú†ÏßÄ
   */
  startFinalEndingVideo() {
    // Ï†ÑÌôò Ìö®Í≥ºÎ•º Î®ºÏ†Ä Î≥¥Ïó¨Ï§å
    this.showVideoTransitionEffect();
  }

  /**
   * Ïã§Ï†ú ÏµúÏ¢Ö ÏóîÎî© ÎπÑÎîîÏò§ Ïû¨ÏÉù
   */
  startFinalEndingVideoActual() {
    // Ïù¥ÎØ∏ ÏµúÏ¢Ö ÎπÑÎîîÏò§ Ïû¨ÏÉù Ï§ëÏù¥Î©¥ Î¨¥Ïãú
    if (this.finalEndingStarted) return;
    this.finalEndingStarted = true;

    console.log('üé¨ Starting Final Ending Video (ending.mp4) - Muted, BGM continues');

    const { width, height } = this.cameras.main;

    // ÏµúÏ¢Ö ÏóîÎî© ÎπÑÎîîÏò§ (ÏùåÏÜåÍ±∞)
    const finalVideo = this.add.video(width / 2, height / 2, 'final_ending_video');
    finalVideo.setDepth(9960);
    finalVideo.setOrigin(0.5);
    finalVideo.setAlpha(0);
    finalVideo.setMute(true); // ÏùåÏÜåÍ±∞ - RAIN_IS_BEST BGMÎßå Îì§Î¶º

    // ÎπÑÎîîÏò§Î•º ÌôîÎ©¥Ïóê ÎßûÍ≤å Ïä§ÏºÄÏùº Ï°∞Ï†ï
    finalVideo.on('play', () => {
      const videoWidth = finalVideo.width;
      const videoHeight = finalVideo.height;
      const scaleX = width / videoWidth;
      const scaleY = height / videoHeight;
      const scale = Math.max(scaleX, scaleY);
      finalVideo.setScale(scale);
    });

    // Î£®ÌîÑ ÏóÜÏù¥ Ïû¨ÏÉù (false = Î£®ÌîÑ ÏïàÌï®)
    finalVideo.play(false);

    // ÎπÑÎîîÏò§ ÌéòÏù¥Îìú Ïù∏
    this.tweens.add({
      targets: finalVideo,
      alpha: 1,
      duration: 500
    });

    this.runnerElements.push(finalVideo);
    this.finalEndingVideo = finalVideo;

    // ÎπÑÎîîÏò§ Ï¢ÖÎ£å Ïãú ÏµúÏ¢Ö ÏóîÎî© Ï≤òÎ¶¨ (ÎÑ§Ïù¥Ìã∞Î∏å Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö©)
    if (finalVideo.video) {
      finalVideo.video.onended = () => {
        console.log('üé¨ Final ending video completed');
        this.finalEndingStarted = false;
        this.showPostVideoEnding();
      };
    }

    // ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàÑÎ•¥Î©¥ Ïä§ÌÇµ Í∞ÄÎä• (2Ï¥à ÌõÑÎ∂ÄÌÑ∞)
    this.time.delayedCall(2000, () => {
      this.input.keyboard.once('keydown', () => {
        if (this.finalEndingVideo) {
          this.finalEndingVideo.stop();
        }
        this.finalEndingStarted = false;
        this.showPostVideoEnding();
      });
    });
  }

  /**
   * ÎπÑÎîîÏò§ Ï¢ÖÎ£å ÌõÑ ÏóîÎî© Ï≤òÎ¶¨ - ÌÅ¨Î†àÎîß Î°§ ÏãúÏûë
   */
  showPostVideoEnding() {
    // Ïù¥ÎØ∏ Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Î¨¥Ïãú
    if (this.postVideoEndingStarted) return;
    this.postVideoEndingStarted = true;

    console.log('üé¨ Post-video ending sequence - Starting Credits');

    const { width, height } = this.cameras.main;

    // ÎπÑÎîîÏò§ Ï†ïÎ¶¨
    if (this.endingVideo) {
      this.endingVideo.destroy();
      this.endingVideo = null;
    }
    if (this.finalEndingVideo) {
      this.finalEndingVideo.destroy();
      this.finalEndingVideo = null;
    }

    // RAIN_IS_BEST BGM ÌéòÏù¥ÎìúÏïÑÏõÉ
    if (this.rainIsBestMusic && this.rainIsBestMusic.isPlaying) {
      this.tweens.add({
        targets: this.rainIsBestMusic,
        volume: 0,
        duration: 1500,
        onComplete: () => {
          this.rainIsBestMusic.stop();
        }
      });
    }

    // ÌéòÏù¥Îìú Ìà¨ Î∏îÎûô
    const fadeOverlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0);
    fadeOverlay.setDepth(9970);
    this.runnerElements.push(fadeOverlay);

    this.tweens.add({
      targets: fadeOverlay,
      alpha: 1,
      duration: 1000,
      onComplete: () => {
        // 2Ï¥à ÎåÄÍ∏∞ ÌõÑ Ï≤†ÌïôÏ†Å Î©îÏãúÏßÄ ÏãúÏûë
        this.time.delayedCall(2000, () => {
          this.showPhilosophicalMessages();
        });
      }
    });
  }

  /**
   * Ï≤†ÌïôÏ†Å Î©îÏãúÏßÄ ÏãúÌÄÄÏä§ (ÏóîÎî©ÏòÅÏÉÅ ‚Üí ÌÅ¨Î†àÎîß ÏÇ¨Ïù¥)
   */
  showPhilosophicalMessages() {
    console.log('üåü Showing Philosophical Messages');

    const { width, height } = this.cameras.main;

    // Î©îÏãúÏßÄ ÏöîÏÜåÎì§ Ï†ÄÏû•
    this.philosophyElements = [];

    // Í≤ÄÏùÄ Î∞∞Í≤Ω ÌôïÎ≥¥
    const blackBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000);
    blackBg.setDepth(9975);
    this.philosophyElements.push(blackBg);

    // ÏùÄÏùÄÌïú Îπõ ÌååÌã∞ÌÅ¥ Î∞∞Í≤Ω
    for (let i = 0; i < 20; i++) {
      const particle = this.add.circle(
        Phaser.Math.Between(0, width),
        Phaser.Math.Between(0, height),
        Phaser.Math.Between(1, 2),
        0xffffff,
        0
      );
      particle.setDepth(9976);
      this.philosophyElements.push(particle);

      // Ï≤úÏ≤úÌûà ÎÇòÌÉÄÎÇ¨Îã§ ÏÇ¨ÎùºÏßÄÎäî Ìö®Í≥º
      this.tweens.add({
        targets: particle,
        alpha: { from: 0, to: Phaser.Math.FloatBetween(0.1, 0.3) },
        duration: Phaser.Math.Between(2000, 4000),
        delay: Phaser.Math.Between(0, 3000),
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    }

    // Ï≤†ÌïôÏ†Å Î©îÏãúÏßÄÎì§ (ÏòÅÏñ¥)
    const messages = [
      "You've come a long way.",
      "You, who were born through such struggle...",
      "You are valuable just as you are.",
      "Thank you for being born.",
      "Enjoy your day today."
    ];

    let currentIndex = 0;
    const messageDuration = 3500; // Í∞Å Î©îÏãúÏßÄ ÌëúÏãú ÏãúÍ∞Ñ
    const fadeTime = 800; // ÌéòÏù¥Îìú Ïù∏/ÏïÑÏõÉ ÏãúÍ∞Ñ

    const showNextMessage = () => {
      if (currentIndex >= messages.length) {
        // Î™®Îì† Î©îÏãúÏßÄ ÏôÑÎ£å - ÌÅ¨Î†àÎîßÏúºÎ°ú Ïù¥Îèô
        this.time.delayedCall(1500, () => {
          // Ï≤†Ìïô Î©îÏãúÏßÄ ÏöîÏÜå Ï†ïÎ¶¨
          this.philosophyElements.forEach(el => {
            if (el) this.tweens.killTweensOf(el);
            if (el && el.destroy) el.destroy();
          });
          this.philosophyElements = [];

          // ÌÅ¨Î†àÎîß ÏãúÏûë
          this.showEndingCredits();
        });
        return;
      }

      const message = messages[currentIndex];

      // Î©îÏãúÏßÄ ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
      const messageText = this.add.text(width / 2, height / 2, message, {
        fontSize: currentIndex === messages.length - 1 ? '28px' : '24px',
        fontFamily: 'Georgia, serif',
        fontStyle: 'italic',
        color: '#ffffff',
        align: 'center',
        wordWrap: { width: width - 100 }
      });
      messageText.setOrigin(0.5);
      messageText.setDepth(9980);
      messageText.setAlpha(0);
      this.philosophyElements.push(messageText);

      // Î∂ÄÎìúÎü¨Ïö¥ Í∏ÄÎ°úÏö∞ Ìö®Í≥º (Í∑∏Î¶ºÏûêÎ°ú ÌëúÌòÑ)
      messageText.setShadow(0, 0, '#ffffff', 10, false, true);

      // ÌéòÏù¥Îìú Ïù∏
      this.tweens.add({
        targets: messageText,
        alpha: 1,
        y: height / 2 - 10,
        duration: fadeTime,
        ease: 'Power2',
        onComplete: () => {
          // Ïû†Ïãú Ïú†ÏßÄ ÌõÑ ÌéòÏù¥Îìú ÏïÑÏõÉ
          this.time.delayedCall(messageDuration - fadeTime * 2, () => {
            this.tweens.add({
              targets: messageText,
              alpha: 0,
              y: height / 2 - 30,
              duration: fadeTime,
              ease: 'Power2',
              onComplete: () => {
                messageText.destroy();
                currentIndex++;
                // Îã§Ïùå Î©îÏãúÏßÄ
                this.time.delayedCall(500, showNextMessage);
              }
            });
          });
        }
      });

      // ÎßàÏßÄÎßâ Î©îÏãúÏßÄÎäî ÌäπÎ≥ÑÌïú Ìö®Í≥º
      if (currentIndex === messages.length - 1) {
        messageText.setColor('#ffffaa');
        messageText.setFontSize('28px');

        // Î∂ÄÎìúÎü¨Ïö¥ ÌéÑÏä§ Ìö®Í≥º
        this.tweens.add({
          targets: messageText,
          scale: 1.05,
          duration: 1500,
          yoyo: true,
          repeat: 1,
          ease: 'Sine.easeInOut'
        });
      }
    };

    // Ï≤´ Î©îÏãúÏßÄ ÏãúÏûë (1Ï¥à ÌõÑ)
    this.time.delayedCall(1000, showNextMessage);
  }

  /**
   * ÏòÅÌôî Ïä§ÌÉÄÏùº ÏóîÎî© ÌÅ¨Î†àÎîß
   */
  showEndingCredits() {
    console.log('üé¨ Starting Ending Credits Roll');

    const { width, height } = this.cameras.main;

    // ÌÅ¨Î†àÎîß ÏöîÏÜåÎì§ Ï†ÄÏû•
    this.creditsElements = [];

    // Í≤ÄÏùÄ Î∞∞Í≤Ω (Ïù¥ÎØ∏ ÏûàÏùÑ Ïàò ÏûàÏßÄÎßå ÌôïÏã§Ìûà)
    const creditsBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000);
    creditsBg.setDepth(9980);
    this.creditsElements.push(creditsBg);

    // ÌîΩÏÖÄ Ïä§ÌÜ∞ BGM ÏãúÏûë
    if (this.pixelStormMusic) {
      console.log('üéµ Playing Pixel Storm BGM');
      this.pixelStormMusic.setVolume(0);
      this.pixelStormMusic.play();
      this.tweens.add({
        targets: this.pixelStormMusic,
        volume: 0.8,
        duration: 2000
      });
    }

    // ÌÅ¨Î†àÎîß ÎÇ¥Ïö© Ï†ïÏùò
    const creditsContent = [
      { type: 'title', text: 'SNAKE GAME 2026' },
      { type: 'space', height: 80 },
      { type: 'subtitle', text: 'THE END' },
      { type: 'space', height: 120 },

      { type: 'category', text: 'CREATED BY' },
      { type: 'name', text: 'dorongnyong' },
      { type: 'space', height: 60 },

      { type: 'category', text: 'GAME DESIGN' },
      { type: 'name', text: 'Snake Game Team' },
      { type: 'space', height: 60 },

      { type: 'category', text: 'PROGRAMMING' },
      { type: 'name', text: 'Phaser 3 Engine' },
      { type: 'space', height: 60 },

      { type: 'category', text: 'ART & ANIMATION' },
      { type: 'name', text: 'Pixel Art Studio' },
      { type: 'space', height: 60 },

      { type: 'category', text: 'MUSIC' },
      { type: 'name', text: 'ÌîΩÏÖÄ Ïä§ÌÜ∞' },
      { type: 'name', text: 'RAIN IS BEST' },
      { type: 'name', text: 'Original Soundtrack' },
      { type: 'space', height: 60 },

      { type: 'category', text: 'SOUND EFFECTS' },
      { type: 'name', text: 'Game Audio Design' },
      { type: 'space', height: 60 },

      { type: 'category', text: 'SPECIAL THANKS' },
      { type: 'name', text: 'Claude AI' },
      { type: 'name', text: 'Anthropic' },
      { type: 'name', text: 'All Players' },
      { type: 'space', height: 100 },

      { type: 'category', text: 'STAGES' },
      { type: 'name', text: 'Basic World - Stages 1~3' },
      { type: 'name', text: 'Deadzone World - Stages 4~6' },
      { type: 'name', text: 'Darkness World - Stages 7~9' },
      { type: 'name', text: 'Machine World - Stages 10~12' },
      { type: 'name', text: 'Cyber World - Stages 13~15' },
      { type: 'name', text: 'Quantum World - Stages 16~18' },
      { type: 'space', height: 100 },

      { type: 'category', text: 'BOSS BATTLES' },
      { type: 'name', text: 'ÎèÖÍ∞úÍµ¨Î¶¨ - Stage 3' },
      { type: 'name', text: 'Bullet Hell - Stage 6' },
      { type: 'name', text: 'Nocturne - Stage 9' },
      { type: 'name', text: 'Gear Boss - Stage 12' },
      { type: 'name', text: 'NEXUS - Stage 15' },
      { type: 'name', text: 'Meta Universe - Stage 18' },
      { type: 'space', height: 120 },

      { type: 'subtitle', text: 'THANK YOU FOR PLAYING' },
      { type: 'space', height: 60 },
      { type: 'name', text: '¬© 2026 Snake Game' },
      { type: 'space', height: 200 },
    ];

    // ÌÅ¨Î†àÎîß ÌÖçÏä§Ìä∏ ÏÉùÏÑ± (ÌôîÎ©¥ ÏïÑÎûòÏóêÏÑú ÏãúÏûë)
    const creditsContainer = this.add.container(width / 2, height + 50);
    creditsContainer.setDepth(9985);
    this.creditsElements.push(creditsContainer);

    let yOffset = 0;
    const textElements = [];

    creditsContent.forEach(item => {
      if (item.type === 'space') {
        yOffset += item.height;
        return;
      }

      let fontSize, color, fontStyle;
      switch (item.type) {
        case 'title':
          fontSize = '48px';
          color = '#ffffff';
          fontStyle = 'bold';
          break;
        case 'subtitle':
          fontSize = '36px';
          color = '#ffcc00';
          fontStyle = 'bold';
          break;
        case 'category':
          fontSize = '20px';
          color = '#888888';
          fontStyle = 'normal';
          break;
        case 'name':
          fontSize = '24px';
          color = '#ffffff';
          fontStyle = 'normal';
          break;
        default:
          fontSize = '20px';
          color = '#ffffff';
          fontStyle = 'normal';
      }

      const text = this.add.text(0, yOffset, item.text, {
        fontFamily: 'Arial, sans-serif',
        fontSize: fontSize,
        fontStyle: fontStyle,
        color: color,
        align: 'center'
      });
      text.setOrigin(0.5, 0);
      textElements.push(text);
      creditsContainer.add(text);

      yOffset += parseInt(fontSize) + 15;
    });

    // ÎπõÎÇòÎäî Î≥Ñ ÌååÌã∞ÌÅ¥ Ìö®Í≥º (Î∞∞Í≤Ω)
    for (let i = 0; i < 30; i++) {
      const star = this.add.circle(
        Phaser.Math.Between(0, width),
        Phaser.Math.Between(0, height),
        Phaser.Math.Between(1, 2),
        0xffffff,
        Phaser.Math.FloatBetween(0.2, 0.6)
      );
      star.setDepth(9981);
      this.creditsElements.push(star);

      // Î∞òÏßùÏûÑ Ìö®Í≥º
      this.tweens.add({
        targets: star,
        alpha: Phaser.Math.FloatBetween(0.1, 0.3),
        duration: Phaser.Math.Between(1000, 3000),
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    }

    // ÌÅ¨Î†àÎîß Ïä§ÌÅ¨Î°§ (ÏúÑÎ°ú Ïò¨ÎùºÍ∞ê)
    const totalHeight = yOffset + height;
    const scrollDuration = totalHeight * 35; // ÏÜçÎèÑ Ï°∞Ï†à (ÎÜíÏùÑÏàòÎ°ù ÎäêÎ¶º)

    this.tweens.add({
      targets: creditsContainer,
      y: -yOffset - 50,
      duration: scrollDuration,
      ease: 'Linear',
      onComplete: () => {
        console.log('üé¨ Credits completed');
        // ÌÅ¨Î†àÎîß Ï¢ÖÎ£å ÌõÑ ÌÉÄÏù¥ÌãÄÎ°ú
        this.time.delayedCall(2000, () => {
          this.endCreditsAndReturnToTitle();
        });
      }
    });

    // Ïä§ÌÇµ Í∞ÄÎä• ÏïàÎÇ¥ (5Ï¥à ÌõÑ)
    this.time.delayedCall(5000, () => {
      const skipText = this.add.text(width - 20, height - 20, 'Press any key to skip', {
        fontFamily: 'Arial, sans-serif',
        fontSize: '14px',
        color: '#666666'
      });
      skipText.setOrigin(1, 1);
      skipText.setDepth(9990);
      skipText.setAlpha(0);
      this.creditsElements.push(skipText);

      this.tweens.add({
        targets: skipText,
        alpha: 0.7,
        duration: 500
      });

      // Ïä§ÌÇµ ÌÇ§ Î¶¨Ïä§ÎÑà
      this.input.keyboard.once('keydown', () => {
        this.endCreditsAndReturnToTitle();
      });
    });
  }

  /**
   * ÌÅ¨Î†àÎîß Ï¢ÖÎ£å ÌõÑ ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ÏúºÎ°ú
   */
  endCreditsAndReturnToTitle() {
    // Ïù¥ÎØ∏ Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Î¨¥Ïãú
    if (this.returningToTitle) return;
    this.returningToTitle = true;

    console.log('üé¨ Ending credits - Returning to title');

    const { width, height } = this.cameras.main;

    // ÌîΩÏÖÄ Ïä§ÌÜ∞ BGM ÌéòÏù¥ÎìúÏïÑÏõÉ
    if (this.pixelStormMusic && this.pixelStormMusic.isPlaying) {
      this.tweens.add({
        targets: this.pixelStormMusic,
        volume: 0,
        duration: 2000,
        onComplete: () => {
          this.pixelStormMusic.stop();
        }
      });
    }

    // ÌéòÏù¥Îìú Ìà¨ ÌôîÏù¥Ìä∏ (ÏÉàÎ°úÏö¥ ÏãúÏûë ÏïîÏãú)
    const fadeWhite = this.add.rectangle(width / 2, height / 2, width, height, 0xffffff, 0);
    fadeWhite.setDepth(9995);

    this.tweens.add({
      targets: fadeWhite,
      alpha: 1,
      duration: 2000,
      onComplete: () => {
        // ÌÅ¨Î†àÎîß ÏöîÏÜå Ï†ïÎ¶¨
        if (this.creditsElements) {
          this.creditsElements.forEach(el => {
            if (el && el.destroy) el.destroy();
          });
          this.creditsElements = [];
        }

        // Îü¨ÎÑà Î™®Îìú Ï†ïÎ¶¨
        this.cleanupRunner();
        this.cleanupMultiverseCollapse();

        // Í≤åÏûÑ ÏÉÅÌÉú ÏôÑÏ†Ñ Ï¥àÍ∏∞Ìôî
        this.postVideoEndingStarted = false;
        this.returningToTitle = false;
        this.runnerMode = false;
        this.multiverseCollapseMode = false;

        // ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ÏúºÎ°ú (Ïî¨ Ïû¨ÏãúÏûë)
        this.time.delayedCall(500, () => {
          fadeWhite.destroy();
          // ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ ÌëúÏãú ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
          SnakeGame.showTitleOnRestart = true;
          this.scene.restart();
        });
      }
    });
  }

  /**
   * ÌÉÄÏù¥ÌãÄ ÌôîÎ©¥ ÌëúÏãú
   */
  showTitleScreen() {
    console.log('üéÆ Showing Title Screen');

    const { width, height } = this.cameras.main;

    // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
    this.moveTimer.paused = true;

    // ÌÉÄÏù¥ÌãÄ ÏöîÏÜåÎì§ Ï†ÄÏû•
    this.titleElements = [];

    // Î∞òÌà¨Î™Ö Ïò§Î≤ÑÎ†àÏù¥
    const overlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.85);
    overlay.setDepth(9900);
    this.titleElements.push(overlay);

    // ÎπõÎÇòÎäî Î≥Ñ Î∞∞Í≤Ω
    for (let i = 0; i < 50; i++) {
      const star = this.add.circle(
        Phaser.Math.Between(0, width),
        Phaser.Math.Between(0, height),
        Phaser.Math.Between(1, 3),
        0xffffff,
        Phaser.Math.FloatBetween(0.2, 0.8)
      );
      star.setDepth(9901);
      this.titleElements.push(star);

      // Î∞òÏßùÏûÑ
      this.tweens.add({
        targets: star,
        alpha: Phaser.Math.FloatBetween(0.1, 0.4),
        duration: Phaser.Math.Between(1000, 3000),
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
    }

    // Í≤åÏûÑ ÌÉÄÏù¥ÌãÄ
    const titleText = this.add.text(width / 2, height / 2 - 100, 'SNAKE GAME', {
      fontSize: '64px',
      fontFamily: 'Arial, sans-serif',
      fontStyle: 'bold',
      color: '#00ff00',
      stroke: '#004400',
      strokeThickness: 8
    });
    titleText.setOrigin(0.5);
    titleText.setDepth(9910);
    titleText.setAlpha(0);
    this.titleElements.push(titleText);

    // ÌÉÄÏù¥ÌãÄ ÌéòÏù¥Îìú Ïù∏
    this.tweens.add({
      targets: titleText,
      alpha: 1,
      y: height / 2 - 80,
      duration: 1000,
      ease: 'Back.easeOut'
    });

    // Î∂ÄÏ†ú
    const subtitleText = this.add.text(width / 2, height / 2 - 20, 'The Journey of Life', {
      fontSize: '20px',
      fontFamily: 'Arial, sans-serif',
      fontStyle: 'italic',
      color: '#88ff88'
    });
    subtitleText.setOrigin(0.5);
    subtitleText.setDepth(9910);
    subtitleText.setAlpha(0);
    this.titleElements.push(subtitleText);

    // Î∂ÄÏ†ú ÌéòÏù¥Îìú Ïù∏ (ÎîúÎ†àÏù¥)
    this.tweens.add({
      targets: subtitleText,
      alpha: 1,
      duration: 800,
      delay: 500,
      ease: 'Power2'
    });

    // ÏãúÏûë ÏïàÎÇ¥
    const startText = this.add.text(width / 2, height / 2 + 80, '[ Press SPACE or ENTER to START ]', {
      fontSize: '18px',
      fontFamily: 'monospace',
      color: '#ffffff'
    });
    startText.setOrigin(0.5);
    startText.setDepth(9910);
    startText.setAlpha(0);
    this.titleElements.push(startText);

    // ÏãúÏûë ÌÖçÏä§Ìä∏ ÌéòÏù¥Îìú Ïù∏ + ÍπúÎπ°ÏûÑ
    this.tweens.add({
      targets: startText,
      alpha: 1,
      duration: 500,
      delay: 1000,
      onComplete: () => {
        // ÍπúÎπ°ÏûÑ Ìö®Í≥º
        this.tweens.add({
          targets: startText,
          alpha: 0.4,
          duration: 600,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });
      }
    });

    // Ï†ÄÏûëÍ∂å
    const copyrightText = this.add.text(width / 2, height - 50, '¬© 2026 dorongnyong', {
      fontSize: '12px',
      fontFamily: 'Arial, sans-serif',
      color: '#666666'
    });
    copyrightText.setOrigin(0.5);
    copyrightText.setDepth(9910);
    this.titleElements.push(copyrightText);

    // ÏãúÏûë ÌÇ§ ÏûÖÎ†• ÎåÄÍ∏∞ (1.5Ï¥à ÌõÑ)
    this.time.delayedCall(1500, () => {
      const startGame = () => {
        // Î™®Îì† ÌÉÄÏù¥ÌãÄ ÏöîÏÜå Ï†úÍ±∞
        this.titleElements.forEach(el => {
          if (el) this.tweens.killTweensOf(el);
          if (el && el.destroy) el.destroy();
        });
        this.titleElements = [];

        // Í≤åÏûÑ ÏãúÏûë
        this.moveTimer.paused = false;

        // BGM ÏãúÏûë
        if (!this.musicStarted && this.bgMusic) {
          this.bgMusic.play();
          this.musicStarted = true;
        }
      };

      this.input.keyboard.once('keydown-SPACE', startGame);
      this.input.keyboard.once('keydown-ENTER', startGame);
    });
  }

  /**
   * Îü¨ÎÑà Í≤åÏûÑÏò§Î≤Ñ
   */
  runnerGameOver() {
    console.log('üíÄ Runner Game Over');

    this.runnerPhase = 'gameover';
    const { width, height } = this.cameras.main;

    // Ïπ¥Î©îÎùº ÏâêÏù¥ÌÅ¨
    this.cameras.main.shake(500, 0.02);

    // ÌîåÎûòÏãú
    this.cameras.main.flash(300, 255, 0, 0);

    // Í≤åÏûÑÏò§Î≤Ñ ÌÖçÏä§Ìä∏
    const gameOverText = this.add.text(width / 2, height / 2 - 50, 'GAME OVER', {
      fontSize: '48px',
      fill: '#ff0000',
      fontStyle: 'bold',
      stroke: '#000000',
      strokeThickness: 6
    }).setOrigin(0.5).setDepth(9700).setAlpha(0);
    this.runnerElements.push(gameOverText);

    this.tweens.add({
      targets: gameOverText,
      alpha: 1,
      scale: { from: 0.5, to: 1 },
      duration: 300,
      ease: 'Back.easeOut'
    });

    // Í±∞Î¶¨ ÌëúÏãú
    const distanceText = this.add.text(width / 2, height / 2 + 20, `Distance: ${Math.floor(this.runnerDistance)}m`, {
      fontSize: '24px',
      fill: '#ffffff'
    }).setOrigin(0.5).setDepth(9700).setAlpha(0);
    this.runnerElements.push(distanceText);

    this.tweens.add({
      targets: distanceText,
      alpha: 1,
      duration: 300,
      delay: 300
    });

    // 2Ï¥à ÌõÑ ÌÅ¥Î¶¨Ïñ¥
    this.time.delayedCall(3000, () => {
      this.cleanupRunner();
      this.cleanupMultiverseCollapse();
      this.stageClear();
    });
  }

  /**
   * Îü¨ÎÑà ÌôîÎ©¥ Í∑∏Î¶¨Í∏∞
   */
  drawRunner() {
    if (!this.runnerGraphics) return;
    this.runnerGraphics.clear();

    const { width, height } = this.cameras.main;

    // Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º (Ïñ¥ÎëêÏö¥ Ïö∞Ï£º)
    this.runnerGraphics.fillStyle(0x0a0a1a, 1);
    this.runnerGraphics.fillRect(0, 0, width, height);

    // Î≥ÑÎì§ (Í∞ÑÎã®ÌïòÍ≤å)
    for (let i = 0; i < 50; i++) {
      const starX = (i * 67 + this.runnerDistance * 0.1) % width;
      const starY = (i * 37) % (this.runnerGroundY - 50);
      const starAlpha = 0.3 + Math.sin(this.runnerDistance * 0.01 + i) * 0.2;
      this.runnerGraphics.fillStyle(0xffffff, starAlpha);
      this.runnerGraphics.fillCircle(starX, starY, 1);
    }

    // Ï£ΩÏùÄ Î±Ä Î∞∞Í≤Ω (Î®ºÏ†Ä Í∑∏Î¶º)
    this.runnerDeadSnakes.forEach(deadSnake => {
      this.runnerGraphics.fillStyle(deadSnake.color, 0.5);
      deadSnake.segments.forEach(seg => {
        this.runnerGraphics.fillRect(
          deadSnake.x + seg.offsetX - 5,
          deadSnake.y + seg.offsetY - 5,
          10, 10
        );
      });
    });

    // ÏßÄÎ©¥
    this.runnerGraphics.fillStyle(0x333333, 1);
    this.runnerGraphics.fillRect(0, this.runnerGroundY + 10, width, height - this.runnerGroundY);

    // ÏßÄÎ©¥ ÎùºÏù∏
    this.runnerGraphics.lineStyle(2, 0x00ff00, 0.5);
    this.runnerGraphics.lineBetween(0, this.runnerGroundY + 10, width, this.runnerGroundY + 10);

    // Î∞∞Í≤Ω Ìù∞ Î±ÄÎì§
    this.runnerWhiteSnakes.forEach(snake => {
      this.runnerGraphics.fillStyle(0xffffff, snake.alpha);
      snake.segments.forEach((seg, i) => {
        const size = i === 0 ? 10 : 8;
        this.runnerGraphics.fillRect(seg.x - size / 2, seg.y - size / 2, size, size);
      });
    });

    // Ïû•Ïï†Î¨º
    this.runnerObstacles.forEach(obs => {
      this.drawRunnerObstacle(obs);
    });

    // ÌîåÎ†àÏù¥Ïñ¥ Î±Ä
    this.runnerPlayerSnake.forEach((seg, i) => {
      // Ìù°ÏàòÎêú ÏÑ∏Í∑∏Î®ºÌä∏Îäî Í∑∏Î¶¨ÏßÄ ÏïäÏùå
      if (seg.absorbed) return;

      const size = i === 0 ? 18 : 14;

      // Í∏ÄÎ°úÏö∞
      this.runnerGraphics.fillStyle(0xffffff, 0.3);
      this.runnerGraphics.fillCircle(seg.x, seg.y, size * 0.8);

      // Î™∏Ï≤¥
      this.runnerGraphics.fillStyle(seg.color, 1);
      this.runnerGraphics.fillRect(seg.x - size / 2, seg.y - size / 2, size, size);

      // Î®∏Î¶¨ Îàà
      if (i === 0) {
        this.runnerGraphics.fillStyle(0x000000, 1);
        this.runnerGraphics.fillCircle(seg.x + 4, seg.y - 2, 2);
        this.runnerGraphics.fillCircle(seg.x + 4, seg.y + 2, 2);
      }
    });

    // Í±∞Î¶¨ ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
    if (this.runnerPhase === 'playing' && this.runnerDistanceText) {
      this.runnerDistanceText.setText(`${Math.floor(this.runnerDistance)}m`);
    }
  }

  /**
   * Ïû•Ïï†Î¨º Í∑∏Î¶¨Í∏∞
   */
  drawRunnerObstacle(obs) {
    const x = obs.x;
    const y = obs.y;

    switch (obs.type) {
      case 'germ':
        // ÏÑ∏Í∑† (Î≥¥ÎùºÏÉâ Ïõê)
        this.runnerGraphics.fillStyle(0x9932cc, 1);
        this.runnerGraphics.fillCircle(x, y - 15, 15);
        // Ï¥âÏàò
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          this.runnerGraphics.lineStyle(3, 0x9932cc, 1);
          this.runnerGraphics.lineBetween(
            x, y - 15,
            x + Math.cos(angle) * 22, y - 15 + Math.sin(angle) * 22
          );
        }
        break;

      case 'saw':
        // ÌÜ±Îãà (ÌöåÏ†ÑÌïòÎäî Ïõê)
        const sawRotation = this.runnerDistance * 0.1;
        this.runnerGraphics.fillStyle(0xaaaaaa, 1);
        this.runnerGraphics.fillCircle(x, y - 25, 20);
        // ÌÜ±Îãà Ïù¥Îπ®
        for (let i = 0; i < 8; i++) {
          const angle = sawRotation + (i / 8) * Math.PI * 2;
          this.runnerGraphics.fillStyle(0x888888, 1);
          this.runnerGraphics.fillTriangle(
            x + Math.cos(angle) * 20, y - 25 + Math.sin(angle) * 20,
            x + Math.cos(angle + 0.2) * 30, y - 25 + Math.sin(angle + 0.2) * 30,
            x + Math.cos(angle - 0.2) * 30, y - 25 + Math.sin(angle - 0.2) * 30
          );
        }
        break;

      case 'frog':
        // ÎèÖÍ∞úÍµ¨Î¶¨ (Stage 3 Î≥¥Ïä§)
        this.runnerGraphics.fillStyle(0x00aa00, 1);
        this.runnerGraphics.fillEllipse(x, y - 15, 25, 20);
        // Îàà
        this.runnerGraphics.fillStyle(0xffff00, 1);
        this.runnerGraphics.fillCircle(x - 8, y - 22, 5);
        this.runnerGraphics.fillCircle(x + 8, y - 22, 5);
        this.runnerGraphics.fillStyle(0x000000, 1);
        this.runnerGraphics.fillCircle(x - 8, y - 22, 2);
        this.runnerGraphics.fillCircle(x + 8, y - 22, 2);
        break;

      case 'nexus':
        // NEXUS (Stage 15 Î≥¥Ïä§)
        this.runnerGraphics.fillStyle(0x00ffff, 1);
        this.runnerGraphics.fillRect(x - 15, y - 50, 30, 50);
        // Îàà (ÎπõÎÇòÎäî)
        const pulse = Math.sin(this.runnerDistance * 0.05) * 0.3 + 0.7;
        this.runnerGraphics.fillStyle(0xff0000, pulse);
        this.runnerGraphics.fillCircle(x - 5, y - 35, 4);
        this.runnerGraphics.fillCircle(x + 5, y - 35, 4);
        break;

      case 'ghost':
        // Í≥†Ïä§Ìä∏ Î±Ä (Phase 1 ÏûîÏÉÅ)
        const ghostColor = Phaser.Utils.Array.GetRandom(this.universeColors || [0xff6b6b]);
        this.runnerGraphics.fillStyle(ghostColor, 0.7);
        for (let i = 0; i < 4; i++) {
          this.runnerGraphics.fillRect(x - 6 + i * 10, y - 30 + Math.sin(i) * 5, 10, 10);
        }
        break;
    }
  }

  /**
   * Îü¨ÎÑà Ï†ïÎ¶¨
   */
  cleanupRunner() {
    console.log('üßπ Cleaning up Runner Mode');

    this.runnerMode = false;
    this.runnerPhase = 'none';

    // BGM Ï†ïÎ¶¨
    if (this.rainIsBestMusic && this.rainIsBestMusic.isPlaying) {
      this.rainIsBestMusic.stop();
    }

    // ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    this.runnerTimers.forEach(timer => {
      if (timer && timer.destroy) timer.destroy();
    });
    this.runnerTimers = [];

    // Í∑∏ÎûòÌîΩ Ï†ïÎ¶¨
    if (this.runnerGraphics) {
      this.runnerGraphics.destroy();
      this.runnerGraphics = null;
    }

    // Í±∞Î¶¨ ÌÖçÏä§Ìä∏ Ï†ïÎ¶¨
    if (this.runnerDistanceText) {
      this.runnerDistanceText.destroy();
      this.runnerDistanceText = null;
    }

    // ÏóîÎî© ÎπÑÎîîÏò§ Ï†ïÎ¶¨
    if (this.endingVideo) {
      this.endingVideo.destroy();
      this.endingVideo = null;
    }
    if (this.finalEndingVideo) {
      this.finalEndingVideo.destroy();
      this.finalEndingVideo = null;
    }
    this.finalEndingStarted = false;
    this.postVideoEndingStarted = false;

    // Îπõ Ïò§Î∏å Ï†ïÎ¶¨
    if (this.runnerLightOrb) {
      this.runnerLightOrb.destroy();
      this.runnerLightOrb = null;
    }

    // ÎÇúÏûê Ï†ïÎ¶¨
    if (this.runnerEgg) {
      this.runnerEgg.destroy();
      this.runnerEgg = null;
    }
    this.runnerEggCore = null;
    this.runnerEggOuterGlow = null;

    // ÎÇëÍ≤®Ïû°Ìûò UI Ï†ïÎ¶¨
    this.cleanupTrappedUI();

    // UI ÏöîÏÜå Ï†ïÎ¶¨
    this.runnerElements.forEach(el => {
      if (el && el.destroy) el.destroy();
    });
    this.runnerElements = [];

    // Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî
    this.runnerObstacles = [];
    this.runnerDeadSnakes = [];
    this.runnerWhiteSnakes = [];
    this.runnerPlayerSnake = [];

    // ÎÇëÍ≤®Ïû°Ìûò ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    this.runnerTrapped = false;
    this.runnerTrappedEnemy = null;
    this.runnerEscapeProgress = 0;
    this.runnerObstaclesPassed = 0;
    this.runnerClearStarted = false;
    this.runnerClearSequenceStarted = false;
    this.runnerObstaclesSpawned = 0;

    // ÌÇ§Î≥¥Îìú Î¶¨Ïä§ÎÑà Ï†úÍ±∞
    this.input.keyboard.off('keydown-SPACE');
  }

  update() {
    if (this.isEscPaused) return;
    // ÌÉÄÏù¥Î®∏ Ïù¥Î≤§Ìä∏Í∞Ä ÏûêÎèôÏúºÎ°ú moveSnakeÎ•º Ìò∏Ï∂úÌïòÎØÄÎ°ú
    // updateÏóêÏÑúÎäî ÏïÑÎ¨¥Í≤ÉÎèÑ ÌïòÏßÄ ÏïäÏïÑÎèÑ Îê®

    // Í∏∞Ïñ¥ ÌÉÄÏù¥ÌÉÑ Î≥¥Ïä§: Ï∞®ÏßÄ ÎåÄÏãú ÏûÖÎ†• Ï≤òÎ¶¨
    if (this.gearTitanMode && this.canChargeDash && !this.gameOver) {
      this.handleChargeInput();
    }
  }
}
